/* automatically generated by rust-bindgen 0.72.1 */
#![allow(warnings)]
#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize)
        };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val { byte | mask } else { byte & !mask }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize)
        };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
#[doc = r" If Bindgen could only determine the size and alignment of a"]
#[doc = r" type, it is represented like this."]
#[derive(PartialEq, Copy, Clone, Debug, Hash)]
#[repr(C)]
pub struct __BindgenOpaqueArray<T: Copy, const N: usize>(pub [T; N]);
impl<T: Copy + Default, const N: usize> Default for __BindgenOpaqueArray<T, N> {
    fn default() -> Self {
        Self([<T as Default>::default(); N])
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _STRSAFE_USE_SECURE_CRT: u32 = 0;
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_CXX26: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const EXCEPTION_EXECUTE_HANDLER: u32 = 1;
pub const EXCEPTION_CONTINUE_SEARCH: u32 = 0;
pub const EXCEPTION_CONTINUE_EXECUTION: i32 = -1;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _CRT_HAS_C11: u32 = 1;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const _STATIC_INLINE_UCRT_FUNCTIONS: u32 = 1;
pub const _UPPER: u32 = 1;
pub const _LOWER: u32 = 2;
pub const _DIGIT: u32 = 4;
pub const _SPACE: u32 = 8;
pub const _PUNCT: u32 = 16;
pub const _CONTROL: u32 = 32;
pub const _BLANK: u32 = 64;
pub const _HEX: u32 = 128;
pub const _LEADBYTE: u32 = 32768;
pub const _ALPHA: u32 = 259;
pub const WINAPI_FAMILY_PC_APP: u32 = 2;
pub const WINAPI_FAMILY_PHONE_APP: u32 = 3;
pub const WINAPI_FAMILY_SYSTEM: u32 = 4;
pub const WINAPI_FAMILY_SERVER: u32 = 5;
pub const WINAPI_FAMILY_GAMES: u32 = 6;
pub const WINAPI_FAMILY_DESKTOP_APP: u32 = 100;
pub const WINAPI_FAMILY_APP: u32 = 2;
pub const WINAPI_FAMILY: u32 = 100;
pub const ANYSIZE_ARRAY: u32 = 1;
pub const __SAL_H_FULL_VER: u32 = 140050727;
pub const __SPECSTRINGS_STRICT_LEVEL: u32 = 1;
pub const __drv_typeConst: u32 = 0;
pub const __drv_typeCond: u32 = 1;
pub const __drv_typeBitset: u32 = 2;
pub const __drv_typeExpr: u32 = 3;
pub const DISPATCH_LEVEL: u32 = 2;
pub const APC_LEVEL: u32 = 1;
pub const PASSIVE_LEVEL: u32 = 0;
pub const HIGH_LEVEL: u32 = 15;
pub const MEMORY_ALLOCATION_ALIGNMENT: u32 = 16;
pub const X86_CACHE_ALIGNMENT_SIZE: u32 = 64;
pub const ARM_CACHE_ALIGNMENT_SIZE: u32 = 128;
pub const SYSTEM_CACHE_ALIGNMENT_SIZE: u32 = 64;
pub const PRAGMA_DEPRECATED_DDK: u32 = 0;
pub const UCSCHAR_INVALID_CHARACTER: u32 = 4294967295;
pub const MIN_UCSCHAR: u32 = 0;
pub const MAX_UCSCHAR: u32 = 1114111;
pub const STRICT: u32 = 1;
pub const ALL_PROCESSOR_GROUPS: u32 = 65535;
pub const MAXIMUM_PROC_PER_GROUP: u32 = 64;
pub const MAXIMUM_PROCESSORS: u32 = 64;
pub const OBJ_HANDLE_TAGBITS: u32 = 3;
pub const APPLICATION_ERROR_MASK: u32 = 536870912;
pub const ERROR_SEVERITY_SUCCESS: u32 = 0;
pub const ERROR_SEVERITY_INFORMATIONAL: u32 = 1073741824;
pub const ERROR_SEVERITY_WARNING: u32 = 2147483648;
pub const ERROR_SEVERITY_ERROR: u32 = 3221225472;
pub const MAXLONGLONG: u64 = 9223372036854775807;
pub const UNICODE_STRING_MAX_CHARS: u32 = 32767;
pub const RTL_BALANCED_NODE_RESERVED_PARENT_MASK: u32 = 3;
pub const OBJ_INHERIT: u32 = 2;
pub const OBJ_PERMANENT: u32 = 16;
pub const OBJ_EXCLUSIVE: u32 = 32;
pub const OBJ_CASE_INSENSITIVE: u32 = 64;
pub const OBJ_OPENIF: u32 = 128;
pub const OBJ_OPENLINK: u32 = 256;
pub const OBJ_KERNEL_HANDLE: u32 = 512;
pub const OBJ_FORCE_ACCESS_CHECK: u32 = 1024;
pub const OBJ_IGNORE_IMPERSONATED_DEVICEMAP: u32 = 2048;
pub const OBJ_DONT_REPARSE: u32 = 4096;
pub const OBJ_VALID_ATTRIBUTES: u32 = 8178;
pub const FALSE: u32 = 0;
pub const TRUE: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const EDEADLK: u32 = 36;
pub const ENAMETOOLONG: u32 = 38;
pub const ENOLCK: u32 = 39;
pub const ENOSYS: u32 = 40;
pub const ENOTEMPTY: u32 = 41;
pub const EINVAL: u32 = 22;
pub const ERANGE: u32 = 34;
pub const EILSEQ: u32 = 42;
pub const STRUNCATE: u32 = 80;
pub const EDEADLOCK: u32 = 36;
pub const EADDRINUSE: u32 = 100;
pub const EADDRNOTAVAIL: u32 = 101;
pub const EAFNOSUPPORT: u32 = 102;
pub const EALREADY: u32 = 103;
pub const EBADMSG: u32 = 104;
pub const ECANCELED: u32 = 105;
pub const ECONNABORTED: u32 = 106;
pub const ECONNREFUSED: u32 = 107;
pub const ECONNRESET: u32 = 108;
pub const EDESTADDRREQ: u32 = 109;
pub const EHOSTUNREACH: u32 = 110;
pub const EIDRM: u32 = 111;
pub const EINPROGRESS: u32 = 112;
pub const EISCONN: u32 = 113;
pub const ELOOP: u32 = 114;
pub const EMSGSIZE: u32 = 115;
pub const ENETDOWN: u32 = 116;
pub const ENETRESET: u32 = 117;
pub const ENETUNREACH: u32 = 118;
pub const ENOBUFS: u32 = 119;
pub const ENODATA: u32 = 120;
pub const ENOLINK: u32 = 121;
pub const ENOMSG: u32 = 122;
pub const ENOPROTOOPT: u32 = 123;
pub const ENOSR: u32 = 124;
pub const ENOSTR: u32 = 125;
pub const ENOTCONN: u32 = 126;
pub const ENOTRECOVERABLE: u32 = 127;
pub const ENOTSOCK: u32 = 128;
pub const ENOTSUP: u32 = 129;
pub const EOPNOTSUPP: u32 = 130;
pub const EOTHER: u32 = 131;
pub const EOVERFLOW: u32 = 132;
pub const EOWNERDEAD: u32 = 133;
pub const EPROTO: u32 = 134;
pub const EPROTONOSUPPORT: u32 = 135;
pub const EPROTOTYPE: u32 = 136;
pub const ETIME: u32 = 137;
pub const ETIMEDOUT: u32 = 138;
pub const ETXTBSY: u32 = 139;
pub const EWOULDBLOCK: u32 = 140;
pub const _NLSCMPERROR: u32 = 2147483647;
pub const MINCHAR: u32 = 128;
pub const MAXCHAR: u32 = 127;
pub const MINSHORT: u32 = 32768;
pub const MAXSHORT: u32 = 32767;
pub const MINLONG: u32 = 2147483648;
pub const MAXLONG: u32 = 2147483647;
pub const MAXUCHAR: u32 = 255;
pub const MAXUSHORT: u32 = 65535;
pub const MAXULONG: u32 = 4294967295;
pub const ENCLAVE_SHORT_ID_LENGTH: u32 = 16;
pub const ENCLAVE_LONG_ID_LENGTH: u32 = 32;
pub const VER_SERVER_NT: u32 = 2147483648;
pub const VER_WORKSTATION_NT: u32 = 1073741824;
pub const VER_SUITE_SMALLBUSINESS: u32 = 1;
pub const VER_SUITE_ENTERPRISE: u32 = 2;
pub const VER_SUITE_BACKOFFICE: u32 = 4;
pub const VER_SUITE_COMMUNICATIONS: u32 = 8;
pub const VER_SUITE_TERMINAL: u32 = 16;
pub const VER_SUITE_SMALLBUSINESS_RESTRICTED: u32 = 32;
pub const VER_SUITE_EMBEDDEDNT: u32 = 64;
pub const VER_SUITE_DATACENTER: u32 = 128;
pub const VER_SUITE_SINGLEUSERTS: u32 = 256;
pub const VER_SUITE_PERSONAL: u32 = 512;
pub const VER_SUITE_BLADE: u32 = 1024;
pub const VER_SUITE_EMBEDDED_RESTRICTED: u32 = 2048;
pub const VER_SUITE_SECURITY_APPLIANCE: u32 = 4096;
pub const VER_SUITE_STORAGE_SERVER: u32 = 8192;
pub const VER_SUITE_COMPUTE_SERVER: u32 = 16384;
pub const VER_SUITE_WH_SERVER: u32 = 32768;
pub const VER_SUITE_MULTIUSERTS: u32 = 131072;
pub const PRODUCT_UNDEFINED: u32 = 0;
pub const PRODUCT_ULTIMATE: u32 = 1;
pub const PRODUCT_HOME_BASIC: u32 = 2;
pub const PRODUCT_HOME_PREMIUM: u32 = 3;
pub const PRODUCT_ENTERPRISE: u32 = 4;
pub const PRODUCT_HOME_BASIC_N: u32 = 5;
pub const PRODUCT_BUSINESS: u32 = 6;
pub const PRODUCT_STANDARD_SERVER: u32 = 7;
pub const PRODUCT_DATACENTER_SERVER: u32 = 8;
pub const PRODUCT_SMALLBUSINESS_SERVER: u32 = 9;
pub const PRODUCT_ENTERPRISE_SERVER: u32 = 10;
pub const PRODUCT_STARTER: u32 = 11;
pub const PRODUCT_DATACENTER_SERVER_CORE: u32 = 12;
pub const PRODUCT_STANDARD_SERVER_CORE: u32 = 13;
pub const PRODUCT_ENTERPRISE_SERVER_CORE: u32 = 14;
pub const PRODUCT_ENTERPRISE_SERVER_IA64: u32 = 15;
pub const PRODUCT_BUSINESS_N: u32 = 16;
pub const PRODUCT_WEB_SERVER: u32 = 17;
pub const PRODUCT_CLUSTER_SERVER: u32 = 18;
pub const PRODUCT_HOME_SERVER: u32 = 19;
pub const PRODUCT_STORAGE_EXPRESS_SERVER: u32 = 20;
pub const PRODUCT_STORAGE_STANDARD_SERVER: u32 = 21;
pub const PRODUCT_STORAGE_WORKGROUP_SERVER: u32 = 22;
pub const PRODUCT_STORAGE_ENTERPRISE_SERVER: u32 = 23;
pub const PRODUCT_SERVER_FOR_SMALLBUSINESS: u32 = 24;
pub const PRODUCT_SMALLBUSINESS_SERVER_PREMIUM: u32 = 25;
pub const PRODUCT_HOME_PREMIUM_N: u32 = 26;
pub const PRODUCT_ENTERPRISE_N: u32 = 27;
pub const PRODUCT_ULTIMATE_N: u32 = 28;
pub const PRODUCT_WEB_SERVER_CORE: u32 = 29;
pub const PRODUCT_MEDIUMBUSINESS_SERVER_MANAGEMENT: u32 = 30;
pub const PRODUCT_MEDIUMBUSINESS_SERVER_SECURITY: u32 = 31;
pub const PRODUCT_MEDIUMBUSINESS_SERVER_MESSAGING: u32 = 32;
pub const PRODUCT_SERVER_FOUNDATION: u32 = 33;
pub const PRODUCT_HOME_PREMIUM_SERVER: u32 = 34;
pub const PRODUCT_SERVER_FOR_SMALLBUSINESS_V: u32 = 35;
pub const PRODUCT_STANDARD_SERVER_V: u32 = 36;
pub const PRODUCT_DATACENTER_SERVER_V: u32 = 37;
pub const PRODUCT_ENTERPRISE_SERVER_V: u32 = 38;
pub const PRODUCT_DATACENTER_SERVER_CORE_V: u32 = 39;
pub const PRODUCT_STANDARD_SERVER_CORE_V: u32 = 40;
pub const PRODUCT_ENTERPRISE_SERVER_CORE_V: u32 = 41;
pub const PRODUCT_HYPERV: u32 = 42;
pub const PRODUCT_STORAGE_EXPRESS_SERVER_CORE: u32 = 43;
pub const PRODUCT_STORAGE_STANDARD_SERVER_CORE: u32 = 44;
pub const PRODUCT_STORAGE_WORKGROUP_SERVER_CORE: u32 = 45;
pub const PRODUCT_STORAGE_ENTERPRISE_SERVER_CORE: u32 = 46;
pub const PRODUCT_STARTER_N: u32 = 47;
pub const PRODUCT_PROFESSIONAL: u32 = 48;
pub const PRODUCT_PROFESSIONAL_N: u32 = 49;
pub const PRODUCT_SB_SOLUTION_SERVER: u32 = 50;
pub const PRODUCT_SERVER_FOR_SB_SOLUTIONS: u32 = 51;
pub const PRODUCT_STANDARD_SERVER_SOLUTIONS: u32 = 52;
pub const PRODUCT_STANDARD_SERVER_SOLUTIONS_CORE: u32 = 53;
pub const PRODUCT_SB_SOLUTION_SERVER_EM: u32 = 54;
pub const PRODUCT_SERVER_FOR_SB_SOLUTIONS_EM: u32 = 55;
pub const PRODUCT_SOLUTION_EMBEDDEDSERVER: u32 = 56;
pub const PRODUCT_SOLUTION_EMBEDDEDSERVER_CORE: u32 = 57;
pub const PRODUCT_PROFESSIONAL_EMBEDDED: u32 = 58;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_MGMT: u32 = 59;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_ADDL: u32 = 60;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_MGMTSVC: u32 = 61;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_ADDLSVC: u32 = 62;
pub const PRODUCT_SMALLBUSINESS_SERVER_PREMIUM_CORE: u32 = 63;
pub const PRODUCT_CLUSTER_SERVER_V: u32 = 64;
pub const PRODUCT_EMBEDDED: u32 = 65;
pub const PRODUCT_STARTER_E: u32 = 66;
pub const PRODUCT_HOME_BASIC_E: u32 = 67;
pub const PRODUCT_HOME_PREMIUM_E: u32 = 68;
pub const PRODUCT_PROFESSIONAL_E: u32 = 69;
pub const PRODUCT_ENTERPRISE_E: u32 = 70;
pub const PRODUCT_ULTIMATE_E: u32 = 71;
pub const PRODUCT_ENTERPRISE_EVALUATION: u32 = 72;
pub const PRODUCT_MULTIPOINT_STANDARD_SERVER: u32 = 76;
pub const PRODUCT_MULTIPOINT_PREMIUM_SERVER: u32 = 77;
pub const PRODUCT_STANDARD_EVALUATION_SERVER: u32 = 79;
pub const PRODUCT_DATACENTER_EVALUATION_SERVER: u32 = 80;
pub const PRODUCT_ENTERPRISE_N_EVALUATION: u32 = 84;
pub const PRODUCT_EMBEDDED_AUTOMOTIVE: u32 = 85;
pub const PRODUCT_EMBEDDED_INDUSTRY_A: u32 = 86;
pub const PRODUCT_THINPC: u32 = 87;
pub const PRODUCT_EMBEDDED_A: u32 = 88;
pub const PRODUCT_EMBEDDED_INDUSTRY: u32 = 89;
pub const PRODUCT_EMBEDDED_E: u32 = 90;
pub const PRODUCT_EMBEDDED_INDUSTRY_E: u32 = 91;
pub const PRODUCT_EMBEDDED_INDUSTRY_A_E: u32 = 92;
pub const PRODUCT_STORAGE_WORKGROUP_EVALUATION_SERVER: u32 = 95;
pub const PRODUCT_STORAGE_STANDARD_EVALUATION_SERVER: u32 = 96;
pub const PRODUCT_CORE_ARM: u32 = 97;
pub const PRODUCT_CORE_N: u32 = 98;
pub const PRODUCT_CORE_COUNTRYSPECIFIC: u32 = 99;
pub const PRODUCT_CORE_SINGLELANGUAGE: u32 = 100;
pub const PRODUCT_CORE: u32 = 101;
pub const PRODUCT_PROFESSIONAL_WMC: u32 = 103;
pub const PRODUCT_EMBEDDED_INDUSTRY_EVAL: u32 = 105;
pub const PRODUCT_EMBEDDED_INDUSTRY_E_EVAL: u32 = 106;
pub const PRODUCT_EMBEDDED_EVAL: u32 = 107;
pub const PRODUCT_EMBEDDED_E_EVAL: u32 = 108;
pub const PRODUCT_NANO_SERVER: u32 = 109;
pub const PRODUCT_CLOUD_STORAGE_SERVER: u32 = 110;
pub const PRODUCT_CORE_CONNECTED: u32 = 111;
pub const PRODUCT_PROFESSIONAL_STUDENT: u32 = 112;
pub const PRODUCT_CORE_CONNECTED_N: u32 = 113;
pub const PRODUCT_PROFESSIONAL_STUDENT_N: u32 = 114;
pub const PRODUCT_CORE_CONNECTED_SINGLELANGUAGE: u32 = 115;
pub const PRODUCT_CORE_CONNECTED_COUNTRYSPECIFIC: u32 = 116;
pub const PRODUCT_CONNECTED_CAR: u32 = 117;
pub const PRODUCT_INDUSTRY_HANDHELD: u32 = 118;
pub const PRODUCT_PPI_PRO: u32 = 119;
pub const PRODUCT_ARM64_SERVER: u32 = 120;
pub const PRODUCT_EDUCATION: u32 = 121;
pub const PRODUCT_EDUCATION_N: u32 = 122;
pub const PRODUCT_IOTUAP: u32 = 123;
pub const PRODUCT_CLOUD_HOST_INFRASTRUCTURE_SERVER: u32 = 124;
pub const PRODUCT_ENTERPRISE_S: u32 = 125;
pub const PRODUCT_ENTERPRISE_S_N: u32 = 126;
pub const PRODUCT_PROFESSIONAL_S: u32 = 127;
pub const PRODUCT_PROFESSIONAL_S_N: u32 = 128;
pub const PRODUCT_ENTERPRISE_S_EVALUATION: u32 = 129;
pub const PRODUCT_ENTERPRISE_S_N_EVALUATION: u32 = 130;
pub const PRODUCT_HOLOGRAPHIC: u32 = 135;
pub const PRODUCT_HOLOGRAPHIC_BUSINESS: u32 = 136;
pub const PRODUCT_PRO_SINGLE_LANGUAGE: u32 = 138;
pub const PRODUCT_PRO_CHINA: u32 = 139;
pub const PRODUCT_ENTERPRISE_SUBSCRIPTION: u32 = 140;
pub const PRODUCT_ENTERPRISE_SUBSCRIPTION_N: u32 = 141;
pub const PRODUCT_DATACENTER_NANO_SERVER: u32 = 143;
pub const PRODUCT_STANDARD_NANO_SERVER: u32 = 144;
pub const PRODUCT_DATACENTER_A_SERVER_CORE: u32 = 145;
pub const PRODUCT_STANDARD_A_SERVER_CORE: u32 = 146;
pub const PRODUCT_DATACENTER_WS_SERVER_CORE: u32 = 147;
pub const PRODUCT_STANDARD_WS_SERVER_CORE: u32 = 148;
pub const PRODUCT_UTILITY_VM: u32 = 149;
pub const PRODUCT_DATACENTER_EVALUATION_SERVER_CORE: u32 = 159;
pub const PRODUCT_STANDARD_EVALUATION_SERVER_CORE: u32 = 160;
pub const PRODUCT_PRO_WORKSTATION: u32 = 161;
pub const PRODUCT_PRO_WORKSTATION_N: u32 = 162;
pub const PRODUCT_PRO_FOR_EDUCATION: u32 = 164;
pub const PRODUCT_PRO_FOR_EDUCATION_N: u32 = 165;
pub const PRODUCT_AZURE_SERVER_CORE: u32 = 168;
pub const PRODUCT_AZURE_NANO_SERVER: u32 = 169;
pub const PRODUCT_ENTERPRISEG: u32 = 171;
pub const PRODUCT_ENTERPRISEGN: u32 = 172;
pub const PRODUCT_SERVERRDSH: u32 = 175;
pub const PRODUCT_CLOUD: u32 = 178;
pub const PRODUCT_CLOUDN: u32 = 179;
pub const PRODUCT_HUBOS: u32 = 180;
pub const PRODUCT_ONECOREUPDATEOS: u32 = 182;
pub const PRODUCT_CLOUDE: u32 = 183;
pub const PRODUCT_IOTOS: u32 = 185;
pub const PRODUCT_CLOUDEN: u32 = 186;
pub const PRODUCT_IOTEDGEOS: u32 = 187;
pub const PRODUCT_IOTENTERPRISE: u32 = 188;
pub const PRODUCT_LITE: u32 = 189;
pub const PRODUCT_IOTENTERPRISES: u32 = 191;
pub const PRODUCT_XBOX_SYSTEMOS: u32 = 192;
pub const PRODUCT_XBOX_GAMEOS: u32 = 194;
pub const PRODUCT_XBOX_ERAOS: u32 = 195;
pub const PRODUCT_XBOX_DURANGOHOSTOS: u32 = 196;
pub const PRODUCT_XBOX_SCARLETTHOSTOS: u32 = 197;
pub const PRODUCT_XBOX_KEYSTONE: u32 = 198;
pub const PRODUCT_AZURE_SERVER_CLOUDHOST: u32 = 199;
pub const PRODUCT_AZURE_SERVER_CLOUDMOS: u32 = 200;
pub const PRODUCT_CLOUDEDITIONN: u32 = 202;
pub const PRODUCT_CLOUDEDITION: u32 = 203;
pub const PRODUCT_VALIDATION: u32 = 204;
pub const PRODUCT_IOTENTERPRISESK: u32 = 205;
pub const PRODUCT_IOTENTERPRISEK: u32 = 206;
pub const PRODUCT_IOTENTERPRISESEVAL: u32 = 207;
pub const PRODUCT_AZURE_SERVER_AGENTBRIDGE: u32 = 208;
pub const PRODUCT_AZURE_SERVER_NANOHOST: u32 = 209;
pub const PRODUCT_WNC: u32 = 210;
pub const PRODUCT_AZURESTACKHCI_SERVER_CORE: u32 = 406;
pub const PRODUCT_DATACENTER_SERVER_AZURE_EDITION: u32 = 407;
pub const PRODUCT_DATACENTER_SERVER_CORE_AZURE_EDITION: u32 = 408;
pub const PRODUCT_DATACENTER_WS_SERVER_CORE_AZURE_EDITION: u32 = 409;
pub const PRODUCT_UNLICENSED: u32 = 2882382797;
pub const _WIN32_WINNT_NT4: u32 = 1024;
pub const _WIN32_WINNT_WIN2K: u32 = 1280;
pub const _WIN32_WINNT_WINXP: u32 = 1281;
pub const _WIN32_WINNT_WS03: u32 = 1282;
pub const _WIN32_WINNT_WIN6: u32 = 1536;
pub const _WIN32_WINNT_VISTA: u32 = 1536;
pub const _WIN32_WINNT_WS08: u32 = 1536;
pub const _WIN32_WINNT_LONGHORN: u32 = 1536;
pub const _WIN32_WINNT_WIN7: u32 = 1537;
pub const _WIN32_WINNT_WIN8: u32 = 1538;
pub const _WIN32_WINNT_WINBLUE: u32 = 1539;
pub const _WIN32_WINNT_WINTHRESHOLD: u32 = 2560;
pub const _WIN32_WINNT_WIN10: u32 = 2560;
pub const _WIN32_IE_IE20: u32 = 512;
pub const _WIN32_IE_IE30: u32 = 768;
pub const _WIN32_IE_IE302: u32 = 770;
pub const _WIN32_IE_IE40: u32 = 1024;
pub const _WIN32_IE_IE401: u32 = 1025;
pub const _WIN32_IE_IE50: u32 = 1280;
pub const _WIN32_IE_IE501: u32 = 1281;
pub const _WIN32_IE_IE55: u32 = 1360;
pub const _WIN32_IE_IE60: u32 = 1536;
pub const _WIN32_IE_IE60SP1: u32 = 1537;
pub const _WIN32_IE_IE60SP2: u32 = 1539;
pub const _WIN32_IE_IE70: u32 = 1792;
pub const _WIN32_IE_IE80: u32 = 2048;
pub const _WIN32_IE_IE90: u32 = 2304;
pub const _WIN32_IE_IE100: u32 = 2560;
pub const _WIN32_IE_IE110: u32 = 2560;
pub const _WIN32_IE_NT4: u32 = 512;
pub const _WIN32_IE_NT4SP1: u32 = 512;
pub const _WIN32_IE_NT4SP2: u32 = 512;
pub const _WIN32_IE_NT4SP3: u32 = 770;
pub const _WIN32_IE_NT4SP4: u32 = 1025;
pub const _WIN32_IE_NT4SP5: u32 = 1025;
pub const _WIN32_IE_NT4SP6: u32 = 1280;
pub const _WIN32_IE_WIN98: u32 = 1025;
pub const _WIN32_IE_WIN98SE: u32 = 1280;
pub const _WIN32_IE_WINME: u32 = 1360;
pub const _WIN32_IE_WIN2K: u32 = 1281;
pub const _WIN32_IE_WIN2KSP1: u32 = 1281;
pub const _WIN32_IE_WIN2KSP2: u32 = 1281;
pub const _WIN32_IE_WIN2KSP3: u32 = 1281;
pub const _WIN32_IE_WIN2KSP4: u32 = 1281;
pub const _WIN32_IE_XP: u32 = 1536;
pub const _WIN32_IE_XPSP1: u32 = 1537;
pub const _WIN32_IE_XPSP2: u32 = 1539;
pub const _WIN32_IE_WS03: u32 = 1538;
pub const _WIN32_IE_WS03SP1: u32 = 1539;
pub const _WIN32_IE_WIN6: u32 = 1792;
pub const _WIN32_IE_LONGHORN: u32 = 1792;
pub const _WIN32_IE_WIN7: u32 = 2048;
pub const _WIN32_IE_WIN8: u32 = 2560;
pub const _WIN32_IE_WINBLUE: u32 = 2560;
pub const _WIN32_IE_WINTHRESHOLD: u32 = 2560;
pub const _WIN32_IE_WIN10: u32 = 2560;
pub const NTDDI_WIN4: u32 = 67108864;
pub const NTDDI_WIN2K: u32 = 83886080;
pub const NTDDI_WIN2KSP1: u32 = 83886336;
pub const NTDDI_WIN2KSP2: u32 = 83886592;
pub const NTDDI_WIN2KSP3: u32 = 83886848;
pub const NTDDI_WIN2KSP4: u32 = 83887104;
pub const NTDDI_WINXP: u32 = 83951616;
pub const NTDDI_WINXPSP1: u32 = 83951872;
pub const NTDDI_WINXPSP2: u32 = 83952128;
pub const NTDDI_WINXPSP3: u32 = 83952384;
pub const NTDDI_WINXPSP4: u32 = 83952640;
pub const NTDDI_WS03: u32 = 84017152;
pub const NTDDI_WS03SP1: u32 = 84017408;
pub const NTDDI_WS03SP2: u32 = 84017664;
pub const NTDDI_WS03SP3: u32 = 84017920;
pub const NTDDI_WS03SP4: u32 = 84018176;
pub const NTDDI_WIN6: u32 = 100663296;
pub const NTDDI_WIN6SP1: u32 = 100663552;
pub const NTDDI_WIN6SP2: u32 = 100663808;
pub const NTDDI_WIN6SP3: u32 = 100664064;
pub const NTDDI_WIN6SP4: u32 = 100664320;
pub const NTDDI_VISTA: u32 = 100663296;
pub const NTDDI_VISTASP1: u32 = 100663552;
pub const NTDDI_VISTASP2: u32 = 100663808;
pub const NTDDI_VISTASP3: u32 = 100664064;
pub const NTDDI_VISTASP4: u32 = 100664320;
pub const NTDDI_LONGHORN: u32 = 100663296;
pub const NTDDI_WS08: u32 = 100663552;
pub const NTDDI_WS08SP2: u32 = 100663808;
pub const NTDDI_WS08SP3: u32 = 100664064;
pub const NTDDI_WS08SP4: u32 = 100664320;
pub const NTDDI_WIN7: u32 = 100728832;
pub const NTDDI_WIN8: u32 = 100794368;
pub const NTDDI_WINBLUE: u32 = 100859904;
pub const NTDDI_WINTHRESHOLD: u32 = 167772160;
pub const NTDDI_WIN10: u32 = 167772160;
pub const NTDDI_WIN10_TH2: u32 = 167772161;
pub const NTDDI_WIN10_RS1: u32 = 167772162;
pub const NTDDI_WIN10_RS2: u32 = 167772163;
pub const NTDDI_WIN10_RS3: u32 = 167772164;
pub const NTDDI_WIN10_RS4: u32 = 167772165;
pub const NTDDI_WIN10_RS5: u32 = 167772166;
pub const NTDDI_WIN10_19H1: u32 = 167772167;
pub const NTDDI_WIN10_VB: u32 = 167772168;
pub const NTDDI_WIN10_MN: u32 = 167772169;
pub const NTDDI_WIN10_FE: u32 = 167772170;
pub const NTDDI_WIN10_CO: u32 = 167772171;
pub const NTDDI_WIN10_NI: u32 = 167772172;
pub const NTDDI_WIN10_CU: u32 = 167772173;
pub const NTDDI_WIN11_ZN: u32 = 167772174;
pub const NTDDI_WIN11_GA: u32 = 167772175;
pub const NTDDI_WIN11_GE: u32 = 167772176;
pub const WDK_NTDDI_VERSION: u32 = 167772176;
pub const OSVERSION_MASK: u32 = 4294901760;
pub const SPVERSION_MASK: u32 = 65280;
pub const SUBVERSION_MASK: u32 = 255;
pub const _WIN32_IE: u32 = 2560;
pub const LANG_NEUTRAL: u32 = 0;
pub const LANG_INVARIANT: u32 = 127;
pub const LANG_AFRIKAANS: u32 = 54;
pub const LANG_ALBANIAN: u32 = 28;
pub const LANG_ALSATIAN: u32 = 132;
pub const LANG_AMHARIC: u32 = 94;
pub const LANG_ARABIC: u32 = 1;
pub const LANG_ARMENIAN: u32 = 43;
pub const LANG_ASSAMESE: u32 = 77;
pub const LANG_AZERI: u32 = 44;
pub const LANG_AZERBAIJANI: u32 = 44;
pub const LANG_BANGLA: u32 = 69;
pub const LANG_BASHKIR: u32 = 109;
pub const LANG_BASQUE: u32 = 45;
pub const LANG_BELARUSIAN: u32 = 35;
pub const LANG_BENGALI: u32 = 69;
pub const LANG_BRETON: u32 = 126;
pub const LANG_BOSNIAN: u32 = 26;
pub const LANG_BOSNIAN_NEUTRAL: u32 = 30746;
pub const LANG_BULGARIAN: u32 = 2;
pub const LANG_CATALAN: u32 = 3;
pub const LANG_CENTRAL_KURDISH: u32 = 146;
pub const LANG_CHEROKEE: u32 = 92;
pub const LANG_CHINESE: u32 = 4;
pub const LANG_CHINESE_SIMPLIFIED: u32 = 4;
pub const LANG_CHINESE_TRADITIONAL: u32 = 31748;
pub const LANG_CORSICAN: u32 = 131;
pub const LANG_CROATIAN: u32 = 26;
pub const LANG_CZECH: u32 = 5;
pub const LANG_DANISH: u32 = 6;
pub const LANG_DARI: u32 = 140;
pub const LANG_DIVEHI: u32 = 101;
pub const LANG_DUTCH: u32 = 19;
pub const LANG_ENGLISH: u32 = 9;
pub const LANG_ESTONIAN: u32 = 37;
pub const LANG_FAEROESE: u32 = 56;
pub const LANG_FARSI: u32 = 41;
pub const LANG_FILIPINO: u32 = 100;
pub const LANG_FINNISH: u32 = 11;
pub const LANG_FRENCH: u32 = 12;
pub const LANG_FRISIAN: u32 = 98;
pub const LANG_FULAH: u32 = 103;
pub const LANG_GALICIAN: u32 = 86;
pub const LANG_GEORGIAN: u32 = 55;
pub const LANG_GERMAN: u32 = 7;
pub const LANG_GREEK: u32 = 8;
pub const LANG_GREENLANDIC: u32 = 111;
pub const LANG_GUJARATI: u32 = 71;
pub const LANG_HAUSA: u32 = 104;
pub const LANG_HAWAIIAN: u32 = 117;
pub const LANG_HEBREW: u32 = 13;
pub const LANG_HINDI: u32 = 57;
pub const LANG_HUNGARIAN: u32 = 14;
pub const LANG_ICELANDIC: u32 = 15;
pub const LANG_IGBO: u32 = 112;
pub const LANG_INDONESIAN: u32 = 33;
pub const LANG_INUKTITUT: u32 = 93;
pub const LANG_IRISH: u32 = 60;
pub const LANG_ITALIAN: u32 = 16;
pub const LANG_JAPANESE: u32 = 17;
pub const LANG_KANNADA: u32 = 75;
pub const LANG_KASHMIRI: u32 = 96;
pub const LANG_KAZAK: u32 = 63;
pub const LANG_KHMER: u32 = 83;
pub const LANG_KICHE: u32 = 134;
pub const LANG_KINYARWANDA: u32 = 135;
pub const LANG_KONKANI: u32 = 87;
pub const LANG_KOREAN: u32 = 18;
pub const LANG_KYRGYZ: u32 = 64;
pub const LANG_LAO: u32 = 84;
pub const LANG_LATVIAN: u32 = 38;
pub const LANG_LITHUANIAN: u32 = 39;
pub const LANG_LOWER_SORBIAN: u32 = 46;
pub const LANG_LUXEMBOURGISH: u32 = 110;
pub const LANG_MACEDONIAN: u32 = 47;
pub const LANG_MALAY: u32 = 62;
pub const LANG_MALAYALAM: u32 = 76;
pub const LANG_MALTESE: u32 = 58;
pub const LANG_MANIPURI: u32 = 88;
pub const LANG_MAORI: u32 = 129;
pub const LANG_MAPUDUNGUN: u32 = 122;
pub const LANG_MARATHI: u32 = 78;
pub const LANG_MOHAWK: u32 = 124;
pub const LANG_MONGOLIAN: u32 = 80;
pub const LANG_NEPALI: u32 = 97;
pub const LANG_NORWEGIAN: u32 = 20;
pub const LANG_OCCITAN: u32 = 130;
pub const LANG_ODIA: u32 = 72;
pub const LANG_ORIYA: u32 = 72;
pub const LANG_PASHTO: u32 = 99;
pub const LANG_PERSIAN: u32 = 41;
pub const LANG_POLISH: u32 = 21;
pub const LANG_PORTUGUESE: u32 = 22;
pub const LANG_PULAR: u32 = 103;
pub const LANG_PUNJABI: u32 = 70;
pub const LANG_QUECHUA: u32 = 107;
pub const LANG_ROMANIAN: u32 = 24;
pub const LANG_ROMANSH: u32 = 23;
pub const LANG_RUSSIAN: u32 = 25;
pub const LANG_SAKHA: u32 = 133;
pub const LANG_SAMI: u32 = 59;
pub const LANG_SANSKRIT: u32 = 79;
pub const LANG_SCOTTISH_GAELIC: u32 = 145;
pub const LANG_SERBIAN: u32 = 26;
pub const LANG_SERBIAN_NEUTRAL: u32 = 31770;
pub const LANG_SINDHI: u32 = 89;
pub const LANG_SINHALESE: u32 = 91;
pub const LANG_SLOVAK: u32 = 27;
pub const LANG_SLOVENIAN: u32 = 36;
pub const LANG_SOTHO: u32 = 108;
pub const LANG_SPANISH: u32 = 10;
pub const LANG_SWAHILI: u32 = 65;
pub const LANG_SWEDISH: u32 = 29;
pub const LANG_SYRIAC: u32 = 90;
pub const LANG_TAJIK: u32 = 40;
pub const LANG_TAMAZIGHT: u32 = 95;
pub const LANG_TAMIL: u32 = 73;
pub const LANG_TATAR: u32 = 68;
pub const LANG_TELUGU: u32 = 74;
pub const LANG_THAI: u32 = 30;
pub const LANG_TIBETAN: u32 = 81;
pub const LANG_TIGRIGNA: u32 = 115;
pub const LANG_TIGRINYA: u32 = 115;
pub const LANG_TSWANA: u32 = 50;
pub const LANG_TURKISH: u32 = 31;
pub const LANG_TURKMEN: u32 = 66;
pub const LANG_UIGHUR: u32 = 128;
pub const LANG_UKRAINIAN: u32 = 34;
pub const LANG_UPPER_SORBIAN: u32 = 46;
pub const LANG_URDU: u32 = 32;
pub const LANG_UZBEK: u32 = 67;
pub const LANG_VALENCIAN: u32 = 3;
pub const LANG_VIETNAMESE: u32 = 42;
pub const LANG_WELSH: u32 = 82;
pub const LANG_WOLOF: u32 = 136;
pub const LANG_XHOSA: u32 = 52;
pub const LANG_YAKUT: u32 = 133;
pub const LANG_YI: u32 = 120;
pub const LANG_YORUBA: u32 = 106;
pub const LANG_ZULU: u32 = 53;
pub const SUBLANG_NEUTRAL: u32 = 0;
pub const SUBLANG_DEFAULT: u32 = 1;
pub const SUBLANG_SYS_DEFAULT: u32 = 2;
pub const SUBLANG_CUSTOM_DEFAULT: u32 = 3;
pub const SUBLANG_CUSTOM_UNSPECIFIED: u32 = 4;
pub const SUBLANG_UI_CUSTOM_DEFAULT: u32 = 5;
pub const SUBLANG_AFRIKAANS_SOUTH_AFRICA: u32 = 1;
pub const SUBLANG_ALBANIAN_ALBANIA: u32 = 1;
pub const SUBLANG_ALSATIAN_FRANCE: u32 = 1;
pub const SUBLANG_AMHARIC_ETHIOPIA: u32 = 1;
pub const SUBLANG_ARABIC_SAUDI_ARABIA: u32 = 1;
pub const SUBLANG_ARABIC_IRAQ: u32 = 2;
pub const SUBLANG_ARABIC_EGYPT: u32 = 3;
pub const SUBLANG_ARABIC_LIBYA: u32 = 4;
pub const SUBLANG_ARABIC_ALGERIA: u32 = 5;
pub const SUBLANG_ARABIC_MOROCCO: u32 = 6;
pub const SUBLANG_ARABIC_TUNISIA: u32 = 7;
pub const SUBLANG_ARABIC_OMAN: u32 = 8;
pub const SUBLANG_ARABIC_YEMEN: u32 = 9;
pub const SUBLANG_ARABIC_SYRIA: u32 = 10;
pub const SUBLANG_ARABIC_JORDAN: u32 = 11;
pub const SUBLANG_ARABIC_LEBANON: u32 = 12;
pub const SUBLANG_ARABIC_KUWAIT: u32 = 13;
pub const SUBLANG_ARABIC_UAE: u32 = 14;
pub const SUBLANG_ARABIC_BAHRAIN: u32 = 15;
pub const SUBLANG_ARABIC_QATAR: u32 = 16;
pub const SUBLANG_ARMENIAN_ARMENIA: u32 = 1;
pub const SUBLANG_ASSAMESE_INDIA: u32 = 1;
pub const SUBLANG_AZERI_LATIN: u32 = 1;
pub const SUBLANG_AZERI_CYRILLIC: u32 = 2;
pub const SUBLANG_AZERBAIJANI_AZERBAIJAN_LATIN: u32 = 1;
pub const SUBLANG_AZERBAIJANI_AZERBAIJAN_CYRILLIC: u32 = 2;
pub const SUBLANG_BANGLA_INDIA: u32 = 1;
pub const SUBLANG_BANGLA_BANGLADESH: u32 = 2;
pub const SUBLANG_BASHKIR_RUSSIA: u32 = 1;
pub const SUBLANG_BASQUE_BASQUE: u32 = 1;
pub const SUBLANG_BELARUSIAN_BELARUS: u32 = 1;
pub const SUBLANG_BENGALI_INDIA: u32 = 1;
pub const SUBLANG_BENGALI_BANGLADESH: u32 = 2;
pub const SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN: u32 = 5;
pub const SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC: u32 = 8;
pub const SUBLANG_BRETON_FRANCE: u32 = 1;
pub const SUBLANG_BULGARIAN_BULGARIA: u32 = 1;
pub const SUBLANG_CATALAN_CATALAN: u32 = 1;
pub const SUBLANG_CENTRAL_KURDISH_IRAQ: u32 = 1;
pub const SUBLANG_CHEROKEE_CHEROKEE: u32 = 1;
pub const SUBLANG_CHINESE_TRADITIONAL: u32 = 1;
pub const SUBLANG_CHINESE_SIMPLIFIED: u32 = 2;
pub const SUBLANG_CHINESE_HONGKONG: u32 = 3;
pub const SUBLANG_CHINESE_SINGAPORE: u32 = 4;
pub const SUBLANG_CHINESE_MACAU: u32 = 5;
pub const SUBLANG_CORSICAN_FRANCE: u32 = 1;
pub const SUBLANG_CZECH_CZECH_REPUBLIC: u32 = 1;
pub const SUBLANG_CROATIAN_CROATIA: u32 = 1;
pub const SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN: u32 = 4;
pub const SUBLANG_DANISH_DENMARK: u32 = 1;
pub const SUBLANG_DARI_AFGHANISTAN: u32 = 1;
pub const SUBLANG_DIVEHI_MALDIVES: u32 = 1;
pub const SUBLANG_DUTCH: u32 = 1;
pub const SUBLANG_DUTCH_BELGIAN: u32 = 2;
pub const SUBLANG_ENGLISH_US: u32 = 1;
pub const SUBLANG_ENGLISH_UK: u32 = 2;
pub const SUBLANG_ENGLISH_AUS: u32 = 3;
pub const SUBLANG_ENGLISH_CAN: u32 = 4;
pub const SUBLANG_ENGLISH_NZ: u32 = 5;
pub const SUBLANG_ENGLISH_EIRE: u32 = 6;
pub const SUBLANG_ENGLISH_SOUTH_AFRICA: u32 = 7;
pub const SUBLANG_ENGLISH_JAMAICA: u32 = 8;
pub const SUBLANG_ENGLISH_CARIBBEAN: u32 = 9;
pub const SUBLANG_ENGLISH_BELIZE: u32 = 10;
pub const SUBLANG_ENGLISH_TRINIDAD: u32 = 11;
pub const SUBLANG_ENGLISH_ZIMBABWE: u32 = 12;
pub const SUBLANG_ENGLISH_PHILIPPINES: u32 = 13;
pub const SUBLANG_ENGLISH_INDIA: u32 = 16;
pub const SUBLANG_ENGLISH_MALAYSIA: u32 = 17;
pub const SUBLANG_ENGLISH_SINGAPORE: u32 = 18;
pub const SUBLANG_ESTONIAN_ESTONIA: u32 = 1;
pub const SUBLANG_FAEROESE_FAROE_ISLANDS: u32 = 1;
pub const SUBLANG_FILIPINO_PHILIPPINES: u32 = 1;
pub const SUBLANG_FINNISH_FINLAND: u32 = 1;
pub const SUBLANG_FRENCH: u32 = 1;
pub const SUBLANG_FRENCH_BELGIAN: u32 = 2;
pub const SUBLANG_FRENCH_CANADIAN: u32 = 3;
pub const SUBLANG_FRENCH_SWISS: u32 = 4;
pub const SUBLANG_FRENCH_LUXEMBOURG: u32 = 5;
pub const SUBLANG_FRENCH_MONACO: u32 = 6;
pub const SUBLANG_FRISIAN_NETHERLANDS: u32 = 1;
pub const SUBLANG_FULAH_SENEGAL: u32 = 2;
pub const SUBLANG_GALICIAN_GALICIAN: u32 = 1;
pub const SUBLANG_GEORGIAN_GEORGIA: u32 = 1;
pub const SUBLANG_GERMAN: u32 = 1;
pub const SUBLANG_GERMAN_SWISS: u32 = 2;
pub const SUBLANG_GERMAN_AUSTRIAN: u32 = 3;
pub const SUBLANG_GERMAN_LUXEMBOURG: u32 = 4;
pub const SUBLANG_GERMAN_LIECHTENSTEIN: u32 = 5;
pub const SUBLANG_GREEK_GREECE: u32 = 1;
pub const SUBLANG_GREENLANDIC_GREENLAND: u32 = 1;
pub const SUBLANG_GUJARATI_INDIA: u32 = 1;
pub const SUBLANG_HAUSA_NIGERIA_LATIN: u32 = 1;
pub const SUBLANG_HAWAIIAN_US: u32 = 1;
pub const SUBLANG_HEBREW_ISRAEL: u32 = 1;
pub const SUBLANG_HINDI_INDIA: u32 = 1;
pub const SUBLANG_HUNGARIAN_HUNGARY: u32 = 1;
pub const SUBLANG_ICELANDIC_ICELAND: u32 = 1;
pub const SUBLANG_IGBO_NIGERIA: u32 = 1;
pub const SUBLANG_INDONESIAN_INDONESIA: u32 = 1;
pub const SUBLANG_INUKTITUT_CANADA: u32 = 1;
pub const SUBLANG_INUKTITUT_CANADA_LATIN: u32 = 2;
pub const SUBLANG_IRISH_IRELAND: u32 = 2;
pub const SUBLANG_ITALIAN: u32 = 1;
pub const SUBLANG_ITALIAN_SWISS: u32 = 2;
pub const SUBLANG_JAPANESE_JAPAN: u32 = 1;
pub const SUBLANG_KANNADA_INDIA: u32 = 1;
pub const SUBLANG_KASHMIRI_SASIA: u32 = 2;
pub const SUBLANG_KASHMIRI_INDIA: u32 = 2;
pub const SUBLANG_KAZAK_KAZAKHSTAN: u32 = 1;
pub const SUBLANG_KHMER_CAMBODIA: u32 = 1;
pub const SUBLANG_KICHE_GUATEMALA: u32 = 1;
pub const SUBLANG_KINYARWANDA_RWANDA: u32 = 1;
pub const SUBLANG_KONKANI_INDIA: u32 = 1;
pub const SUBLANG_KOREAN: u32 = 1;
pub const SUBLANG_KYRGYZ_KYRGYZSTAN: u32 = 1;
pub const SUBLANG_LAO_LAO: u32 = 1;
pub const SUBLANG_LATVIAN_LATVIA: u32 = 1;
pub const SUBLANG_LITHUANIAN: u32 = 1;
pub const SUBLANG_LOWER_SORBIAN_GERMANY: u32 = 2;
pub const SUBLANG_LUXEMBOURGISH_LUXEMBOURG: u32 = 1;
pub const SUBLANG_MACEDONIAN_MACEDONIA: u32 = 1;
pub const SUBLANG_MALAY_MALAYSIA: u32 = 1;
pub const SUBLANG_MALAY_BRUNEI_DARUSSALAM: u32 = 2;
pub const SUBLANG_MALAYALAM_INDIA: u32 = 1;
pub const SUBLANG_MALTESE_MALTA: u32 = 1;
pub const SUBLANG_MAORI_NEW_ZEALAND: u32 = 1;
pub const SUBLANG_MAPUDUNGUN_CHILE: u32 = 1;
pub const SUBLANG_MARATHI_INDIA: u32 = 1;
pub const SUBLANG_MOHAWK_MOHAWK: u32 = 1;
pub const SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA: u32 = 1;
pub const SUBLANG_MONGOLIAN_PRC: u32 = 2;
pub const SUBLANG_NEPALI_INDIA: u32 = 2;
pub const SUBLANG_NEPALI_NEPAL: u32 = 1;
pub const SUBLANG_NORWEGIAN_BOKMAL: u32 = 1;
pub const SUBLANG_NORWEGIAN_NYNORSK: u32 = 2;
pub const SUBLANG_OCCITAN_FRANCE: u32 = 1;
pub const SUBLANG_ODIA_INDIA: u32 = 1;
pub const SUBLANG_ORIYA_INDIA: u32 = 1;
pub const SUBLANG_PASHTO_AFGHANISTAN: u32 = 1;
pub const SUBLANG_PERSIAN_IRAN: u32 = 1;
pub const SUBLANG_POLISH_POLAND: u32 = 1;
pub const SUBLANG_PORTUGUESE: u32 = 2;
pub const SUBLANG_PORTUGUESE_BRAZILIAN: u32 = 1;
pub const SUBLANG_PULAR_SENEGAL: u32 = 2;
pub const SUBLANG_PUNJABI_INDIA: u32 = 1;
pub const SUBLANG_PUNJABI_PAKISTAN: u32 = 2;
pub const SUBLANG_QUECHUA_BOLIVIA: u32 = 1;
pub const SUBLANG_QUECHUA_ECUADOR: u32 = 2;
pub const SUBLANG_QUECHUA_PERU: u32 = 3;
pub const SUBLANG_ROMANIAN_ROMANIA: u32 = 1;
pub const SUBLANG_ROMANSH_SWITZERLAND: u32 = 1;
pub const SUBLANG_RUSSIAN_RUSSIA: u32 = 1;
pub const SUBLANG_SAKHA_RUSSIA: u32 = 1;
pub const SUBLANG_SAMI_NORTHERN_NORWAY: u32 = 1;
pub const SUBLANG_SAMI_NORTHERN_SWEDEN: u32 = 2;
pub const SUBLANG_SAMI_NORTHERN_FINLAND: u32 = 3;
pub const SUBLANG_SAMI_LULE_NORWAY: u32 = 4;
pub const SUBLANG_SAMI_LULE_SWEDEN: u32 = 5;
pub const SUBLANG_SAMI_SOUTHERN_NORWAY: u32 = 6;
pub const SUBLANG_SAMI_SOUTHERN_SWEDEN: u32 = 7;
pub const SUBLANG_SAMI_SKOLT_FINLAND: u32 = 8;
pub const SUBLANG_SAMI_INARI_FINLAND: u32 = 9;
pub const SUBLANG_SANSKRIT_INDIA: u32 = 1;
pub const SUBLANG_SCOTTISH_GAELIC: u32 = 1;
pub const SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_LATIN: u32 = 6;
pub const SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_CYRILLIC: u32 = 7;
pub const SUBLANG_SERBIAN_MONTENEGRO_LATIN: u32 = 11;
pub const SUBLANG_SERBIAN_MONTENEGRO_CYRILLIC: u32 = 12;
pub const SUBLANG_SERBIAN_SERBIA_LATIN: u32 = 9;
pub const SUBLANG_SERBIAN_SERBIA_CYRILLIC: u32 = 10;
pub const SUBLANG_SERBIAN_CROATIA: u32 = 1;
pub const SUBLANG_SERBIAN_LATIN: u32 = 2;
pub const SUBLANG_SERBIAN_CYRILLIC: u32 = 3;
pub const SUBLANG_SINDHI_INDIA: u32 = 1;
pub const SUBLANG_SINDHI_PAKISTAN: u32 = 2;
pub const SUBLANG_SINDHI_AFGHANISTAN: u32 = 2;
pub const SUBLANG_SINHALESE_SRI_LANKA: u32 = 1;
pub const SUBLANG_SOTHO_NORTHERN_SOUTH_AFRICA: u32 = 1;
pub const SUBLANG_SLOVAK_SLOVAKIA: u32 = 1;
pub const SUBLANG_SLOVENIAN_SLOVENIA: u32 = 1;
pub const SUBLANG_SPANISH: u32 = 1;
pub const SUBLANG_SPANISH_MEXICAN: u32 = 2;
pub const SUBLANG_SPANISH_MODERN: u32 = 3;
pub const SUBLANG_SPANISH_GUATEMALA: u32 = 4;
pub const SUBLANG_SPANISH_COSTA_RICA: u32 = 5;
pub const SUBLANG_SPANISH_PANAMA: u32 = 6;
pub const SUBLANG_SPANISH_DOMINICAN_REPUBLIC: u32 = 7;
pub const SUBLANG_SPANISH_VENEZUELA: u32 = 8;
pub const SUBLANG_SPANISH_COLOMBIA: u32 = 9;
pub const SUBLANG_SPANISH_PERU: u32 = 10;
pub const SUBLANG_SPANISH_ARGENTINA: u32 = 11;
pub const SUBLANG_SPANISH_ECUADOR: u32 = 12;
pub const SUBLANG_SPANISH_CHILE: u32 = 13;
pub const SUBLANG_SPANISH_URUGUAY: u32 = 14;
pub const SUBLANG_SPANISH_PARAGUAY: u32 = 15;
pub const SUBLANG_SPANISH_BOLIVIA: u32 = 16;
pub const SUBLANG_SPANISH_EL_SALVADOR: u32 = 17;
pub const SUBLANG_SPANISH_HONDURAS: u32 = 18;
pub const SUBLANG_SPANISH_NICARAGUA: u32 = 19;
pub const SUBLANG_SPANISH_PUERTO_RICO: u32 = 20;
pub const SUBLANG_SPANISH_US: u32 = 21;
pub const SUBLANG_SWAHILI_KENYA: u32 = 1;
pub const SUBLANG_SWEDISH: u32 = 1;
pub const SUBLANG_SWEDISH_FINLAND: u32 = 2;
pub const SUBLANG_SYRIAC_SYRIA: u32 = 1;
pub const SUBLANG_TAJIK_TAJIKISTAN: u32 = 1;
pub const SUBLANG_TAMAZIGHT_ALGERIA_LATIN: u32 = 2;
pub const SUBLANG_TAMAZIGHT_MOROCCO_TIFINAGH: u32 = 4;
pub const SUBLANG_TAMIL_INDIA: u32 = 1;
pub const SUBLANG_TAMIL_SRI_LANKA: u32 = 2;
pub const SUBLANG_TATAR_RUSSIA: u32 = 1;
pub const SUBLANG_TELUGU_INDIA: u32 = 1;
pub const SUBLANG_THAI_THAILAND: u32 = 1;
pub const SUBLANG_TIBETAN_PRC: u32 = 1;
pub const SUBLANG_TIGRIGNA_ERITREA: u32 = 2;
pub const SUBLANG_TIGRINYA_ERITREA: u32 = 2;
pub const SUBLANG_TIGRINYA_ETHIOPIA: u32 = 1;
pub const SUBLANG_TSWANA_BOTSWANA: u32 = 2;
pub const SUBLANG_TSWANA_SOUTH_AFRICA: u32 = 1;
pub const SUBLANG_TURKISH_TURKEY: u32 = 1;
pub const SUBLANG_TURKMEN_TURKMENISTAN: u32 = 1;
pub const SUBLANG_UIGHUR_PRC: u32 = 1;
pub const SUBLANG_UKRAINIAN_UKRAINE: u32 = 1;
pub const SUBLANG_UPPER_SORBIAN_GERMANY: u32 = 1;
pub const SUBLANG_URDU_PAKISTAN: u32 = 1;
pub const SUBLANG_URDU_INDIA: u32 = 2;
pub const SUBLANG_UZBEK_LATIN: u32 = 1;
pub const SUBLANG_UZBEK_CYRILLIC: u32 = 2;
pub const SUBLANG_VALENCIAN_VALENCIA: u32 = 2;
pub const SUBLANG_VIETNAMESE_VIETNAM: u32 = 1;
pub const SUBLANG_WELSH_UNITED_KINGDOM: u32 = 1;
pub const SUBLANG_WOLOF_SENEGAL: u32 = 1;
pub const SUBLANG_XHOSA_SOUTH_AFRICA: u32 = 1;
pub const SUBLANG_YAKUT_RUSSIA: u32 = 1;
pub const SUBLANG_YI_PRC: u32 = 1;
pub const SUBLANG_YORUBA_NIGERIA: u32 = 1;
pub const SUBLANG_ZULU_SOUTH_AFRICA: u32 = 1;
pub const SORT_DEFAULT: u32 = 0;
pub const SORT_INVARIANT_MATH: u32 = 1;
pub const SORT_JAPANESE_XJIS: u32 = 0;
pub const SORT_JAPANESE_UNICODE: u32 = 1;
pub const SORT_JAPANESE_RADICALSTROKE: u32 = 4;
pub const SORT_CHINESE_BIG5: u32 = 0;
pub const SORT_CHINESE_PRCP: u32 = 0;
pub const SORT_CHINESE_UNICODE: u32 = 1;
pub const SORT_CHINESE_PRC: u32 = 2;
pub const SORT_CHINESE_BOPOMOFO: u32 = 3;
pub const SORT_CHINESE_RADICALSTROKE: u32 = 4;
pub const SORT_KOREAN_KSC: u32 = 0;
pub const SORT_KOREAN_UNICODE: u32 = 1;
pub const SORT_GERMAN_PHONE_BOOK: u32 = 1;
pub const SORT_HUNGARIAN_DEFAULT: u32 = 0;
pub const SORT_HUNGARIAN_TECHNICAL: u32 = 1;
pub const SORT_GEORGIAN_TRADITIONAL: u32 = 0;
pub const SORT_GEORGIAN_MODERN: u32 = 1;
pub const NLS_VALID_LOCALE_MASK: u32 = 1048575;
pub const LOCALE_NAME_MAX_LENGTH: u32 = 85;
pub const LOCALE_TRANSIENT_KEYBOARD1: u32 = 8192;
pub const LOCALE_TRANSIENT_KEYBOARD2: u32 = 9216;
pub const LOCALE_TRANSIENT_KEYBOARD3: u32 = 10240;
pub const LOCALE_TRANSIENT_KEYBOARD4: u32 = 11264;
pub const FACILITY_DEBUGGER: u32 = 1;
pub const FACILITY_RPC_RUNTIME: u32 = 2;
pub const FACILITY_RPC_STUBS: u32 = 3;
pub const FACILITY_IO_ERROR_CODE: u32 = 4;
pub const FACILITY_CODCLASS_ERROR_CODE: u32 = 6;
pub const FACILITY_NTWIN32: u32 = 7;
pub const FACILITY_NTCERT: u32 = 8;
pub const FACILITY_NTSSPI: u32 = 9;
pub const FACILITY_TERMINAL_SERVER: u32 = 10;
pub const FACILTIY_MUI_ERROR_CODE: u32 = 11;
pub const FACILITY_USB_ERROR_CODE: u32 = 16;
pub const FACILITY_HID_ERROR_CODE: u32 = 17;
pub const FACILITY_FIREWIRE_ERROR_CODE: u32 = 18;
pub const FACILITY_CLUSTER_ERROR_CODE: u32 = 19;
pub const FACILITY_ACPI_ERROR_CODE: u32 = 20;
pub const FACILITY_SXS_ERROR_CODE: u32 = 21;
pub const FACILITY_TRANSACTION: u32 = 25;
pub const FACILITY_COMMONLOG: u32 = 26;
pub const FACILITY_VIDEO: u32 = 27;
pub const FACILITY_FILTER_MANAGER: u32 = 28;
pub const FACILITY_MONITOR: u32 = 29;
pub const FACILITY_GRAPHICS_KERNEL: u32 = 30;
pub const FACILITY_CAMERA: u32 = 31;
pub const FACILITY_DRIVER_FRAMEWORK: u32 = 32;
pub const FACILITY_FVE_ERROR_CODE: u32 = 33;
pub const FACILITY_FWP_ERROR_CODE: u32 = 34;
pub const FACILITY_NDIS_ERROR_CODE: u32 = 35;
pub const FACILITY_QUIC_ERROR_CODE: u32 = 36;
pub const FACILITY_TPM: u32 = 41;
pub const FACILITY_RTPM: u32 = 42;
pub const FACILITY_HYPERVISOR: u32 = 53;
pub const FACILITY_IPSEC: u32 = 54;
pub const FACILITY_VIRTUALIZATION: u32 = 55;
pub const FACILITY_VOLMGR: u32 = 56;
pub const FACILITY_BCD_ERROR_CODE: u32 = 57;
pub const FACILITY_WIN32K_NTUSER: u32 = 62;
pub const FACILITY_WIN32K_NTGDI: u32 = 63;
pub const FACILITY_RESUME_KEY_FILTER: u32 = 64;
pub const FACILITY_RDBSS: u32 = 65;
pub const FACILITY_BTH_ATT: u32 = 66;
pub const FACILITY_SECUREBOOT: u32 = 67;
pub const FACILITY_AUDIO_KERNEL: u32 = 68;
pub const FACILITY_VSM: u32 = 69;
pub const FACILITY_NT_IORING: u32 = 70;
pub const FACILITY_VOLSNAP: u32 = 80;
pub const FACILITY_SDBUS: u32 = 81;
pub const FACILITY_SHARED_VHDX: u32 = 92;
pub const FACILITY_SMB: u32 = 93;
pub const FACILITY_XVS: u32 = 94;
pub const FACILITY_INTERIX: u32 = 153;
pub const FACILITY_SPACES: u32 = 231;
pub const FACILITY_SECURITY_CORE: u32 = 232;
pub const FACILITY_SYSTEM_INTEGRITY: u32 = 233;
pub const FACILITY_LICENSING: u32 = 234;
pub const FACILITY_PLATFORM_MANIFEST: u32 = 235;
pub const FACILITY_APP_EXEC: u32 = 236;
pub const FACILITY_UNIONFS: u32 = 237;
pub const FACILITY_PLATFORM_RUNTIME_MECHANISM: u32 = 238;
pub const FACILITY_WIN_ACCEL: u32 = 239;
pub const FACILITY_MAXIMUM_VALUE: u32 = 240;
pub const STATUS_SEVERITY_SUCCESS: u32 = 0;
pub const STATUS_SEVERITY_INFORMATIONAL: u32 = 1;
pub const STATUS_SEVERITY_WARNING: u32 = 2;
pub const STATUS_SEVERITY_ERROR: u32 = 3;
pub const BUGCHECK_CONTEXT_MODIFIER: u32 = 2147483648;
pub const FACILITY_MCA_ERROR_CODE: u32 = 5;
pub const MCA_EXTREG_V2MAX: u32 = 24;
pub const LOW_LEVEL: u32 = 0;
pub const CMCI_LEVEL: u32 = 5;
pub const CLOCK_LEVEL: u32 = 13;
pub const IPI_LEVEL: u32 = 14;
pub const DRS_LEVEL: u32 = 14;
pub const POWER_LEVEL: u32 = 14;
pub const PROFILE_LEVEL: u32 = 15;
pub const LOW_PRIORITY: u32 = 0;
pub const LOW_REALTIME_PRIORITY: u32 = 16;
pub const HIGH_PRIORITY: u32 = 31;
pub const MAXIMUM_PRIORITY: u32 = 32;
pub const MAXIMUM_WAIT_OBJECTS: u32 = 64;
pub const MAXIMUM_SUSPEND_COUNT: u32 = 127;
pub const LOCK_QUEUE_WAIT: u32 = 1;
pub const LOCK_QUEUE_WAIT_BIT: u32 = 0;
pub const LOCK_QUEUE_OWNER: u32 = 2;
pub const LOCK_QUEUE_OWNER_BIT: u32 = 1;
pub const LOCK_QUEUE_HALTED: u32 = 4;
pub const LOCK_QUEUE_HALTED_BIT: u32 = 2;
pub const LOCK_QUEUE_VALID_FLAGS: u32 = 7;
pub const LockQueueUnusedSpare0: u32 = 0;
pub const LockQueueUnusedSpare1: u32 = 1;
pub const LockQueueUnusedSpare2: u32 = 2;
pub const LockQueueUnusedSpare3: u32 = 3;
pub const LockQueueVacbLock: u32 = 4;
pub const LockQueueMasterLock: u32 = 5;
pub const LockQueueNonPagedPoolLock: u32 = 6;
pub const LockQueueIoCancelLock: u32 = 7;
pub const LockQueueUnusedSpare8: u32 = 8;
pub const LockQueueIoVpbLock: u32 = 9;
pub const LockQueueIoDatabaseLock: u32 = 10;
pub const LockQueueIoCompletionLock: u32 = 11;
pub const LockQueueNtfsStructLock: u32 = 12;
pub const LockQueueAfdWorkQueueLock: u32 = 13;
pub const LockQueueBcbLock: u32 = 14;
pub const LockQueueUnusedSpare15: u32 = 15;
pub const LockQueueUnusedSpare16: u32 = 16;
pub const LockQueueMaximumLock: u32 = 17;
pub const DPC_WATCHDOG_GLOBAL_TRIAGE_BLOCK_SIGNATURE: u32 = 2931740382;
pub const DPC_WATCHDOG_GLOBAL_TRIAGE_BLOCK_REVISION_1: u32 = 1;
pub const _MM_HINT_T0: u32 = 1;
pub const _MM_HINT_T1: u32 = 2;
pub const _MM_HINT_T2: u32 = 3;
pub const _MM_HINT_NTA: u32 = 0;
pub const PF_TEMPORAL_LEVEL_1: u32 = 1;
pub const PF_TEMPORAL_LEVEL_2: u32 = 2;
pub const PF_TEMPORAL_LEVEL_3: u32 = 3;
pub const PF_NON_TEMPORAL_LEVEL_ALL: u32 = 0;
pub const DELETE: u32 = 65536;
pub const READ_CONTROL: u32 = 131072;
pub const WRITE_DAC: u32 = 262144;
pub const WRITE_OWNER: u32 = 524288;
pub const SYNCHRONIZE: u32 = 1048576;
pub const STANDARD_RIGHTS_REQUIRED: u32 = 983040;
pub const STANDARD_RIGHTS_READ: u32 = 131072;
pub const STANDARD_RIGHTS_WRITE: u32 = 131072;
pub const STANDARD_RIGHTS_EXECUTE: u32 = 131072;
pub const STANDARD_RIGHTS_ALL: u32 = 2031616;
pub const SPECIFIC_RIGHTS_ALL: u32 = 65535;
pub const ACCESS_SYSTEM_SECURITY: u32 = 16777216;
pub const MAXIMUM_ALLOWED: u32 = 33554432;
pub const GENERIC_READ: u32 = 2147483648;
pub const GENERIC_WRITE: u32 = 1073741824;
pub const GENERIC_EXECUTE: u32 = 536870912;
pub const GENERIC_ALL: u32 = 268435456;
pub const ACL_REVISION: u32 = 2;
pub const ACL_REVISION_DS: u32 = 4;
pub const ACL_REVISION1: u32 = 1;
pub const ACL_REVISION2: u32 = 2;
pub const ACL_REVISION3: u32 = 3;
pub const ACL_REVISION4: u32 = 4;
pub const MAX_ACL_REVISION: u32 = 4;
pub const SECURITY_DESCRIPTOR_REVISION: u32 = 1;
pub const SECURITY_DESCRIPTOR_REVISION1: u32 = 1;
pub const SE_PRIVILEGE_ENABLED_BY_DEFAULT: u32 = 1;
pub const SE_PRIVILEGE_ENABLED: u32 = 2;
pub const SE_PRIVILEGE_REMOVED: u32 = 4;
pub const SE_PRIVILEGE_USED_FOR_ACCESS: u32 = 2147483648;
pub const SE_PRIVILEGE_VALID_ATTRIBUTES: u32 = 2147483655;
pub const PRIVILEGE_SET_ALL_NECESSARY: u32 = 1;
pub const SE_MIN_WELL_KNOWN_PRIVILEGE: u32 = 2;
pub const SE_CREATE_TOKEN_PRIVILEGE: u32 = 2;
pub const SE_ASSIGNPRIMARYTOKEN_PRIVILEGE: u32 = 3;
pub const SE_LOCK_MEMORY_PRIVILEGE: u32 = 4;
pub const SE_INCREASE_QUOTA_PRIVILEGE: u32 = 5;
pub const SE_MACHINE_ACCOUNT_PRIVILEGE: u32 = 6;
pub const SE_TCB_PRIVILEGE: u32 = 7;
pub const SE_SECURITY_PRIVILEGE: u32 = 8;
pub const SE_TAKE_OWNERSHIP_PRIVILEGE: u32 = 9;
pub const SE_LOAD_DRIVER_PRIVILEGE: u32 = 10;
pub const SE_SYSTEM_PROFILE_PRIVILEGE: u32 = 11;
pub const SE_SYSTEMTIME_PRIVILEGE: u32 = 12;
pub const SE_PROF_SINGLE_PROCESS_PRIVILEGE: u32 = 13;
pub const SE_INC_BASE_PRIORITY_PRIVILEGE: u32 = 14;
pub const SE_CREATE_PAGEFILE_PRIVILEGE: u32 = 15;
pub const SE_CREATE_PERMANENT_PRIVILEGE: u32 = 16;
pub const SE_BACKUP_PRIVILEGE: u32 = 17;
pub const SE_RESTORE_PRIVILEGE: u32 = 18;
pub const SE_SHUTDOWN_PRIVILEGE: u32 = 19;
pub const SE_DEBUG_PRIVILEGE: u32 = 20;
pub const SE_AUDIT_PRIVILEGE: u32 = 21;
pub const SE_SYSTEM_ENVIRONMENT_PRIVILEGE: u32 = 22;
pub const SE_CHANGE_NOTIFY_PRIVILEGE: u32 = 23;
pub const SE_REMOTE_SHUTDOWN_PRIVILEGE: u32 = 24;
pub const SE_UNDOCK_PRIVILEGE: u32 = 25;
pub const SE_SYNC_AGENT_PRIVILEGE: u32 = 26;
pub const SE_ENABLE_DELEGATION_PRIVILEGE: u32 = 27;
pub const SE_MANAGE_VOLUME_PRIVILEGE: u32 = 28;
pub const SE_IMPERSONATE_PRIVILEGE: u32 = 29;
pub const SE_CREATE_GLOBAL_PRIVILEGE: u32 = 30;
pub const SE_TRUSTED_CREDMAN_ACCESS_PRIVILEGE: u32 = 31;
pub const SE_RELABEL_PRIVILEGE: u32 = 32;
pub const SE_INC_WORKING_SET_PRIVILEGE: u32 = 33;
pub const SE_TIME_ZONE_PRIVILEGE: u32 = 34;
pub const SE_CREATE_SYMBOLIC_LINK_PRIVILEGE: u32 = 35;
pub const SE_DELEGATE_SESSION_USER_IMPERSONATE_PRIVILEGE: u32 = 36;
pub const SE_MAX_WELL_KNOWN_PRIVILEGE: u32 = 36;
pub const SECURITY_DYNAMIC_TRACKING: u32 = 1;
pub const SECURITY_STATIC_TRACKING: u32 = 0;
pub const OWNER_SECURITY_INFORMATION: u32 = 1;
pub const GROUP_SECURITY_INFORMATION: u32 = 2;
pub const DACL_SECURITY_INFORMATION: u32 = 4;
pub const SACL_SECURITY_INFORMATION: u32 = 8;
pub const LABEL_SECURITY_INFORMATION: u32 = 16;
pub const ATTRIBUTE_SECURITY_INFORMATION: u32 = 32;
pub const SCOPE_SECURITY_INFORMATION: u32 = 64;
pub const PROCESS_TRUST_LABEL_SECURITY_INFORMATION: u32 = 128;
pub const ACCESS_FILTER_SECURITY_INFORMATION: u32 = 256;
pub const BACKUP_SECURITY_INFORMATION: u32 = 65536;
pub const PROTECTED_DACL_SECURITY_INFORMATION: u32 = 2147483648;
pub const PROTECTED_SACL_SECURITY_INFORMATION: u32 = 1073741824;
pub const UNPROTECTED_DACL_SECURITY_INFORMATION: u32 = 536870912;
pub const UNPROTECTED_SACL_SECURITY_INFORMATION: u32 = 268435456;
pub const SE_ADT_OBJECT_ONLY: u32 = 1;
pub const SE_MAX_AUDIT_PARAMETERS: u32 = 32;
pub const SE_MAX_GENERIC_AUDIT_PARAMETERS: u32 = 28;
pub const SE_ADT_PARAMETERS_SELF_RELATIVE: u32 = 1;
pub const SE_ADT_PARAMETERS_SEND_TO_LSA: u32 = 2;
pub const SE_ADT_PARAMETER_EXTENSIBLE_AUDIT: u32 = 4;
pub const SE_ADT_PARAMETER_GENERIC_AUDIT: u32 = 8;
pub const SE_ADT_PARAMETER_WRITE_SYNCHRONOUS: u32 = 16;
pub const FILE_DEVICE_BEEP: u32 = 1;
pub const FILE_DEVICE_CD_ROM: u32 = 2;
pub const FILE_DEVICE_CD_ROM_FILE_SYSTEM: u32 = 3;
pub const FILE_DEVICE_CONTROLLER: u32 = 4;
pub const FILE_DEVICE_DATALINK: u32 = 5;
pub const FILE_DEVICE_DFS: u32 = 6;
pub const FILE_DEVICE_DISK: u32 = 7;
pub const FILE_DEVICE_DISK_FILE_SYSTEM: u32 = 8;
pub const FILE_DEVICE_FILE_SYSTEM: u32 = 9;
pub const FILE_DEVICE_INPORT_PORT: u32 = 10;
pub const FILE_DEVICE_KEYBOARD: u32 = 11;
pub const FILE_DEVICE_MAILSLOT: u32 = 12;
pub const FILE_DEVICE_MIDI_IN: u32 = 13;
pub const FILE_DEVICE_MIDI_OUT: u32 = 14;
pub const FILE_DEVICE_MOUSE: u32 = 15;
pub const FILE_DEVICE_MULTI_UNC_PROVIDER: u32 = 16;
pub const FILE_DEVICE_NAMED_PIPE: u32 = 17;
pub const FILE_DEVICE_NETWORK: u32 = 18;
pub const FILE_DEVICE_NETWORK_BROWSER: u32 = 19;
pub const FILE_DEVICE_NETWORK_FILE_SYSTEM: u32 = 20;
pub const FILE_DEVICE_NULL: u32 = 21;
pub const FILE_DEVICE_PARALLEL_PORT: u32 = 22;
pub const FILE_DEVICE_PHYSICAL_NETCARD: u32 = 23;
pub const FILE_DEVICE_PRINTER: u32 = 24;
pub const FILE_DEVICE_SCANNER: u32 = 25;
pub const FILE_DEVICE_SERIAL_MOUSE_PORT: u32 = 26;
pub const FILE_DEVICE_SERIAL_PORT: u32 = 27;
pub const FILE_DEVICE_SCREEN: u32 = 28;
pub const FILE_DEVICE_SOUND: u32 = 29;
pub const FILE_DEVICE_STREAMS: u32 = 30;
pub const FILE_DEVICE_TAPE: u32 = 31;
pub const FILE_DEVICE_TAPE_FILE_SYSTEM: u32 = 32;
pub const FILE_DEVICE_TRANSPORT: u32 = 33;
pub const FILE_DEVICE_UNKNOWN: u32 = 34;
pub const FILE_DEVICE_VIDEO: u32 = 35;
pub const FILE_DEVICE_VIRTUAL_DISK: u32 = 36;
pub const FILE_DEVICE_WAVE_IN: u32 = 37;
pub const FILE_DEVICE_WAVE_OUT: u32 = 38;
pub const FILE_DEVICE_8042_PORT: u32 = 39;
pub const FILE_DEVICE_NETWORK_REDIRECTOR: u32 = 40;
pub const FILE_DEVICE_BATTERY: u32 = 41;
pub const FILE_DEVICE_BUS_EXTENDER: u32 = 42;
pub const FILE_DEVICE_MODEM: u32 = 43;
pub const FILE_DEVICE_VDM: u32 = 44;
pub const FILE_DEVICE_MASS_STORAGE: u32 = 45;
pub const FILE_DEVICE_SMB: u32 = 46;
pub const FILE_DEVICE_KS: u32 = 47;
pub const FILE_DEVICE_CHANGER: u32 = 48;
pub const FILE_DEVICE_SMARTCARD: u32 = 49;
pub const FILE_DEVICE_ACPI: u32 = 50;
pub const FILE_DEVICE_DVD: u32 = 51;
pub const FILE_DEVICE_FULLSCREEN_VIDEO: u32 = 52;
pub const FILE_DEVICE_DFS_FILE_SYSTEM: u32 = 53;
pub const FILE_DEVICE_DFS_VOLUME: u32 = 54;
pub const FILE_DEVICE_SERENUM: u32 = 55;
pub const FILE_DEVICE_TERMSRV: u32 = 56;
pub const FILE_DEVICE_KSEC: u32 = 57;
pub const FILE_DEVICE_FIPS: u32 = 58;
pub const FILE_DEVICE_INFINIBAND: u32 = 59;
pub const FILE_DEVICE_VMBUS: u32 = 62;
pub const FILE_DEVICE_CRYPT_PROVIDER: u32 = 63;
pub const FILE_DEVICE_WPD: u32 = 64;
pub const FILE_DEVICE_BLUETOOTH: u32 = 65;
pub const FILE_DEVICE_MT_COMPOSITE: u32 = 66;
pub const FILE_DEVICE_MT_TRANSPORT: u32 = 67;
pub const FILE_DEVICE_BIOMETRIC: u32 = 68;
pub const FILE_DEVICE_PMI: u32 = 69;
pub const FILE_DEVICE_EHSTOR: u32 = 70;
pub const FILE_DEVICE_DEVAPI: u32 = 71;
pub const FILE_DEVICE_GPIO: u32 = 72;
pub const FILE_DEVICE_USBEX: u32 = 73;
pub const FILE_DEVICE_CONSOLE: u32 = 80;
pub const FILE_DEVICE_NFP: u32 = 81;
pub const FILE_DEVICE_SYSENV: u32 = 82;
pub const FILE_DEVICE_VIRTUAL_BLOCK: u32 = 83;
pub const FILE_DEVICE_POINT_OF_SERVICE: u32 = 84;
pub const FILE_DEVICE_STORAGE_REPLICATION: u32 = 85;
pub const FILE_DEVICE_TRUST_ENV: u32 = 86;
pub const FILE_DEVICE_UCM: u32 = 87;
pub const FILE_DEVICE_UCMTCPCI: u32 = 88;
pub const FILE_DEVICE_PERSISTENT_MEMORY: u32 = 89;
pub const FILE_DEVICE_NVDIMM: u32 = 90;
pub const FILE_DEVICE_HOLOGRAPHIC: u32 = 91;
pub const FILE_DEVICE_SDFXHCI: u32 = 92;
pub const FILE_DEVICE_UCMUCSI: u32 = 93;
pub const FILE_DEVICE_PRM: u32 = 94;
pub const FILE_DEVICE_EVENT_COLLECTOR: u32 = 95;
pub const FILE_DEVICE_USB4: u32 = 96;
pub const FILE_DEVICE_SOUNDWIRE: u32 = 97;
pub const METHOD_BUFFERED: u32 = 0;
pub const METHOD_IN_DIRECT: u32 = 1;
pub const METHOD_OUT_DIRECT: u32 = 2;
pub const METHOD_NEITHER: u32 = 3;
pub const METHOD_DIRECT_TO_HARDWARE: u32 = 1;
pub const METHOD_DIRECT_FROM_HARDWARE: u32 = 2;
pub const FILE_ANY_ACCESS: u32 = 0;
pub const FILE_SPECIAL_ACCESS: u32 = 0;
pub const FILE_READ_ACCESS: u32 = 1;
pub const FILE_WRITE_ACCESS: u32 = 2;
pub const FILE_READ_DATA: u32 = 1;
pub const FILE_LIST_DIRECTORY: u32 = 1;
pub const FILE_WRITE_DATA: u32 = 2;
pub const FILE_ADD_FILE: u32 = 2;
pub const FILE_APPEND_DATA: u32 = 4;
pub const FILE_ADD_SUBDIRECTORY: u32 = 4;
pub const FILE_CREATE_PIPE_INSTANCE: u32 = 4;
pub const FILE_READ_EA: u32 = 8;
pub const FILE_WRITE_EA: u32 = 16;
pub const FILE_EXECUTE: u32 = 32;
pub const FILE_TRAVERSE: u32 = 32;
pub const FILE_DELETE_CHILD: u32 = 64;
pub const FILE_READ_ATTRIBUTES: u32 = 128;
pub const FILE_WRITE_ATTRIBUTES: u32 = 256;
pub const FILE_ALL_ACCESS: u32 = 2032127;
pub const FILE_GENERIC_READ: u32 = 1179785;
pub const FILE_GENERIC_WRITE: u32 = 1179926;
pub const FILE_GENERIC_EXECUTE: u32 = 1179808;
pub const FILE_SHARE_READ: u32 = 1;
pub const FILE_SHARE_WRITE: u32 = 2;
pub const FILE_SHARE_DELETE: u32 = 4;
pub const FILE_SHARE_VALID_FLAGS: u32 = 7;
pub const FILE_ATTRIBUTE_READONLY: u32 = 1;
pub const FILE_ATTRIBUTE_HIDDEN: u32 = 2;
pub const FILE_ATTRIBUTE_SYSTEM: u32 = 4;
pub const FILE_ATTRIBUTE_DIRECTORY: u32 = 16;
pub const FILE_ATTRIBUTE_ARCHIVE: u32 = 32;
pub const FILE_ATTRIBUTE_DEVICE: u32 = 64;
pub const FILE_ATTRIBUTE_NORMAL: u32 = 128;
pub const FILE_ATTRIBUTE_TEMPORARY: u32 = 256;
pub const FILE_ATTRIBUTE_SPARSE_FILE: u32 = 512;
pub const FILE_ATTRIBUTE_REPARSE_POINT: u32 = 1024;
pub const FILE_ATTRIBUTE_COMPRESSED: u32 = 2048;
pub const FILE_ATTRIBUTE_OFFLINE: u32 = 4096;
pub const FILE_ATTRIBUTE_NOT_CONTENT_INDEXED: u32 = 8192;
pub const FILE_ATTRIBUTE_ENCRYPTED: u32 = 16384;
pub const FILE_ATTRIBUTE_INTEGRITY_STREAM: u32 = 32768;
pub const FILE_ATTRIBUTE_VIRTUAL: u32 = 65536;
pub const FILE_ATTRIBUTE_NO_SCRUB_DATA: u32 = 131072;
pub const FILE_ATTRIBUTE_EA: u32 = 262144;
pub const FILE_ATTRIBUTE_PINNED: u32 = 524288;
pub const FILE_ATTRIBUTE_UNPINNED: u32 = 1048576;
pub const FILE_ATTRIBUTE_RECALL_ON_OPEN: u32 = 262144;
pub const FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS: u32 = 4194304;
pub const TREE_CONNECT_ATTRIBUTE_PRIVACY: u32 = 16384;
pub const TREE_CONNECT_ATTRIBUTE_INTEGRITY: u32 = 32768;
pub const TREE_CONNECT_ATTRIBUTE_GLOBAL: u32 = 4;
pub const TREE_CONNECT_ATTRIBUTE_PINNED: u32 = 2;
pub const FILE_ATTRIBUTE_STRICTLY_SEQUENTIAL: u32 = 536870912;
pub const FILE_ATTRIBUTE_VALID_FLAGS: u32 = 5963703;
pub const FILE_ATTRIBUTE_VALID_SET_FLAGS: u32 = 1716647;
pub const FILE_ATTRIBUTE_VALID_KERNEL_SET_FLAGS: u32 = 5910951;
pub const FILE_SUPERSEDE: u32 = 0;
pub const FILE_OPEN: u32 = 1;
pub const FILE_CREATE: u32 = 2;
pub const FILE_OPEN_IF: u32 = 3;
pub const FILE_OVERWRITE: u32 = 4;
pub const FILE_OVERWRITE_IF: u32 = 5;
pub const FILE_MAXIMUM_DISPOSITION: u32 = 5;
pub const FILE_DIRECTORY_FILE: u32 = 1;
pub const FILE_WRITE_THROUGH: u32 = 2;
pub const FILE_SEQUENTIAL_ONLY: u32 = 4;
pub const FILE_NO_INTERMEDIATE_BUFFERING: u32 = 8;
pub const FILE_SYNCHRONOUS_IO_ALERT: u32 = 16;
pub const FILE_SYNCHRONOUS_IO_NONALERT: u32 = 32;
pub const FILE_NON_DIRECTORY_FILE: u32 = 64;
pub const FILE_CREATE_TREE_CONNECTION: u32 = 128;
pub const FILE_COMPLETE_IF_OPLOCKED: u32 = 256;
pub const FILE_NO_EA_KNOWLEDGE: u32 = 512;
pub const FILE_OPEN_REMOTE_INSTANCE: u32 = 1024;
pub const FILE_RANDOM_ACCESS: u32 = 2048;
pub const FILE_DELETE_ON_CLOSE: u32 = 4096;
pub const FILE_OPEN_BY_FILE_ID: u32 = 8192;
pub const FILE_OPEN_FOR_BACKUP_INTENT: u32 = 16384;
pub const FILE_NO_COMPRESSION: u32 = 32768;
pub const FILE_OPEN_REQUIRING_OPLOCK: u32 = 65536;
pub const FILE_DISALLOW_EXCLUSIVE: u32 = 131072;
pub const FILE_SESSION_AWARE: u32 = 262144;
pub const FILE_RESERVE_OPFILTER: u32 = 1048576;
pub const FILE_OPEN_REPARSE_POINT: u32 = 2097152;
pub const FILE_OPEN_NO_RECALL: u32 = 4194304;
pub const FILE_OPEN_FOR_FREE_SPACE_QUERY: u32 = 8388608;
pub const TREE_CONNECT_NO_CLIENT_BUFFERING: u32 = 8;
pub const TREE_CONNECT_WRITE_THROUGH: u32 = 2;
pub const FILE_VALID_OPTION_FLAGS: u32 = 16777215;
pub const FILE_VALID_PIPE_OPTION_FLAGS: u32 = 50;
pub const FILE_VALID_MAILSLOT_OPTION_FLAGS: u32 = 50;
pub const FILE_VALID_SET_FLAGS: u32 = 54;
pub const FILE_CONTAINS_EXTENDED_CREATE_INFORMATION: u32 = 268435456;
pub const FILE_VALID_EXTENDED_OPTION_FLAGS: u32 = 268435456;
pub const FILE_SUPERSEDED: u32 = 0;
pub const FILE_OPENED: u32 = 1;
pub const FILE_CREATED: u32 = 2;
pub const FILE_OVERWRITTEN: u32 = 3;
pub const FILE_EXISTS: u32 = 4;
pub const FILE_DOES_NOT_EXIST: u32 = 5;
pub const FILE_QUERY_RESTART_SCAN: u32 = 1;
pub const FILE_QUERY_RETURN_SINGLE_ENTRY: u32 = 2;
pub const FILE_QUERY_INDEX_SPECIFIED: u32 = 4;
pub const FILE_QUERY_RETURN_ON_DISK_ENTRIES_ONLY: u32 = 8;
pub const FILE_QUERY_NO_CURSOR_UPDATE: u32 = 16;
pub const FILE_WRITE_TO_END_OF_FILE: u32 = 4294967295;
pub const FILE_USE_FILE_POINTER_POSITION: u32 = 4294967294;
pub const FILE_BYTE_ALIGNMENT: u32 = 0;
pub const FILE_WORD_ALIGNMENT: u32 = 1;
pub const FILE_LONG_ALIGNMENT: u32 = 3;
pub const FILE_QUAD_ALIGNMENT: u32 = 7;
pub const FILE_OCTA_ALIGNMENT: u32 = 15;
pub const FILE_32_BYTE_ALIGNMENT: u32 = 31;
pub const FILE_64_BYTE_ALIGNMENT: u32 = 63;
pub const FILE_128_BYTE_ALIGNMENT: u32 = 127;
pub const FILE_256_BYTE_ALIGNMENT: u32 = 255;
pub const FILE_512_BYTE_ALIGNMENT: u32 = 511;
pub const MAXIMUM_FILENAME_LENGTH: u32 = 256;
pub const FILE_REMOVABLE_MEDIA: u32 = 1;
pub const FILE_READ_ONLY_DEVICE: u32 = 2;
pub const FILE_FLOPPY_DISKETTE: u32 = 4;
pub const FILE_WRITE_ONCE_MEDIA: u32 = 8;
pub const FILE_REMOTE_DEVICE: u32 = 16;
pub const FILE_DEVICE_IS_MOUNTED: u32 = 32;
pub const FILE_VIRTUAL_VOLUME: u32 = 64;
pub const FILE_AUTOGENERATED_DEVICE_NAME: u32 = 128;
pub const FILE_DEVICE_SECURE_OPEN: u32 = 256;
pub const FILE_CHARACTERISTIC_PNP_DEVICE: u32 = 2048;
pub const FILE_CHARACTERISTIC_TS_DEVICE: u32 = 4096;
pub const FILE_CHARACTERISTIC_WEBDAV_DEVICE: u32 = 8192;
pub const FILE_CHARACTERISTIC_CSV: u32 = 65536;
pub const FILE_DEVICE_ALLOW_APPCONTAINER_TRAVERSAL: u32 = 131072;
pub const FILE_PORTABLE_DEVICE: u32 = 262144;
pub const FILE_REMOTE_DEVICE_VSMB: u32 = 524288;
pub const FILE_DEVICE_REQUIRE_SECURITY_CHECK: u32 = 1048576;
pub const IO_SESSION_STATE_ALL_EVENTS: u32 = 4294967295;
pub const IO_SESSION_STATE_CREATION_EVENT: u32 = 1;
pub const IO_SESSION_STATE_TERMINATION_EVENT: u32 = 2;
pub const IO_SESSION_STATE_CONNECT_EVENT: u32 = 4;
pub const IO_SESSION_STATE_DISCONNECT_EVENT: u32 = 8;
pub const IO_SESSION_STATE_LOGON_EVENT: u32 = 16;
pub const IO_SESSION_STATE_LOGOFF_EVENT: u32 = 32;
pub const IO_SESSION_STATE_VALID_EVENT_MASK: u32 = 63;
pub const IO_SESSION_MAX_PAYLOAD_SIZE: u32 = 256;
pub const FILE_SKIP_COMPLETION_PORT_ON_SUCCESS: u32 = 1;
pub const FILE_SKIP_SET_EVENT_ON_HANDLE: u32 = 2;
pub const FILE_SKIP_SET_USER_EVENT_ON_FAST_IO: u32 = 4;
pub const FLUSH_FLAGS_FILE_DATA_ONLY: u32 = 1;
pub const FLUSH_FLAGS_NO_SYNC: u32 = 2;
pub const FLUSH_FLAGS_FILE_DATA_SYNC_ONLY: u32 = 4;
pub const ERROR_LOG_LIMIT_SIZE: u32 = 240;
pub const PORT_MAXIMUM_MESSAGE_LENGTH: u32 = 512;
pub const KEY_QUERY_VALUE: u32 = 1;
pub const KEY_SET_VALUE: u32 = 2;
pub const KEY_CREATE_SUB_KEY: u32 = 4;
pub const KEY_ENUMERATE_SUB_KEYS: u32 = 8;
pub const KEY_NOTIFY: u32 = 16;
pub const KEY_CREATE_LINK: u32 = 32;
pub const KEY_WOW64_32KEY: u32 = 512;
pub const KEY_WOW64_64KEY: u32 = 256;
pub const KEY_WOW64_RES: u32 = 768;
pub const KEY_READ: u32 = 131097;
pub const KEY_WRITE: u32 = 131078;
pub const KEY_EXECUTE: u32 = 131097;
pub const KEY_ALL_ACCESS: u32 = 983103;
pub const REG_OPTION_RESERVED: u32 = 0;
pub const REG_OPTION_NON_VOLATILE: u32 = 0;
pub const REG_OPTION_VOLATILE: u32 = 1;
pub const REG_OPTION_CREATE_LINK: u32 = 2;
pub const REG_OPTION_BACKUP_RESTORE: u32 = 4;
pub const REG_OPTION_OPEN_LINK: u32 = 8;
pub const REG_OPTION_DONT_VIRTUALIZE: u32 = 16;
pub const REG_LEGAL_OPTION: u32 = 31;
pub const REG_OPEN_LEGAL_OPTION: u32 = 28;
pub const REG_CREATED_NEW_KEY: u32 = 1;
pub const REG_OPENED_EXISTING_KEY: u32 = 2;
pub const REG_STANDARD_FORMAT: u32 = 1;
pub const REG_LATEST_FORMAT: u32 = 2;
pub const REG_NO_COMPRESSION: u32 = 4;
pub const REG_WHOLE_HIVE_VOLATILE: u32 = 1;
pub const REG_REFRESH_HIVE: u32 = 2;
pub const REG_NO_LAZY_FLUSH: u32 = 4;
pub const REG_FORCE_RESTORE: u32 = 8;
pub const REG_APP_HIVE: u32 = 16;
pub const REG_PROCESS_PRIVATE: u32 = 32;
pub const REG_START_JOURNAL: u32 = 64;
pub const REG_HIVE_EXACT_FILE_GROWTH: u32 = 128;
pub const REG_HIVE_NO_RM: u32 = 256;
pub const REG_HIVE_SINGLE_LOG: u32 = 512;
pub const REG_BOOT_HIVE: u32 = 1024;
pub const REG_LOAD_HIVE_OPEN_HANDLE: u32 = 2048;
pub const REG_FLUSH_HIVE_FILE_GROWTH: u32 = 4096;
pub const REG_OPEN_READ_ONLY: u32 = 8192;
pub const REG_IMMUTABLE: u32 = 16384;
pub const REG_NO_IMPERSONATION_FALLBACK: u32 = 32768;
pub const REG_APP_HIVE_OPEN_READ_ONLY: u32 = 8192;
pub const REG_FORCE_UNLOAD: u32 = 1;
pub const REG_UNLOAD_LEGAL_FLAGS: u32 = 1;
pub const REG_NOTIFY_CHANGE_NAME: u32 = 1;
pub const REG_NOTIFY_CHANGE_ATTRIBUTES: u32 = 2;
pub const REG_NOTIFY_CHANGE_LAST_SET: u32 = 4;
pub const REG_NOTIFY_CHANGE_SECURITY: u32 = 8;
pub const REG_NOTIFY_THREAD_AGNOSTIC: u32 = 268435456;
pub const REG_LEGAL_CHANGE_FILTER: u32 = 268435471;
pub const OBJECT_TYPE_CREATE: u32 = 1;
pub const OBJECT_TYPE_ALL_ACCESS: u32 = 983041;
pub const DIRECTORY_QUERY: u32 = 1;
pub const DIRECTORY_TRAVERSE: u32 = 2;
pub const DIRECTORY_CREATE_OBJECT: u32 = 4;
pub const DIRECTORY_CREATE_SUBDIRECTORY: u32 = 8;
pub const DIRECTORY_ALL_ACCESS: u32 = 983055;
pub const SYMBOLIC_LINK_QUERY: u32 = 1;
pub const SYMBOLIC_LINK_SET: u32 = 2;
pub const SYMBOLIC_LINK_ALL_ACCESS: u32 = 983041;
pub const SYMBOLIC_LINK_ALL_ACCESS_EX: u32 = 1048575;
pub const DUPLICATE_CLOSE_SOURCE: u32 = 1;
pub const DUPLICATE_SAME_ACCESS: u32 = 2;
pub const DUPLICATE_SAME_ATTRIBUTES: u32 = 4;
pub const SECTION_QUERY: u32 = 1;
pub const SECTION_MAP_WRITE: u32 = 2;
pub const SECTION_MAP_READ: u32 = 4;
pub const SECTION_MAP_EXECUTE: u32 = 8;
pub const SECTION_EXTEND_SIZE: u32 = 16;
pub const SECTION_MAP_EXECUTE_EXPLICIT: u32 = 32;
pub const SECTION_ALL_ACCESS: u32 = 983071;
pub const SESSION_QUERY_ACCESS: u32 = 1;
pub const SESSION_MODIFY_ACCESS: u32 = 2;
pub const SESSION_ALL_ACCESS: u32 = 983043;
pub const SEGMENT_ALL_ACCESS: u32 = 983071;
pub const PAGE_NOACCESS: u32 = 1;
pub const PAGE_READONLY: u32 = 2;
pub const PAGE_READWRITE: u32 = 4;
pub const PAGE_WRITECOPY: u32 = 8;
pub const PAGE_EXECUTE: u32 = 16;
pub const PAGE_EXECUTE_READ: u32 = 32;
pub const PAGE_EXECUTE_READWRITE: u32 = 64;
pub const PAGE_EXECUTE_WRITECOPY: u32 = 128;
pub const PAGE_GUARD: u32 = 256;
pub const PAGE_NOCACHE: u32 = 512;
pub const PAGE_WRITECOMBINE: u32 = 1024;
pub const PAGE_GRAPHICS_NOACCESS: u32 = 2048;
pub const PAGE_GRAPHICS_READONLY: u32 = 4096;
pub const PAGE_GRAPHICS_READWRITE: u32 = 8192;
pub const PAGE_GRAPHICS_EXECUTE: u32 = 16384;
pub const PAGE_GRAPHICS_EXECUTE_READ: u32 = 32768;
pub const PAGE_GRAPHICS_EXECUTE_READWRITE: u32 = 65536;
pub const PAGE_GRAPHICS_COHERENT: u32 = 131072;
pub const PAGE_GRAPHICS_NOCACHE: u32 = 262144;
pub const PAGE_ENCLAVE_THREAD_CONTROL: u32 = 2147483648;
pub const PAGE_REVERT_TO_FILE_MAP: u32 = 2147483648;
pub const PAGE_TARGETS_NO_UPDATE: u32 = 1073741824;
pub const PAGE_TARGETS_INVALID: u32 = 1073741824;
pub const PAGE_ENCLAVE_UNVALIDATED: u32 = 536870912;
pub const PAGE_ENCLAVE_NO_CHANGE: u32 = 536870912;
pub const PAGE_ENCLAVE_MASK: u32 = 268435456;
pub const PAGE_ENCLAVE_DECOMMIT: u32 = 268435456;
pub const PAGE_ENCLAVE_SS_FIRST: u32 = 268435457;
pub const PAGE_ENCLAVE_SS_REST: u32 = 268435458;
pub const MEM_COMMIT: u32 = 4096;
pub const MEM_RESERVE: u32 = 8192;
pub const MEM_RESET: u32 = 524288;
pub const MEM_TOP_DOWN: u32 = 1048576;
pub const MEM_RESET_UNDO: u32 = 16777216;
pub const MEM_LARGE_PAGES: u32 = 536870912;
pub const MEM_4MB_PAGES: u32 = 2147483648;
pub const MEM_DECOMMIT: u32 = 16384;
pub const MEM_RELEASE: u32 = 32768;
pub const MEM_FREE: u32 = 65536;
pub const MEM_EXTENDED_PARAMETER_GRAPHICS: u32 = 1;
pub const MEM_EXTENDED_PARAMETER_NONPAGED: u32 = 2;
pub const MEM_EXTENDED_PARAMETER_ZERO_PAGES_OPTIONAL: u32 = 4;
pub const MEM_EXTENDED_PARAMETER_NONPAGED_LARGE: u32 = 8;
pub const MEM_EXTENDED_PARAMETER_NONPAGED_HUGE: u32 = 16;
pub const MEM_EXTENDED_PARAMETER_SOFT_FAULT_PAGES: u32 = 32;
pub const MEM_EXTENDED_PARAMETER_EC_CODE: u32 = 64;
pub const MEM_EXTENDED_PARAMETER_IMAGE_NO_HPAT: u32 = 128;
pub const MEM_EXTENDED_PARAMETER_TYPE_BITS: u32 = 8;
pub const SEC_HUGE_PAGES: u32 = 131072;
pub const SEC_64K_PAGES: u32 = 524288;
pub const SEC_FILE: u32 = 8388608;
pub const SEC_IMAGE: u32 = 16777216;
pub const SEC_RESERVE: u32 = 67108864;
pub const SEC_COMMIT: u32 = 134217728;
pub const SEC_NOCACHE: u32 = 268435456;
pub const SEC_LARGE_PAGES: u32 = 2147483648;
pub const SEC_IMAGE_NO_EXECUTE: u32 = 285212672;
pub const MEM_PRIVATE: u32 = 131072;
pub const MEM_MAPPED: u32 = 262144;
pub const PROCESS_DUP_HANDLE: u32 = 64;
pub const PROCESS_ALL_ACCESS: u32 = 2097151;
pub const THREAD_TERMINATE: u32 = 1;
pub const THREAD_SUSPEND_RESUME: u32 = 2;
pub const THREAD_ALERT: u32 = 4;
pub const THREAD_GET_CONTEXT: u32 = 8;
pub const THREAD_SET_CONTEXT: u32 = 16;
pub const THREAD_SET_INFORMATION: u32 = 32;
pub const THREAD_SET_LIMITED_INFORMATION: u32 = 1024;
pub const THREAD_QUERY_LIMITED_INFORMATION: u32 = 2048;
pub const THREAD_RESUME: u32 = 4096;
pub const THREAD_ALL_ACCESS: u32 = 2097151;
pub const MEMORY_PARTITION_QUERY_ACCESS: u32 = 1;
pub const MEMORY_PARTITION_MODIFY_ACCESS: u32 = 2;
pub const MEMORY_PARTITION_ALL_ACCESS: u32 = 2031619;
pub const POWERBUTTON_ACTION_INDEX_NOTHING: u32 = 0;
pub const POWERBUTTON_ACTION_INDEX_SLEEP: u32 = 1;
pub const POWERBUTTON_ACTION_INDEX_HIBERNATE: u32 = 2;
pub const POWERBUTTON_ACTION_INDEX_SHUTDOWN: u32 = 3;
pub const POWERBUTTON_ACTION_INDEX_TURN_OFF_THE_DISPLAY: u32 = 4;
pub const POWERBUTTON_ACTION_VALUE_NOTHING: u32 = 0;
pub const POWERBUTTON_ACTION_VALUE_SLEEP: u32 = 2;
pub const POWERBUTTON_ACTION_VALUE_HIBERNATE: u32 = 3;
pub const POWERBUTTON_ACTION_VALUE_SHUTDOWN: u32 = 6;
pub const POWERBUTTON_ACTION_VALUE_TURN_OFF_THE_DISPLAY: u32 = 8;
pub const PERFSTATE_POLICY_CHANGE_IDEAL: u32 = 0;
pub const PERFSTATE_POLICY_CHANGE_SINGLE: u32 = 1;
pub const PERFSTATE_POLICY_CHANGE_ROCKET: u32 = 2;
pub const PERFSTATE_POLICY_CHANGE_IDEAL_AGGRESSIVE: u32 = 3;
pub const PERFSTATE_POLICY_CHANGE_DECREASE_MAX: u32 = 2;
pub const PERFSTATE_POLICY_CHANGE_INCREASE_MAX: u32 = 3;
pub const PROCESSOR_THROTTLE_DISABLED: u32 = 0;
pub const PROCESSOR_THROTTLE_ENABLED: u32 = 1;
pub const PROCESSOR_THROTTLE_AUTOMATIC: u32 = 2;
pub const PROCESSOR_PERF_BOOST_POLICY_DISABLED: u32 = 0;
pub const PROCESSOR_PERF_BOOST_POLICY_MAX: u32 = 100;
pub const PROCESSOR_PERF_BOOST_MODE_DISABLED: u32 = 0;
pub const PROCESSOR_PERF_BOOST_MODE_ENABLED: u32 = 1;
pub const PROCESSOR_PERF_BOOST_MODE_AGGRESSIVE: u32 = 2;
pub const PROCESSOR_PERF_BOOST_MODE_EFFICIENT_ENABLED: u32 = 3;
pub const PROCESSOR_PERF_BOOST_MODE_EFFICIENT_AGGRESSIVE: u32 = 4;
pub const PROCESSOR_PERF_BOOST_MODE_AGGRESSIVE_AT_GUARANTEED: u32 = 5;
pub const PROCESSOR_PERF_BOOST_MODE_EFFICIENT_AGGRESSIVE_AT_GUARANTEED: u32 = 6;
pub const PROCESSOR_PERF_BOOST_MODE_MAX: u32 = 6;
pub const PROCESSOR_PERF_AUTONOMOUS_MODE_DISABLED: u32 = 0;
pub const PROCESSOR_PERF_AUTONOMOUS_MODE_ENABLED: u32 = 1;
pub const PROCESSOR_PERF_PERFORMANCE_PREFERENCE: u32 = 255;
pub const PROCESSOR_PERF_ENERGY_PREFERENCE: u32 = 0;
pub const PROCESSOR_PERF_MINIMUM_ACTIVITY_WINDOW: u32 = 0;
pub const PROCESSOR_PERF_MAXIMUM_ACTIVITY_WINDOW: u32 = 1270000000;
pub const PROCESSOR_DUTY_CYCLING_DISABLED: u32 = 0;
pub const PROCESSOR_DUTY_CYCLING_ENABLED: u32 = 1;
pub const CORE_PARKING_POLICY_CHANGE_IDEAL: u32 = 0;
pub const CORE_PARKING_POLICY_CHANGE_SINGLE: u32 = 1;
pub const CORE_PARKING_POLICY_CHANGE_ROCKET: u32 = 2;
pub const CORE_PARKING_POLICY_CHANGE_MULTISTEP: u32 = 3;
pub const CORE_PARKING_POLICY_CHANGE_MAX: u32 = 3;
pub const PARKING_TOPOLOGY_POLICY_DISABLED: u32 = 0;
pub const PARKING_TOPOLOGY_POLICY_ROUNDROBIN: u32 = 1;
pub const PARKING_TOPOLOGY_POLICY_SEQUENTIAL: u32 = 2;
pub const SMT_UNPARKING_POLICY_CORE: u32 = 0;
pub const SMT_UNPARKING_POLICY_CORE_PER_THREAD: u32 = 1;
pub const SMT_UNPARKING_POLICY_LP_ROUNDROBIN: u32 = 2;
pub const SMT_UNPARKING_POLICY_LP_SEQUENTIAL: u32 = 3;
pub const POWER_DEVICE_IDLE_POLICY_PERFORMANCE: u32 = 0;
pub const POWER_DEVICE_IDLE_POLICY_CONSERVATIVE: u32 = 1;
pub const POWER_CONNECTIVITY_IN_STANDBY_DISABLED: u32 = 0;
pub const POWER_CONNECTIVITY_IN_STANDBY_ENABLED: u32 = 1;
pub const POWER_CONNECTIVITY_IN_STANDBY_SYSTEM_MANAGED: u32 = 2;
pub const POWER_DISCONNECTED_STANDBY_MODE_NORMAL: u32 = 0;
pub const POWER_DISCONNECTED_STANDBY_MODE_AGGRESSIVE: u32 = 1;
pub const POWER_SYSTEM_MAXIMUM: u32 = 7;
pub const DIAGNOSTIC_REASON_VERSION: u32 = 0;
pub const DIAGNOSTIC_REASON_SIMPLE_STRING: u32 = 1;
pub const DIAGNOSTIC_REASON_DETAILED_STRING: u32 = 2;
pub const DIAGNOSTIC_REASON_NOT_SPECIFIED: u32 = 2147483648;
pub const DIAGNOSTIC_REASON_INVALID_FLAGS: i64 = -2147483656;
pub const POWER_REQUEST_CONTEXT_VERSION: u32 = 0;
pub const POWER_REQUEST_CONTEXT_SIMPLE_STRING: u32 = 1;
pub const POWER_REQUEST_CONTEXT_DETAILED_STRING: u32 = 2;
pub const PDCAP_D0_SUPPORTED: u32 = 1;
pub const PDCAP_D1_SUPPORTED: u32 = 2;
pub const PDCAP_D2_SUPPORTED: u32 = 4;
pub const PDCAP_D3_SUPPORTED: u32 = 8;
pub const PDCAP_WAKE_FROM_D0_SUPPORTED: u32 = 16;
pub const PDCAP_WAKE_FROM_D1_SUPPORTED: u32 = 32;
pub const PDCAP_WAKE_FROM_D2_SUPPORTED: u32 = 64;
pub const PDCAP_WAKE_FROM_D3_SUPPORTED: u32 = 128;
pub const PDCAP_WARM_EJECT_SUPPORTED: u32 = 256;
pub const POWER_SETTING_VALUE_VERSION: u32 = 1;
pub const POWER_PLATFORM_ROLE_V1: u32 = 1;
pub const POWER_PLATFORM_ROLE_V2: u32 = 2;
pub const POWER_PLATFORM_ROLE_VERSION: u32 = 2;
pub const REG_NONE: u32 = 0;
pub const REG_SZ: u32 = 1;
pub const REG_EXPAND_SZ: u32 = 2;
pub const REG_BINARY: u32 = 3;
pub const REG_DWORD: u32 = 4;
pub const REG_DWORD_LITTLE_ENDIAN: u32 = 4;
pub const REG_DWORD_BIG_ENDIAN: u32 = 5;
pub const REG_LINK: u32 = 6;
pub const REG_MULTI_SZ: u32 = 7;
pub const REG_RESOURCE_LIST: u32 = 8;
pub const REG_FULL_RESOURCE_DESCRIPTOR: u32 = 9;
pub const REG_RESOURCE_REQUIREMENTS_LIST: u32 = 10;
pub const REG_QWORD: u32 = 11;
pub const REG_QWORD_LITTLE_ENDIAN: u32 = 11;
pub const SERVICE_KERNEL_DRIVER: u32 = 1;
pub const SERVICE_FILE_SYSTEM_DRIVER: u32 = 2;
pub const SERVICE_ADAPTER: u32 = 4;
pub const SERVICE_RECOGNIZER_DRIVER: u32 = 8;
pub const SERVICE_DRIVER: u32 = 11;
pub const SERVICE_WIN32_OWN_PROCESS: u32 = 16;
pub const SERVICE_WIN32_SHARE_PROCESS: u32 = 32;
pub const SERVICE_WIN32: u32 = 48;
pub const SERVICE_USER_SERVICE: u32 = 64;
pub const SERVICE_USERSERVICE_INSTANCE: u32 = 128;
pub const SERVICE_USER_SHARE_PROCESS: u32 = 96;
pub const SERVICE_USER_OWN_PROCESS: u32 = 80;
pub const SERVICE_INTERACTIVE_PROCESS: u32 = 256;
pub const SERVICE_PKG_SERVICE: u32 = 512;
pub const SERVICE_TYPE_ALL: u32 = 1023;
pub const SERVICE_BOOT_START: u32 = 0;
pub const SERVICE_SYSTEM_START: u32 = 1;
pub const SERVICE_AUTO_START: u32 = 2;
pub const SERVICE_DEMAND_START: u32 = 3;
pub const SERVICE_DISABLED: u32 = 4;
pub const SERVICE_ERROR_IGNORE: u32 = 0;
pub const SERVICE_ERROR_NORMAL: u32 = 1;
pub const SERVICE_ERROR_SEVERE: u32 = 2;
pub const SERVICE_ERROR_CRITICAL: u32 = 3;
pub const CM_SERVICE_NETWORK_BOOT_LOAD: u32 = 1;
pub const CM_SERVICE_VIRTUAL_DISK_BOOT_LOAD: u32 = 2;
pub const CM_SERVICE_USB_DISK_BOOT_LOAD: u32 = 4;
pub const CM_SERVICE_SD_DISK_BOOT_LOAD: u32 = 8;
pub const CM_SERVICE_USB3_DISK_BOOT_LOAD: u32 = 16;
pub const CM_SERVICE_MEASURED_BOOT_LOAD: u32 = 32;
pub const CM_SERVICE_VERIFIER_BOOT_LOAD: u32 = 64;
pub const CM_SERVICE_WINPE_BOOT_LOAD: u32 = 128;
pub const CM_SERVICE_RAM_DISK_BOOT_LOAD: u32 = 256;
pub const CM_SERVICE_VALID_PROMOTION_MASK: u32 = 511;
pub const CmResourceTypeNull: u32 = 0;
pub const CmResourceTypePort: u32 = 1;
pub const CmResourceTypeInterrupt: u32 = 2;
pub const CmResourceTypeMemory: u32 = 3;
pub const CmResourceTypeDma: u32 = 4;
pub const CmResourceTypeDeviceSpecific: u32 = 5;
pub const CmResourceTypeBusNumber: u32 = 6;
pub const CmResourceTypeMemoryLarge: u32 = 7;
pub const CmResourceTypeNonArbitrated: u32 = 128;
pub const CmResourceTypeConfigData: u32 = 128;
pub const CmResourceTypeDevicePrivate: u32 = 129;
pub const CmResourceTypePcCardConfig: u32 = 130;
pub const CmResourceTypeMfCardConfig: u32 = 131;
pub const CmResourceTypeConnection: u32 = 132;
pub const CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE: u32 = 0;
pub const CM_RESOURCE_INTERRUPT_LATCHED: u32 = 1;
pub const CM_RESOURCE_INTERRUPT_MESSAGE: u32 = 2;
pub const CM_RESOURCE_INTERRUPT_POLICY_INCLUDED: u32 = 4;
pub const CM_RESOURCE_INTERRUPT_SECONDARY_INTERRUPT: u32 = 16;
pub const CM_RESOURCE_INTERRUPT_WAKE_HINT: u32 = 32;
pub const CM_RESOURCE_INTERRUPT_LEVEL_LATCHED_BITS: u32 = 1;
pub const CM_RESOURCE_MEMORY_READ_WRITE: u32 = 0;
pub const CM_RESOURCE_MEMORY_READ_ONLY: u32 = 1;
pub const CM_RESOURCE_MEMORY_WRITE_ONLY: u32 = 2;
pub const CM_RESOURCE_MEMORY_WRITEABILITY_MASK: u32 = 3;
pub const CM_RESOURCE_MEMORY_PREFETCHABLE: u32 = 4;
pub const CM_RESOURCE_MEMORY_COMBINEDWRITE: u32 = 8;
pub const CM_RESOURCE_MEMORY_24: u32 = 16;
pub const CM_RESOURCE_MEMORY_CACHEABLE: u32 = 32;
pub const CM_RESOURCE_MEMORY_WINDOW_DECODE: u32 = 64;
pub const CM_RESOURCE_MEMORY_BAR: u32 = 128;
pub const CM_RESOURCE_MEMORY_COMPAT_FOR_INACCESSIBLE_RANGE: u32 = 256;
pub const CM_RESOURCE_MEMORY_LARGE: u32 = 3584;
pub const CM_RESOURCE_MEMORY_LARGE_40: u32 = 512;
pub const CM_RESOURCE_MEMORY_LARGE_48: u32 = 1024;
pub const CM_RESOURCE_MEMORY_LARGE_64: u32 = 2048;
pub const CM_RESOURCE_MEMORY_LARGE_40_MAXLEN: u64 = 1099511627520;
pub const CM_RESOURCE_MEMORY_LARGE_48_MAXLEN: u64 = 281474976645120;
pub const CM_RESOURCE_MEMORY_LARGE_64_MAXLEN: i64 = -4294967296;
pub const CM_RESOURCE_PORT_MEMORY: u32 = 0;
pub const CM_RESOURCE_PORT_IO: u32 = 1;
pub const CM_RESOURCE_PORT_10_BIT_DECODE: u32 = 4;
pub const CM_RESOURCE_PORT_12_BIT_DECODE: u32 = 8;
pub const CM_RESOURCE_PORT_16_BIT_DECODE: u32 = 16;
pub const CM_RESOURCE_PORT_POSITIVE_DECODE: u32 = 32;
pub const CM_RESOURCE_PORT_PASSIVE_DECODE: u32 = 64;
pub const CM_RESOURCE_PORT_WINDOW_DECODE: u32 = 128;
pub const CM_RESOURCE_PORT_BAR: u32 = 256;
pub const CM_RESOURCE_DMA_8: u32 = 0;
pub const CM_RESOURCE_DMA_16: u32 = 1;
pub const CM_RESOURCE_DMA_32: u32 = 2;
pub const CM_RESOURCE_DMA_8_AND_16: u32 = 4;
pub const CM_RESOURCE_DMA_BUS_MASTER: u32 = 8;
pub const CM_RESOURCE_DMA_TYPE_A: u32 = 16;
pub const CM_RESOURCE_DMA_TYPE_B: u32 = 32;
pub const CM_RESOURCE_DMA_TYPE_F: u32 = 64;
pub const CM_RESOURCE_DMA_V3: u32 = 128;
pub const DMAV3_TRANFER_WIDTH_8: u32 = 0;
pub const DMAV3_TRANFER_WIDTH_16: u32 = 1;
pub const DMAV3_TRANFER_WIDTH_32: u32 = 2;
pub const DMAV3_TRANFER_WIDTH_64: u32 = 3;
pub const DMAV3_TRANFER_WIDTH_128: u32 = 4;
pub const DMAV3_TRANFER_WIDTH_256: u32 = 5;
pub const CM_RESOURCE_CONNECTION_CLASS_GPIO: u32 = 1;
pub const CM_RESOURCE_CONNECTION_CLASS_SERIAL: u32 = 2;
pub const CM_RESOURCE_CONNECTION_CLASS_FUNCTION_CONFIG: u32 = 3;
pub const CM_RESOURCE_CONNECTION_TYPE_GPIO_IO: u32 = 2;
pub const CM_RESOURCE_CONNECTION_TYPE_SERIAL_I2C: u32 = 1;
pub const CM_RESOURCE_CONNECTION_TYPE_SERIAL_SPI: u32 = 2;
pub const CM_RESOURCE_CONNECTION_TYPE_SERIAL_UART: u32 = 3;
pub const CM_RESOURCE_CONNECTION_TYPE_FUNCTION_CONFIG: u32 = 1;
pub const EISA_FUNCTION_ENABLED: u32 = 128;
pub const EISA_FREE_FORM_DATA: u32 = 64;
pub const EISA_HAS_PORT_INIT_ENTRY: u32 = 32;
pub const EISA_HAS_PORT_RANGE: u32 = 16;
pub const EISA_HAS_DMA_ENTRY: u32 = 8;
pub const EISA_HAS_IRQ_ENTRY: u32 = 4;
pub const EISA_HAS_MEMORY_ENTRY: u32 = 2;
pub const EISA_HAS_TYPE_ENTRY: u32 = 1;
pub const EISA_HAS_INFORMATION: u32 = 31;
pub const EISA_MORE_ENTRIES: u32 = 128;
pub const EISA_SYSTEM_MEMORY: u32 = 0;
pub const EISA_MEMORY_TYPE_RAM: u32 = 1;
pub const EISA_INVALID_SLOT: u32 = 128;
pub const EISA_INVALID_FUNCTION: u32 = 129;
pub const EISA_INVALID_CONFIGURATION: u32 = 130;
pub const EISA_EMPTY_SLOT: u32 = 131;
pub const EISA_INVALID_BIOS_CALL: u32 = 134;
pub const IO_RESOURCE_PREFERRED: u32 = 1;
pub const IO_RESOURCE_DEFAULT: u32 = 2;
pub const IO_RESOURCE_ALTERNATIVE: u32 = 8;
pub const FAST_FAIL_LEGACY_GS_VIOLATION: u32 = 0;
pub const FAST_FAIL_VTGUARD_CHECK_FAILURE: u32 = 1;
pub const FAST_FAIL_STACK_COOKIE_CHECK_FAILURE: u32 = 2;
pub const FAST_FAIL_CORRUPT_LIST_ENTRY: u32 = 3;
pub const FAST_FAIL_INCORRECT_STACK: u32 = 4;
pub const FAST_FAIL_INVALID_ARG: u32 = 5;
pub const FAST_FAIL_GS_COOKIE_INIT: u32 = 6;
pub const FAST_FAIL_FATAL_APP_EXIT: u32 = 7;
pub const FAST_FAIL_RANGE_CHECK_FAILURE: u32 = 8;
pub const FAST_FAIL_UNSAFE_REGISTRY_ACCESS: u32 = 9;
pub const FAST_FAIL_GUARD_ICALL_CHECK_FAILURE: u32 = 10;
pub const FAST_FAIL_GUARD_WRITE_CHECK_FAILURE: u32 = 11;
pub const FAST_FAIL_INVALID_FIBER_SWITCH: u32 = 12;
pub const FAST_FAIL_INVALID_SET_OF_CONTEXT: u32 = 13;
pub const FAST_FAIL_INVALID_REFERENCE_COUNT: u32 = 14;
pub const FAST_FAIL_INVALID_JUMP_BUFFER: u32 = 18;
pub const FAST_FAIL_MRDATA_MODIFIED: u32 = 19;
pub const FAST_FAIL_CERTIFICATION_FAILURE: u32 = 20;
pub const FAST_FAIL_INVALID_EXCEPTION_CHAIN: u32 = 21;
pub const FAST_FAIL_CRYPTO_LIBRARY: u32 = 22;
pub const FAST_FAIL_INVALID_CALL_IN_DLL_CALLOUT: u32 = 23;
pub const FAST_FAIL_INVALID_IMAGE_BASE: u32 = 24;
pub const FAST_FAIL_DLOAD_PROTECTION_FAILURE: u32 = 25;
pub const FAST_FAIL_UNSAFE_EXTENSION_CALL: u32 = 26;
pub const FAST_FAIL_DEPRECATED_SERVICE_INVOKED: u32 = 27;
pub const FAST_FAIL_INVALID_BUFFER_ACCESS: u32 = 28;
pub const FAST_FAIL_INVALID_BALANCED_TREE: u32 = 29;
pub const FAST_FAIL_INVALID_NEXT_THREAD: u32 = 30;
pub const FAST_FAIL_GUARD_ICALL_CHECK_SUPPRESSED: u32 = 31;
pub const FAST_FAIL_APCS_DISABLED: u32 = 32;
pub const FAST_FAIL_INVALID_IDLE_STATE: u32 = 33;
pub const FAST_FAIL_MRDATA_PROTECTION_FAILURE: u32 = 34;
pub const FAST_FAIL_UNEXPECTED_HEAP_EXCEPTION: u32 = 35;
pub const FAST_FAIL_INVALID_LOCK_STATE: u32 = 36;
pub const FAST_FAIL_GUARD_JUMPTABLE: u32 = 37;
pub const FAST_FAIL_INVALID_LONGJUMP_TARGET: u32 = 38;
pub const FAST_FAIL_INVALID_DISPATCH_CONTEXT: u32 = 39;
pub const FAST_FAIL_INVALID_THREAD: u32 = 40;
pub const FAST_FAIL_INVALID_SYSCALL_NUMBER: u32 = 41;
pub const FAST_FAIL_INVALID_FILE_OPERATION: u32 = 42;
pub const FAST_FAIL_LPAC_ACCESS_DENIED: u32 = 43;
pub const FAST_FAIL_GUARD_SS_FAILURE: u32 = 44;
pub const FAST_FAIL_LOADER_CONTINUITY_FAILURE: u32 = 45;
pub const FAST_FAIL_GUARD_EXPORT_SUPPRESSION_FAILURE: u32 = 46;
pub const FAST_FAIL_INVALID_CONTROL_STACK: u32 = 47;
pub const FAST_FAIL_SET_CONTEXT_DENIED: u32 = 48;
pub const FAST_FAIL_INVALID_IAT: u32 = 49;
pub const FAST_FAIL_HEAP_METADATA_CORRUPTION: u32 = 50;
pub const FAST_FAIL_PAYLOAD_RESTRICTION_VIOLATION: u32 = 51;
pub const FAST_FAIL_LOW_LABEL_ACCESS_DENIED: u32 = 52;
pub const FAST_FAIL_ENCLAVE_CALL_FAILURE: u32 = 53;
pub const FAST_FAIL_UNHANDLED_LSS_EXCEPTON: u32 = 54;
pub const FAST_FAIL_ADMINLESS_ACCESS_DENIED: u32 = 55;
pub const FAST_FAIL_UNEXPECTED_CALL: u32 = 56;
pub const FAST_FAIL_CONTROL_INVALID_RETURN_ADDRESS: u32 = 57;
pub const FAST_FAIL_UNEXPECTED_HOST_BEHAVIOR: u32 = 58;
pub const FAST_FAIL_FLAGS_CORRUPTION: u32 = 59;
pub const FAST_FAIL_VEH_CORRUPTION: u32 = 60;
pub const FAST_FAIL_ETW_CORRUPTION: u32 = 61;
pub const FAST_FAIL_RIO_ABORT: u32 = 62;
pub const FAST_FAIL_INVALID_PFN: u32 = 63;
pub const FAST_FAIL_GUARD_ICALL_CHECK_FAILURE_XFG: u32 = 64;
pub const FAST_FAIL_CAST_GUARD: u32 = 65;
pub const FAST_FAIL_HOST_VISIBILITY_CHANGE: u32 = 66;
pub const FAST_FAIL_KERNEL_CET_SHADOW_STACK_ASSIST: u32 = 67;
pub const FAST_FAIL_PATCH_CALLBACK_FAILED: u32 = 68;
pub const FAST_FAIL_NTDLL_PATCH_FAILED: u32 = 69;
pub const FAST_FAIL_INVALID_FLS_DATA: u32 = 70;
pub const FAST_FAIL_INVALID_FAST_FAIL_CODE: u32 = 4294967295;
pub const RTL_QUERY_REGISTRY_SUBKEY: u32 = 1;
pub const RTL_QUERY_REGISTRY_TOPKEY: u32 = 2;
pub const RTL_QUERY_REGISTRY_REQUIRED: u32 = 4;
pub const RTL_QUERY_REGISTRY_NOVALUE: u32 = 8;
pub const RTL_QUERY_REGISTRY_NOEXPAND: u32 = 16;
pub const RTL_QUERY_REGISTRY_DIRECT: u32 = 32;
pub const RTL_QUERY_REGISTRY_DELETE: u32 = 64;
pub const RTL_QUERY_REGISTRY_NOSTRING: u32 = 128;
pub const RTL_QUERY_REGISTRY_TYPECHECK: u32 = 256;
pub const RTL_QUERY_REGISTRY_TYPECHECK_SHIFT: u32 = 24;
pub const RTL_QUERY_REGISTRY_TYPECHECK_MASK: u32 = 4278190080;
pub const RTL_REGISTRY_ABSOLUTE: u32 = 0;
pub const RTL_REGISTRY_SERVICES: u32 = 1;
pub const RTL_REGISTRY_CONTROL: u32 = 2;
pub const RTL_REGISTRY_WINDOWS_NT: u32 = 3;
pub const RTL_REGISTRY_DEVICEMAP: u32 = 4;
pub const RTL_REGISTRY_USER: u32 = 5;
pub const RTL_REGISTRY_MAXIMUM: u32 = 6;
pub const RTL_REGISTRY_HANDLE: u32 = 1073741824;
pub const RTL_REGISTRY_OPTIONAL: u32 = 2147483648;
pub const HASH_STRING_ALGORITHM_DEFAULT: u32 = 0;
pub const HASH_STRING_ALGORITHM_X65599: u32 = 1;
pub const HASH_STRING_ALGORITHM_INVALID: u32 = 4294967295;
pub const RTL_GUID_STRING_SIZE: u32 = 38;
pub const DBG_STATUS_CONTROL_C: u32 = 1;
pub const DBG_STATUS_SYSRQ: u32 = 2;
pub const DBG_STATUS_BUGCHECK_FIRST: u32 = 3;
pub const DBG_STATUS_BUGCHECK_SECOND: u32 = 4;
pub const DBG_STATUS_FATAL: u32 = 5;
pub const DBG_STATUS_DEBUG_CONTROL: u32 = 6;
pub const DBG_STATUS_WORKER: u32 = 7;
pub const LOWBYTE_MASK: u32 = 255;
pub const SHORT_LEAST_SIGNIFICANT_BIT: u32 = 0;
pub const SHORT_MOST_SIGNIFICANT_BIT: u32 = 1;
pub const LONG_LEAST_SIGNIFICANT_BIT: u32 = 0;
pub const LONG_3RD_MOST_SIGNIFICANT_BIT: u32 = 1;
pub const LONG_2ND_MOST_SIGNIFICANT_BIT: u32 = 2;
pub const LONG_MOST_SIGNIFICANT_BIT: u32 = 3;
pub const SEF_DACL_AUTO_INHERIT: u32 = 1;
pub const SEF_SACL_AUTO_INHERIT: u32 = 2;
pub const SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT: u32 = 4;
pub const SEF_AVOID_PRIVILEGE_CHECK: u32 = 8;
pub const SEF_AVOID_OWNER_CHECK: u32 = 16;
pub const SEF_DEFAULT_OWNER_FROM_PARENT: u32 = 32;
pub const SEF_DEFAULT_GROUP_FROM_PARENT: u32 = 64;
pub const SEF_MACL_NO_WRITE_UP: u32 = 256;
pub const SEF_MACL_NO_READ_UP: u32 = 512;
pub const SEF_MACL_NO_EXECUTE_UP: u32 = 1024;
pub const SEF_AI_USE_EXTRA_PARAMS: u32 = 2048;
pub const SEF_AVOID_OWNER_RESTRICTION: u32 = 4096;
pub const SEF_FORCE_USER_MODE: u32 = 8192;
pub const SEF_NORMALIZE_OUTPUT_DESCRIPTOR: u32 = 16384;
pub const SEF_MACL_VALID_FLAGS: u32 = 1792;
pub const VER_EQUAL: u32 = 1;
pub const VER_GREATER: u32 = 2;
pub const VER_GREATER_EQUAL: u32 = 3;
pub const VER_LESS: u32 = 4;
pub const VER_LESS_EQUAL: u32 = 5;
pub const VER_AND: u32 = 6;
pub const VER_OR: u32 = 7;
pub const VER_CONDITION_MASK: u32 = 7;
pub const VER_NUM_BITS_PER_CONDITION_MASK: u32 = 3;
pub const VER_MINORVERSION: u32 = 1;
pub const VER_MAJORVERSION: u32 = 2;
pub const VER_BUILDNUMBER: u32 = 4;
pub const VER_PLATFORMID: u32 = 8;
pub const VER_SERVICEPACKMINOR: u32 = 16;
pub const VER_SERVICEPACKMAJOR: u32 = 32;
pub const VER_SUITENAME: u32 = 64;
pub const VER_PRODUCT_TYPE: u32 = 128;
pub const VER_NT_WORKSTATION: u32 = 1;
pub const VER_NT_DOMAIN_CONTROLLER: u32 = 2;
pub const VER_NT_SERVER: u32 = 3;
pub const VER_PLATFORM_WIN32s: u32 = 0;
pub const VER_PLATFORM_WIN32_WINDOWS: u32 = 1;
pub const VER_PLATFORM_WIN32_NT: u32 = 2;
pub const DPFLTR_ERROR_LEVEL: u32 = 0;
pub const DPFLTR_WARNING_LEVEL: u32 = 1;
pub const DPFLTR_TRACE_LEVEL: u32 = 2;
pub const DPFLTR_INFO_LEVEL: u32 = 3;
pub const DPFLTR_MASK: u32 = 2147483648;
pub const VRL_PREDEFINED_CLASS_BEGIN: u32 = 1;
pub const VRL_CUSTOM_CLASS_BEGIN: u32 = 256;
pub const VRL_CLASS_CONSISTENCY: u32 = 1;
pub const VRL_ENABLE_KERNEL_BREAKS: u32 = 2147483648;
pub const CTMF_INCLUDE_APPCONTAINER: u32 = 1;
pub const CTMF_INCLUDE_LPAC: u32 = 2;
pub const CTMF_VALID_FLAGS: u32 = 3;
pub const IMAGE_POLICY_METADATA_VERSION: u32 = 1;
pub const IMAGE_POLICY_SECTION_NAME: &[u8; 9] = b".tPolicy\0";
pub const TRANSACTION_MANAGER_VOLATILE: u32 = 1;
pub const TRANSACTION_MANAGER_COMMIT_DEFAULT: u32 = 0;
pub const TRANSACTION_MANAGER_COMMIT_SYSTEM_VOLUME: u32 = 2;
pub const TRANSACTION_MANAGER_COMMIT_SYSTEM_HIVES: u32 = 4;
pub const TRANSACTION_MANAGER_COMMIT_LOWEST: u32 = 8;
pub const TRANSACTION_MANAGER_CORRUPT_FOR_RECOVERY: u32 = 16;
pub const TRANSACTION_MANAGER_CORRUPT_FOR_PROGRESS: u32 = 32;
pub const TRANSACTION_MANAGER_MAXIMUM_OPTION: u32 = 63;
pub const TRANSACTION_DO_NOT_PROMOTE: u32 = 1;
pub const TRANSACTION_MAXIMUM_OPTION: u32 = 1;
pub const RESOURCE_MANAGER_VOLATILE: u32 = 1;
pub const RESOURCE_MANAGER_COMMUNICATION: u32 = 2;
pub const RESOURCE_MANAGER_MAXIMUM_OPTION: u32 = 3;
pub const CRM_PROTOCOL_EXPLICIT_MARSHAL_ONLY: u32 = 1;
pub const CRM_PROTOCOL_DYNAMIC_MARSHAL_INFO: u32 = 2;
pub const CRM_PROTOCOL_MAXIMUM_OPTION: u32 = 3;
pub const ENLISTMENT_SUPERIOR: u32 = 1;
pub const ENLISTMENT_MAXIMUM_OPTION: u32 = 1;
pub const TRANSACTION_NOTIFY_MASK: u32 = 1073741823;
pub const TRANSACTION_NOTIFY_PREPREPARE: u32 = 1;
pub const TRANSACTION_NOTIFY_PREPARE: u32 = 2;
pub const TRANSACTION_NOTIFY_COMMIT: u32 = 4;
pub const TRANSACTION_NOTIFY_ROLLBACK: u32 = 8;
pub const TRANSACTION_NOTIFY_PREPREPARE_COMPLETE: u32 = 16;
pub const TRANSACTION_NOTIFY_PREPARE_COMPLETE: u32 = 32;
pub const TRANSACTION_NOTIFY_COMMIT_COMPLETE: u32 = 64;
pub const TRANSACTION_NOTIFY_ROLLBACK_COMPLETE: u32 = 128;
pub const TRANSACTION_NOTIFY_RECOVER: u32 = 256;
pub const TRANSACTION_NOTIFY_SINGLE_PHASE_COMMIT: u32 = 512;
pub const TRANSACTION_NOTIFY_DELEGATE_COMMIT: u32 = 1024;
pub const TRANSACTION_NOTIFY_RECOVER_QUERY: u32 = 2048;
pub const TRANSACTION_NOTIFY_ENLIST_PREPREPARE: u32 = 4096;
pub const TRANSACTION_NOTIFY_LAST_RECOVER: u32 = 8192;
pub const TRANSACTION_NOTIFY_INDOUBT: u32 = 16384;
pub const TRANSACTION_NOTIFY_PROPAGATE_PULL: u32 = 32768;
pub const TRANSACTION_NOTIFY_PROPAGATE_PUSH: u32 = 65536;
pub const TRANSACTION_NOTIFY_MARSHAL: u32 = 131072;
pub const TRANSACTION_NOTIFY_ENLIST_MASK: u32 = 262144;
pub const TRANSACTION_NOTIFY_RM_DISCONNECTED: u32 = 16777216;
pub const TRANSACTION_NOTIFY_TM_ONLINE: u32 = 33554432;
pub const TRANSACTION_NOTIFY_COMMIT_REQUEST: u32 = 67108864;
pub const TRANSACTION_NOTIFY_PROMOTE: u32 = 134217728;
pub const TRANSACTION_NOTIFY_PROMOTE_NEW: u32 = 268435456;
pub const TRANSACTION_NOTIFY_REQUEST_OUTCOME: u32 = 536870912;
pub const TRANSACTION_NOTIFY_COMMIT_FINALIZE: u32 = 1073741824;
pub const TRANSACTIONMANAGER_OBJECT_PATH: &[u8; 21] = b"\\TransactionManager\\\0";
pub const TRANSACTION_OBJECT_PATH: &[u8; 14] = b"\\Transaction\\\0";
pub const ENLISTMENT_OBJECT_PATH: &[u8; 13] = b"\\Enlistment\\\0";
pub const RESOURCE_MANAGER_OBJECT_PATH: &[u8; 18] = b"\\ResourceManager\\\0";
pub const TRANSACTION_NOTIFICATION_TM_ONLINE_FLAG_IS_CLUSTERED: u32 = 1;
pub const KTM_MARSHAL_BLOB_VERSION_MAJOR: u32 = 1;
pub const KTM_MARSHAL_BLOB_VERSION_MINOR: u32 = 1;
pub const MAX_TRANSACTION_DESCRIPTION_LENGTH: u32 = 64;
pub const MAX_RESOURCEMANAGER_DESCRIPTION_LENGTH: u32 = 64;
pub const TRANSACTIONMANAGER_QUERY_INFORMATION: u32 = 1;
pub const TRANSACTIONMANAGER_SET_INFORMATION: u32 = 2;
pub const TRANSACTIONMANAGER_RECOVER: u32 = 4;
pub const TRANSACTIONMANAGER_RENAME: u32 = 8;
pub const TRANSACTIONMANAGER_CREATE_RM: u32 = 16;
pub const TRANSACTIONMANAGER_BIND_TRANSACTION: u32 = 32;
pub const TRANSACTIONMANAGER_GENERIC_READ: u32 = 131073;
pub const TRANSACTIONMANAGER_GENERIC_WRITE: u32 = 131102;
pub const TRANSACTIONMANAGER_GENERIC_EXECUTE: u32 = 131072;
pub const TRANSACTIONMANAGER_ALL_ACCESS: u32 = 983103;
pub const TRANSACTION_QUERY_INFORMATION: u32 = 1;
pub const TRANSACTION_SET_INFORMATION: u32 = 2;
pub const TRANSACTION_ENLIST: u32 = 4;
pub const TRANSACTION_COMMIT: u32 = 8;
pub const TRANSACTION_ROLLBACK: u32 = 16;
pub const TRANSACTION_PROPAGATE: u32 = 32;
pub const TRANSACTION_RIGHT_RESERVED1: u32 = 64;
pub const TRANSACTION_GENERIC_READ: u32 = 1179649;
pub const TRANSACTION_GENERIC_WRITE: u32 = 1179710;
pub const TRANSACTION_GENERIC_EXECUTE: u32 = 1179672;
pub const TRANSACTION_ALL_ACCESS: u32 = 2031679;
pub const TRANSACTION_RESOURCE_MANAGER_RIGHTS: u32 = 1179703;
pub const RESOURCEMANAGER_QUERY_INFORMATION: u32 = 1;
pub const RESOURCEMANAGER_SET_INFORMATION: u32 = 2;
pub const RESOURCEMANAGER_RECOVER: u32 = 4;
pub const RESOURCEMANAGER_ENLIST: u32 = 8;
pub const RESOURCEMANAGER_GET_NOTIFICATION: u32 = 16;
pub const RESOURCEMANAGER_REGISTER_PROTOCOL: u32 = 32;
pub const RESOURCEMANAGER_COMPLETE_PROPAGATION: u32 = 64;
pub const RESOURCEMANAGER_GENERIC_READ: u32 = 1179649;
pub const RESOURCEMANAGER_GENERIC_WRITE: u32 = 1179774;
pub const RESOURCEMANAGER_GENERIC_EXECUTE: u32 = 1179740;
pub const RESOURCEMANAGER_ALL_ACCESS: u32 = 2031743;
pub const ENLISTMENT_QUERY_INFORMATION: u32 = 1;
pub const ENLISTMENT_SET_INFORMATION: u32 = 2;
pub const ENLISTMENT_RECOVER: u32 = 4;
pub const ENLISTMENT_SUBORDINATE_RIGHTS: u32 = 8;
pub const ENLISTMENT_SUPERIOR_RIGHTS: u32 = 16;
pub const ENLISTMENT_GENERIC_READ: u32 = 131073;
pub const ENLISTMENT_GENERIC_WRITE: u32 = 131102;
pub const ENLISTMENT_GENERIC_EXECUTE: u32 = 131100;
pub const ENLISTMENT_ALL_ACCESS: u32 = 983071;
pub const POOL_TAGGING: u32 = 1;
pub const DPC_NORMAL: u32 = 0;
pub const DPC_THREADED: u32 = 1;
pub const PAGE_SIZE: u32 = 4096;
pub const PAGE_SHIFT: u32 = 12;
pub const MDL_MAPPED_TO_SYSTEM_VA: u32 = 1;
pub const MDL_PAGES_LOCKED: u32 = 2;
pub const MDL_SOURCE_IS_NONPAGED_POOL: u32 = 4;
pub const MDL_ALLOCATED_FIXED_SIZE: u32 = 8;
pub const MDL_PARTIAL: u32 = 16;
pub const MDL_PARTIAL_HAS_BEEN_MAPPED: u32 = 32;
pub const MDL_IO_PAGE_READ: u32 = 64;
pub const MDL_WRITE_OPERATION: u32 = 128;
pub const MDL_LOCKED_PAGE_TABLES: u32 = 256;
pub const MDL_PARENT_MAPPED_SYSTEM_VA: u32 = 256;
pub const MDL_FREE_EXTRA_PTES: u32 = 512;
pub const MDL_DESCRIBES_AWE: u32 = 1024;
pub const MDL_IO_SPACE: u32 = 2048;
pub const MDL_NETWORK_HEADER: u32 = 4096;
pub const MDL_MAPPING_CAN_FAIL: u32 = 8192;
pub const MDL_PAGE_CONTENTS_INVARIANT: u32 = 16384;
pub const MDL_ALLOCATED_MUST_SUCCEED: u32 = 16384;
pub const MDL_INTERNAL: u32 = 32768;
pub const TIMER_TOLERABLE_DELAY_BITS: u32 = 6;
pub const TIMER_EXPIRED_INDEX_BITS: u32 = 6;
pub const TIMER_PROCESSOR_INDEX_BITS: u32 = 5;
pub const FLUSH_MULTIPLE_MAXIMUM: u32 = 19;
pub const ALLOC_PRAGMA: u32 = 1;
pub const ALLOC_DATA_PRAGMA: u32 = 1;
pub const EVENT_QUERY_STATE: u32 = 1;
pub const EVENT_MODIFY_STATE: u32 = 2;
pub const EVENT_ALL_ACCESS: u32 = 2031619;
pub const SEMAPHORE_QUERY_STATE: u32 = 1;
pub const SEMAPHORE_MODIFY_STATE: u32 = 2;
pub const SEMAPHORE_ALL_ACCESS: u32 = 2031619;
pub const LTP_PC_SMT: u32 = 1;
pub const CACHE_FULLY_ASSOCIATIVE: u32 = 255;
pub const SYSTEM_CPU_SET_INFORMATION_PARKED: u32 = 1;
pub const SYSTEM_CPU_SET_INFORMATION_ALLOCATED: u32 = 2;
pub const SYSTEM_CPU_SET_INFORMATION_ALLOCATED_TO_TARGET_PROCESS: u32 = 4;
pub const SYSTEM_CPU_SET_INFORMATION_REALTIME: u32 = 8;
pub const PF_FLOATING_POINT_PRECISION_ERRATA: u32 = 0;
pub const PF_FLOATING_POINT_EMULATED: u32 = 1;
pub const PF_COMPARE_EXCHANGE_DOUBLE: u32 = 2;
pub const PF_MMX_INSTRUCTIONS_AVAILABLE: u32 = 3;
pub const PF_PPC_MOVEMEM_64BIT_OK: u32 = 4;
pub const PF_ALPHA_BYTE_INSTRUCTIONS: u32 = 5;
pub const PF_XMMI_INSTRUCTIONS_AVAILABLE: u32 = 6;
pub const PF_3DNOW_INSTRUCTIONS_AVAILABLE: u32 = 7;
pub const PF_RDTSC_INSTRUCTION_AVAILABLE: u32 = 8;
pub const PF_PAE_ENABLED: u32 = 9;
pub const PF_XMMI64_INSTRUCTIONS_AVAILABLE: u32 = 10;
pub const PF_SSE_DAZ_MODE_AVAILABLE: u32 = 11;
pub const PF_NX_ENABLED: u32 = 12;
pub const PF_SSE3_INSTRUCTIONS_AVAILABLE: u32 = 13;
pub const PF_COMPARE_EXCHANGE128: u32 = 14;
pub const PF_COMPARE64_EXCHANGE128: u32 = 15;
pub const PF_CHANNELS_ENABLED: u32 = 16;
pub const PF_XSAVE_ENABLED: u32 = 17;
pub const PF_ARM_VFP_32_REGISTERS_AVAILABLE: u32 = 18;
pub const PF_ARM_NEON_INSTRUCTIONS_AVAILABLE: u32 = 19;
pub const PF_SECOND_LEVEL_ADDRESS_TRANSLATION: u32 = 20;
pub const PF_VIRT_FIRMWARE_ENABLED: u32 = 21;
pub const PF_RDWRFSGSBASE_AVAILABLE: u32 = 22;
pub const PF_FASTFAIL_AVAILABLE: u32 = 23;
pub const PF_ARM_DIVIDE_INSTRUCTION_AVAILABLE: u32 = 24;
pub const PF_ARM_64BIT_LOADSTORE_ATOMIC: u32 = 25;
pub const PF_ARM_EXTERNAL_CACHE_AVAILABLE: u32 = 26;
pub const PF_ARM_FMAC_INSTRUCTIONS_AVAILABLE: u32 = 27;
pub const PF_RDRAND_INSTRUCTION_AVAILABLE: u32 = 28;
pub const PF_ARM_V8_INSTRUCTIONS_AVAILABLE: u32 = 29;
pub const PF_ARM_V8_CRYPTO_INSTRUCTIONS_AVAILABLE: u32 = 30;
pub const PF_ARM_V8_CRC32_INSTRUCTIONS_AVAILABLE: u32 = 31;
pub const PF_RDTSCP_INSTRUCTION_AVAILABLE: u32 = 32;
pub const PF_RDPID_INSTRUCTION_AVAILABLE: u32 = 33;
pub const PF_ARM_V81_ATOMIC_INSTRUCTIONS_AVAILABLE: u32 = 34;
pub const PF_MONITORX_INSTRUCTION_AVAILABLE: u32 = 35;
pub const PF_SSSE3_INSTRUCTIONS_AVAILABLE: u32 = 36;
pub const PF_SSE4_1_INSTRUCTIONS_AVAILABLE: u32 = 37;
pub const PF_SSE4_2_INSTRUCTIONS_AVAILABLE: u32 = 38;
pub const PF_AVX_INSTRUCTIONS_AVAILABLE: u32 = 39;
pub const PF_AVX2_INSTRUCTIONS_AVAILABLE: u32 = 40;
pub const PF_AVX512F_INSTRUCTIONS_AVAILABLE: u32 = 41;
pub const PF_ERMS_AVAILABLE: u32 = 42;
pub const PF_ARM_V82_DP_INSTRUCTIONS_AVAILABLE: u32 = 43;
pub const PF_ARM_V83_JSCVT_INSTRUCTIONS_AVAILABLE: u32 = 44;
pub const PF_ARM_V83_LRCPC_INSTRUCTIONS_AVAILABLE: u32 = 45;
pub const IsNEC_98: u32 = 0;
pub const IsNotNEC_98: u32 = 1;
pub const PROCESSOR_FEATURE_MAX: u32 = 64;
pub const EXCEPTION_NONCONTINUABLE: u32 = 1;
pub const EXCEPTION_UNWINDING: u32 = 2;
pub const EXCEPTION_EXIT_UNWIND: u32 = 4;
pub const EXCEPTION_STACK_INVALID: u32 = 8;
pub const EXCEPTION_NESTED_CALL: u32 = 16;
pub const EXCEPTION_TARGET_UNWIND: u32 = 32;
pub const EXCEPTION_COLLIDED_UNWIND: u32 = 64;
pub const EXCEPTION_SOFTWARE_ORIGINATE: u32 = 128;
pub const EXCEPTION_UNWIND: u32 = 102;
pub const EXCEPTION_MAXIMUM_PARAMETERS: u32 = 15;
pub const THREAD_WAIT_OBJECTS: u32 = 3;
pub const SINGLE_GROUP_LEGACY_API: u32 = 1;
pub const KB_SECONDARY_DATA_FLAG_ADDITIONAL_DATA: u32 = 1;
pub const KB_SECONDARY_DATA_FLAG_NO_DEVICE_ACCESS: u32 = 2;
pub const KB_ADD_PAGES_FLAG_VIRTUAL_ADDRESS: u32 = 1;
pub const KB_ADD_PAGES_FLAG_PHYSICAL_ADDRESS: u32 = 2;
pub const KB_ADD_PAGES_FLAG_ADDITIONAL_RANGES_EXIST: u32 = 2147483648;
pub const KB_REMOVE_PAGES_FLAG_VIRTUAL_ADDRESS: u32 = 1;
pub const KB_REMOVE_PAGES_FLAG_PHYSICAL_ADDRESS: u32 = 2;
pub const KB_REMOVE_PAGES_FLAG_ADDITIONAL_RANGES_EXIST: u32 = 2147483648;
pub const KE_MAX_TRIAGE_DUMP_DATA_MEMORY_SIZE: u32 = 33554432;
pub const KB_TRIAGE_DUMP_DATA_FLAG_BUGCHECK_ACTIVE: u32 = 1;
pub const EXCEPTION_DIVIDED_BY_ZERO: u32 = 0;
pub const EXCEPTION_DEBUG: u32 = 1;
pub const EXCEPTION_NMI: u32 = 2;
pub const EXCEPTION_INT3: u32 = 3;
pub const EXCEPTION_BOUND_CHECK: u32 = 5;
pub const EXCEPTION_INVALID_OPCODE: u32 = 6;
pub const EXCEPTION_NPX_NOT_AVAILABLE: u32 = 7;
pub const EXCEPTION_DOUBLE_FAULT: u32 = 8;
pub const EXCEPTION_NPX_OVERRUN: u32 = 9;
pub const EXCEPTION_INVALID_TSS: u32 = 10;
pub const EXCEPTION_SEGMENT_NOT_PRESENT: u32 = 11;
pub const EXCEPTION_STACK_FAULT: u32 = 12;
pub const EXCEPTION_GP_FAULT: u32 = 13;
pub const EXCEPTION_RESERVED_TRAP: u32 = 15;
pub const EXCEPTION_NPX_ERROR: u32 = 16;
pub const EXCEPTION_ALIGNMENT_CHECK: u32 = 17;
pub const EXCEPTION_CP_FAULT: u32 = 21;
pub const EXCEPTION_SE_FAULT: u32 = 23;
pub const EXCEPTION_VIRTUALIZATION_FAULT: u32 = 32;
pub const KE_PROCESSOR_CHANGE_ADD_EXISTING: u32 = 1;
pub const INVALID_PROCESSOR_INDEX: u32 = 4294967295;
pub const POOL_COLD_ALLOCATION: u32 = 256;
pub const POOL_NX_ALLOCATION: u32 = 512;
pub const POOL_ZERO_ALLOCATION: u32 = 1024;
pub const POOL_QUOTA_FAIL_INSTEAD_OF_RAISE: u32 = 8;
pub const POOL_RAISE_IF_ALLOCATION_FAILURE: u32 = 16;
pub const POOL_EXTENDED_PARAMETER_TYPE_BITS: u32 = 8;
pub const POOL_EXTENDED_PARAMETER_REQUIRED_FIELD_BITS: u32 = 1;
pub const POOL_EXTENDED_PARAMETER_RESERVED_BITS: u32 = 55;
pub const SECURE_POOL_FLAGS_NONE: u32 = 0;
pub const SECURE_POOL_FLAGS_FREEABLE: u32 = 1;
pub const SECURE_POOL_FLAGS_MODIFIABLE: u32 = 2;
pub const POOL_CREATE_FLG_SECURE_POOL: u32 = 1;
pub const POOL_CREATE_FLG_USE_GLOBAL_POOL: u32 = 2;
pub const POOL_CREATE_FLG_VALID_FLAGS: u32 = 3;
pub const POOL_CREATE_PARAMS_VERSION: u32 = 1;
pub const FM_LOCK_BIT: u32 = 1;
pub const FM_LOCK_BIT_V: u32 = 0;
pub const EX_LOOKASIDE_LIST_EX_FLAGS_RAISE_ON_FAIL: u32 = 1;
pub const EX_LOOKASIDE_LIST_EX_FLAGS_FAIL_NO_RAISE: u32 = 2;
pub const EX_MAXIMUM_LOOKASIDE_DEPTH_BASE: u32 = 256;
pub const EX_MAXIMUM_LOOKASIDE_DEPTH_LIMIT: u32 = 1024;
pub const ResourceNeverExclusive: u32 = 16;
pub const ResourceReleaseByOtherThread: u32 = 32;
pub const ResourceOwnedExclusive: u32 = 128;
pub const RESOURCE_HASH_TABLE_SIZE: u32 = 64;
pub const FLAG_OWNER_POINTER_IS_THREAD: u32 = 1;
pub const EX_RUNDOWN_ACTIVE: u32 = 1;
pub const EX_RUNDOWN_COUNT_SHIFT: u32 = 1;
pub const EX_RUNDOWN_COUNT_INC: u32 = 2;
pub const EX_TIMER_HIGH_RESOLUTION: u32 = 4;
pub const EX_TIMER_NO_WAKE: u32 = 8;
pub const EX_TIMER_NOTIFICATION: u32 = 2147483648;
pub const EX_CARR_ALLOCATE_PAGED_POOL: u32 = 0;
pub const EX_CARR_ALLOCATE_NONPAGED_POOL: u32 = 1;
pub const EX_CARR_DISABLE_EXPANSION: u32 = 2;
pub const EX_CARR_VALID_FLAGS: u32 = 3;
pub const EX_DEFAULT_PUSH_LOCK_FLAGS: u32 = 0;
pub const ATS_DEVICE_SVM_OPTOUT: u32 = 1;
pub const EVENT_INCREMENT: u32 = 1;
pub const IO_NO_INCREMENT: u32 = 0;
pub const IO_CD_ROM_INCREMENT: u32 = 1;
pub const IO_DISK_INCREMENT: u32 = 1;
pub const IO_KEYBOARD_INCREMENT: u32 = 6;
pub const IO_MAILSLOT_INCREMENT: u32 = 2;
pub const IO_MOUSE_INCREMENT: u32 = 6;
pub const IO_NAMED_PIPE_INCREMENT: u32 = 2;
pub const IO_NETWORK_INCREMENT: u32 = 2;
pub const IO_PARALLEL_INCREMENT: u32 = 1;
pub const IO_SERIAL_INCREMENT: u32 = 2;
pub const IO_SOUND_INCREMENT: u32 = 8;
pub const IO_VIDEO_INCREMENT: u32 = 1;
pub const SEMAPHORE_INCREMENT: u32 = 1;
pub const MM_MAXIMUM_DISK_IO_SIZE: u32 = 65536;
pub const MM_PERMANENT_ADDRESS_IS_IO_SPACE: u32 = 1;
pub const MM_DUMP_MAP_CACHED: u32 = 1;
pub const MM_DUMP_MAP_INVALIDATE: u32 = 2;
pub const MdlMappingNoWrite: u32 = 2147483648;
pub const MdlMappingNoExecute: u32 = 1073741824;
pub const MdlMappingWithGuardPtes: u32 = 536870912;
pub const MM_MAPPING_ADDRESS_DIVISIBLE: u32 = 1;
pub const MM_DONT_ZERO_ALLOCATION: u32 = 1;
pub const MM_ALLOCATE_FROM_LOCAL_NODE_ONLY: u32 = 2;
pub const MM_ALLOCATE_FULLY_REQUIRED: u32 = 4;
pub const MM_ALLOCATE_NO_WAIT: u32 = 8;
pub const MM_ALLOCATE_PREFER_CONTIGUOUS: u32 = 16;
pub const MM_ALLOCATE_REQUIRE_CONTIGUOUS_CHUNKS: u32 = 32;
pub const MM_ALLOCATE_FAST_LARGE_PAGES: u32 = 64;
pub const MM_ALLOCATE_TRIM_IF_NECESSARY: u32 = 128;
pub const MM_ALLOCATE_AND_HOT_REMOVE: u32 = 256;
pub const MM_FREE_MDL_PAGES_ZERO: u32 = 1;
pub const MM_ANY_NODE_OK: u32 = 2147483648;
pub const MM_ALLOCATE_CONTIGUOUS_MEMORY_FAST_ONLY: u32 = 1;
pub const MM_PROTECT_DRIVER_SECTION_ALLOW_UNLOAD: u32 = 1;
pub const MM_PROTECT_DRIVER_SECTION_VALID_FLAGS: u32 = 1;
pub const INITIAL_PRIVILEGE_COUNT: u32 = 3;
pub const IO_TYPE_ADAPTER: u32 = 1;
pub const IO_TYPE_CONTROLLER: u32 = 2;
pub const IO_TYPE_DEVICE: u32 = 3;
pub const IO_TYPE_DRIVER: u32 = 4;
pub const IO_TYPE_FILE: u32 = 5;
pub const IO_TYPE_IRP: u32 = 6;
pub const IO_TYPE_MASTER_ADAPTER: u32 = 7;
pub const IO_TYPE_OPEN_PACKET: u32 = 8;
pub const IO_TYPE_TIMER: u32 = 9;
pub const IO_TYPE_VPB: u32 = 10;
pub const IO_TYPE_ERROR_LOG: u32 = 11;
pub const IO_TYPE_ERROR_MESSAGE: u32 = 12;
pub const IO_TYPE_DEVICE_OBJECT_EXTENSION: u32 = 13;
pub const IO_TYPE_IORING: u32 = 14;
pub const IRP_MJ_CREATE: u32 = 0;
pub const IRP_MJ_CREATE_NAMED_PIPE: u32 = 1;
pub const IRP_MJ_CLOSE: u32 = 2;
pub const IRP_MJ_READ: u32 = 3;
pub const IRP_MJ_WRITE: u32 = 4;
pub const IRP_MJ_QUERY_INFORMATION: u32 = 5;
pub const IRP_MJ_SET_INFORMATION: u32 = 6;
pub const IRP_MJ_QUERY_EA: u32 = 7;
pub const IRP_MJ_SET_EA: u32 = 8;
pub const IRP_MJ_FLUSH_BUFFERS: u32 = 9;
pub const IRP_MJ_QUERY_VOLUME_INFORMATION: u32 = 10;
pub const IRP_MJ_SET_VOLUME_INFORMATION: u32 = 11;
pub const IRP_MJ_DIRECTORY_CONTROL: u32 = 12;
pub const IRP_MJ_FILE_SYSTEM_CONTROL: u32 = 13;
pub const IRP_MJ_DEVICE_CONTROL: u32 = 14;
pub const IRP_MJ_INTERNAL_DEVICE_CONTROL: u32 = 15;
pub const IRP_MJ_SHUTDOWN: u32 = 16;
pub const IRP_MJ_LOCK_CONTROL: u32 = 17;
pub const IRP_MJ_CLEANUP: u32 = 18;
pub const IRP_MJ_CREATE_MAILSLOT: u32 = 19;
pub const IRP_MJ_QUERY_SECURITY: u32 = 20;
pub const IRP_MJ_SET_SECURITY: u32 = 21;
pub const IRP_MJ_POWER: u32 = 22;
pub const IRP_MJ_SYSTEM_CONTROL: u32 = 23;
pub const IRP_MJ_DEVICE_CHANGE: u32 = 24;
pub const IRP_MJ_QUERY_QUOTA: u32 = 25;
pub const IRP_MJ_SET_QUOTA: u32 = 26;
pub const IRP_MJ_PNP: u32 = 27;
pub const IRP_MJ_PNP_POWER: u32 = 27;
pub const IRP_MJ_MAXIMUM_FUNCTION: u32 = 27;
pub const IRP_MJ_SCSI: u32 = 15;
pub const IRP_MN_SCSI_CLASS: u32 = 1;
pub const IRP_MN_START_DEVICE: u32 = 0;
pub const IRP_MN_QUERY_REMOVE_DEVICE: u32 = 1;
pub const IRP_MN_REMOVE_DEVICE: u32 = 2;
pub const IRP_MN_CANCEL_REMOVE_DEVICE: u32 = 3;
pub const IRP_MN_STOP_DEVICE: u32 = 4;
pub const IRP_MN_QUERY_STOP_DEVICE: u32 = 5;
pub const IRP_MN_CANCEL_STOP_DEVICE: u32 = 6;
pub const IRP_MN_QUERY_DEVICE_RELATIONS: u32 = 7;
pub const IRP_MN_QUERY_INTERFACE: u32 = 8;
pub const IRP_MN_QUERY_CAPABILITIES: u32 = 9;
pub const IRP_MN_QUERY_RESOURCES: u32 = 10;
pub const IRP_MN_QUERY_RESOURCE_REQUIREMENTS: u32 = 11;
pub const IRP_MN_QUERY_DEVICE_TEXT: u32 = 12;
pub const IRP_MN_FILTER_RESOURCE_REQUIREMENTS: u32 = 13;
pub const IRP_MN_READ_CONFIG: u32 = 15;
pub const IRP_MN_WRITE_CONFIG: u32 = 16;
pub const IRP_MN_EJECT: u32 = 17;
pub const IRP_MN_SET_LOCK: u32 = 18;
pub const IRP_MN_QUERY_ID: u32 = 19;
pub const IRP_MN_QUERY_PNP_DEVICE_STATE: u32 = 20;
pub const IRP_MN_QUERY_BUS_INFORMATION: u32 = 21;
pub const IRP_MN_DEVICE_USAGE_NOTIFICATION: u32 = 22;
pub const IRP_MN_SURPRISE_REMOVAL: u32 = 23;
pub const IRP_MN_DEVICE_ENUMERATED: u32 = 25;
pub const IRP_MN_WAIT_WAKE: u32 = 0;
pub const IRP_MN_POWER_SEQUENCE: u32 = 1;
pub const IRP_MN_SET_POWER: u32 = 2;
pub const IRP_MN_QUERY_POWER: u32 = 3;
pub const IRP_MN_QUERY_ALL_DATA: u32 = 0;
pub const IRP_MN_QUERY_SINGLE_INSTANCE: u32 = 1;
pub const IRP_MN_CHANGE_SINGLE_INSTANCE: u32 = 2;
pub const IRP_MN_CHANGE_SINGLE_ITEM: u32 = 3;
pub const IRP_MN_ENABLE_EVENTS: u32 = 4;
pub const IRP_MN_DISABLE_EVENTS: u32 = 5;
pub const IRP_MN_ENABLE_COLLECTION: u32 = 6;
pub const IRP_MN_DISABLE_COLLECTION: u32 = 7;
pub const IRP_MN_REGINFO: u32 = 8;
pub const IRP_MN_EXECUTE_METHOD: u32 = 9;
pub const IRP_MN_REGINFO_EX: u32 = 11;
pub const IO_FORCE_ACCESS_CHECK: u32 = 1;
pub const IO_NO_PARAMETER_CHECKING: u32 = 256;
pub const IO_REPARSE: u32 = 0;
pub const IO_REMOUNT: u32 = 1;
pub const IO_REPARSE_GLOBAL: u32 = 2;
pub const VPB_MOUNTED: u32 = 1;
pub const VPB_LOCKED: u32 = 2;
pub const VPB_PERSISTENT: u32 = 4;
pub const VPB_REMOVE_PENDING: u32 = 8;
pub const VPB_RAW_MOUNT: u32 = 16;
pub const VPB_DIRECT_WRITES_ALLOWED: u32 = 32;
pub const VPB_FLAGS_BYPASSIO_BLOCKED: u32 = 64;
pub const VPB_DISMOUNTING: u32 = 128;
pub const DO_VERIFY_VOLUME: u32 = 2;
pub const DO_BUFFERED_IO: u32 = 4;
pub const DO_EXCLUSIVE: u32 = 8;
pub const DO_DIRECT_IO: u32 = 16;
pub const DO_MAP_IO_BUFFER: u32 = 32;
pub const DO_DEVICE_INITIALIZING: u32 = 128;
pub const DO_SHUTDOWN_REGISTERED: u32 = 2048;
pub const DO_BUS_ENUMERATED_DEVICE: u32 = 4096;
pub const DO_POWER_PAGABLE: u32 = 8192;
pub const DO_POWER_INRUSH: u32 = 16384;
pub const DO_DEVICE_TO_BE_RESET: u32 = 67108864;
pub const DO_DAX_VOLUME: u32 = 268435456;
pub const DRVO_UNLOAD_INVOKED: u32 = 1;
pub const DRVO_LEGACY_DRIVER: u32 = 2;
pub const DRVO_BUILTIN_DRIVER: u32 = 4;
pub const FO_FILE_OPEN: u32 = 1;
pub const FO_SYNCHRONOUS_IO: u32 = 2;
pub const FO_ALERTABLE_IO: u32 = 4;
pub const FO_NO_INTERMEDIATE_BUFFERING: u32 = 8;
pub const FO_WRITE_THROUGH: u32 = 16;
pub const FO_SEQUENTIAL_ONLY: u32 = 32;
pub const FO_CACHE_SUPPORTED: u32 = 64;
pub const FO_NAMED_PIPE: u32 = 128;
pub const FO_STREAM_FILE: u32 = 256;
pub const FO_MAILSLOT: u32 = 512;
pub const FO_GENERATE_AUDIT_ON_CLOSE: u32 = 1024;
pub const FO_QUEUE_IRP_TO_THREAD: u32 = 1024;
pub const FO_DIRECT_DEVICE_OPEN: u32 = 2048;
pub const FO_FILE_MODIFIED: u32 = 4096;
pub const FO_FILE_SIZE_CHANGED: u32 = 8192;
pub const FO_CLEANUP_COMPLETE: u32 = 16384;
pub const FO_TEMPORARY_FILE: u32 = 32768;
pub const FO_DELETE_ON_CLOSE: u32 = 65536;
pub const FO_OPENED_CASE_SENSITIVE: u32 = 131072;
pub const FO_HANDLE_CREATED: u32 = 262144;
pub const FO_FILE_FAST_IO_READ: u32 = 524288;
pub const FO_RANDOM_ACCESS: u32 = 1048576;
pub const FO_FILE_OPEN_CANCELLED: u32 = 2097152;
pub const FO_VOLUME_OPEN: u32 = 4194304;
pub const FO_BYPASS_IO_ENABLED: u32 = 8388608;
pub const FO_REMOTE_ORIGIN: u32 = 16777216;
pub const FO_DISALLOW_EXCLUSIVE: u32 = 33554432;
pub const FO_SKIP_COMPLETION_PORT: u32 = 33554432;
pub const FO_SKIP_SET_EVENT: u32 = 67108864;
pub const FO_SKIP_SET_FAST_IO: u32 = 134217728;
pub const FO_INDIRECT_WAIT_OBJECT: u32 = 268435456;
pub const FO_SECTION_MINSTORE_TREATMENT: u32 = 536870912;
pub const FO_FLAGS_VALID_ONLY_DURING_CREATE: u32 = 33554432;
pub const IRP_NOCACHE: u32 = 1;
pub const IRP_PAGING_IO: u32 = 2;
pub const IRP_MOUNT_COMPLETION: u32 = 2;
pub const IRP_SYNCHRONOUS_API: u32 = 4;
pub const IRP_ASSOCIATED_IRP: u32 = 8;
pub const IRP_BUFFERED_IO: u32 = 16;
pub const IRP_DEALLOCATE_BUFFER: u32 = 32;
pub const IRP_INPUT_OPERATION: u32 = 64;
pub const IRP_SYNCHRONOUS_PAGING_IO: u32 = 64;
pub const IRP_CREATE_OPERATION: u32 = 128;
pub const IRP_READ_OPERATION: u32 = 256;
pub const IRP_WRITE_OPERATION: u32 = 512;
pub const IRP_CLOSE_OPERATION: u32 = 1024;
pub const IRP_DEFER_IO_COMPLETION: u32 = 2048;
pub const IRP_OB_QUERY_NAME: u32 = 4096;
pub const IRP_HOLD_DEVICE_QUEUE: u32 = 8192;
pub const IRP_UM_DRIVER_INITIATED_IO: u32 = 4194304;
pub const IRP_QUOTA_CHARGED: u32 = 1;
pub const IRP_ALLOCATED_MUST_SUCCEED: u32 = 2;
pub const IRP_ALLOCATED_FIXED_SIZE: u32 = 4;
pub const IRP_LOOKASIDE_ALLOCATION: u32 = 8;
pub const SL_PENDING_RETURNED: u32 = 1;
pub const SL_ERROR_RETURNED: u32 = 2;
pub const SL_INVOKE_ON_CANCEL: u32 = 32;
pub const SL_INVOKE_ON_SUCCESS: u32 = 64;
pub const SL_INVOKE_ON_ERROR: u32 = 128;
pub const SL_FORCE_ACCESS_CHECK: u32 = 1;
pub const SL_OPEN_PAGING_FILE: u32 = 2;
pub const SL_OPEN_TARGET_DIRECTORY: u32 = 4;
pub const SL_STOP_ON_SYMLINK: u32 = 8;
pub const SL_IGNORE_READONLY_ATTRIBUTE: u32 = 64;
pub const SL_CASE_SENSITIVE: u32 = 128;
pub const SL_KEY_SPECIFIED: u32 = 1;
pub const SL_OVERRIDE_VERIFY_VOLUME: u32 = 2;
pub const SL_WRITE_THROUGH: u32 = 4;
pub const SL_FT_SEQUENTIAL_WRITE: u32 = 8;
pub const SL_FORCE_DIRECT_WRITE: u32 = 16;
pub const SL_REALTIME_STREAM: u32 = 32;
pub const SL_PERSISTENT_MEMORY_FIXED_MAPPING: u32 = 32;
pub const SL_BYPASS_IO: u32 = 64;
pub const SL_FORCE_ASYNCHRONOUS: u32 = 1;
pub const SL_READ_ACCESS_GRANTED: u32 = 1;
pub const SL_WRITE_ACCESS_GRANTED: u32 = 4;
pub const SL_FAIL_IMMEDIATELY: u32 = 1;
pub const SL_EXCLUSIVE_LOCK: u32 = 2;
pub const SL_RESTART_SCAN: u32 = 1;
pub const SL_RETURN_SINGLE_ENTRY: u32 = 2;
pub const SL_INDEX_SPECIFIED: u32 = 4;
pub const SL_RETURN_ON_DISK_ENTRIES_ONLY: u32 = 8;
pub const SL_NO_CURSOR_UPDATE: u32 = 16;
pub const SL_QUERY_DIRECTORY_MASK: u32 = 27;
pub const SL_WATCH_TREE: u32 = 1;
pub const SL_ALLOW_RAW_MOUNT: u32 = 1;
pub const SL_BYPASS_ACCESS_CHECK: u32 = 1;
pub const SL_INFO_FORCE_ACCESS_CHECK: u32 = 1;
pub const SL_INFO_IGNORE_READONLY_ATTRIBUTE: u32 = 64;
pub const PNP_DEVICE_DISABLED: u32 = 1;
pub const PNP_DEVICE_DONT_DISPLAY_IN_UI: u32 = 2;
pub const PNP_DEVICE_FAILED: u32 = 4;
pub const PNP_DEVICE_REMOVED: u32 = 8;
pub const PNP_DEVICE_RESOURCE_REQUIREMENTS_CHANGED: u32 = 16;
pub const PNP_DEVICE_NOT_DISABLEABLE: u32 = 32;
pub const PNP_DEVICE_DISCONNECTED: u32 = 64;
pub const PNP_DEVICE_RESOURCE_UPDATED: u32 = 128;
pub const PNP_DEVICE_ASSIGNED_TO_GUEST: u32 = 256;
pub const IO_SHARE_ACCESS_NO_WRITE_PERMISSION: u32 = 2147483648;
pub const IO_SHARE_ACCESS_NON_PRIMARY_STREAM: u32 = 128;
pub const IO_CHECK_SHARE_ACCESS_UPDATE_SHARE_ACCESS: u32 = 1;
pub const IO_CHECK_SHARE_ACCESS_DONT_UPDATE_FILE_OBJECT: u32 = 2;
pub const IO_CHECK_SHARE_ACCESS_DONT_CHECK_READ: u32 = 4;
pub const IO_CHECK_SHARE_ACCESS_DONT_CHECK_WRITE: u32 = 8;
pub const IO_CHECK_SHARE_ACCESS_DONT_CHECK_DELETE: u32 = 16;
pub const IO_CHECK_SHARE_ACCESS_FORCE_CHECK: u32 = 32;
pub const IO_CHECK_SHARE_ACCESS_FORCE_USING_SCB: u32 = 64;
pub const CONNECT_FULLY_SPECIFIED: u32 = 1;
pub const CONNECT_LINE_BASED: u32 = 2;
pub const CONNECT_MESSAGE_BASED: u32 = 3;
pub const CONNECT_FULLY_SPECIFIED_GROUP: u32 = 4;
pub const CONNECT_MESSAGE_BASED_PASSIVE: u32 = 5;
pub const CONNECT_CURRENT_VERSION: u32 = 5;
pub const WDM_MAJORVERSION: u32 = 6;
pub const WDM_MINORVERSION: u32 = 0;
pub const WMIREG_ACTION_REGISTER: u32 = 1;
pub const WMIREG_ACTION_DEREGISTER: u32 = 2;
pub const WMIREG_ACTION_REREGISTER: u32 = 3;
pub const WMIREG_ACTION_UPDATE_GUIDS: u32 = 4;
pub const WMIREG_ACTION_BLOCK_IRPS: u32 = 5;
pub const WMIREGISTER: u32 = 0;
pub const WMIUPDATE: u32 = 1;
pub const IO_TYPE_CSQ_IRP_CONTEXT: u32 = 1;
pub const IO_TYPE_CSQ: u32 = 2;
pub const IO_TYPE_CSQ_EX: u32 = 3;
pub const IO_ATTRIBUTION_INFO_V1: u32 = 1;
pub const IO_SET_IRP_IO_ATTRIBUTION_FROM_THREAD: u32 = 1;
pub const IO_SET_IRP_IO_ATTRIBUTION_FROM_PROCESS: u32 = 2;
pub const IO_SET_IRP_IO_ATTRIBUTION_FLAGS_MASK: u32 = 3;
pub const EVENT_MIN_LEVEL: u32 = 0;
pub const EVENT_MAX_LEVEL: u32 = 255;
pub const EVENT_ACTIVITY_CTRL_GET_ID: u32 = 1;
pub const EVENT_ACTIVITY_CTRL_SET_ID: u32 = 2;
pub const EVENT_ACTIVITY_CTRL_CREATE_ID: u32 = 3;
pub const EVENT_ACTIVITY_CTRL_GET_SET_ID: u32 = 4;
pub const EVENT_ACTIVITY_CTRL_CREATE_SET_ID: u32 = 5;
pub const MAX_EVENT_DATA_DESCRIPTORS: u32 = 128;
pub const MAX_EVENT_FILTER_DATA_SIZE: u32 = 1024;
pub const MAX_EVENT_FILTER_PAYLOAD_SIZE: u32 = 4096;
pub const MAX_EVENT_FILTER_EVENT_NAME_SIZE: u32 = 4096;
pub const MAX_EVENT_FILTERS_COUNT: u32 = 13;
pub const MAX_EVENT_FILTER_PID_COUNT: u32 = 8;
pub const MAX_EVENT_FILTER_EVENT_ID_COUNT: u32 = 64;
pub const EVENT_FILTER_TYPE_NONE: u32 = 0;
pub const EVENT_FILTER_TYPE_SCHEMATIZED: u32 = 2147483648;
pub const EVENT_FILTER_TYPE_SYSTEM_FLAGS: u32 = 2147483649;
pub const EVENT_FILTER_TYPE_TRACEHANDLE: u32 = 2147483650;
pub const EVENT_FILTER_TYPE_PID: u32 = 2147483652;
pub const EVENT_FILTER_TYPE_EXECUTABLE_NAME: u32 = 2147483656;
pub const EVENT_FILTER_TYPE_PACKAGE_ID: u32 = 2147483664;
pub const EVENT_FILTER_TYPE_PACKAGE_APP_ID: u32 = 2147483680;
pub const EVENT_FILTER_TYPE_PAYLOAD: u32 = 2147483904;
pub const EVENT_FILTER_TYPE_EVENT_ID: u32 = 2147484160;
pub const EVENT_FILTER_TYPE_EVENT_NAME: u32 = 2147484672;
pub const EVENT_FILTER_TYPE_STACKWALK: u32 = 2147487744;
pub const EVENT_FILTER_TYPE_STACKWALK_NAME: u32 = 2147491840;
pub const EVENT_FILTER_TYPE_STACKWALK_LEVEL_KW: u32 = 2147500032;
pub const EVENT_FILTER_TYPE_CONTAINER: u32 = 2147516416;
pub const EVENT_DATA_DESCRIPTOR_TYPE_NONE: u32 = 0;
pub const EVENT_DATA_DESCRIPTOR_TYPE_EVENT_METADATA: u32 = 1;
pub const EVENT_DATA_DESCRIPTOR_TYPE_PROVIDER_METADATA: u32 = 2;
pub const EVENT_DATA_DESCRIPTOR_TYPE_TIMESTAMP_OVERRIDE: u32 = 3;
pub const EVENT_WRITE_FLAG_NO_FAULTING: u32 = 1;
pub const EVENT_WRITE_FLAG_INPRIVATE: u32 = 2;
pub const __string_type: u32 = 0;
pub const __guid_type: u32 = 0;
pub const __multiString_type: u32 = 0;
pub const PCI_SECURITY_INTERFACE_VERSION: u32 = 1;
pub const PCI_SECURITY_INTERFACE_VERSION2: u32 = 2;
pub const PCI_SECURITY_FULLY_SUPPORTED: u32 = 1;
pub const PCI_SECURITY_ENHANCED: u32 = 2;
pub const PCI_SECURITY_GUEST_ASSIGNED: u32 = 1;
pub const PCI_SECURITY_DIRECT_TRANSLATED_P2P: u32 = 4;
pub const PCI_SECURITY_SRIOV_DIRECT_TRANSLATED_P2P: u32 = 262144;
pub const PCI_ATS_INTERFACE_VERSION: u32 = 1;
pub const PNP_EXTENDED_ADDRESS_INTERFACE_VERSION: u32 = 1;
pub const D3COLD_SUPPORT_INTERFACE_VERSION: u32 = 1;
pub const PCI_PTM_TIME_SOURCE_AUX: u32 = 4294967295;
pub const NPEM_CONTROL_INTERFACE_VERSION1: u32 = 1;
pub const NPEM_CONTROL_INTERFACE_VERSION2: u32 = 2;
pub const NPEM_CONTROL_INTERFACE_CURRENT_VERSION: u32 = 2;
pub const PLUGPLAY_REGKEY_DEVICE: u32 = 1;
pub const PLUGPLAY_REGKEY_DRIVER: u32 = 2;
pub const PLUGPLAY_REGKEY_CURRENT_HWPROFILE: u32 = 4;
pub const DEVICE_INTERFACE_INCLUDE_NONACTIVE: u32 = 1;
pub const PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES: u32 = 1;
pub const KERNEL_SOFT_RESTART_NOTIFICATION_VERSION: u32 = 1;
pub const DEVPROP_TYPEMOD_ARRAY: u32 = 4096;
pub const DEVPROP_TYPEMOD_LIST: u32 = 8192;
pub const DEVPROP_TYPE_EMPTY: u32 = 0;
pub const DEVPROP_TYPE_NULL: u32 = 1;
pub const DEVPROP_TYPE_SBYTE: u32 = 2;
pub const DEVPROP_TYPE_BYTE: u32 = 3;
pub const DEVPROP_TYPE_INT16: u32 = 4;
pub const DEVPROP_TYPE_UINT16: u32 = 5;
pub const DEVPROP_TYPE_INT32: u32 = 6;
pub const DEVPROP_TYPE_UINT32: u32 = 7;
pub const DEVPROP_TYPE_INT64: u32 = 8;
pub const DEVPROP_TYPE_UINT64: u32 = 9;
pub const DEVPROP_TYPE_FLOAT: u32 = 10;
pub const DEVPROP_TYPE_DOUBLE: u32 = 11;
pub const DEVPROP_TYPE_DECIMAL: u32 = 12;
pub const DEVPROP_TYPE_GUID: u32 = 13;
pub const DEVPROP_TYPE_CURRENCY: u32 = 14;
pub const DEVPROP_TYPE_DATE: u32 = 15;
pub const DEVPROP_TYPE_FILETIME: u32 = 16;
pub const DEVPROP_TYPE_BOOLEAN: u32 = 17;
pub const DEVPROP_TYPE_STRING: u32 = 18;
pub const DEVPROP_TYPE_STRING_LIST: u32 = 8210;
pub const DEVPROP_TYPE_SECURITY_DESCRIPTOR: u32 = 19;
pub const DEVPROP_TYPE_SECURITY_DESCRIPTOR_STRING: u32 = 20;
pub const DEVPROP_TYPE_DEVPROPKEY: u32 = 21;
pub const DEVPROP_TYPE_DEVPROPTYPE: u32 = 22;
pub const DEVPROP_TYPE_BINARY: u32 = 4099;
pub const DEVPROP_TYPE_ERROR: u32 = 23;
pub const DEVPROP_TYPE_NTSTATUS: u32 = 24;
pub const DEVPROP_TYPE_STRING_INDIRECT: u32 = 25;
pub const MAX_DEVPROP_TYPE: u32 = 25;
pub const MAX_DEVPROP_TYPEMOD: u32 = 8192;
pub const DEVPROP_MASK_TYPE: u32 = 4095;
pub const DEVPROP_MASK_TYPEMOD: u32 = 61440;
pub const DEVPROPID_FIRST_USABLE: u32 = 2;
pub const PLUGPLAY_PROPERTY_PERSISTENT: u32 = 1;
pub const PNP_REPLACE_NO_MAP: u64 = 9223372036854775807;
pub const PNP_REPLACE_PARAMETERS_VERSION: u32 = 2;
pub const PNP_REPLACE_DRIVER_INTERFACE_VERSION: u32 = 1;
pub const PNP_REPLACE_MEMORY_SUPPORTED: u32 = 1;
pub const PNP_REPLACE_PROCESSOR_SUPPORTED: u32 = 2;
pub const PNP_REPLACE_HARDWARE_MEMORY_MIRRORING: u32 = 4;
pub const PNP_REPLACE_HARDWARE_PAGE_COPY: u32 = 8;
pub const PNP_REPLACE_HARDWARE_QUIESCE: u32 = 16;
pub const DEVICE_RESET_INTERFACE_VERSION_1: u32 = 1;
pub const DEVICE_RESET_INTERFACE_VERSION_2: u32 = 2;
pub const DEVICE_RESET_INTERFACE_VERSION_3: u32 = 3;
pub const DEVICE_RESET_INTERFACE_VERSION: u32 = 1;
pub const SECURE_DRIVER_INTERFACE_VERSION: u32 = 1;
pub const SDEV_IDENTIFIER_INTERFACE_VERSION: u32 = 1;
pub const DEVICE_DESCRIPTION_VERSION: u32 = 0;
pub const DEVICE_DESCRIPTION_VERSION1: u32 = 1;
pub const DEVICE_DESCRIPTION_VERSION2: u32 = 2;
pub const DEVICE_DESCRIPTION_VERSION3: u32 = 3;
pub const DMA_ADAPTER_INFO_VERSION1: u32 = 1;
pub const DMA_ADAPTER_INFO_VERSION_CRASHDUMP: u32 = 4294967295;
pub const ADAPTER_INFO_SYNCHRONOUS_CALLBACK: u32 = 1;
pub const ADAPTER_INFO_API_BYPASS: u32 = 2;
pub const DMA_TRANSFER_INFO_VERSION1: u32 = 1;
pub const DMA_TRANSFER_INFO_VERSION2: u32 = 2;
pub const DMA_TRANSFER_CONTEXT_VERSION1: u32 = 1;
pub const DMA_TRANSFER_CONTEXT_SIZE_V1: u32 = 128;
pub const DMA_SYNCHRONOUS_CALLBACK: u32 = 1;
pub const DMA_ZERO_BUFFERS: u32 = 2;
pub const DMA_FAIL_ON_BOUNCE: u32 = 4;
pub const HAL_MASK_UNMASK_FLAGS_NONE: u32 = 0;
pub const HAL_MASK_UNMASK_FLAGS_SERVICING_DEFERRED: u32 = 1;
pub const HAL_MASK_UNMASK_FLAGS_SERVICING_COMPLETE: u32 = 2;
pub const HAL_DMA_ADAPTER_VERSION_1: u32 = 1;
pub const DOMAIN_COMMON_BUFFER_LARGE_PAGE: u32 = 1;
pub const IOMMU_ACCESS_NONE: u32 = 0;
pub const IOMMU_ACCESS_READ: u32 = 1;
pub const IOMMU_ACCESS_WRITE: u32 = 2;
pub const DMA_IOMMU_INTERFACE_VERSION_1: u32 = 1;
pub const DMA_IOMMU_INTERFACE_VERSION: u32 = 1;
pub const DMA_IOMMU_INTERFACE_EX_VERSION_1: u32 = 1;
pub const DMA_IOMMU_INTERFACE_EX_VERSION_2: u32 = 2;
pub const DMA_IOMMU_INTERFACE_EX_VERSION_MIN: u32 = 1;
pub const DMA_IOMMU_INTERFACE_EX_VERSION_MAX: u32 = 2;
pub const DMA_IOMMU_INTERFACE_EX_VERSION: u32 = 1;
pub const PO_MEM_PRESERVE: u32 = 1;
pub const PO_MEM_CLONE: u32 = 2;
pub const PO_MEM_CL_OR_NCHK: u32 = 4;
pub const PO_MEM_DISCARD: u32 = 32768;
pub const PO_MEM_PAGE_ADDRESS: u32 = 16384;
pub const PO_MEM_BOOT_PHASE: u32 = 65536;
pub const PO_CB_SYSTEM_POWER_POLICY: u32 = 0;
pub const PO_CB_AC_STATUS: u32 = 1;
pub const PO_CB_BUTTON_COLLISION: u32 = 2;
pub const PO_CB_SYSTEM_STATE_LOCK: u32 = 3;
pub const PO_CB_LID_SWITCH_STATE: u32 = 4;
pub const PO_CB_PROCESSOR_POWER_POLICY: u32 = 5;
pub const PO_FX_VERSION_V1: u32 = 1;
pub const PO_FX_VERSION_V2: u32 = 2;
pub const PO_FX_VERSION_V3: u32 = 3;
pub const PO_FX_VERSION: u32 = 1;
pub const PO_FX_COMPONENT_FLAG_F0_ON_DX: u32 = 1;
pub const PO_FX_COMPONENT_FLAG_NO_DEBOUNCE: u32 = 2;
pub const PO_FX_DEVICE_FLAG_RESERVED_1: u32 = 1;
pub const PO_FX_DEVICE_FLAG_DFX_DIRECT_CHILDREN_OPTIONAL: u32 = 2;
pub const PO_FX_DEVICE_FLAG_DFX_POWER_CHILDREN_OPTIONAL: u32 = 4;
pub const PO_FX_DEVICE_FLAG_DFX_CHILDREN_OPTIONAL: u32 = 6;
pub const PO_FX_DEVICE_FLAG_DISABLE_FAST_RESUME: u32 = 8;
pub const PO_FX_DEVICE_FLAG_ENABLE_FAST_RESUME: u32 = 16;
pub const PO_FX_DEVICE_FLAG_NO_FAULT_CALLBACKS: u32 = 32;
pub const PO_FX_DIRECTED_FX_DEFAULT_IDLE_TIMEOUT: u32 = 0;
pub const PO_FX_DIRECTED_FX_MAX_IDLE_TIMEOUT: u32 = 600;
pub const PO_FX_UNKNOWN_POWER: u32 = 4294967295;
pub const PO_FX_UNKNOWN_TIME: i32 = -1;
pub const PO_FX_FLAG_BLOCKING: u32 = 1;
pub const PO_FX_FLAG_ASYNC_ONLY: u32 = 2;
pub const PO_FX_FLAG_PERF_PEP_OPTIONAL: u32 = 1;
pub const PO_FX_FLAG_PERF_QUERY_ON_F0: u32 = 2;
pub const PO_FX_FLAG_PERF_QUERY_ON_ALL_IDLE_STATES: u32 = 4;
pub const OB_FLT_REGISTRATION_VERSION_0100: u32 = 256;
pub const OB_FLT_REGISTRATION_VERSION: u32 = 256;
pub const OB_OPERATION_HANDLE_CREATE: u32 = 1;
pub const OB_OPERATION_HANDLE_DUPLICATE: u32 = 2;
pub const PCI_TYPE0_ADDRESSES: u32 = 6;
pub const PCI_TYPE1_ADDRESSES: u32 = 2;
pub const PCI_TYPE2_ADDRESSES: u32 = 5;
pub const PCI_EXTENDED_CONFIG_LENGTH: u32 = 4096;
pub const PCI_MAX_DEVICES: u32 = 32;
pub const PCI_MAX_FUNCTION: u32 = 8;
pub const PCI_MAX_BRIDGE_NUMBER: u32 = 255;
pub const PCI_MAX_SEGMENT_NUMBER: u32 = 65535;
pub const PCI_INVALID_VENDORID: u32 = 65535;
pub const PCI_MULTIFUNCTION: u32 = 128;
pub const PCI_DEVICE_TYPE: u32 = 0;
pub const PCI_BRIDGE_TYPE: u32 = 1;
pub const PCI_CARDBUS_BRIDGE_TYPE: u32 = 2;
pub const PCI_ENABLE_IO_SPACE: u32 = 1;
pub const PCI_ENABLE_MEMORY_SPACE: u32 = 2;
pub const PCI_ENABLE_BUS_MASTER: u32 = 4;
pub const PCI_ENABLE_SPECIAL_CYCLES: u32 = 8;
pub const PCI_ENABLE_WRITE_AND_INVALIDATE: u32 = 16;
pub const PCI_ENABLE_VGA_COMPATIBLE_PALETTE: u32 = 32;
pub const PCI_ENABLE_PARITY: u32 = 64;
pub const PCI_ENABLE_WAIT_CYCLE: u32 = 128;
pub const PCI_ENABLE_SERR: u32 = 256;
pub const PCI_ENABLE_FAST_BACK_TO_BACK: u32 = 512;
pub const PCI_DISABLE_LEVEL_INTERRUPT: u32 = 1024;
pub const PCI_STATUS_IMMEDIATE_READINESS: u32 = 1;
pub const PCI_STATUS_INTERRUPT_PENDING: u32 = 8;
pub const PCI_STATUS_CAPABILITIES_LIST: u32 = 16;
pub const PCI_STATUS_66MHZ_CAPABLE: u32 = 32;
pub const PCI_STATUS_UDF_SUPPORTED: u32 = 64;
pub const PCI_STATUS_FAST_BACK_TO_BACK: u32 = 128;
pub const PCI_STATUS_DATA_PARITY_DETECTED: u32 = 256;
pub const PCI_STATUS_DEVSEL: u32 = 1536;
pub const PCI_STATUS_SIGNALED_TARGET_ABORT: u32 = 2048;
pub const PCI_STATUS_RECEIVED_TARGET_ABORT: u32 = 4096;
pub const PCI_STATUS_RECEIVED_MASTER_ABORT: u32 = 8192;
pub const PCI_STATUS_SIGNALED_SYSTEM_ERROR: u32 = 16384;
pub const PCI_STATUS_DETECTED_PARITY_ERROR: u32 = 32768;
pub const PCI_WHICHSPACE_CONFIG: u32 = 0;
pub const PCI_WHICHSPACE_ROM: u32 = 1382638416;
pub const PCI_CAPABILITY_ID_POWER_MANAGEMENT: u32 = 1;
pub const PCI_CAPABILITY_ID_AGP: u32 = 2;
pub const PCI_CAPABILITY_ID_VPD: u32 = 3;
pub const PCI_CAPABILITY_ID_SLOT_ID: u32 = 4;
pub const PCI_CAPABILITY_ID_MSI: u32 = 5;
pub const PCI_CAPABILITY_ID_CPCI_HOTSWAP: u32 = 6;
pub const PCI_CAPABILITY_ID_PCIX: u32 = 7;
pub const PCI_CAPABILITY_ID_HYPERTRANSPORT: u32 = 8;
pub const PCI_CAPABILITY_ID_VENDOR_SPECIFIC: u32 = 9;
pub const PCI_CAPABILITY_ID_DEBUG_PORT: u32 = 10;
pub const PCI_CAPABILITY_ID_CPCI_RES_CTRL: u32 = 11;
pub const PCI_CAPABILITY_ID_SHPC: u32 = 12;
pub const PCI_CAPABILITY_ID_P2P_SSID: u32 = 13;
pub const PCI_CAPABILITY_ID_AGP_TARGET: u32 = 14;
pub const PCI_CAPABILITY_ID_SECURE: u32 = 15;
pub const PCI_CAPABILITY_ID_PCI_EXPRESS: u32 = 16;
pub const PCI_CAPABILITY_ID_MSIX: u32 = 17;
pub const PCI_CAPABILITY_ID_SATA_CONFIG: u32 = 18;
pub const PCI_CAPABILITY_ID_ADVANCED_FEATURES: u32 = 19;
pub const PCI_CAPABILITY_ID_FPB: u32 = 21;
pub const PCI_EXPRESS_ADVANCED_ERROR_REPORTING_CAP_ID: u32 = 1;
pub const PCI_EXPRESS_VIRTUAL_CHANNEL_CAP_ID: u32 = 2;
pub const PCI_EXPRESS_DEVICE_SERIAL_NUMBER_CAP_ID: u32 = 3;
pub const PCI_EXPRESS_POWER_BUDGETING_CAP_ID: u32 = 4;
pub const PCI_EXPRESS_RC_LINK_DECLARATION_CAP_ID: u32 = 5;
pub const PCI_EXPRESS_RC_INTERNAL_LINK_CONTROL_CAP_ID: u32 = 6;
pub const PCI_EXPRESS_RC_EVENT_COLLECTOR_ENDPOINT_ASSOCIATION_CAP_ID: u32 = 7;
pub const PCI_EXPRESS_MFVC_CAP_ID: u32 = 8;
pub const PCI_EXPRESS_VC_AND_MFVC_CAP_ID: u32 = 9;
pub const PCI_EXPRESS_RCRB_HEADER_CAP_ID: u32 = 10;
pub const PCI_EXPRESS_VENDOR_SPECIFIC_CAP_ID: u32 = 11;
pub const PCI_EXPRESS_CONFIGURATION_ACCESS_CORRELATION_CAP_ID: u32 = 12;
pub const PCI_EXPRESS_ACCESS_CONTROL_SERVICES_CAP_ID: u32 = 13;
pub const PCI_EXPRESS_ARI_CAP_ID: u32 = 14;
pub const PCI_EXPRESS_ATS_CAP_ID: u32 = 15;
pub const PCI_EXPRESS_SINGLE_ROOT_IO_VIRTUALIZATION_CAP_ID: u32 = 16;
pub const PCI_EXPRESS_MULTI_ROOT_IO_VIRTUALIZATION_CAP_ID: u32 = 17;
pub const PCI_EXPRESS_MULTICAST_CAP_ID: u32 = 18;
pub const PCI_EXPRESS_PAGE_REQUEST_CAP_ID: u32 = 19;
pub const PCI_EXPRESS_RESERVED_FOR_AMD_CAP_ID: u32 = 20;
pub const PCI_EXPRESS_RESIZABLE_BAR_CAP_ID: u32 = 21;
pub const PCI_EXPRESS_DPA_CAP_ID: u32 = 22;
pub const PCI_EXPRESS_TPH_REQUESTER_CAP_ID: u32 = 23;
pub const PCI_EXPRESS_LTR_CAP_ID: u32 = 24;
pub const PCI_EXPRESS_SECONDARY_PCI_EXPRESS_CAP_ID: u32 = 25;
pub const PCI_EXPRESS_PMUX_CAP_ID: u32 = 26;
pub const PCI_EXPRESS_PASID_CAP_ID: u32 = 27;
pub const PCI_EXPRESS_LN_REQUESTER_CAP_ID: u32 = 28;
pub const PCI_EXPRESS_DPC_CAP_ID: u32 = 29;
pub const PCI_EXPRESS_L1_PM_SS_CAP_ID: u32 = 30;
pub const PCI_EXPRESS_PTM_CAP_ID: u32 = 31;
pub const PCI_EXPRESS_MPCIE_CAP_ID: u32 = 32;
pub const PCI_EXPRESS_FRS_QUEUEING_CAP_ID: u32 = 33;
pub const PCI_EXPRESS_READINESS_TIME_REPORTING_CAP_ID: u32 = 34;
pub const PCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_CAP_ID: u32 = 35;
pub const PCI_EXPRESS_NPEM_CAP_ID: u32 = 41;
pub const ROOT_CMD_ENABLE_CORRECTABLE_ERROR_REPORTING: u32 = 1;
pub const ROOT_CMD_ENABLE_NONFATAL_ERROR_REPORTING: u32 = 2;
pub const ROOT_CMD_ENABLE_FATAL_ERROR_REPORTING: u32 = 4;
pub const ROOT_CMD_ERROR_REPORTING_ENABLE_MASK: u32 = 7;
pub const PCI_ACS_ALLOWED: u32 = 0;
pub const PCI_ACS_BLOCKED: u32 = 1;
pub const PCI_ACS_REDIRECTED: u32 = 2;
pub const PCI_CLASS_PRE_20: u32 = 0;
pub const PCI_CLASS_MASS_STORAGE_CTLR: u32 = 1;
pub const PCI_CLASS_NETWORK_CTLR: u32 = 2;
pub const PCI_CLASS_DISPLAY_CTLR: u32 = 3;
pub const PCI_CLASS_MULTIMEDIA_DEV: u32 = 4;
pub const PCI_CLASS_MEMORY_CTLR: u32 = 5;
pub const PCI_CLASS_BRIDGE_DEV: u32 = 6;
pub const PCI_CLASS_SIMPLE_COMMS_CTLR: u32 = 7;
pub const PCI_CLASS_BASE_SYSTEM_DEV: u32 = 8;
pub const PCI_CLASS_INPUT_DEV: u32 = 9;
pub const PCI_CLASS_DOCKING_STATION: u32 = 10;
pub const PCI_CLASS_PROCESSOR: u32 = 11;
pub const PCI_CLASS_SERIAL_BUS_CTLR: u32 = 12;
pub const PCI_CLASS_WIRELESS_CTLR: u32 = 13;
pub const PCI_CLASS_INTELLIGENT_IO_CTLR: u32 = 14;
pub const PCI_CLASS_SATELLITE_COMMS_CTLR: u32 = 15;
pub const PCI_CLASS_ENCRYPTION_DECRYPTION: u32 = 16;
pub const PCI_CLASS_DATA_ACQ_SIGNAL_PROC: u32 = 17;
pub const PCI_CLASS_NOT_DEFINED: u32 = 255;
pub const PCI_SUBCLASS_PRE_20_NON_VGA: u32 = 0;
pub const PCI_SUBCLASS_PRE_20_VGA: u32 = 1;
pub const PCI_SUBCLASS_MSC_SCSI_BUS_CTLR: u32 = 0;
pub const PCI_SUBCLASS_MSC_IDE_CTLR: u32 = 1;
pub const PCI_SUBCLASS_MSC_FLOPPY_CTLR: u32 = 2;
pub const PCI_SUBCLASS_MSC_IPI_CTLR: u32 = 3;
pub const PCI_SUBCLASS_MSC_RAID_CTLR: u32 = 4;
pub const PCI_SUBCLASS_MSC_AHCI_CTLR: u32 = 6;
pub const PCI_SUBCLASS_MSC_NVM_CTLR: u32 = 8;
pub const PCI_SUBCLASS_MSC_OTHER: u32 = 128;
pub const PCI_PROGRAMMING_INTERFACE_MSC_NVM_EXPRESS: u32 = 2;
pub const PCI_SUBCLASS_NET_ETHERNET_CTLR: u32 = 0;
pub const PCI_SUBCLASS_NET_TOKEN_RING_CTLR: u32 = 1;
pub const PCI_SUBCLASS_NET_FDDI_CTLR: u32 = 2;
pub const PCI_SUBCLASS_NET_ATM_CTLR: u32 = 3;
pub const PCI_SUBCLASS_NET_ISDN_CTLR: u32 = 4;
pub const PCI_SUBCLASS_NET_OTHER: u32 = 128;
pub const PCI_SUBCLASS_VID_VGA_CTLR: u32 = 0;
pub const PCI_SUBCLASS_VID_XGA_CTLR: u32 = 1;
pub const PCI_SUBLCASS_VID_3D_CTLR: u32 = 2;
pub const PCI_SUBCLASS_VID_OTHER: u32 = 128;
pub const PCI_SUBCLASS_MM_VIDEO_DEV: u32 = 0;
pub const PCI_SUBCLASS_MM_AUDIO_DEV: u32 = 1;
pub const PCI_SUBCLASS_MM_TELEPHONY_DEV: u32 = 2;
pub const PCI_SUBCLASS_MM_OTHER: u32 = 128;
pub const PCI_SUBCLASS_MEM_RAM: u32 = 0;
pub const PCI_SUBCLASS_MEM_FLASH: u32 = 1;
pub const PCI_SUBCLASS_MEM_OTHER: u32 = 128;
pub const PCI_SUBCLASS_BR_HOST: u32 = 0;
pub const PCI_SUBCLASS_BR_ISA: u32 = 1;
pub const PCI_SUBCLASS_BR_EISA: u32 = 2;
pub const PCI_SUBCLASS_BR_MCA: u32 = 3;
pub const PCI_SUBCLASS_BR_PCI_TO_PCI: u32 = 4;
pub const PCI_SUBCLASS_BR_PCMCIA: u32 = 5;
pub const PCI_SUBCLASS_BR_NUBUS: u32 = 6;
pub const PCI_SUBCLASS_BR_CARDBUS: u32 = 7;
pub const PCI_SUBCLASS_BR_RACEWAY: u32 = 8;
pub const PCI_SUBCLASS_BR_OTHER: u32 = 128;
pub const PCI_SUBCLASS_COM_SERIAL: u32 = 0;
pub const PCI_SUBCLASS_COM_PARALLEL: u32 = 1;
pub const PCI_SUBCLASS_COM_MULTIPORT: u32 = 2;
pub const PCI_SUBCLASS_COM_MODEM: u32 = 3;
pub const PCI_SUBCLASS_COM_OTHER: u32 = 128;
pub const PCI_SUBCLASS_SYS_INTERRUPT_CTLR: u32 = 0;
pub const PCI_SUBCLASS_SYS_DMA_CTLR: u32 = 1;
pub const PCI_SUBCLASS_SYS_SYSTEM_TIMER: u32 = 2;
pub const PCI_SUBCLASS_SYS_REAL_TIME_CLOCK: u32 = 3;
pub const PCI_SUBCLASS_SYS_GEN_HOTPLUG_CTLR: u32 = 4;
pub const PCI_SUBCLASS_SYS_SDIO_CTRL: u32 = 5;
pub const PCI_SUBCLASS_SYS_RCEC: u32 = 7;
pub const PCI_SUBCLASS_SYS_OTHER: u32 = 128;
pub const PCI_SUBCLASS_INP_KEYBOARD: u32 = 0;
pub const PCI_SUBCLASS_INP_DIGITIZER: u32 = 1;
pub const PCI_SUBCLASS_INP_MOUSE: u32 = 2;
pub const PCI_SUBCLASS_INP_SCANNER: u32 = 3;
pub const PCI_SUBCLASS_INP_GAMEPORT: u32 = 4;
pub const PCI_SUBCLASS_INP_OTHER: u32 = 128;
pub const PCI_SUBCLASS_DOC_GENERIC: u32 = 0;
pub const PCI_SUBCLASS_DOC_OTHER: u32 = 128;
pub const PCI_SUBCLASS_PROC_386: u32 = 0;
pub const PCI_SUBCLASS_PROC_486: u32 = 1;
pub const PCI_SUBCLASS_PROC_PENTIUM: u32 = 2;
pub const PCI_SUBCLASS_PROC_ALPHA: u32 = 16;
pub const PCI_SUBCLASS_PROC_POWERPC: u32 = 32;
pub const PCI_SUBCLASS_PROC_COPROCESSOR: u32 = 64;
pub const PCI_SUBCLASS_SB_IEEE1394: u32 = 0;
pub const PCI_SUBCLASS_SB_ACCESS: u32 = 1;
pub const PCI_SUBCLASS_SB_SSA: u32 = 2;
pub const PCI_SUBCLASS_SB_USB: u32 = 3;
pub const PCI_SUBCLASS_SB_FIBRE_CHANNEL: u32 = 4;
pub const PCI_SUBCLASS_SB_SMBUS: u32 = 5;
pub const PCI_SUBCLASS_SB_THUNDERBOLT: u32 = 10;
pub const PCI_SUBCLASS_WIRELESS_IRDA: u32 = 0;
pub const PCI_SUBCLASS_WIRELESS_CON_IR: u32 = 1;
pub const PCI_SUBCLASS_WIRELESS_RF: u32 = 16;
pub const PCI_SUBCLASS_WIRELESS_OTHER: u32 = 128;
pub const PCI_SUBCLASS_INTIO_I2O: u32 = 0;
pub const PCI_SUBCLASS_SAT_TV: u32 = 1;
pub const PCI_SUBCLASS_SAT_AUDIO: u32 = 2;
pub const PCI_SUBCLASS_SAT_VOICE: u32 = 3;
pub const PCI_SUBCLASS_SAT_DATA: u32 = 4;
pub const PCI_SUBCLASS_CRYPTO_NET_COMP: u32 = 0;
pub const PCI_SUBCLASS_CRYPTO_ENTERTAINMENT: u32 = 16;
pub const PCI_SUBCLASS_CRYPTO_OTHER: u32 = 128;
pub const PCI_SUBCLASS_DASP_DPIO: u32 = 0;
pub const PCI_SUBCLASS_DASP_OTHER: u32 = 128;
pub const PCI_ADDRESS_IO_SPACE: u32 = 1;
pub const PCI_ADDRESS_MEMORY_TYPE_MASK: u32 = 6;
pub const PCI_ADDRESS_MEMORY_PREFETCHABLE: u32 = 8;
pub const PCI_ADDRESS_IO_ADDRESS_MASK: u32 = 4294967292;
pub const PCI_ADDRESS_MEMORY_ADDRESS_MASK: u32 = 4294967280;
pub const PCI_ADDRESS_ROM_ADDRESS_MASK: u32 = 4294965248;
pub const PCI_TYPE_32BIT: u32 = 0;
pub const PCI_TYPE_20BIT: u32 = 2;
pub const PCI_TYPE_64BIT: u32 = 4;
pub const PCI_ROMADDRESS_ENABLED: u32 = 1;
pub const PCI_DEVICE_PRESENT_INTERFACE_VERSION: u32 = 1;
pub const PCI_USE_SUBSYSTEM_IDS: u32 = 1;
pub const PCI_USE_REVISION: u32 = 2;
pub const PCI_USE_VENDEV_IDS: u32 = 4;
pub const PCI_USE_CLASS_SUBCLASS: u32 = 8;
pub const PCI_USE_PROGIF: u32 = 16;
pub const PCI_USE_LOCAL_BUS: u32 = 32;
pub const PCI_USE_LOCAL_DEVICE: u32 = 64;
pub const PCI_EXPRESS_LINK_QUIESCENT_INTERFACE_VERSION: u32 = 1;
pub const PCI_EXPRESS_ROOT_PORT_INTERFACE_VERSION: u32 = 1;
pub const PCI_MSIX_TABLE_CONFIG_INTERFACE_VERSION: u32 = 1;
pub const FILE_ATTRIBUTE_DEDICATED: u32 = 256;
pub const EA_CONTAINER_NAME: &[u8; 14] = b"ContainerName\0";
pub const EA_CONTAINER_SIZE: &[u8; 14] = b"ContainerSize\0";
pub const CLFS_BASELOG_EXTENSION: &[u8; 5] = b".blf\0";
pub const CLFS_FLAG_NO_FLAGS: u32 = 0;
pub const CLFS_FLAG_FORCE_APPEND: u32 = 1;
pub const CLFS_FLAG_FORCE_FLUSH: u32 = 2;
pub const CLFS_FLAG_USE_RESERVATION: u32 = 4;
pub const CLFS_FLAG_REENTRANT_FILE_SYSTEM: u32 = 8;
pub const CLFS_FLAG_NON_REENTRANT_FILTER: u32 = 16;
pub const CLFS_FLAG_REENTRANT_FILTER: u32 = 32;
pub const CLFS_FLAG_IGNORE_SHARE_ACCESS: u32 = 64;
pub const CLFS_FLAG_READ_IN_PROGRESS: u32 = 128;
pub const CLFS_FLAG_MINIFILTER_LEVEL: u32 = 256;
pub const CLFS_FLAG_HIDDEN_SYSTEM_LOG: u32 = 512;
pub const CLFS_MARSHALLING_FLAG_NONE: u32 = 0;
pub const CLFS_MARSHALLING_FLAG_DISABLE_BUFF_INIT: u32 = 1;
pub const CLFS_FLAG_FILTER_INTERMEDIATE_LEVEL: u32 = 16;
pub const CLFS_FLAG_FILTER_TOP_LEVEL: u32 = 32;
pub const ClfsNullRecord: u32 = 0;
pub const ClfsDataRecord: u32 = 1;
pub const ClfsRestartRecord: u32 = 2;
pub const ClfsClientRecord: u32 = 3;
pub const CLFS_CONTAINER_STREAM_PREFIX: &[u8; 7] = b"%BLF%:\0";
pub const CLFS_CONTAINER_RELATIVE_PREFIX: &[u8; 7] = b"%BLF%\\\0";
pub const ClsContainerInitializing: u32 = 1;
pub const ClsContainerInactive: u32 = 2;
pub const ClsContainerActive: u32 = 4;
pub const ClsContainerActivePendingDelete: u32 = 8;
pub const ClsContainerPendingArchive: u32 = 16;
pub const ClsContainerPendingArchiveAndDelete: u32 = 32;
pub const ClfsContainerInitializing: u32 = 1;
pub const ClfsContainerInactive: u32 = 2;
pub const ClfsContainerActive: u32 = 4;
pub const ClfsContainerActivePendingDelete: u32 = 8;
pub const ClfsContainerPendingArchive: u32 = 16;
pub const ClfsContainerPendingArchiveAndDelete: u32 = 32;
pub const CLFS_MAX_CONTAINER_INFO: u32 = 256;
pub const CLFS_SCAN_INIT: u32 = 1;
pub const CLFS_SCAN_FORWARD: u32 = 2;
pub const CLFS_SCAN_BACKWARD: u32 = 4;
pub const CLFS_SCAN_CLOSE: u32 = 8;
pub const CLFS_SCAN_INITIALIZED: u32 = 16;
pub const CLFS_SCAN_BUFFERED: u32 = 32;
pub const CLFS_MGMT_POLICY_VERSION: u32 = 1;
pub const LOG_POLICY_OVERWRITE: u32 = 1;
pub const LOG_POLICY_PERSIST: u32 = 2;
pub const CLFS_MGMT_CLIENT_REGISTRATION_VERSION: u32 = 1;
pub const PCW_VERSION_1: u32 = 256;
pub const PCW_VERSION_2: u32 = 512;
pub const PCW_CURRENT_VERSION: u32 = 512;
pub const SECURE_SECTION_ALLOW_PARTIAL_MDL: u32 = 1;
pub type va_list = *mut core::ffi::c_char;
unsafe extern "C" {
    pub fn __va_start(arg1: *mut *mut core::ffi::c_char, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = core::ffi::c_ushort;
unsafe extern "C" {
    pub fn __security_init_cookie();
}
unsafe extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
unsafe extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
unsafe extern "C" {
    pub static mut __security_cookie: usize;
}
pub const _EXCEPTION_DISPOSITION_ExceptionContinueExecution: _EXCEPTION_DISPOSITION = 0;
pub const _EXCEPTION_DISPOSITION_ExceptionContinueSearch: _EXCEPTION_DISPOSITION = 1;
pub const _EXCEPTION_DISPOSITION_ExceptionNestedException: _EXCEPTION_DISPOSITION = 2;
pub const _EXCEPTION_DISPOSITION_ExceptionCollidedUnwind: _EXCEPTION_DISPOSITION = 3;
pub type _EXCEPTION_DISPOSITION = core::ffi::c_int;

use alloc::vec::Vec;
pub use self::_EXCEPTION_DISPOSITION as EXCEPTION_DISPOSITION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CONTEXT {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_CONTEXT {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn __C_specific_handler(
        ExceptionRecord: *mut _EXCEPTION_RECORD,
        EstablisherFrame: *mut core::ffi::c_void,
        ContextRecord: *mut _CONTEXT,
        DispatcherContext: *mut _DISPATCHER_CONTEXT,
    ) -> EXCEPTION_DISPOSITION;
}
unsafe extern "C" {
    pub fn _exception_code() -> core::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn _exception_info() -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn _abnormal_termination() -> core::ffi::c_int;
}
pub type __crt_bool = bool;
unsafe extern "C" {
    pub fn _invalid_parameter_noinfo();
}
unsafe extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn() -> !;
}
unsafe extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: core::ffi::c_uint,
        _Reserved: usize,
    ) -> !;
}
pub type errno_t = core::ffi::c_int;
pub type wint_t = core::ffi::c_ushort;
pub type wctype_t = core::ffi::c_ushort;
pub type __time32_t = core::ffi::c_long;
pub type __time64_t = core::ffi::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const core::ffi::c_ushort,
    pub _locale_mb_cur_max: core::ffi::c_int,
    pub _locale_lc_codepage: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: core::ffi::c_ulong,
    pub _Byte: core::ffi::c_ushort,
    pub _State: core::ffi::c_ushort,
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
unsafe extern "C" {
    pub fn iswalnum(_C: wint_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn iswalpha(_C: wint_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn iswascii(_C: wint_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn iswblank(_C: wint_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn iswcntrl(_C: wint_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn iswdigit(_C: wint_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn iswgraph(_C: wint_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn iswlower(_C: wint_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn iswprint(_C: wint_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn iswpunct(_C: wint_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn iswspace(_C: wint_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn iswupper(_C: wint_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn iswxdigit(_C: wint_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __iswcsymf(_C: wint_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __iswcsym(_C: wint_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _iswalnum_l(_C: wint_t, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _iswalpha_l(_C: wint_t, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _iswblank_l(_C: wint_t, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _iswcntrl_l(_C: wint_t, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _iswdigit_l(_C: wint_t, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _iswgraph_l(_C: wint_t, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _iswlower_l(_C: wint_t, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _iswprint_l(_C: wint_t, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _iswpunct_l(_C: wint_t, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _iswspace_l(_C: wint_t, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _iswupper_l(_C: wint_t, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _iswxdigit_l(_C: wint_t, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _iswcsymf_l(_C: wint_t, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _iswcsym_l(_C: wint_t, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn towupper(_C: wint_t) -> wint_t;
}
unsafe extern "C" {
    pub fn towlower(_C: wint_t) -> wint_t;
}
unsafe extern "C" {
    pub fn iswctype(_C: wint_t, _Type: wctype_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _towupper_l(_C: wint_t, _Locale: _locale_t) -> wint_t;
}
unsafe extern "C" {
    pub fn _towlower_l(_C: wint_t, _Locale: _locale_t) -> wint_t;
}
unsafe extern "C" {
    pub fn _iswctype_l(_C: wint_t, _Type: wctype_t, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn isleadbyte(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _isleadbyte_l(_C: core::ffi::c_int, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn is_wctype(_C: wint_t, _Type: wctype_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _isctype(_C: core::ffi::c_int, _Type: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _isctype_l(
        _C: core::ffi::c_int,
        _Type: core::ffi::c_int,
        _Locale: _locale_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn isalpha(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _isalpha_l(_C: core::ffi::c_int, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn isupper(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _isupper_l(_C: core::ffi::c_int, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn islower(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _islower_l(_C: core::ffi::c_int, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn isdigit(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _isdigit_l(_C: core::ffi::c_int, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn isxdigit(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _isxdigit_l(_C: core::ffi::c_int, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn isspace(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _isspace_l(_C: core::ffi::c_int, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn ispunct(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _ispunct_l(_C: core::ffi::c_int, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn isblank(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _isblank_l(_C: core::ffi::c_int, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn isalnum(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _isalnum_l(_C: core::ffi::c_int, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn isprint(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _isprint_l(_C: core::ffi::c_int, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn isgraph(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _isgraph_l(_C: core::ffi::c_int, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn iscntrl(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _iscntrl_l(_C: core::ffi::c_int, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn toupper(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn tolower(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _tolower(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _tolower_l(_C: core::ffi::c_int, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _toupper(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _toupper_l(_C: core::ffi::c_int, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __isascii(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __toascii(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __iscsymf(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __iscsym(_C: core::ffi::c_int) -> core::ffi::c_int;
}
pub type POINTER_64_INT = core::ffi::c_ulonglong;
pub type INT8 = core::ffi::c_schar;
pub type PINT8 = *mut core::ffi::c_schar;
pub type INT16 = core::ffi::c_short;
pub type PINT16 = *mut core::ffi::c_short;
pub type INT32 = core::ffi::c_int;
pub type PINT32 = *mut core::ffi::c_int;
pub type INT64 = core::ffi::c_longlong;
pub type PINT64 = *mut core::ffi::c_longlong;
pub type UINT8 = core::ffi::c_uchar;
pub type PUINT8 = *mut core::ffi::c_uchar;
pub type UINT16 = core::ffi::c_ushort;
pub type PUINT16 = *mut core::ffi::c_ushort;
pub type UINT32 = core::ffi::c_uint;
pub type PUINT32 = *mut core::ffi::c_uint;
pub type UINT64 = core::ffi::c_ulonglong;
pub type PUINT64 = *mut core::ffi::c_ulonglong;
pub type LONG32 = core::ffi::c_int;
pub type PLONG32 = *mut core::ffi::c_int;
pub type ULONG32 = core::ffi::c_uint;
pub type PULONG32 = *mut core::ffi::c_uint;
pub type DWORD32 = core::ffi::c_uint;
pub type PDWORD32 = *mut core::ffi::c_uint;
pub type INT_PTR = core::ffi::c_longlong;
pub type PINT_PTR = *mut core::ffi::c_longlong;
pub type UINT_PTR = core::ffi::c_ulonglong;
pub type PUINT_PTR = *mut core::ffi::c_ulonglong;
pub type LONG_PTR = core::ffi::c_longlong;
pub type PLONG_PTR = *mut core::ffi::c_longlong;
pub type ULONG_PTR = core::ffi::c_ulonglong;
pub type PULONG_PTR = *mut core::ffi::c_ulonglong;
pub type PHANDLE64 = *mut *mut core::ffi::c_void;
pub type SHANDLE_PTR = core::ffi::c_longlong;
pub type HANDLE_PTR = core::ffi::c_ulonglong;
pub type UHALF_PTR = core::ffi::c_uint;
pub type PUHALF_PTR = *mut core::ffi::c_uint;
pub type HALF_PTR = core::ffi::c_int;
pub type PHALF_PTR = *mut core::ffi::c_int;
pub type SIZE_T = ULONG_PTR;
pub type PSIZE_T = *mut ULONG_PTR;
pub type SSIZE_T = LONG_PTR;
pub type PSSIZE_T = *mut LONG_PTR;
pub type DWORD_PTR = ULONG_PTR;
pub type PDWORD_PTR = *mut ULONG_PTR;
pub type LONG64 = core::ffi::c_longlong;
pub type PLONG64 = *mut core::ffi::c_longlong;
pub type ULONG64 = core::ffi::c_ulonglong;
pub type PULONG64 = *mut core::ffi::c_ulonglong;
pub type DWORD64 = core::ffi::c_ulonglong;
pub type PDWORD64 = *mut core::ffi::c_ulonglong;
pub type KAFFINITY = ULONG_PTR;
pub type PKAFFINITY = *mut KAFFINITY;
pub type PVOID = *mut core::ffi::c_void;
pub type CHAR = core::ffi::c_char;
pub type SHORT = core::ffi::c_short;
pub type LONG = core::ffi::c_long;
pub type INT = core::ffi::c_int;
pub type WCHAR = wchar_t;
pub type PWCHAR = *mut WCHAR;
pub type LPWCH = *mut WCHAR;
pub type PWCH = *mut WCHAR;
pub type LPCWCH = *const WCHAR;
pub type PCWCH = *const WCHAR;
pub type NWPSTR = *mut WCHAR;
pub type LPWSTR = *mut WCHAR;
pub type PWSTR = *mut WCHAR;
pub type PZPWSTR = *mut PWSTR;
pub type PCZPWSTR = *const PWSTR;
pub type LPUWSTR = *mut WCHAR;
pub type PUWSTR = *mut WCHAR;
pub type LPCWSTR = *const WCHAR;
pub type PCWSTR = *const WCHAR;
pub type PZPCWSTR = *mut PCWSTR;
pub type PCZPCWSTR = *const PCWSTR;
pub type LPCUWSTR = *const WCHAR;
pub type PCUWSTR = *const WCHAR;
pub type PZZWSTR = *mut WCHAR;
pub type PCZZWSTR = *const WCHAR;
pub type PUZZWSTR = *mut WCHAR;
pub type PCUZZWSTR = *const WCHAR;
pub type PNZWCH = *mut WCHAR;
pub type PCNZWCH = *const WCHAR;
pub type PUNZWCH = *mut WCHAR;
pub type PCUNZWCH = *const WCHAR;
pub type LPCWCHAR = *const WCHAR;
pub type PCWCHAR = *const WCHAR;
pub type LPCUWCHAR = *const WCHAR;
pub type PCUWCHAR = *const WCHAR;
pub type UCSCHAR = core::ffi::c_ulong;
pub type PUCSCHAR = *mut UCSCHAR;
pub type PCUCSCHAR = *const UCSCHAR;
pub type PUCSSTR = *mut UCSCHAR;
pub type PUUCSSTR = *mut UCSCHAR;
pub type PCUCSSTR = *const UCSCHAR;
pub type PCUUCSSTR = *const UCSCHAR;
pub type PUUCSCHAR = *mut UCSCHAR;
pub type PCUUCSCHAR = *const UCSCHAR;
pub type PCHAR = *mut CHAR;
pub type LPCH = *mut CHAR;
pub type PCH = *mut CHAR;
pub type LPCCH = *const CHAR;
pub type PCCH = *const CHAR;
pub type NPSTR = *mut CHAR;
pub type LPSTR = *mut CHAR;
pub type PSTR = *mut CHAR;
pub type PZPSTR = *mut PSTR;
pub type PCZPSTR = *const PSTR;
pub type LPCSTR = *const CHAR;
pub type PCSTR = *const CHAR;
pub type PZPCSTR = *mut PCSTR;
pub type PCZPCSTR = *const PCSTR;
pub type PZZSTR = *mut CHAR;
pub type PCZZSTR = *const CHAR;
pub type PNZCH = *mut CHAR;
pub type PCNZCH = *const CHAR;
pub type TCHAR = core::ffi::c_char;
pub type PTCHAR = *mut core::ffi::c_char;
pub type TUCHAR = core::ffi::c_uchar;
pub type PTUCHAR = *mut core::ffi::c_uchar;
pub type LPTCH = LPCH;
pub type PTCH = LPCH;
pub type LPCTCH = LPCCH;
pub type PCTCH = LPCCH;
pub type PTSTR = LPSTR;
pub type LPTSTR = LPSTR;
pub type PUTSTR = LPSTR;
pub type LPUTSTR = LPSTR;
pub type PCTSTR = LPCSTR;
pub type LPCTSTR = LPCSTR;
pub type PCUTSTR = LPCSTR;
pub type LPCUTSTR = LPCSTR;
pub type PZZTSTR = PZZSTR;
pub type PUZZTSTR = PZZSTR;
pub type PCZZTSTR = PCZZSTR;
pub type PCUZZTSTR = PCZZSTR;
pub type PZPTSTR = PZPSTR;
pub type PNZTCH = PNZCH;
pub type PUNZTCH = PNZCH;
pub type PCNZTCH = PCNZCH;
pub type PCUNZTCH = PCNZCH;
pub type DOUBLE = f64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _QUAD {
    pub __bindgen_anon_1: _QUAD__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _QUAD__bindgen_ty_1 {
    pub UseThisFieldToCopy: core::ffi::c_longlong,
    pub DoNotUseThisField: f64,
}
pub type QUAD = _QUAD;
pub type PSHORT = *mut SHORT;
pub type PLONG = *mut LONG;
pub type PQUAD = *mut QUAD;
pub type UCHAR = core::ffi::c_uchar;
pub type USHORT = core::ffi::c_ushort;
pub type ULONG = core::ffi::c_ulong;
pub type UQUAD = QUAD;
pub type PUCHAR = *mut UCHAR;
pub type PUSHORT = *mut USHORT;
pub type PULONG = *mut ULONG;
pub type PUQUAD = *mut UQUAD;
pub type PCUCHAR = *const UCHAR;
pub type PCUSHORT = *const USHORT;
pub type PCULONG = *const ULONG;
pub type PCUQUAD = *const UQUAD;
pub type SCHAR = core::ffi::c_schar;
pub type PSCHAR = *mut SCHAR;
pub type PCSCHAR = *const SCHAR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESSOR_NUMBER {
    pub Group: USHORT,
    pub Number: UCHAR,
    pub Reserved: UCHAR,
}
pub type PROCESSOR_NUMBER = _PROCESSOR_NUMBER;
pub type PPROCESSOR_NUMBER = *mut _PROCESSOR_NUMBER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GROUP_AFFINITY {
    pub Mask: KAFFINITY,
    pub Group: USHORT,
    pub Reserved: [USHORT; 3usize],
}
pub type GROUP_AFFINITY = _GROUP_AFFINITY;
pub type PGROUP_AFFINITY = *mut _GROUP_AFFINITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GROUP_AFFINITY32 {
    pub Mask: ULONG,
    pub Group: USHORT,
    pub Reserved: [USHORT; 3usize],
}
pub type GROUP_AFFINITY32 = _GROUP_AFFINITY32;
pub type PGROUP_AFFINITY32 = *mut _GROUP_AFFINITY32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GROUP_AFFINITY64 {
    pub Mask: core::ffi::c_ulonglong,
    pub Group: USHORT,
    pub Reserved: [USHORT; 3usize],
}
pub type GROUP_AFFINITY64 = _GROUP_AFFINITY64;
pub type PGROUP_AFFINITY64 = *mut _GROUP_AFFINITY64;
pub type HANDLE = *mut core::ffi::c_void;
pub type PHANDLE = *mut HANDLE;
pub type FCHAR = UCHAR;
pub type FSHORT = USHORT;
pub type FLONG = ULONG;
pub type HRESULT = core::ffi::c_long;
pub type CCHAR = core::ffi::c_char;
pub type CSHORT = core::ffi::c_short;
pub type CLONG = ULONG;
pub type PCCHAR = *mut CCHAR;
pub type PCSHORT = *mut CSHORT;
pub type PCLONG = *mut CLONG;
pub type LCID = ULONG;
pub type PLCID = PULONG;
pub type LANGID = USHORT;
pub const COMPARTMENT_ID_UNSPECIFIED_COMPARTMENT_ID: COMPARTMENT_ID = 0;
pub const COMPARTMENT_ID_DEFAULT_COMPARTMENT_ID: COMPARTMENT_ID = 1;
pub type COMPARTMENT_ID = core::ffi::c_int;
pub type PCOMPARTMENT_ID = *mut COMPARTMENT_ID;
pub type LOGICAL = ULONG;
pub type PLOGICAL = *mut ULONG;
pub type NTSTATUS = LONG;
pub type PNTSTATUS = *mut NTSTATUS;
pub type PCNTSTATUS = *const NTSTATUS;
pub type SECURITY_STATUS = core::ffi::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLOAT128 {
    pub LowPart: core::ffi::c_longlong,
    pub HighPart: core::ffi::c_longlong,
}
pub type FLOAT128 = _FLOAT128;
pub type PFLOAT128 = *mut FLOAT128;
pub type LONGLONG = core::ffi::c_longlong;
pub type ULONGLONG = core::ffi::c_ulonglong;
pub type PLONGLONG = *mut LONGLONG;
pub type PULONGLONG = *mut ULONGLONG;
pub type USN = LONGLONG;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LARGE_INTEGER {
    pub __bindgen_anon_1: _LARGE_INTEGER__bindgen_ty_1,
    pub u: _LARGE_INTEGER__bindgen_ty_2,
    pub QuadPart: LONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_1 {
    pub LowPart: ULONG,
    pub HighPart: LONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_2 {
    pub LowPart: ULONG,
    pub HighPart: LONG,
}
pub type LARGE_INTEGER = _LARGE_INTEGER;
pub type PLARGE_INTEGER = *mut LARGE_INTEGER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ULARGE_INTEGER {
    pub __bindgen_anon_1: _ULARGE_INTEGER__bindgen_ty_1,
    pub u: _ULARGE_INTEGER__bindgen_ty_2,
    pub QuadPart: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_1 {
    pub LowPart: ULONG,
    pub HighPart: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_2 {
    pub LowPart: ULONG,
    pub HighPart: ULONG,
}
pub type ULARGE_INTEGER = _ULARGE_INTEGER;
pub type PULARGE_INTEGER = *mut ULARGE_INTEGER;
pub type RTL_REFERENCE_COUNT = LONG_PTR;
pub type PRTL_REFERENCE_COUNT = *mut LONG_PTR;
pub type RTL_REFERENCE_COUNT32 = LONG;
pub type PRTL_REFERENCE_COUNT32 = *mut LONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LUID {
    pub LowPart: ULONG,
    pub HighPart: LONG,
}
pub type LUID = _LUID;
pub type PLUID = *mut _LUID;
pub type DWORDLONG = ULONGLONG;
pub type PDWORDLONG = *mut DWORDLONG;
pub type PHYSICAL_ADDRESS = LARGE_INTEGER;
pub type PPHYSICAL_ADDRESS = *mut LARGE_INTEGER;
unsafe extern "C" {
    pub fn _rotl8(Value: core::ffi::c_uchar, Shift: core::ffi::c_uchar) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _rotl16(Value: core::ffi::c_ushort, Shift: core::ffi::c_uchar) -> core::ffi::c_ushort;
}
unsafe extern "C" {
    pub fn _rotr8(Value: core::ffi::c_uchar, Shift: core::ffi::c_uchar) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _rotr16(Value: core::ffi::c_ushort, Shift: core::ffi::c_uchar) -> core::ffi::c_ushort;
}
unsafe extern "C" {
    pub fn _rotl(Value: core::ffi::c_uint, Shift: core::ffi::c_int) -> core::ffi::c_uint;
}
unsafe extern "C" {
    pub fn _rotl64(
        Value: core::ffi::c_ulonglong,
        Shift: core::ffi::c_int,
    ) -> core::ffi::c_ulonglong;
}
unsafe extern "C" {
    pub fn _rotr(Value: core::ffi::c_uint, Shift: core::ffi::c_int) -> core::ffi::c_uint;
}
unsafe extern "C" {
    pub fn _rotr64(
        Value: core::ffi::c_ulonglong,
        Shift: core::ffi::c_int,
    ) -> core::ffi::c_ulonglong;
}
pub const _EVENT_TYPE_NotificationEvent: _EVENT_TYPE = 0;
pub const _EVENT_TYPE_SynchronizationEvent: _EVENT_TYPE = 1;
pub type _EVENT_TYPE = core::ffi::c_int;
pub use self::_EVENT_TYPE as EVENT_TYPE;
pub const _TIMER_TYPE_NotificationTimer: _TIMER_TYPE = 0;
pub const _TIMER_TYPE_SynchronizationTimer: _TIMER_TYPE = 1;
pub type _TIMER_TYPE = core::ffi::c_int;
pub use self::_TIMER_TYPE as TIMER_TYPE;
pub const _WAIT_TYPE_WaitAll: _WAIT_TYPE = 0;
pub const _WAIT_TYPE_WaitAny: _WAIT_TYPE = 1;
pub const _WAIT_TYPE_WaitNotification: _WAIT_TYPE = 2;
pub const _WAIT_TYPE_WaitDequeue: _WAIT_TYPE = 3;
pub const _WAIT_TYPE_WaitDpc: _WAIT_TYPE = 4;
pub type _WAIT_TYPE = core::ffi::c_int;
pub use self::_WAIT_TYPE as WAIT_TYPE;
pub type PSZ = *mut CHAR;
pub type PCSZ = *const core::ffi::c_char;
pub type RTL_STRING_LENGTH_TYPE = USHORT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STRING {
    pub Length: USHORT,
    pub MaximumLength: USHORT,
    pub Buffer: PCHAR,
}
pub type STRING = _STRING;
pub type PSTRING = *mut STRING;
pub type ANSI_STRING = STRING;
pub type PANSI_STRING = PSTRING;
pub type OEM_STRING = STRING;
pub type POEM_STRING = PSTRING;
pub type PCOEM_STRING = *const STRING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CSTRING {
    pub Length: USHORT,
    pub MaximumLength: USHORT,
    pub Buffer: *const core::ffi::c_char,
}
pub type CSTRING = _CSTRING;
pub type PCSTRING = *mut CSTRING;
pub type CANSI_STRING = STRING;
pub type PCANSI_STRING = PSTRING;
pub type UTF8_STRING = STRING;
pub type PUTF8_STRING = PSTRING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UNICODE_STRING {
    pub Length: USHORT,
    pub MaximumLength: USHORT,
    pub Buffer: PWCH,
}

impl _UNICODE_STRING {
    pub fn from_str(s: &str) -> Self {
        let mut wide: Vec<u16> = s.encode_utf16().chain(Some(0)).collect();

        let length = ((wide.len() - 1) * 2) as u16;
        let max_length = (wide.len() * 2) as u16;

        let buffer = wide.as_mut_ptr();
        core::mem::forget(wide);

        Self {
            Length: length,
            MaximumLength: max_length,
            Buffer: buffer,
        }
    }
}

pub type UNICODE_STRING = _UNICODE_STRING;
pub type PUNICODE_STRING = *mut UNICODE_STRING;
pub type PCUNICODE_STRING = *const UNICODE_STRING;
pub type BOOLEAN = UCHAR;
pub type PBOOLEAN = *mut BOOLEAN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LIST_ENTRY {
    pub Flink: *mut _LIST_ENTRY,
    pub Blink: *mut _LIST_ENTRY,
}
pub type LIST_ENTRY = _LIST_ENTRY;
pub type PLIST_ENTRY = *mut _LIST_ENTRY;
pub type PRLIST_ENTRY = *mut _LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SINGLE_LIST_ENTRY {
    pub Next: *mut _SINGLE_LIST_ENTRY,
}
pub type SINGLE_LIST_ENTRY = _SINGLE_LIST_ENTRY;
pub type PSINGLE_LIST_ENTRY = *mut _SINGLE_LIST_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_BALANCED_NODE {
    pub __bindgen_anon_1: _RTL_BALANCED_NODE__bindgen_ty_1,
    pub __bindgen_anon_2: _RTL_BALANCED_NODE__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_BALANCED_NODE__bindgen_ty_1 {
    pub Children: [*mut _RTL_BALANCED_NODE; 2usize],
    pub __bindgen_anon_1: _RTL_BALANCED_NODE__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_BALANCED_NODE__bindgen_ty_1__bindgen_ty_1 {
    pub Left: *mut _RTL_BALANCED_NODE,
    pub Right: *mut _RTL_BALANCED_NODE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_BALANCED_NODE__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub ParentValue: ULONG_PTR,
}
impl _RTL_BALANCED_NODE__bindgen_ty_2 {
    #[inline]
    pub fn Red(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Red(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Red_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Red_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Balance(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Balance(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Balance_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Balance_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(Red: UCHAR, Balance: UCHAR) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Red: u8 = unsafe { ::core::mem::transmute(Red) };
            Red as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let Balance: u8 = unsafe { ::core::mem::transmute(Balance) };
            Balance as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type RTL_BALANCED_NODE = _RTL_BALANCED_NODE;
pub type PRTL_BALANCED_NODE = *mut _RTL_BALANCED_NODE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LIST_ENTRY32 {
    pub Flink: ULONG,
    pub Blink: ULONG,
}
pub type PLIST_ENTRY32 = *mut LIST_ENTRY32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LIST_ENTRY64 {
    pub Flink: ULONGLONG,
    pub Blink: ULONGLONG,
}
pub type PLIST_ENTRY64 = *mut LIST_ENTRY64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SINGLE_LIST_ENTRY32 {
    pub Next: ULONG,
}
pub type SINGLE_LIST_ENTRY32 = _SINGLE_LIST_ENTRY32;
pub type PSINGLE_LIST_ENTRY32 = *mut _SINGLE_LIST_ENTRY32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WNF_STATE_NAME {
    pub Data: [ULONG; 2usize],
}
pub type WNF_STATE_NAME = _WNF_STATE_NAME;
pub type PWNF_STATE_NAME = *mut _WNF_STATE_NAME;
pub type PCWNF_STATE_NAME = *const _WNF_STATE_NAME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STRING32 {
    pub Length: USHORT,
    pub MaximumLength: USHORT,
    pub Buffer: ULONG,
}
pub type STRING32 = _STRING32;
pub type PSTRING32 = *mut STRING32;
pub type UNICODE_STRING32 = STRING32;
pub type PUNICODE_STRING32 = *mut UNICODE_STRING32;
pub type ANSI_STRING32 = STRING32;
pub type PANSI_STRING32 = *mut ANSI_STRING32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STRING64 {
    pub Length: USHORT,
    pub MaximumLength: USHORT,
    pub Buffer: ULONGLONG,
}
pub type STRING64 = _STRING64;
pub type PSTRING64 = *mut STRING64;
pub type UNICODE_STRING64 = STRING64;
pub type PUNICODE_STRING64 = *mut UNICODE_STRING64;
pub type ANSI_STRING64 = STRING64;
pub type PANSI_STRING64 = *mut ANSI_STRING64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_ATTRIBUTES64 {
    pub Length: ULONG,
    pub RootDirectory: ULONG64,
    pub ObjectName: ULONG64,
    pub Attributes: ULONG,
    pub SecurityDescriptor: ULONG64,
    pub SecurityQualityOfService: ULONG64,
}
pub type OBJECT_ATTRIBUTES64 = _OBJECT_ATTRIBUTES64;
pub type POBJECT_ATTRIBUTES64 = *mut OBJECT_ATTRIBUTES64;
pub type PCOBJECT_ATTRIBUTES64 = *const OBJECT_ATTRIBUTES64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_ATTRIBUTES32 {
    pub Length: ULONG,
    pub RootDirectory: ULONG,
    pub ObjectName: ULONG,
    pub Attributes: ULONG,
    pub SecurityDescriptor: ULONG,
    pub SecurityQualityOfService: ULONG,
}
pub type OBJECT_ATTRIBUTES32 = _OBJECT_ATTRIBUTES32;
pub type POBJECT_ATTRIBUTES32 = *mut OBJECT_ATTRIBUTES32;
pub type PCOBJECT_ATTRIBUTES32 = *const OBJECT_ATTRIBUTES32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_ATTRIBUTES {
    pub Length: ULONG,
    pub RootDirectory: HANDLE,
    pub ObjectName: PUNICODE_STRING,
    pub Attributes: ULONG,
    pub SecurityDescriptor: PVOID,
    pub SecurityQualityOfService: PVOID,
}
pub type OBJECT_ATTRIBUTES = _OBJECT_ATTRIBUTES;
pub type POBJECT_ATTRIBUTES = *mut OBJECT_ATTRIBUTES;
pub type PCOBJECT_ATTRIBUTES = *const OBJECT_ATTRIBUTES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUID {
    pub Data1: core::ffi::c_ulong,
    pub Data2: core::ffi::c_ushort,
    pub Data3: core::ffi::c_ushort,
    pub Data4: [core::ffi::c_uchar; 8usize],
}
pub type GUID = _GUID;
pub type LPGUID = *mut GUID;
pub type LPCGUID = *const GUID;
pub type IID = GUID;
pub type LPIID = *mut IID;
pub type CLSID = GUID;
pub type LPCLSID = *mut CLSID;
pub type FMTID = GUID;
pub type LPFMTID = *mut FMTID;
unsafe extern "C" {
    pub fn _errno() -> *mut core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _set_errno(_Value: core::ffi::c_int) -> errno_t;
}
unsafe extern "C" {
    pub fn _get_errno(_Value: *mut core::ffi::c_int) -> errno_t;
}
unsafe extern "C" {
    pub fn __doserrno() -> *mut core::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn _set_doserrno(_Value: core::ffi::c_ulong) -> errno_t;
}
unsafe extern "C" {
    pub fn _get_doserrno(_Value: *mut core::ffi::c_ulong) -> errno_t;
}
unsafe extern "C" {
    pub fn memchr(
        _Buf: *const core::ffi::c_void,
        _Val: core::ffi::c_int,
        _MaxCount: core::ffi::c_ulonglong,
    ) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn memcmp(
        _Buf1: *const core::ffi::c_void,
        _Buf2: *const core::ffi::c_void,
        _Size: core::ffi::c_ulonglong,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn memcpy(
        _Dst: *mut core::ffi::c_void,
        _Src: *const core::ffi::c_void,
        _Size: core::ffi::c_ulonglong,
    ) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn memmove(
        _Dst: *mut core::ffi::c_void,
        _Src: *const core::ffi::c_void,
        _Size: core::ffi::c_ulonglong,
    ) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn memset(
        _Dst: *mut core::ffi::c_void,
        _Val: core::ffi::c_int,
        _Size: core::ffi::c_ulonglong,
    ) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn strchr(_Str: *const core::ffi::c_char, _Val: core::ffi::c_int)
                  -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strrchr(_Str: *const core::ffi::c_char, _Ch: core::ffi::c_int)
                   -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strstr(
        _Str: *const core::ffi::c_char,
        _SubStr: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn wcschr(
        _Str: *const core::ffi::c_ushort,
        _Ch: core::ffi::c_ushort,
    ) -> *mut core::ffi::c_ushort;
}
unsafe extern "C" {
    pub fn wcsrchr(_Str: *const wchar_t, _Ch: wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcsstr(_Str: *const wchar_t, _SubStr: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn _memicmp(
        _Buf1: *const core::ffi::c_void,
        _Buf2: *const core::ffi::c_void,
        _Size: usize,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _memicmp_l(
        _Buf1: *const core::ffi::c_void,
        _Buf2: *const core::ffi::c_void,
        _Size: usize,
        _Locale: _locale_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn memccpy(
        _Dst: *mut core::ffi::c_void,
        _Src: *const core::ffi::c_void,
        _Val: core::ffi::c_int,
        _Size: core::ffi::c_ulonglong,
    ) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn memicmp(
        _Buf1: *const core::ffi::c_void,
        _Buf2: *const core::ffi::c_void,
        _Size: usize,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wcscat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn wcscpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn wcsncat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn wcsncpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn wcstok_s(
        _String: *mut wchar_t,
        _Delimiter: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn _wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcscat(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcscmp(
        _String1: *const core::ffi::c_ushort,
        _String2: *const core::ffi::c_ushort,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wcscpy(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcscspn(_String: *const wchar_t, _Control: *const wchar_t) -> usize;
}
unsafe extern "C" {
    pub fn wcslen(_String: *const core::ffi::c_ushort) -> core::ffi::c_ulonglong;
}
unsafe extern "C" {
    pub fn wcsnlen(_Source: *const wchar_t, _MaxCount: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcsncat(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: usize,
    ) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcsncmp(
        _String1: *const core::ffi::c_ushort,
        _String2: *const core::ffi::c_ushort,
        _MaxCount: core::ffi::c_ulonglong,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wcsncpy(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: usize,
    ) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcspbrk(_String: *const wchar_t, _Control: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcsspn(_String: *const wchar_t, _Control: *const wchar_t) -> usize;
}
unsafe extern "C" {
    pub fn wcstok(
        _String: *mut wchar_t,
        _Delimiter: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn _wcserror(_ErrorNumber: core::ffi::c_int) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn _wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _ErrorNumber: core::ffi::c_int,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn __wcserror(_String: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn __wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _ErrorMessage: *const wchar_t,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn _wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _wcsicmp_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _wcsnicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _wcsnicmp_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _wcsnset_s(
        _Destination: *mut wchar_t,
        _SizeInWords: usize,
        _Value: wchar_t,
        _MaxCount: usize,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn _wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: usize) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn _wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn _wcsset_s(_Destination: *mut wchar_t, _SizeInWords: usize, _Value: wchar_t) -> errno_t;
}
unsafe extern "C" {
    pub fn _wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn _wcslwr_s(_String: *mut wchar_t, _SizeInWords: usize) -> errno_t;
}
unsafe extern "C" {
    pub fn _wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn _wcslwr_s_l(_String: *mut wchar_t, _SizeInWords: usize, _Locale: _locale_t) -> errno_t;
}
unsafe extern "C" {
    pub fn _wcslwr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn _wcsupr_s(_String: *mut wchar_t, _Size: usize) -> errno_t;
}
unsafe extern "C" {
    pub fn _wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn _wcsupr_s_l(_String: *mut wchar_t, _Size: usize, _Locale: _locale_t) -> errno_t;
}
unsafe extern "C" {
    pub fn _wcsupr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcsxfrm(_Destination: *mut wchar_t, _Source: *const wchar_t, _MaxCount: usize) -> usize;
}
unsafe extern "C" {
    pub fn _wcsxfrm_l(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn wcscoll(_String1: *const wchar_t, _String2: *const wchar_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _wcscoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _wcsicoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _wcsncoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _wcsncoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _wcsnicoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _wcsnicoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wcsnicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: usize) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn strcpy_s(
        _Destination: *mut core::ffi::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const core::ffi::c_char,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn strcat_s(
        _Destination: *mut core::ffi::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const core::ffi::c_char,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn strerror_s(
        _Buffer: *mut core::ffi::c_char,
        _SizeInBytes: usize,
        _ErrorNumber: core::ffi::c_int,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn strncat_s(
        _Destination: *mut core::ffi::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const core::ffi::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn strncpy_s(
        _Destination: *mut core::ffi::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const core::ffi::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn strtok_s(
        _String: *mut core::ffi::c_char,
        _Delimiter: *const core::ffi::c_char,
        _Context: *mut *mut core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _memccpy(
        _Dst: *mut core::ffi::c_void,
        _Src: *const core::ffi::c_void,
        _Val: core::ffi::c_int,
        _MaxCount: usize,
    ) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn strcat(
        _Destination: *mut core::ffi::c_char,
        _Source: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strcmp(
        _Str1: *const core::ffi::c_char,
        _Str2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _strcmpi(
        _String1: *const core::ffi::c_char,
        _String2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn strcoll(
        _String1: *const core::ffi::c_char,
        _String2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _strcoll_l(
        _String1: *const core::ffi::c_char,
        _String2: *const core::ffi::c_char,
        _Locale: _locale_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn strcpy(
        _Destination: *mut core::ffi::c_char,
        _Source: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strcspn(
        _Str: *const core::ffi::c_char,
        _Control: *const core::ffi::c_char,
    ) -> core::ffi::c_ulonglong;
}
unsafe extern "C" {
    pub fn _strdup(_Source: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _strerror(_ErrorMessage: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _strerror_s(
        _Buffer: *mut core::ffi::c_char,
        _SizeInBytes: usize,
        _ErrorMessage: *const core::ffi::c_char,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn strerror(_ErrorMessage: core::ffi::c_int) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _stricmp(
        _String1: *const core::ffi::c_char,
        _String2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _stricoll(
        _String1: *const core::ffi::c_char,
        _String2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _stricoll_l(
        _String1: *const core::ffi::c_char,
        _String2: *const core::ffi::c_char,
        _Locale: _locale_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _stricmp_l(
        _String1: *const core::ffi::c_char,
        _String2: *const core::ffi::c_char,
        _Locale: _locale_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn strlen(_Str: *const core::ffi::c_char) -> core::ffi::c_ulonglong;
}
unsafe extern "C" {
    pub fn _strlwr_s(_String: *mut core::ffi::c_char, _Size: usize) -> errno_t;
}
unsafe extern "C" {
    pub fn _strlwr(_String: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _strlwr_s_l(
        _String: *mut core::ffi::c_char,
        _Size: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn _strlwr_l(_String: *mut core::ffi::c_char, _Locale: _locale_t)
                     -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strncat(
        _Destination: *mut core::ffi::c_char,
        _Source: *const core::ffi::c_char,
        _Count: core::ffi::c_ulonglong,
    ) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strncmp(
        _Str1: *const core::ffi::c_char,
        _Str2: *const core::ffi::c_char,
        _MaxCount: core::ffi::c_ulonglong,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _strnicmp(
        _String1: *const core::ffi::c_char,
        _String2: *const core::ffi::c_char,
        _MaxCount: usize,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _strnicmp_l(
        _String1: *const core::ffi::c_char,
        _String2: *const core::ffi::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _strnicoll(
        _String1: *const core::ffi::c_char,
        _String2: *const core::ffi::c_char,
        _MaxCount: usize,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _strnicoll_l(
        _String1: *const core::ffi::c_char,
        _String2: *const core::ffi::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _strncoll(
        _String1: *const core::ffi::c_char,
        _String2: *const core::ffi::c_char,
        _MaxCount: usize,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _strncoll_l(
        _String1: *const core::ffi::c_char,
        _String2: *const core::ffi::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __strncnt(_String: *const core::ffi::c_char, _Count: usize) -> usize;
}
unsafe extern "C" {
    pub fn strncpy(
        _Destination: *mut core::ffi::c_char,
        _Source: *const core::ffi::c_char,
        _Count: core::ffi::c_ulonglong,
    ) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strnlen(_String: *const core::ffi::c_char, _MaxCount: usize) -> usize;
}
unsafe extern "C" {
    pub fn _strnset_s(
        _String: *mut core::ffi::c_char,
        _SizeInBytes: usize,
        _Value: core::ffi::c_int,
        _MaxCount: usize,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn _strnset(
        _Destination: *mut core::ffi::c_char,
        _Value: core::ffi::c_int,
        _Count: usize,
    ) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strpbrk(
        _Str: *const core::ffi::c_char,
        _Control: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _strrev(_Str: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _strset_s(
        _Destination: *mut core::ffi::c_char,
        _DestinationSize: usize,
        _Value: core::ffi::c_int,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn _strset(
        _Destination: *mut core::ffi::c_char,
        _Value: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strspn(
        _Str: *const core::ffi::c_char,
        _Control: *const core::ffi::c_char,
    ) -> core::ffi::c_ulonglong;
}
unsafe extern "C" {
    pub fn strtok(
        _String: *mut core::ffi::c_char,
        _Delimiter: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _strupr_s(_String: *mut core::ffi::c_char, _Size: usize) -> errno_t;
}
unsafe extern "C" {
    pub fn _strupr(_String: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _strupr_s_l(
        _String: *mut core::ffi::c_char,
        _Size: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn _strupr_l(_String: *mut core::ffi::c_char, _Locale: _locale_t)
                     -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strxfrm(
        _Destination: *mut core::ffi::c_char,
        _Source: *const core::ffi::c_char,
        _MaxCount: core::ffi::c_ulonglong,
    ) -> core::ffi::c_ulonglong;
}
unsafe extern "C" {
    pub fn _strxfrm_l(
        _Destination: *mut core::ffi::c_char,
        _Source: *const core::ffi::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strdup(_String: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strcmpi(
        _String1: *const core::ffi::c_char,
        _String2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn stricmp(
        _String1: *const core::ffi::c_char,
        _String2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn strlwr(_String: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strnicmp(
        _String1: *const core::ffi::c_char,
        _String2: *const core::ffi::c_char,
        _MaxCount: usize,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn strnset(
        _String: *mut core::ffi::c_char,
        _Value: core::ffi::c_int,
        _MaxCount: usize,
    ) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strrev(_String: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strset(
        _String: *mut core::ffi::c_char,
        _Value: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strupr(_String: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECTID {
    pub Lineage: GUID,
    pub Uniquifier: ULONG,
}
pub type OBJECTID = _OBJECTID;
unsafe extern "C" {
    pub fn _RTL_CONSTANT_STRING_type_check(s: *const core::ffi::c_void) -> core::ffi::c_char;
}
pub type PEXCEPTION_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut _EXCEPTION_RECORD,
        arg2: PVOID,
        arg3: *mut _CONTEXT,
        arg4: PVOID,
    ) -> EXCEPTION_DISPOSITION,
>;
pub type KIRQL = UCHAR;
pub type PKIRQL = *mut KIRQL;
pub const _NT_PRODUCT_TYPE_NtProductWinNt: _NT_PRODUCT_TYPE = 1;
pub const _NT_PRODUCT_TYPE_NtProductLanManNt: _NT_PRODUCT_TYPE = 2;
pub const _NT_PRODUCT_TYPE_NtProductServer: _NT_PRODUCT_TYPE = 3;
pub type _NT_PRODUCT_TYPE = core::ffi::c_int;
pub use self::_NT_PRODUCT_TYPE as NT_PRODUCT_TYPE;
pub type PNT_PRODUCT_TYPE = *mut _NT_PRODUCT_TYPE;
pub const _SUITE_TYPE_SmallBusiness: _SUITE_TYPE = 0;
pub const _SUITE_TYPE_Enterprise: _SUITE_TYPE = 1;
pub const _SUITE_TYPE_BackOffice: _SUITE_TYPE = 2;
pub const _SUITE_TYPE_CommunicationServer: _SUITE_TYPE = 3;
pub const _SUITE_TYPE_TerminalServer: _SUITE_TYPE = 4;
pub const _SUITE_TYPE_SmallBusinessRestricted: _SUITE_TYPE = 5;
pub const _SUITE_TYPE_EmbeddedNT: _SUITE_TYPE = 6;
pub const _SUITE_TYPE_DataCenter: _SUITE_TYPE = 7;
pub const _SUITE_TYPE_SingleUserTS: _SUITE_TYPE = 8;
pub const _SUITE_TYPE_Personal: _SUITE_TYPE = 9;
pub const _SUITE_TYPE_Blade: _SUITE_TYPE = 10;
pub const _SUITE_TYPE_EmbeddedRestricted: _SUITE_TYPE = 11;
pub const _SUITE_TYPE_SecurityAppliance: _SUITE_TYPE = 12;
pub const _SUITE_TYPE_StorageServer: _SUITE_TYPE = 13;
pub const _SUITE_TYPE_ComputeServer: _SUITE_TYPE = 14;
pub const _SUITE_TYPE_WHServer: _SUITE_TYPE = 15;
pub const _SUITE_TYPE_PhoneNT: _SUITE_TYPE = 16;
pub const _SUITE_TYPE_MultiUserTS: _SUITE_TYPE = 17;
pub const _SUITE_TYPE_MaxSuiteType: _SUITE_TYPE = 18;
pub type _SUITE_TYPE = core::ffi::c_int;
pub use self::_SUITE_TYPE as SUITE_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _bindgen_ty_1 {
    pub x: core::ffi::c_char,
    pub test: LARGE_INTEGER,
}
pub type __C_ASSERT__ = [core::ffi::c_char; 1usize];
pub type __prefast_analysis_mode_flag0 = core::ffi::c_int;
pub type __prefast_analysis_mode_flag1 = core::ffi::c_int;
pub type PACCESS_STATE = *mut _ACCESS_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CALLBACK_OBJECT {
    _unused: [u8; 0],
}
pub type PCALLBACK_OBJECT = *mut _CALLBACK_OBJECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EPROCESS {
    _unused: [u8; 0],
}
pub type PEPROCESS = *mut _EPROCESS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETHREAD {
    _unused: [u8; 0],
}
pub type PETHREAD = *mut _ETHREAD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_TIMER {
    _unused: [u8; 0],
}
pub type PIO_TIMER = *mut _IO_TIMER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KINTERRUPT {
    _unused: [u8; 0],
}
pub type PKINTERRUPT = *mut _KINTERRUPT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTHREAD {
    _unused: [u8; 0],
}
pub type PKTHREAD = *mut _KTHREAD;
pub type PRKTHREAD = *mut _KTHREAD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KPROCESS {
    _unused: [u8; 0],
}
pub type PKPROCESS = *mut _KPROCESS;
pub type PRKPROCESS = *mut _KPROCESS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_TYPE {
    _unused: [u8; 0],
}
pub type POBJECT_TYPE = *mut _OBJECT_TYPE;
pub type PSECURITY_QUALITY_OF_SERVICE = *mut _SECURITY_QUALITY_OF_SERVICE;
pub type PCONTEXT = *mut _CONTEXT;
pub type PIO_STACK_LOCATION = *mut _IO_STACK_LOCATION;
pub type PVPB = *mut _VPB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_GET_QUOTA_INFORMATION {
    _unused: [u8; 0],
}
pub type PFILE_GET_QUOTA_INFORMATION = *mut _FILE_GET_QUOTA_INFORMATION;
unsafe extern "C" {
    pub fn __readgsqword(Offset: core::ffi::c_ulong) -> core::ffi::c_ulonglong;
}
pub const MCA_EXCEPTION_TYPE_HAL_MCE_RECORD: MCA_EXCEPTION_TYPE = 0;
pub const MCA_EXCEPTION_TYPE_HAL_MCA_RECORD: MCA_EXCEPTION_TYPE = 1;
pub type MCA_EXCEPTION_TYPE = core::ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MCI_ADDR {
    pub __bindgen_anon_1: _MCI_ADDR__bindgen_ty_1,
    pub QuadPart: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MCI_ADDR__bindgen_ty_1 {
    pub Address: ULONG,
    pub Reserved: ULONG,
}
pub type MCI_ADDR = _MCI_ADDR;
pub type PMCI_ADDR = *mut _MCI_ADDR;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MCI_STATS {
    pub MciStatus: _MCI_STATS__bindgen_ty_1,
    pub QuadPart: ULONG64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MCI_STATS__bindgen_ty_1 {
    pub McaErrorCode: USHORT,
    pub ModelErrorCode: USHORT,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _MCI_STATS__bindgen_ty_1 {
    #[inline]
    pub fn OtherInformation(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set_OtherInformation(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn OtherInformation_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                25u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_OtherInformation_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                25u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ContextCorrupt(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ContextCorrupt(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ContextCorrupt_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ContextCorrupt_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AddressValid(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AddressValid(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AddressValid_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AddressValid_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MiscValid(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MiscValid(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MiscValid_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MiscValid_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ErrorEnabled(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ErrorEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ErrorEnabled_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ErrorEnabled_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectedError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectedError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectedError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                29usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectedError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                29usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn StatusOverFlow(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_StatusOverFlow(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn StatusOverFlow_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_StatusOverFlow_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Valid(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Valid(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Valid_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Valid_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OtherInformation: ULONG,
        ContextCorrupt: ULONG,
        AddressValid: ULONG,
        MiscValid: ULONG,
        ErrorEnabled: ULONG,
        UncorrectedError: ULONG,
        StatusOverFlow: ULONG,
        Valid: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 25u8, {
            let OtherInformation: u32 = unsafe { ::core::mem::transmute(OtherInformation) };
            OtherInformation as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let ContextCorrupt: u32 = unsafe { ::core::mem::transmute(ContextCorrupt) };
            ContextCorrupt as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let AddressValid: u32 = unsafe { ::core::mem::transmute(AddressValid) };
            AddressValid as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let MiscValid: u32 = unsafe { ::core::mem::transmute(MiscValid) };
            MiscValid as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let ErrorEnabled: u32 = unsafe { ::core::mem::transmute(ErrorEnabled) };
            ErrorEnabled as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let UncorrectedError: u32 = unsafe { ::core::mem::transmute(UncorrectedError) };
            UncorrectedError as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let StatusOverFlow: u32 = unsafe { ::core::mem::transmute(StatusOverFlow) };
            StatusOverFlow as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let Valid: u32 = unsafe { ::core::mem::transmute(Valid) };
            Valid as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type MCI_STATS = _MCI_STATS;
pub type PMCI_STATS = *mut _MCI_STATS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MCA_EXCEPTION {
    pub VersionNumber: ULONG,
    pub ExceptionType: MCA_EXCEPTION_TYPE,
    pub TimeStamp: LARGE_INTEGER,
    pub ProcessorNumber: ULONG,
    pub Reserved1: ULONG,
    pub u: _MCA_EXCEPTION__bindgen_ty_1,
    pub ExtCnt: ULONG,
    pub Reserved3: ULONG,
    pub ExtReg: [ULONGLONG; 24usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MCA_EXCEPTION__bindgen_ty_1 {
    pub Mca: _MCA_EXCEPTION__bindgen_ty_1__bindgen_ty_1,
    pub Mce: _MCA_EXCEPTION__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MCA_EXCEPTION__bindgen_ty_1__bindgen_ty_1 {
    pub BankNumber: UCHAR,
    pub Reserved2: [UCHAR; 7usize],
    pub Status: MCI_STATS,
    pub Address: MCI_ADDR,
    pub Misc: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MCA_EXCEPTION__bindgen_ty_1__bindgen_ty_2 {
    pub Address: ULONGLONG,
    pub Type: ULONGLONG,
}
pub type MCA_EXCEPTION = _MCA_EXCEPTION;
pub type PMCA_EXCEPTION = *mut _MCA_EXCEPTION;
pub type CMC_EXCEPTION = MCA_EXCEPTION;
pub type PCMC_EXCEPTION = *mut MCA_EXCEPTION;
pub type CPE_EXCEPTION = MCA_EXCEPTION;
pub type PCPE_EXCEPTION = *mut MCA_EXCEPTION;
pub type ERROR_SEVERITY = UCHAR;
pub type PERROR_SEVERITY = *mut UCHAR;
pub const _ERROR_SEVERITY_VALUE_ErrorRecoverable: _ERROR_SEVERITY_VALUE = 0;
pub const _ERROR_SEVERITY_VALUE_ErrorFatal: _ERROR_SEVERITY_VALUE = 1;
pub const _ERROR_SEVERITY_VALUE_ErrorCorrected: _ERROR_SEVERITY_VALUE = 2;
pub const _ERROR_SEVERITY_VALUE_ErrorOthers: _ERROR_SEVERITY_VALUE = 3;
pub type _ERROR_SEVERITY_VALUE = core::ffi::c_int;
pub use self::_ERROR_SEVERITY_VALUE as ERROR_SEVERITY_VALUE;
unsafe extern "C" {
    pub static mut KeNumberProcessors: CCHAR;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KSYSTEM_TIME {
    pub LowPart: ULONG,
    pub High1Time: LONG,
    pub High2Time: LONG,
}
pub type KSYSTEM_TIME = _KSYSTEM_TIME;
pub type PKSYSTEM_TIME = *mut _KSYSTEM_TIME;
pub type KPRIORITY = LONG;
pub type KSPIN_LOCK = ULONG_PTR;
pub type PKSPIN_LOCK = *mut KSPIN_LOCK;
pub type KSPIN_LOCK_QUEUE_NUMBER = ULONG64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KSPIN_LOCK_QUEUE {
    pub Next: *mut _KSPIN_LOCK_QUEUE,
    pub Lock: PKSPIN_LOCK,
}
pub type KSPIN_LOCK_QUEUE = _KSPIN_LOCK_QUEUE;
pub type PKSPIN_LOCK_QUEUE = *mut _KSPIN_LOCK_QUEUE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KLOCK_QUEUE_HANDLE {
    pub LockQueue: KSPIN_LOCK_QUEUE,
    pub OldIrql: KIRQL,
}
pub type KLOCK_QUEUE_HANDLE = _KLOCK_QUEUE_HANDLE;
pub type PKLOCK_QUEUE_HANDLE = *mut _KLOCK_QUEUE_HANDLE;
pub const _KPROFILE_SOURCE_ProfileTime: _KPROFILE_SOURCE = 0;
pub const _KPROFILE_SOURCE_ProfileAlignmentFixup: _KPROFILE_SOURCE = 1;
pub const _KPROFILE_SOURCE_ProfileTotalIssues: _KPROFILE_SOURCE = 2;
pub const _KPROFILE_SOURCE_ProfilePipelineDry: _KPROFILE_SOURCE = 3;
pub const _KPROFILE_SOURCE_ProfileLoadInstructions: _KPROFILE_SOURCE = 4;
pub const _KPROFILE_SOURCE_ProfilePipelineFrozen: _KPROFILE_SOURCE = 5;
pub const _KPROFILE_SOURCE_ProfileBranchInstructions: _KPROFILE_SOURCE = 6;
pub const _KPROFILE_SOURCE_ProfileTotalNonissues: _KPROFILE_SOURCE = 7;
pub const _KPROFILE_SOURCE_ProfileDcacheMisses: _KPROFILE_SOURCE = 8;
pub const _KPROFILE_SOURCE_ProfileIcacheMisses: _KPROFILE_SOURCE = 9;
pub const _KPROFILE_SOURCE_ProfileCacheMisses: _KPROFILE_SOURCE = 10;
pub const _KPROFILE_SOURCE_ProfileBranchMispredictions: _KPROFILE_SOURCE = 11;
pub const _KPROFILE_SOURCE_ProfileStoreInstructions: _KPROFILE_SOURCE = 12;
pub const _KPROFILE_SOURCE_ProfileFpInstructions: _KPROFILE_SOURCE = 13;
pub const _KPROFILE_SOURCE_ProfileIntegerInstructions: _KPROFILE_SOURCE = 14;
pub const _KPROFILE_SOURCE_Profile2Issue: _KPROFILE_SOURCE = 15;
pub const _KPROFILE_SOURCE_Profile3Issue: _KPROFILE_SOURCE = 16;
pub const _KPROFILE_SOURCE_Profile4Issue: _KPROFILE_SOURCE = 17;
pub const _KPROFILE_SOURCE_ProfileSpecialInstructions: _KPROFILE_SOURCE = 18;
pub const _KPROFILE_SOURCE_ProfileTotalCycles: _KPROFILE_SOURCE = 19;
pub const _KPROFILE_SOURCE_ProfileIcacheIssues: _KPROFILE_SOURCE = 20;
pub const _KPROFILE_SOURCE_ProfileDcacheAccesses: _KPROFILE_SOURCE = 21;
pub const _KPROFILE_SOURCE_ProfileMemoryBarrierCycles: _KPROFILE_SOURCE = 22;
pub const _KPROFILE_SOURCE_ProfileLoadLinkedIssues: _KPROFILE_SOURCE = 23;
pub const _KPROFILE_SOURCE_ProfileMaximum: _KPROFILE_SOURCE = 24;
pub type _KPROFILE_SOURCE = core::ffi::c_int;
pub use self::_KPROFILE_SOURCE as KPROFILE_SOURCE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DPC_WATCHDOG_GLOBAL_TRIAGE_BLOCK {
    pub Signature: ULONG,
    pub Revision: USHORT,
    pub Size: USHORT,
    pub DpcWatchdogProfileOffset: USHORT,
    pub DpcWatchdogProfileLength: ULONG,
}
pub type DPC_WATCHDOG_GLOBAL_TRIAGE_BLOCK = _DPC_WATCHDOG_GLOBAL_TRIAGE_BLOCK;
pub type PDPC_WATCHDOG_GLOBAL_TRIAGE_BLOCK = *mut _DPC_WATCHDOG_GLOBAL_TRIAGE_BLOCK;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _M128A {
    pub Low: ULONGLONG,
    pub High: LONGLONG,
}
pub type M128A = _M128A;
pub type PM128A = *mut _M128A;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _XSAVE_FORMAT {
    pub ControlWord: USHORT,
    pub StatusWord: USHORT,
    pub TagWord: UCHAR,
    pub Reserved1: UCHAR,
    pub ErrorOpcode: USHORT,
    pub ErrorOffset: ULONG,
    pub ErrorSelector: USHORT,
    pub Reserved2: USHORT,
    pub DataOffset: ULONG,
    pub DataSelector: USHORT,
    pub Reserved3: USHORT,
    pub MxCsr: ULONG,
    pub MxCsr_Mask: ULONG,
    pub FloatRegisters: [M128A; 8usize],
    pub XmmRegisters: [M128A; 16usize],
    pub Reserved4: [UCHAR; 96usize],
}
pub type XSAVE_FORMAT = _XSAVE_FORMAT;
pub type PXSAVE_FORMAT = *mut _XSAVE_FORMAT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XSAVE_CET_U_FORMAT {
    pub Ia32CetUMsr: ULONG64,
    pub Ia32Pl3SspMsr: ULONG64,
}
pub type XSAVE_CET_U_FORMAT = _XSAVE_CET_U_FORMAT;
pub type PXSAVE_CET_U_FORMAT = *mut _XSAVE_CET_U_FORMAT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XSAVE_AREA_HEADER {
    pub Mask: ULONG64,
    pub CompactionMask: ULONG64,
    pub Reserved2: [ULONG64; 6usize],
}
pub type XSAVE_AREA_HEADER = _XSAVE_AREA_HEADER;
pub type PXSAVE_AREA_HEADER = *mut _XSAVE_AREA_HEADER;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _XSAVE_AREA {
    pub LegacyState: XSAVE_FORMAT,
    pub Header: XSAVE_AREA_HEADER,
}
pub type XSAVE_AREA = _XSAVE_AREA;
pub type PXSAVE_AREA = *mut _XSAVE_AREA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XSTATE_CONTEXT {
    pub Mask: ULONG64,
    pub Length: ULONG,
    pub Reserved1: ULONG,
    pub Area: PXSAVE_AREA,
    pub Buffer: PVOID,
}
pub type XSTATE_CONTEXT = _XSTATE_CONTEXT;
pub type PXSTATE_CONTEXT = *mut _XSTATE_CONTEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KERNEL_CET_CONTEXT {
    pub Ssp: ULONG64,
    pub Rip: ULONG64,
    pub SegCs: USHORT,
    pub __bindgen_anon_1: _KERNEL_CET_CONTEXT__bindgen_ty_1,
    pub Fill: [USHORT; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KERNEL_CET_CONTEXT__bindgen_ty_1 {
    pub AllFlags: USHORT,
    pub __bindgen_anon_1: _KERNEL_CET_CONTEXT__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KERNEL_CET_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _KERNEL_CET_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn UseWrss(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UseWrss(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UseWrss_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_UseWrss_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PopShadowStackOne(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PopShadowStackOne(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PopShadowStackOne_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PopShadowStackOne_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Unused(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 14u8) as u16) }
    }
    #[inline]
    pub fn set_Unused(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Unused_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                14u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Unused_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                14u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        UseWrss: USHORT,
        PopShadowStackOne: USHORT,
        Unused: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let UseWrss: u16 = unsafe { ::core::mem::transmute(UseWrss) };
            UseWrss as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PopShadowStackOne: u16 = unsafe { ::core::mem::transmute(PopShadowStackOne) };
            PopShadowStackOne as u64
        });
        __bindgen_bitfield_unit.set(2usize, 14u8, {
            let Unused: u16 = unsafe { ::core::mem::transmute(Unused) };
            Unused as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type KERNEL_CET_CONTEXT = _KERNEL_CET_CONTEXT;
pub type PKERNEL_CET_CONTEXT = *mut _KERNEL_CET_CONTEXT;
unsafe extern "C" {
    pub fn _bittest(
        Base: *const core::ffi::c_long,
        Offset: core::ffi::c_long,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _bittestandcomplement(
        Base: *mut core::ffi::c_long,
        Offset: core::ffi::c_long,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _bittestandset(
        Base: *mut core::ffi::c_long,
        Offset: core::ffi::c_long,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _bittestandreset(
        Base: *mut core::ffi::c_long,
        Offset: core::ffi::c_long,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _interlockedbittestandset(
        Base: *mut core::ffi::c_long,
        Offset: core::ffi::c_long,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _interlockedbittestandreset(
        Base: *mut core::ffi::c_long,
        Offset: core::ffi::c_long,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _bittest64(
        Base: *const core::ffi::c_longlong,
        Offset: core::ffi::c_longlong,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _bittestandcomplement64(
        Base: *mut core::ffi::c_longlong,
        Offset: core::ffi::c_longlong,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _bittestandset64(
        Base: *mut core::ffi::c_longlong,
        Offset: core::ffi::c_longlong,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _bittestandreset64(
        Base: *mut core::ffi::c_longlong,
        Offset: core::ffi::c_longlong,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _interlockedbittestandset64(
        Base: *mut core::ffi::c_longlong,
        Offset: core::ffi::c_longlong,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _interlockedbittestandreset64(
        Base: *mut core::ffi::c_longlong,
        Offset: core::ffi::c_longlong,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _BitScanForward(
        Index: *mut core::ffi::c_ulong,
        Mask: core::ffi::c_ulong,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _BitScanReverse(
        Index: *mut core::ffi::c_ulong,
        Mask: core::ffi::c_ulong,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _BitScanForward64(
        Index: *mut core::ffi::c_ulong,
        Mask: core::ffi::c_ulonglong,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _BitScanReverse64(
        Index: *mut core::ffi::c_ulong,
        Mask: core::ffi::c_ulonglong,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _InterlockedIncrement16(Addend: *mut core::ffi::c_short) -> core::ffi::c_short;
}
unsafe extern "C" {
    pub fn _InterlockedDecrement16(Addend: *mut core::ffi::c_short) -> core::ffi::c_short;
}
unsafe extern "C" {
    pub fn _InterlockedCompareExchange16(
        Destination: *mut core::ffi::c_short,
        ExChange: core::ffi::c_short,
        Comperand: core::ffi::c_short,
    ) -> core::ffi::c_short;
}
unsafe extern "C" {
    pub fn _InterlockedAnd(
        Destination: *mut core::ffi::c_long,
        Value: core::ffi::c_long,
    ) -> core::ffi::c_long;
}
unsafe extern "C" {
    pub fn _InterlockedOr(
        Destination: *mut core::ffi::c_long,
        Value: core::ffi::c_long,
    ) -> core::ffi::c_long;
}
unsafe extern "C" {
    pub fn _InterlockedXor(
        Destination: *mut core::ffi::c_long,
        Value: core::ffi::c_long,
    ) -> core::ffi::c_long;
}
unsafe extern "C" {
    pub fn _InterlockedAnd64(
        Destination: *mut core::ffi::c_longlong,
        Value: core::ffi::c_longlong,
    ) -> core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn _InterlockedOr64(
        Destination: *mut core::ffi::c_longlong,
        Value: core::ffi::c_longlong,
    ) -> core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn _InterlockedXor64(
        Destination: *mut core::ffi::c_longlong,
        Value: core::ffi::c_longlong,
    ) -> core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn _InterlockedIncrement(Addend: *mut core::ffi::c_long) -> core::ffi::c_long;
}
unsafe extern "C" {
    pub fn _InterlockedDecrement(Addend: *mut core::ffi::c_long) -> core::ffi::c_long;
}
unsafe extern "C" {
    pub fn _InterlockedExchange(
        Target: *mut core::ffi::c_long,
        Value: core::ffi::c_long,
    ) -> core::ffi::c_long;
}
unsafe extern "C" {
    pub fn _InterlockedExchangeAdd(
        Addend: *mut core::ffi::c_long,
        Value: core::ffi::c_long,
    ) -> core::ffi::c_long;
}
unsafe extern "C" {
    pub fn _InterlockedCompareExchange(
        Destination: *mut core::ffi::c_long,
        ExChange: core::ffi::c_long,
        Comperand: core::ffi::c_long,
    ) -> core::ffi::c_long;
}
unsafe extern "C" {
    pub fn _InterlockedIncrement64(Addend: *mut core::ffi::c_longlong) -> core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn _InterlockedDecrement64(Addend: *mut core::ffi::c_longlong) -> core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn _InterlockedExchange64(
        Target: *mut core::ffi::c_longlong,
        Value: core::ffi::c_longlong,
    ) -> core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn _InterlockedExchangeAdd64(
        Addend: *mut core::ffi::c_longlong,
        Value: core::ffi::c_longlong,
    ) -> core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn _InterlockedCompareExchange64(
        Destination: *mut core::ffi::c_longlong,
        ExChange: core::ffi::c_longlong,
        Comperand: core::ffi::c_longlong,
    ) -> core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn _InterlockedCompareExchange128(
        Destination: *mut core::ffi::c_longlong,
        ExchangeHigh: core::ffi::c_longlong,
        ExchangeLow: core::ffi::c_longlong,
        ComparandResult: *mut core::ffi::c_longlong,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _InterlockedCompareExchangePointer(
        Destination: *mut *mut core::ffi::c_void,
        Exchange: *mut core::ffi::c_void,
        Comperand: *mut core::ffi::c_void,
    ) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn _InterlockedExchangePointer(
        Target: *mut *mut core::ffi::c_void,
        Value: *mut core::ffi::c_void,
    ) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn _InterlockedExchange8(
        Target: *mut core::ffi::c_char,
        Value: core::ffi::c_char,
    ) -> core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _InterlockedExchange16(
        Destination: *mut core::ffi::c_short,
        ExChange: core::ffi::c_short,
    ) -> core::ffi::c_short;
}
unsafe extern "C" {
    pub fn _InterlockedExchangeAdd8(
        _Addend: *mut core::ffi::c_char,
        _Value: core::ffi::c_char,
    ) -> core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _InterlockedAnd8(
        Destination: *mut core::ffi::c_char,
        Value: core::ffi::c_char,
    ) -> core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _InterlockedOr8(
        Destination: *mut core::ffi::c_char,
        Value: core::ffi::c_char,
    ) -> core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _InterlockedXor8(
        Destination: *mut core::ffi::c_char,
        Value: core::ffi::c_char,
    ) -> core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _InterlockedAnd16(
        Destination: *mut core::ffi::c_short,
        Value: core::ffi::c_short,
    ) -> core::ffi::c_short;
}
unsafe extern "C" {
    pub fn _InterlockedOr16(
        Destination: *mut core::ffi::c_short,
        Value: core::ffi::c_short,
    ) -> core::ffi::c_short;
}
unsafe extern "C" {
    pub fn _InterlockedXor16(
        Destination: *mut core::ffi::c_short,
        Value: core::ffi::c_short,
    ) -> core::ffi::c_short;
}
unsafe extern "C" {
    pub fn __cpuidex(
        CPUInfo: *mut core::ffi::c_int,
        Function: core::ffi::c_int,
        SubLeaf: core::ffi::c_int,
    );
}
unsafe extern "C" {
    pub fn _mm_clflush(Address: *const core::ffi::c_void);
}
unsafe extern "C" {
    pub fn _ReadWriteBarrier();
}
unsafe extern "C" {
    pub fn __faststorefence();
}
unsafe extern "C" {
    pub fn _mm_lfence();
}
unsafe extern "C" {
    pub fn _mm_mfence();
}
unsafe extern "C" {
    pub fn _mm_sfence();
}
unsafe extern "C" {
    pub fn _mm_pause();
}
unsafe extern "C" {
    pub fn _mm_prefetch(a: *const core::ffi::c_char, sel: core::ffi::c_int);
}
unsafe extern "C" {
    pub fn _m_prefetchw(Source: *const core::ffi::c_void);
}
unsafe extern "C" {
    pub fn _mm_getcsr() -> core::ffi::c_uint;
}
unsafe extern "C" {
    pub fn _mm_setcsr(MxCsr: core::ffi::c_uint);
}
unsafe extern "C" {
    pub fn __getcallerseflags() -> core::ffi::c_uint;
}
unsafe extern "C" {
    pub fn __segmentlimit(Selector: ULONG) -> ULONG;
}
unsafe extern "C" {
    pub fn __readpmc(Counter: ULONG) -> ULONG64;
}
unsafe extern "C" {
    pub fn __rdtsc() -> core::ffi::c_ulonglong;
}
unsafe extern "C" {
    pub fn __movsb(Destination: PUCHAR, Source: *const UCHAR, Count: SIZE_T);
}
unsafe extern "C" {
    pub fn __movsw(Destination: PUSHORT, Source: *const USHORT, Count: SIZE_T);
}
unsafe extern "C" {
    pub fn __movsd(Destination: PULONG, Source: *const ULONG, Count: SIZE_T);
}
unsafe extern "C" {
    pub fn __movsq(Destination: PULONG64, Source: *const ULONG64, Count: SIZE_T);
}
unsafe extern "C" {
    pub fn __stosb(
        Destination: *mut core::ffi::c_uchar,
        Value: core::ffi::c_uchar,
        Count: core::ffi::c_ulonglong,
    );
}
unsafe extern "C" {
    pub fn __stosw(Destination: PUSHORT, Value: USHORT, Count: SIZE_T);
}
unsafe extern "C" {
    pub fn __stosd(Destination: PULONG, Value: ULONG, Count: SIZE_T);
}
unsafe extern "C" {
    pub fn __stosq(Destination: PULONG64, Value: ULONG64, Count: SIZE_T);
}
unsafe extern "C" {
    pub fn __mulh(
        Multiplier: core::ffi::c_longlong,
        Multiplicand: core::ffi::c_longlong,
    ) -> core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn __umulh(
        Multiplier: core::ffi::c_ulonglong,
        Multiplicand: core::ffi::c_ulonglong,
    ) -> core::ffi::c_ulonglong;
}
unsafe extern "C" {
    pub fn __popcnt64(operand: core::ffi::c_ulonglong) -> core::ffi::c_ulonglong;
}
unsafe extern "C" {
    pub fn __shiftleft128(
        LowPart: core::ffi::c_ulonglong,
        HighPart: core::ffi::c_ulonglong,
        Shift: core::ffi::c_uchar,
    ) -> core::ffi::c_ulonglong;
}
unsafe extern "C" {
    pub fn __shiftright128(
        LowPart: core::ffi::c_ulonglong,
        HighPart: core::ffi::c_ulonglong,
        Shift: core::ffi::c_uchar,
    ) -> core::ffi::c_ulonglong;
}
unsafe extern "C" {
    pub fn _mul128(
        Multiplier: core::ffi::c_longlong,
        Multiplicand: core::ffi::c_longlong,
        HighProduct: *mut core::ffi::c_longlong,
    ) -> core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn UnsignedMultiply128(
        Multiplier: ULONG64,
        Multiplicand: ULONG64,
        HighProduct: *mut ULONG64,
    ) -> ULONG64;
}
unsafe extern "C" {
    pub fn _umul128(
        Multiplier: core::ffi::c_ulonglong,
        Multiplicand: core::ffi::c_ulonglong,
        HighProduct: *mut core::ffi::c_ulonglong,
    ) -> core::ffi::c_ulonglong;
}
unsafe extern "C" {
    pub fn __readgsbyte(Offset: core::ffi::c_ulong) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn __readgsword(Offset: core::ffi::c_ulong) -> core::ffi::c_ushort;
}
unsafe extern "C" {
    pub fn __readgsdword(Offset: core::ffi::c_ulong) -> core::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn __writegsbyte(Offset: ULONG, Data: UCHAR);
}
unsafe extern "C" {
    pub fn __writegsword(Offset: ULONG, Data: USHORT);
}
unsafe extern "C" {
    pub fn __writegsdword(Offset: ULONG, Data: ULONG);
}
unsafe extern "C" {
    pub fn __writegsqword(Offset: ULONG, Data: ULONG64);
}
unsafe extern "C" {
    pub fn __incgsbyte(Offset: ULONG);
}
unsafe extern "C" {
    pub fn __addgsbyte(Offset: ULONG, Value: UCHAR);
}
unsafe extern "C" {
    pub fn __incgsword(Offset: ULONG);
}
unsafe extern "C" {
    pub fn __addgsword(Offset: ULONG, Value: USHORT);
}
unsafe extern "C" {
    pub fn __incgsdword(Offset: ULONG);
}
unsafe extern "C" {
    pub fn __addgsdword(Offset: ULONG, Value: ULONG);
}
unsafe extern "C" {
    pub fn __incgsqword(Offset: ULONG);
}
unsafe extern "C" {
    pub fn __addgsqword(Offset: ULONG, Value: ULONG64);
}
pub type XMM_SAVE_AREA32 = XSAVE_FORMAT;
pub type PXMM_SAVE_AREA32 = *mut XSAVE_FORMAT;
unsafe extern "C" {
    pub fn __int2c() -> !;
}
pub type PACCESS_TOKEN = PVOID;
pub type PSECURITY_DESCRIPTOR = PVOID;
pub type PSID = PVOID;
pub type PCLAIMS_BLOB = PVOID;
pub type ACCESS_MASK = ULONG;
pub type PACCESS_MASK = *mut ACCESS_MASK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GENERIC_MAPPING {
    pub GenericRead: ACCESS_MASK,
    pub GenericWrite: ACCESS_MASK,
    pub GenericExecute: ACCESS_MASK,
    pub GenericAll: ACCESS_MASK,
}
pub type GENERIC_MAPPING = _GENERIC_MAPPING;
pub type PGENERIC_MAPPING = *mut GENERIC_MAPPING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LUID_AND_ATTRIBUTES {
    pub Luid: LUID,
    pub Attributes: ULONG,
}
pub type LUID_AND_ATTRIBUTES = _LUID_AND_ATTRIBUTES;
pub type PLUID_AND_ATTRIBUTES = *mut _LUID_AND_ATTRIBUTES;
pub type LUID_AND_ATTRIBUTES_ARRAY = [LUID_AND_ATTRIBUTES; 1usize];
pub type PLUID_AND_ATTRIBUTES_ARRAY = *mut LUID_AND_ATTRIBUTES_ARRAY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACL {
    pub AclRevision: UCHAR,
    pub Sbz1: UCHAR,
    pub AclSize: USHORT,
    pub AceCount: USHORT,
    pub Sbz2: USHORT,
}
pub type ACL = _ACL;
pub type PACL = *mut ACL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRIVILEGE_SET {
    pub PrivilegeCount: ULONG,
    pub Control: ULONG,
    pub Privilege: [LUID_AND_ATTRIBUTES; 1usize],
}
pub type PRIVILEGE_SET = _PRIVILEGE_SET;
pub type PPRIVILEGE_SET = *mut _PRIVILEGE_SET;
pub const _SECURITY_IMPERSONATION_LEVEL_SecurityAnonymous: _SECURITY_IMPERSONATION_LEVEL = 0;
pub const _SECURITY_IMPERSONATION_LEVEL_SecurityIdentification: _SECURITY_IMPERSONATION_LEVEL = 1;
pub const _SECURITY_IMPERSONATION_LEVEL_SecurityImpersonation: _SECURITY_IMPERSONATION_LEVEL = 2;
pub const _SECURITY_IMPERSONATION_LEVEL_SecurityDelegation: _SECURITY_IMPERSONATION_LEVEL = 3;
pub type _SECURITY_IMPERSONATION_LEVEL = core::ffi::c_int;
pub use self::_SECURITY_IMPERSONATION_LEVEL as SECURITY_IMPERSONATION_LEVEL;
pub type PSECURITY_IMPERSONATION_LEVEL = *mut _SECURITY_IMPERSONATION_LEVEL;
pub type SECURITY_CONTEXT_TRACKING_MODE = BOOLEAN;
pub type PSECURITY_CONTEXT_TRACKING_MODE = *mut BOOLEAN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_QUALITY_OF_SERVICE {
    pub Length: ULONG,
    pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    pub ContextTrackingMode: SECURITY_CONTEXT_TRACKING_MODE,
    pub EffectiveOnly: BOOLEAN,
}
pub type SECURITY_QUALITY_OF_SERVICE = _SECURITY_QUALITY_OF_SERVICE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_IMPERSONATION_STATE {
    pub Token: PACCESS_TOKEN,
    pub CopyOnOpen: BOOLEAN,
    pub EffectiveOnly: BOOLEAN,
    pub Level: SECURITY_IMPERSONATION_LEVEL,
}
pub type SE_IMPERSONATION_STATE = _SE_IMPERSONATION_STATE;
pub type PSE_IMPERSONATION_STATE = *mut _SE_IMPERSONATION_STATE;
pub type SECURITY_INFORMATION = ULONG;
pub type PSECURITY_INFORMATION = *mut ULONG;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeNone: _SE_ADT_PARAMETER_TYPE = 0;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeString: _SE_ADT_PARAMETER_TYPE = 1;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeFileSpec: _SE_ADT_PARAMETER_TYPE = 2;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeUlong: _SE_ADT_PARAMETER_TYPE = 3;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeSid: _SE_ADT_PARAMETER_TYPE = 4;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeLogonId: _SE_ADT_PARAMETER_TYPE = 5;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeNoLogonId: _SE_ADT_PARAMETER_TYPE = 6;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeAccessMask: _SE_ADT_PARAMETER_TYPE = 7;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypePrivs: _SE_ADT_PARAMETER_TYPE = 8;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeObjectTypes: _SE_ADT_PARAMETER_TYPE = 9;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeHexUlong: _SE_ADT_PARAMETER_TYPE = 10;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypePtr: _SE_ADT_PARAMETER_TYPE = 11;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeTime: _SE_ADT_PARAMETER_TYPE = 12;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeGuid: _SE_ADT_PARAMETER_TYPE = 13;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeLuid: _SE_ADT_PARAMETER_TYPE = 14;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeHexInt64: _SE_ADT_PARAMETER_TYPE = 15;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeStringList: _SE_ADT_PARAMETER_TYPE = 16;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeSidList: _SE_ADT_PARAMETER_TYPE = 17;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeDuration: _SE_ADT_PARAMETER_TYPE = 18;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeUserAccountControl: _SE_ADT_PARAMETER_TYPE = 19;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeNoUac: _SE_ADT_PARAMETER_TYPE = 20;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeMessage: _SE_ADT_PARAMETER_TYPE = 21;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeDateTime: _SE_ADT_PARAMETER_TYPE = 22;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeSockAddr: _SE_ADT_PARAMETER_TYPE = 23;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeSD: _SE_ADT_PARAMETER_TYPE = 24;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeLogonHours: _SE_ADT_PARAMETER_TYPE = 25;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeLogonIdNoSid: _SE_ADT_PARAMETER_TYPE = 26;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeUlongNoConv: _SE_ADT_PARAMETER_TYPE = 27;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeSockAddrNoPort: _SE_ADT_PARAMETER_TYPE = 28;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeAccessReason: _SE_ADT_PARAMETER_TYPE = 29;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeStagingReason: _SE_ADT_PARAMETER_TYPE = 30;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeResourceAttribute: _SE_ADT_PARAMETER_TYPE = 31;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeClaims: _SE_ADT_PARAMETER_TYPE = 32;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeLogonIdAsSid: _SE_ADT_PARAMETER_TYPE = 33;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeMultiSzString: _SE_ADT_PARAMETER_TYPE = 34;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeLogonIdEx: _SE_ADT_PARAMETER_TYPE = 35;
pub type _SE_ADT_PARAMETER_TYPE = core::ffi::c_int;
pub use self::_SE_ADT_PARAMETER_TYPE as SE_ADT_PARAMETER_TYPE;
pub type PSE_ADT_PARAMETER_TYPE = *mut _SE_ADT_PARAMETER_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_ADT_OBJECT_TYPE {
    pub ObjectType: GUID,
    pub Flags: USHORT,
    pub Level: USHORT,
    pub AccessMask: ACCESS_MASK,
}
pub type SE_ADT_OBJECT_TYPE = _SE_ADT_OBJECT_TYPE;
pub type PSE_ADT_OBJECT_TYPE = *mut _SE_ADT_OBJECT_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_ADT_PARAMETER_ARRAY_ENTRY {
    pub Type: SE_ADT_PARAMETER_TYPE,
    pub Length: ULONG,
    pub Data: [ULONG_PTR; 2usize],
    pub Address: PVOID,
}
pub type SE_ADT_PARAMETER_ARRAY_ENTRY = _SE_ADT_PARAMETER_ARRAY_ENTRY;
pub type PSE_ADT_PARAMETER_ARRAY_ENTRY = *mut _SE_ADT_PARAMETER_ARRAY_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_ADT_ACCESS_REASON {
    pub AccessMask: ACCESS_MASK,
    pub AccessReasons: [ULONG; 32usize],
    pub ObjectTypeIndex: ULONG,
    pub AccessGranted: ULONG,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
}
pub type SE_ADT_ACCESS_REASON = _SE_ADT_ACCESS_REASON;
pub type PSE_ADT_ACCESS_REASON = *mut _SE_ADT_ACCESS_REASON;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_ADT_CLAIMS {
    pub Length: ULONG,
    pub Claims: PCLAIMS_BLOB,
}
pub type SE_ADT_CLAIMS = _SE_ADT_CLAIMS;
pub type PSE_ADT_CLAIMS = *mut _SE_ADT_CLAIMS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_ADT_PARAMETER_ARRAY {
    pub CategoryId: ULONG,
    pub AuditId: ULONG,
    pub ParameterCount: ULONG,
    pub Length: ULONG,
    pub FlatSubCategoryId: USHORT,
    pub Type: USHORT,
    pub Flags: ULONG,
    pub Parameters: [SE_ADT_PARAMETER_ARRAY_ENTRY; 32usize],
}
pub type SE_ADT_PARAMETER_ARRAY = _SE_ADT_PARAMETER_ARRAY;
pub type PSE_ADT_PARAMETER_ARRAY = *mut _SE_ADT_PARAMETER_ARRAY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_ADT_PARAMETER_ARRAY_EX {
    pub CategoryId: ULONG,
    pub AuditId: ULONG,
    pub Version: ULONG,
    pub ParameterCount: ULONG,
    pub Length: ULONG,
    pub FlatSubCategoryId: USHORT,
    pub Type: USHORT,
    pub Flags: ULONG,
    pub Parameters: [SE_ADT_PARAMETER_ARRAY_ENTRY; 32usize],
}
pub type SE_ADT_PARAMETER_ARRAY_EX = _SE_ADT_PARAMETER_ARRAY_EX;
pub type PSE_ADT_PARAMETER_ARRAY_EX = *mut _SE_ADT_PARAMETER_ARRAY_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STATUS_BLOCK {
    pub __bindgen_anon_1: _IO_STATUS_BLOCK__bindgen_ty_1,
    pub Information: ULONG_PTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STATUS_BLOCK__bindgen_ty_1 {
    pub Status: NTSTATUS,
    pub Pointer: PVOID,
}
pub type IO_STATUS_BLOCK = _IO_STATUS_BLOCK;
pub type PIO_STATUS_BLOCK = *mut _IO_STATUS_BLOCK;
pub type IO_STATUS_BLOCK64 = IO_STATUS_BLOCK;
pub type PIO_STATUS_BLOCK64 = *mut IO_STATUS_BLOCK64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STATUS_BLOCK32 {
    pub Status: NTSTATUS,
    pub Information: ULONG,
}
pub type IO_STATUS_BLOCK32 = _IO_STATUS_BLOCK32;
pub type PIO_STATUS_BLOCK32 = *mut _IO_STATUS_BLOCK32;
pub type PIO_APC_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(ApcContext: PVOID, IoStatusBlock: PIO_STATUS_BLOCK, Reserved: ULONG),
>;
pub const _IO_SESSION_EVENT_IoSessionEventIgnore: _IO_SESSION_EVENT = 0;
pub const _IO_SESSION_EVENT_IoSessionEventCreated: _IO_SESSION_EVENT = 1;
pub const _IO_SESSION_EVENT_IoSessionEventTerminated: _IO_SESSION_EVENT = 2;
pub const _IO_SESSION_EVENT_IoSessionEventConnected: _IO_SESSION_EVENT = 3;
pub const _IO_SESSION_EVENT_IoSessionEventDisconnected: _IO_SESSION_EVENT = 4;
pub const _IO_SESSION_EVENT_IoSessionEventLogon: _IO_SESSION_EVENT = 5;
pub const _IO_SESSION_EVENT_IoSessionEventLogoff: _IO_SESSION_EVENT = 6;
pub const _IO_SESSION_EVENT_IoSessionEventMax: _IO_SESSION_EVENT = 7;
pub type _IO_SESSION_EVENT = core::ffi::c_int;
pub use self::_IO_SESSION_EVENT as IO_SESSION_EVENT;
pub type PIO_SESSION_EVENT = *mut _IO_SESSION_EVENT;
pub const _IO_SESSION_STATE_IoSessionStateCreated: _IO_SESSION_STATE = 1;
pub const _IO_SESSION_STATE_IoSessionStateInitialized: _IO_SESSION_STATE = 2;
pub const _IO_SESSION_STATE_IoSessionStateConnected: _IO_SESSION_STATE = 3;
pub const _IO_SESSION_STATE_IoSessionStateDisconnected: _IO_SESSION_STATE = 4;
pub const _IO_SESSION_STATE_IoSessionStateDisconnectedLoggedOn: _IO_SESSION_STATE = 5;
pub const _IO_SESSION_STATE_IoSessionStateLoggedOn: _IO_SESSION_STATE = 6;
pub const _IO_SESSION_STATE_IoSessionStateLoggedOff: _IO_SESSION_STATE = 7;
pub const _IO_SESSION_STATE_IoSessionStateTerminated: _IO_SESSION_STATE = 8;
pub const _IO_SESSION_STATE_IoSessionStateMax: _IO_SESSION_STATE = 9;
pub type _IO_SESSION_STATE = core::ffi::c_int;
pub use self::_IO_SESSION_STATE as IO_SESSION_STATE;
pub type PIO_SESSION_STATE = *mut _IO_SESSION_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_SESSION_CONNECT_INFO {
    pub SessionId: ULONG,
    pub LocalSession: BOOLEAN,
}
pub type IO_SESSION_CONNECT_INFO = _IO_SESSION_CONNECT_INFO;
pub type PIO_SESSION_CONNECT_INFO = *mut _IO_SESSION_CONNECT_INFO;
pub const _FILE_INFORMATION_CLASS_FileDirectoryInformation: _FILE_INFORMATION_CLASS = 1;
pub const _FILE_INFORMATION_CLASS_FileFullDirectoryInformation: _FILE_INFORMATION_CLASS = 2;
pub const _FILE_INFORMATION_CLASS_FileBothDirectoryInformation: _FILE_INFORMATION_CLASS = 3;
pub const _FILE_INFORMATION_CLASS_FileBasicInformation: _FILE_INFORMATION_CLASS = 4;
pub const _FILE_INFORMATION_CLASS_FileStandardInformation: _FILE_INFORMATION_CLASS = 5;
pub const _FILE_INFORMATION_CLASS_FileInternalInformation: _FILE_INFORMATION_CLASS = 6;
pub const _FILE_INFORMATION_CLASS_FileEaInformation: _FILE_INFORMATION_CLASS = 7;
pub const _FILE_INFORMATION_CLASS_FileAccessInformation: _FILE_INFORMATION_CLASS = 8;
pub const _FILE_INFORMATION_CLASS_FileNameInformation: _FILE_INFORMATION_CLASS = 9;
pub const _FILE_INFORMATION_CLASS_FileRenameInformation: _FILE_INFORMATION_CLASS = 10;
pub const _FILE_INFORMATION_CLASS_FileLinkInformation: _FILE_INFORMATION_CLASS = 11;
pub const _FILE_INFORMATION_CLASS_FileNamesInformation: _FILE_INFORMATION_CLASS = 12;
pub const _FILE_INFORMATION_CLASS_FileDispositionInformation: _FILE_INFORMATION_CLASS = 13;
pub const _FILE_INFORMATION_CLASS_FilePositionInformation: _FILE_INFORMATION_CLASS = 14;
pub const _FILE_INFORMATION_CLASS_FileFullEaInformation: _FILE_INFORMATION_CLASS = 15;
pub const _FILE_INFORMATION_CLASS_FileModeInformation: _FILE_INFORMATION_CLASS = 16;
pub const _FILE_INFORMATION_CLASS_FileAlignmentInformation: _FILE_INFORMATION_CLASS = 17;
pub const _FILE_INFORMATION_CLASS_FileAllInformation: _FILE_INFORMATION_CLASS = 18;
pub const _FILE_INFORMATION_CLASS_FileAllocationInformation: _FILE_INFORMATION_CLASS = 19;
pub const _FILE_INFORMATION_CLASS_FileEndOfFileInformation: _FILE_INFORMATION_CLASS = 20;
pub const _FILE_INFORMATION_CLASS_FileAlternateNameInformation: _FILE_INFORMATION_CLASS = 21;
pub const _FILE_INFORMATION_CLASS_FileStreamInformation: _FILE_INFORMATION_CLASS = 22;
pub const _FILE_INFORMATION_CLASS_FilePipeInformation: _FILE_INFORMATION_CLASS = 23;
pub const _FILE_INFORMATION_CLASS_FilePipeLocalInformation: _FILE_INFORMATION_CLASS = 24;
pub const _FILE_INFORMATION_CLASS_FilePipeRemoteInformation: _FILE_INFORMATION_CLASS = 25;
pub const _FILE_INFORMATION_CLASS_FileMailslotQueryInformation: _FILE_INFORMATION_CLASS = 26;
pub const _FILE_INFORMATION_CLASS_FileMailslotSetInformation: _FILE_INFORMATION_CLASS = 27;
pub const _FILE_INFORMATION_CLASS_FileCompressionInformation: _FILE_INFORMATION_CLASS = 28;
pub const _FILE_INFORMATION_CLASS_FileObjectIdInformation: _FILE_INFORMATION_CLASS = 29;
pub const _FILE_INFORMATION_CLASS_FileCompletionInformation: _FILE_INFORMATION_CLASS = 30;
pub const _FILE_INFORMATION_CLASS_FileMoveClusterInformation: _FILE_INFORMATION_CLASS = 31;
pub const _FILE_INFORMATION_CLASS_FileQuotaInformation: _FILE_INFORMATION_CLASS = 32;
pub const _FILE_INFORMATION_CLASS_FileReparsePointInformation: _FILE_INFORMATION_CLASS = 33;
pub const _FILE_INFORMATION_CLASS_FileNetworkOpenInformation: _FILE_INFORMATION_CLASS = 34;
pub const _FILE_INFORMATION_CLASS_FileAttributeTagInformation: _FILE_INFORMATION_CLASS = 35;
pub const _FILE_INFORMATION_CLASS_FileTrackingInformation: _FILE_INFORMATION_CLASS = 36;
pub const _FILE_INFORMATION_CLASS_FileIdBothDirectoryInformation: _FILE_INFORMATION_CLASS = 37;
pub const _FILE_INFORMATION_CLASS_FileIdFullDirectoryInformation: _FILE_INFORMATION_CLASS = 38;
pub const _FILE_INFORMATION_CLASS_FileValidDataLengthInformation: _FILE_INFORMATION_CLASS = 39;
pub const _FILE_INFORMATION_CLASS_FileShortNameInformation: _FILE_INFORMATION_CLASS = 40;
pub const _FILE_INFORMATION_CLASS_FileIoCompletionNotificationInformation: _FILE_INFORMATION_CLASS =
    41;
pub const _FILE_INFORMATION_CLASS_FileIoStatusBlockRangeInformation: _FILE_INFORMATION_CLASS = 42;
pub const _FILE_INFORMATION_CLASS_FileIoPriorityHintInformation: _FILE_INFORMATION_CLASS = 43;
pub const _FILE_INFORMATION_CLASS_FileSfioReserveInformation: _FILE_INFORMATION_CLASS = 44;
pub const _FILE_INFORMATION_CLASS_FileSfioVolumeInformation: _FILE_INFORMATION_CLASS = 45;
pub const _FILE_INFORMATION_CLASS_FileHardLinkInformation: _FILE_INFORMATION_CLASS = 46;
pub const _FILE_INFORMATION_CLASS_FileProcessIdsUsingFileInformation: _FILE_INFORMATION_CLASS = 47;
pub const _FILE_INFORMATION_CLASS_FileNormalizedNameInformation: _FILE_INFORMATION_CLASS = 48;
pub const _FILE_INFORMATION_CLASS_FileNetworkPhysicalNameInformation: _FILE_INFORMATION_CLASS = 49;
pub const _FILE_INFORMATION_CLASS_FileIdGlobalTxDirectoryInformation: _FILE_INFORMATION_CLASS = 50;
pub const _FILE_INFORMATION_CLASS_FileIsRemoteDeviceInformation: _FILE_INFORMATION_CLASS = 51;
pub const _FILE_INFORMATION_CLASS_FileUnusedInformation: _FILE_INFORMATION_CLASS = 52;
pub const _FILE_INFORMATION_CLASS_FileNumaNodeInformation: _FILE_INFORMATION_CLASS = 53;
pub const _FILE_INFORMATION_CLASS_FileStandardLinkInformation: _FILE_INFORMATION_CLASS = 54;
pub const _FILE_INFORMATION_CLASS_FileRemoteProtocolInformation: _FILE_INFORMATION_CLASS = 55;
pub const _FILE_INFORMATION_CLASS_FileRenameInformationBypassAccessCheck: _FILE_INFORMATION_CLASS =
    56;
pub const _FILE_INFORMATION_CLASS_FileLinkInformationBypassAccessCheck: _FILE_INFORMATION_CLASS =
    57;
pub const _FILE_INFORMATION_CLASS_FileVolumeNameInformation: _FILE_INFORMATION_CLASS = 58;
pub const _FILE_INFORMATION_CLASS_FileIdInformation: _FILE_INFORMATION_CLASS = 59;
pub const _FILE_INFORMATION_CLASS_FileIdExtdDirectoryInformation: _FILE_INFORMATION_CLASS = 60;
pub const _FILE_INFORMATION_CLASS_FileReplaceCompletionInformation: _FILE_INFORMATION_CLASS = 61;
pub const _FILE_INFORMATION_CLASS_FileHardLinkFullIdInformation: _FILE_INFORMATION_CLASS = 62;
pub const _FILE_INFORMATION_CLASS_FileIdExtdBothDirectoryInformation: _FILE_INFORMATION_CLASS = 63;
pub const _FILE_INFORMATION_CLASS_FileDispositionInformationEx: _FILE_INFORMATION_CLASS = 64;
pub const _FILE_INFORMATION_CLASS_FileRenameInformationEx: _FILE_INFORMATION_CLASS = 65;
pub const _FILE_INFORMATION_CLASS_FileRenameInformationExBypassAccessCheck:
_FILE_INFORMATION_CLASS = 66;
pub const _FILE_INFORMATION_CLASS_FileDesiredStorageClassInformation: _FILE_INFORMATION_CLASS = 67;
pub const _FILE_INFORMATION_CLASS_FileStatInformation: _FILE_INFORMATION_CLASS = 68;
pub const _FILE_INFORMATION_CLASS_FileMemoryPartitionInformation: _FILE_INFORMATION_CLASS = 69;
pub const _FILE_INFORMATION_CLASS_FileStatLxInformation: _FILE_INFORMATION_CLASS = 70;
pub const _FILE_INFORMATION_CLASS_FileCaseSensitiveInformation: _FILE_INFORMATION_CLASS = 71;
pub const _FILE_INFORMATION_CLASS_FileLinkInformationEx: _FILE_INFORMATION_CLASS = 72;
pub const _FILE_INFORMATION_CLASS_FileLinkInformationExBypassAccessCheck: _FILE_INFORMATION_CLASS =
    73;
pub const _FILE_INFORMATION_CLASS_FileStorageReserveIdInformation: _FILE_INFORMATION_CLASS = 74;
pub const _FILE_INFORMATION_CLASS_FileCaseSensitiveInformationForceAccessCheck:
_FILE_INFORMATION_CLASS = 75;
pub const _FILE_INFORMATION_CLASS_FileKnownFolderInformation: _FILE_INFORMATION_CLASS = 76;
pub const _FILE_INFORMATION_CLASS_FileStatBasicInformation: _FILE_INFORMATION_CLASS = 77;
pub const _FILE_INFORMATION_CLASS_FileId64ExtdDirectoryInformation: _FILE_INFORMATION_CLASS = 78;
pub const _FILE_INFORMATION_CLASS_FileId64ExtdBothDirectoryInformation: _FILE_INFORMATION_CLASS =
    79;
pub const _FILE_INFORMATION_CLASS_FileIdAllExtdDirectoryInformation: _FILE_INFORMATION_CLASS = 80;
pub const _FILE_INFORMATION_CLASS_FileIdAllExtdBothDirectoryInformation: _FILE_INFORMATION_CLASS =
    81;
pub const _FILE_INFORMATION_CLASS_FileMaximumInformation: _FILE_INFORMATION_CLASS = 82;
pub type _FILE_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_FILE_INFORMATION_CLASS as FILE_INFORMATION_CLASS;
pub type PFILE_INFORMATION_CLASS = *mut _FILE_INFORMATION_CLASS;
pub const _DIRECTORY_NOTIFY_INFORMATION_CLASS_DirectoryNotifyInformation:
_DIRECTORY_NOTIFY_INFORMATION_CLASS = 1;
pub const _DIRECTORY_NOTIFY_INFORMATION_CLASS_DirectoryNotifyExtendedInformation:
_DIRECTORY_NOTIFY_INFORMATION_CLASS = 2;
pub const _DIRECTORY_NOTIFY_INFORMATION_CLASS_DirectoryNotifyFullInformation:
_DIRECTORY_NOTIFY_INFORMATION_CLASS = 3;
pub const _DIRECTORY_NOTIFY_INFORMATION_CLASS_DirectoryNotifyMaximumInformation:
_DIRECTORY_NOTIFY_INFORMATION_CLASS = 4;
pub type _DIRECTORY_NOTIFY_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_DIRECTORY_NOTIFY_INFORMATION_CLASS as DIRECTORY_NOTIFY_INFORMATION_CLASS;
pub type PDIRECTORY_NOTIFY_INFORMATION_CLASS = *mut _DIRECTORY_NOTIFY_INFORMATION_CLASS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_BASIC_INFORMATION {
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub FileAttributes: ULONG,
}
pub type FILE_BASIC_INFORMATION = _FILE_BASIC_INFORMATION;
pub type PFILE_BASIC_INFORMATION = *mut _FILE_BASIC_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STANDARD_INFORMATION {
    pub AllocationSize: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub NumberOfLinks: ULONG,
    pub DeletePending: BOOLEAN,
    pub Directory: BOOLEAN,
}
pub type FILE_STANDARD_INFORMATION = _FILE_STANDARD_INFORMATION;
pub type PFILE_STANDARD_INFORMATION = *mut _FILE_STANDARD_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STANDARD_INFORMATION_EX {
    pub AllocationSize: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub NumberOfLinks: ULONG,
    pub DeletePending: BOOLEAN,
    pub Directory: BOOLEAN,
    pub AlternateStream: BOOLEAN,
    pub MetadataAttribute: BOOLEAN,
}
pub type FILE_STANDARD_INFORMATION_EX = _FILE_STANDARD_INFORMATION_EX;
pub type PFILE_STANDARD_INFORMATION_EX = *mut _FILE_STANDARD_INFORMATION_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_POSITION_INFORMATION {
    pub CurrentByteOffset: LARGE_INTEGER,
}
pub type FILE_POSITION_INFORMATION = _FILE_POSITION_INFORMATION;
pub type PFILE_POSITION_INFORMATION = *mut _FILE_POSITION_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_NETWORK_OPEN_INFORMATION {
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub FileAttributes: ULONG,
}
pub type FILE_NETWORK_OPEN_INFORMATION = _FILE_NETWORK_OPEN_INFORMATION;
pub type PFILE_NETWORK_OPEN_INFORMATION = *mut _FILE_NETWORK_OPEN_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FULL_EA_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub Flags: UCHAR,
    pub EaNameLength: UCHAR,
    pub EaValueLength: USHORT,
    pub EaName: [CHAR; 1usize],
}
pub type FILE_FULL_EA_INFORMATION = _FILE_FULL_EA_INFORMATION;
pub type PFILE_FULL_EA_INFORMATION = *mut _FILE_FULL_EA_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_SFIO_RESERVE_INFORMATION {
    pub RequestsPerPeriod: ULONG,
    pub Period: ULONG,
    pub RetryFailures: BOOLEAN,
    pub Discardable: BOOLEAN,
    pub RequestSize: ULONG,
    pub NumOutstandingRequests: ULONG,
}
pub type FILE_SFIO_RESERVE_INFORMATION = _FILE_SFIO_RESERVE_INFORMATION;
pub type PFILE_SFIO_RESERVE_INFORMATION = *mut _FILE_SFIO_RESERVE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_SFIO_VOLUME_INFORMATION {
    pub MaximumRequestsPerPeriod: ULONG,
    pub MinimumPeriod: ULONG,
    pub MinimumTransferSize: ULONG,
}
pub type FILE_SFIO_VOLUME_INFORMATION = _FILE_SFIO_VOLUME_INFORMATION;
pub type PFILE_SFIO_VOLUME_INFORMATION = *mut _FILE_SFIO_VOLUME_INFORMATION;
pub const _IO_PRIORITY_HINT_IoPriorityVeryLow: _IO_PRIORITY_HINT = 0;
pub const _IO_PRIORITY_HINT_IoPriorityLow: _IO_PRIORITY_HINT = 1;
pub const _IO_PRIORITY_HINT_IoPriorityNormal: _IO_PRIORITY_HINT = 2;
pub const _IO_PRIORITY_HINT_IoPriorityHigh: _IO_PRIORITY_HINT = 3;
pub const _IO_PRIORITY_HINT_IoPriorityCritical: _IO_PRIORITY_HINT = 4;
pub const _IO_PRIORITY_HINT_MaxIoPriorityTypes: _IO_PRIORITY_HINT = 5;
pub type _IO_PRIORITY_HINT = core::ffi::c_int;
pub use self::_IO_PRIORITY_HINT as IO_PRIORITY_HINT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_IO_PRIORITY_HINT_INFORMATION {
    pub PriorityHint: IO_PRIORITY_HINT,
}
pub type FILE_IO_PRIORITY_HINT_INFORMATION = _FILE_IO_PRIORITY_HINT_INFORMATION;
pub type PFILE_IO_PRIORITY_HINT_INFORMATION = *mut _FILE_IO_PRIORITY_HINT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_IO_PRIORITY_HINT_INFORMATION_EX {
    pub PriorityHint: IO_PRIORITY_HINT,
    pub BoostOutstanding: BOOLEAN,
}
pub type FILE_IO_PRIORITY_HINT_INFORMATION_EX = _FILE_IO_PRIORITY_HINT_INFORMATION_EX;
pub type PFILE_IO_PRIORITY_HINT_INFORMATION_EX = *mut _FILE_IO_PRIORITY_HINT_INFORMATION_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_IO_COMPLETION_NOTIFICATION_INFORMATION {
    pub Flags: ULONG,
}
pub type FILE_IO_COMPLETION_NOTIFICATION_INFORMATION = _FILE_IO_COMPLETION_NOTIFICATION_INFORMATION;
pub type PFILE_IO_COMPLETION_NOTIFICATION_INFORMATION =
*mut _FILE_IO_COMPLETION_NOTIFICATION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PROCESS_IDS_USING_FILE_INFORMATION {
    pub NumberOfProcessIdsInList: ULONG,
    pub ProcessIdList: [ULONG_PTR; 1usize],
}
pub type FILE_PROCESS_IDS_USING_FILE_INFORMATION = _FILE_PROCESS_IDS_USING_FILE_INFORMATION;
pub type PFILE_PROCESS_IDS_USING_FILE_INFORMATION = *mut _FILE_PROCESS_IDS_USING_FILE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_IS_REMOTE_DEVICE_INFORMATION {
    pub IsRemote: BOOLEAN,
}
pub type FILE_IS_REMOTE_DEVICE_INFORMATION = _FILE_IS_REMOTE_DEVICE_INFORMATION;
pub type PFILE_IS_REMOTE_DEVICE_INFORMATION = *mut _FILE_IS_REMOTE_DEVICE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_NUMA_NODE_INFORMATION {
    pub NodeNumber: USHORT,
}
pub type FILE_NUMA_NODE_INFORMATION = _FILE_NUMA_NODE_INFORMATION;
pub type PFILE_NUMA_NODE_INFORMATION = *mut _FILE_NUMA_NODE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_IOSTATUSBLOCK_RANGE_INFORMATION {
    pub IoStatusBlockRange: PUCHAR,
    pub Length: ULONG,
}
pub type FILE_IOSTATUSBLOCK_RANGE_INFORMATION = _FILE_IOSTATUSBLOCK_RANGE_INFORMATION;
pub type PFILE_IOSTATUSBLOCK_RANGE_INFORMATION = *mut _FILE_IOSTATUSBLOCK_RANGE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_MEMORY_PARTITION_INFORMATION {
    pub OwnerPartitionHandle: ULONG_PTR,
    pub Flags: _FILE_MEMORY_PARTITION_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_MEMORY_PARTITION_INFORMATION__bindgen_ty_1 {
    pub __bindgen_anon_1: _FILE_MEMORY_PARTITION_INFORMATION__bindgen_ty_1__bindgen_ty_1,
    pub AllFlags: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_MEMORY_PARTITION_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub NoCrossPartitionAccess: UCHAR,
    pub Spare: [UCHAR; 3usize],
}
pub type FILE_MEMORY_PARTITION_INFORMATION = _FILE_MEMORY_PARTITION_INFORMATION;
pub type PFILE_MEMORY_PARTITION_INFORMATION = *mut _FILE_MEMORY_PARTITION_INFORMATION;
pub const _FSINFOCLASS_FileFsVolumeInformation: _FSINFOCLASS = 1;
pub const _FSINFOCLASS_FileFsLabelInformation: _FSINFOCLASS = 2;
pub const _FSINFOCLASS_FileFsSizeInformation: _FSINFOCLASS = 3;
pub const _FSINFOCLASS_FileFsDeviceInformation: _FSINFOCLASS = 4;
pub const _FSINFOCLASS_FileFsAttributeInformation: _FSINFOCLASS = 5;
pub const _FSINFOCLASS_FileFsControlInformation: _FSINFOCLASS = 6;
pub const _FSINFOCLASS_FileFsFullSizeInformation: _FSINFOCLASS = 7;
pub const _FSINFOCLASS_FileFsObjectIdInformation: _FSINFOCLASS = 8;
pub const _FSINFOCLASS_FileFsDriverPathInformation: _FSINFOCLASS = 9;
pub const _FSINFOCLASS_FileFsVolumeFlagsInformation: _FSINFOCLASS = 10;
pub const _FSINFOCLASS_FileFsSectorSizeInformation: _FSINFOCLASS = 11;
pub const _FSINFOCLASS_FileFsDataCopyInformation: _FSINFOCLASS = 12;
pub const _FSINFOCLASS_FileFsMetadataSizeInformation: _FSINFOCLASS = 13;
pub const _FSINFOCLASS_FileFsFullSizeInformationEx: _FSINFOCLASS = 14;
pub const _FSINFOCLASS_FileFsGuidInformation: _FSINFOCLASS = 15;
pub const _FSINFOCLASS_FileFsMaximumInformation: _FSINFOCLASS = 16;
pub type _FSINFOCLASS = core::ffi::c_int;
pub use self::_FSINFOCLASS as FS_INFORMATION_CLASS;
pub type PFS_INFORMATION_CLASS = *mut _FSINFOCLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FS_DEVICE_INFORMATION {
    pub DeviceType: ULONG,
    pub Characteristics: ULONG,
}
pub type FILE_FS_DEVICE_INFORMATION = _FILE_FS_DEVICE_INFORMATION;
pub type PFILE_FS_DEVICE_INFORMATION = *mut _FILE_FS_DEVICE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_SEGMENT_ELEMENT {
    pub Buffer: *mut core::ffi::c_void,
    pub Alignment: ULONGLONG,
}
pub type FILE_SEGMENT_ELEMENT = _FILE_SEGMENT_ELEMENT;
pub type PFILE_SEGMENT_ELEMENT = *mut _FILE_SEGMENT_ELEMENT;
pub const _INTERFACE_TYPE_InterfaceTypeUndefined: _INTERFACE_TYPE = -1;
pub const _INTERFACE_TYPE_Internal: _INTERFACE_TYPE = 0;
pub const _INTERFACE_TYPE_Isa: _INTERFACE_TYPE = 1;
pub const _INTERFACE_TYPE_Eisa: _INTERFACE_TYPE = 2;
pub const _INTERFACE_TYPE_MicroChannel: _INTERFACE_TYPE = 3;
pub const _INTERFACE_TYPE_TurboChannel: _INTERFACE_TYPE = 4;
pub const _INTERFACE_TYPE_PCIBus: _INTERFACE_TYPE = 5;
pub const _INTERFACE_TYPE_VMEBus: _INTERFACE_TYPE = 6;
pub const _INTERFACE_TYPE_NuBus: _INTERFACE_TYPE = 7;
pub const _INTERFACE_TYPE_PCMCIABus: _INTERFACE_TYPE = 8;
pub const _INTERFACE_TYPE_CBus: _INTERFACE_TYPE = 9;
pub const _INTERFACE_TYPE_MPIBus: _INTERFACE_TYPE = 10;
pub const _INTERFACE_TYPE_MPSABus: _INTERFACE_TYPE = 11;
pub const _INTERFACE_TYPE_ProcessorInternal: _INTERFACE_TYPE = 12;
pub const _INTERFACE_TYPE_InternalPowerBus: _INTERFACE_TYPE = 13;
pub const _INTERFACE_TYPE_PNPISABus: _INTERFACE_TYPE = 14;
pub const _INTERFACE_TYPE_PNPBus: _INTERFACE_TYPE = 15;
pub const _INTERFACE_TYPE_Vmcs: _INTERFACE_TYPE = 16;
pub const _INTERFACE_TYPE_ACPIBus: _INTERFACE_TYPE = 17;
pub const _INTERFACE_TYPE_MaximumInterfaceType: _INTERFACE_TYPE = 18;
pub type _INTERFACE_TYPE = core::ffi::c_int;
pub use self::_INTERFACE_TYPE as INTERFACE_TYPE;
pub type PINTERFACE_TYPE = *mut _INTERFACE_TYPE;
pub const _DMA_WIDTH_Width8Bits: _DMA_WIDTH = 0;
pub const _DMA_WIDTH_Width16Bits: _DMA_WIDTH = 1;
pub const _DMA_WIDTH_Width32Bits: _DMA_WIDTH = 2;
pub const _DMA_WIDTH_Width64Bits: _DMA_WIDTH = 3;
pub const _DMA_WIDTH_WidthNoWrap: _DMA_WIDTH = 4;
pub const _DMA_WIDTH_MaximumDmaWidth: _DMA_WIDTH = 5;
pub type _DMA_WIDTH = core::ffi::c_int;
pub use self::_DMA_WIDTH as DMA_WIDTH;
pub type PDMA_WIDTH = *mut _DMA_WIDTH;
pub const _DMA_SPEED_Compatible: _DMA_SPEED = 0;
pub const _DMA_SPEED_TypeA: _DMA_SPEED = 1;
pub const _DMA_SPEED_TypeB: _DMA_SPEED = 2;
pub const _DMA_SPEED_TypeC: _DMA_SPEED = 3;
pub const _DMA_SPEED_TypeF: _DMA_SPEED = 4;
pub const _DMA_SPEED_MaximumDmaSpeed: _DMA_SPEED = 5;
pub type _DMA_SPEED = core::ffi::c_int;
pub use self::_DMA_SPEED as DMA_SPEED;
pub type PDMA_SPEED = *mut _DMA_SPEED;
pub type PINTERFACE_REFERENCE = ::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
pub type PINTERFACE_DEREFERENCE = ::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_ERROR_LOG_PACKET {
    pub MajorFunctionCode: UCHAR,
    pub RetryCount: UCHAR,
    pub DumpDataSize: USHORT,
    pub NumberOfStrings: USHORT,
    pub StringOffset: USHORT,
    pub EventCategory: USHORT,
    pub ErrorCode: NTSTATUS,
    pub UniqueErrorValue: ULONG,
    pub FinalStatus: NTSTATUS,
    pub SequenceNumber: ULONG,
    pub IoControlCode: ULONG,
    pub DeviceOffset: LARGE_INTEGER,
    pub DumpData: [ULONG; 1usize],
}
pub type IO_ERROR_LOG_PACKET = _IO_ERROR_LOG_PACKET;
pub type PIO_ERROR_LOG_PACKET = *mut _IO_ERROR_LOG_PACKET;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_ERROR_LOG_MESSAGE {
    pub Type: USHORT,
    pub Size: USHORT,
    pub DriverNameLength: USHORT,
    pub TimeStamp: LARGE_INTEGER,
    pub DriverNameOffset: ULONG,
    pub EntryData: IO_ERROR_LOG_PACKET,
}
pub type IO_ERROR_LOG_MESSAGE = _IO_ERROR_LOG_MESSAGE;
pub type PIO_ERROR_LOG_MESSAGE = *mut _IO_ERROR_LOG_MESSAGE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KEY_BASIC_INFORMATION {
    pub LastWriteTime: LARGE_INTEGER,
    pub TitleIndex: ULONG,
    pub NameLength: ULONG,
    pub Name: [WCHAR; 1usize],
}
pub type KEY_BASIC_INFORMATION = _KEY_BASIC_INFORMATION;
pub type PKEY_BASIC_INFORMATION = *mut _KEY_BASIC_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KEY_NODE_INFORMATION {
    pub LastWriteTime: LARGE_INTEGER,
    pub TitleIndex: ULONG,
    pub ClassOffset: ULONG,
    pub ClassLength: ULONG,
    pub NameLength: ULONG,
    pub Name: [WCHAR; 1usize],
}
pub type KEY_NODE_INFORMATION = _KEY_NODE_INFORMATION;
pub type PKEY_NODE_INFORMATION = *mut _KEY_NODE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KEY_FULL_INFORMATION {
    pub LastWriteTime: LARGE_INTEGER,
    pub TitleIndex: ULONG,
    pub ClassOffset: ULONG,
    pub ClassLength: ULONG,
    pub SubKeys: ULONG,
    pub MaxNameLen: ULONG,
    pub MaxClassLen: ULONG,
    pub Values: ULONG,
    pub MaxValueNameLen: ULONG,
    pub MaxValueDataLen: ULONG,
    pub Class: [WCHAR; 1usize],
}
pub type KEY_FULL_INFORMATION = _KEY_FULL_INFORMATION;
pub type PKEY_FULL_INFORMATION = *mut _KEY_FULL_INFORMATION;
pub const _KEY_INFORMATION_CLASS_KeyBasicInformation: _KEY_INFORMATION_CLASS = 0;
pub const _KEY_INFORMATION_CLASS_KeyNodeInformation: _KEY_INFORMATION_CLASS = 1;
pub const _KEY_INFORMATION_CLASS_KeyFullInformation: _KEY_INFORMATION_CLASS = 2;
pub const _KEY_INFORMATION_CLASS_KeyNameInformation: _KEY_INFORMATION_CLASS = 3;
pub const _KEY_INFORMATION_CLASS_KeyCachedInformation: _KEY_INFORMATION_CLASS = 4;
pub const _KEY_INFORMATION_CLASS_KeyFlagsInformation: _KEY_INFORMATION_CLASS = 5;
pub const _KEY_INFORMATION_CLASS_KeyVirtualizationInformation: _KEY_INFORMATION_CLASS = 6;
pub const _KEY_INFORMATION_CLASS_KeyHandleTagsInformation: _KEY_INFORMATION_CLASS = 7;
pub const _KEY_INFORMATION_CLASS_KeyTrustInformation: _KEY_INFORMATION_CLASS = 8;
pub const _KEY_INFORMATION_CLASS_KeyLayerInformation: _KEY_INFORMATION_CLASS = 9;
pub const _KEY_INFORMATION_CLASS_MaxKeyInfoClass: _KEY_INFORMATION_CLASS = 10;
pub type _KEY_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_KEY_INFORMATION_CLASS as KEY_INFORMATION_CLASS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KEY_WRITE_TIME_INFORMATION {
    pub LastWriteTime: LARGE_INTEGER,
}
pub type KEY_WRITE_TIME_INFORMATION = _KEY_WRITE_TIME_INFORMATION;
pub type PKEY_WRITE_TIME_INFORMATION = *mut _KEY_WRITE_TIME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KEY_WOW64_FLAGS_INFORMATION {
    pub UserFlags: ULONG,
}
pub type KEY_WOW64_FLAGS_INFORMATION = _KEY_WOW64_FLAGS_INFORMATION;
pub type PKEY_WOW64_FLAGS_INFORMATION = *mut _KEY_WOW64_FLAGS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KEY_CONTROL_FLAGS_INFORMATION {
    pub ControlFlags: ULONG,
}
pub type KEY_CONTROL_FLAGS_INFORMATION = _KEY_CONTROL_FLAGS_INFORMATION;
pub type PKEY_CONTROL_FLAGS_INFORMATION = *mut _KEY_CONTROL_FLAGS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KEY_SET_VIRTUALIZATION_INFORMATION {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KEY_SET_VIRTUALIZATION_INFORMATION {
    #[inline]
    pub fn VirtualTarget(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VirtualTarget(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VirtualTarget_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VirtualTarget_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VirtualStore(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VirtualStore(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VirtualStore_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VirtualStore_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VirtualSource(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VirtualSource(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VirtualSource_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VirtualSource_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                29u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                29u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        VirtualTarget: ULONG,
        VirtualStore: ULONG,
        VirtualSource: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let VirtualTarget: u32 = unsafe { ::core::mem::transmute(VirtualTarget) };
            VirtualTarget as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let VirtualStore: u32 = unsafe { ::core::mem::transmute(VirtualStore) };
            VirtualStore as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let VirtualSource: u32 = unsafe { ::core::mem::transmute(VirtualSource) };
            VirtualSource as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type KEY_SET_VIRTUALIZATION_INFORMATION = _KEY_SET_VIRTUALIZATION_INFORMATION;
pub type PKEY_SET_VIRTUALIZATION_INFORMATION = *mut _KEY_SET_VIRTUALIZATION_INFORMATION;
pub const _KEY_SET_INFORMATION_CLASS_KeyWriteTimeInformation: _KEY_SET_INFORMATION_CLASS = 0;
pub const _KEY_SET_INFORMATION_CLASS_KeyWow64FlagsInformation: _KEY_SET_INFORMATION_CLASS = 1;
pub const _KEY_SET_INFORMATION_CLASS_KeyControlFlagsInformation: _KEY_SET_INFORMATION_CLASS = 2;
pub const _KEY_SET_INFORMATION_CLASS_KeySetVirtualizationInformation: _KEY_SET_INFORMATION_CLASS =
    3;
pub const _KEY_SET_INFORMATION_CLASS_KeySetDebugInformation: _KEY_SET_INFORMATION_CLASS = 4;
pub const _KEY_SET_INFORMATION_CLASS_KeySetHandleTagsInformation: _KEY_SET_INFORMATION_CLASS = 5;
pub const _KEY_SET_INFORMATION_CLASS_KeySetLayerInformation: _KEY_SET_INFORMATION_CLASS = 6;
pub const _KEY_SET_INFORMATION_CLASS_MaxKeySetInfoClass: _KEY_SET_INFORMATION_CLASS = 7;
pub type _KEY_SET_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_KEY_SET_INFORMATION_CLASS as KEY_SET_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KEY_VALUE_BASIC_INFORMATION {
    pub TitleIndex: ULONG,
    pub Type: ULONG,
    pub NameLength: ULONG,
    pub Name: [WCHAR; 1usize],
}
pub type KEY_VALUE_BASIC_INFORMATION = _KEY_VALUE_BASIC_INFORMATION;
pub type PKEY_VALUE_BASIC_INFORMATION = *mut _KEY_VALUE_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KEY_VALUE_FULL_INFORMATION {
    pub TitleIndex: ULONG,
    pub Type: ULONG,
    pub DataOffset: ULONG,
    pub DataLength: ULONG,
    pub NameLength: ULONG,
    pub Name: [WCHAR; 1usize],
}
pub type KEY_VALUE_FULL_INFORMATION = _KEY_VALUE_FULL_INFORMATION;
pub type PKEY_VALUE_FULL_INFORMATION = *mut _KEY_VALUE_FULL_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KEY_VALUE_PARTIAL_INFORMATION {
    pub TitleIndex: ULONG,
    pub Type: ULONG,
    pub DataLength: ULONG,
    pub Data: [UCHAR; 1usize],
}
pub type KEY_VALUE_PARTIAL_INFORMATION = _KEY_VALUE_PARTIAL_INFORMATION;
pub type PKEY_VALUE_PARTIAL_INFORMATION = *mut _KEY_VALUE_PARTIAL_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 {
    pub Type: ULONG,
    pub DataLength: ULONG,
    pub Data: [UCHAR; 1usize],
}
pub type KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 = _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64;
pub type PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64 = *mut _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KEY_VALUE_LAYER_INFORMATION {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KEY_VALUE_LAYER_INFORMATION {
    #[inline]
    pub fn IsTombstone(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsTombstone(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IsTombstone_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IsTombstone_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        IsTombstone: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let IsTombstone: u32 = unsafe { ::core::mem::transmute(IsTombstone) };
            IsTombstone as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type KEY_VALUE_LAYER_INFORMATION = _KEY_VALUE_LAYER_INFORMATION;
pub type PKEY_VALUE_LAYER_INFORMATION = *mut _KEY_VALUE_LAYER_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KEY_VALUE_ENTRY {
    pub ValueName: PUNICODE_STRING,
    pub DataLength: ULONG,
    pub DataOffset: ULONG,
    pub Type: ULONG,
}
pub type KEY_VALUE_ENTRY = _KEY_VALUE_ENTRY;
pub type PKEY_VALUE_ENTRY = *mut _KEY_VALUE_ENTRY;
pub const _KEY_VALUE_INFORMATION_CLASS_KeyValueBasicInformation: _KEY_VALUE_INFORMATION_CLASS = 0;
pub const _KEY_VALUE_INFORMATION_CLASS_KeyValueFullInformation: _KEY_VALUE_INFORMATION_CLASS = 1;
pub const _KEY_VALUE_INFORMATION_CLASS_KeyValuePartialInformation: _KEY_VALUE_INFORMATION_CLASS = 2;
pub const _KEY_VALUE_INFORMATION_CLASS_KeyValueFullInformationAlign64:
_KEY_VALUE_INFORMATION_CLASS = 3;
pub const _KEY_VALUE_INFORMATION_CLASS_KeyValuePartialInformationAlign64:
_KEY_VALUE_INFORMATION_CLASS = 4;
pub const _KEY_VALUE_INFORMATION_CLASS_KeyValueLayerInformation: _KEY_VALUE_INFORMATION_CLASS = 5;
pub const _KEY_VALUE_INFORMATION_CLASS_MaxKeyValueInfoClass: _KEY_VALUE_INFORMATION_CLASS = 6;
pub type _KEY_VALUE_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_KEY_VALUE_INFORMATION_CLASS as KEY_VALUE_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KEY_TRUST_INFORMATION {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KEY_TRUST_INFORMATION {
    #[inline]
    pub fn TrustedKey(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TrustedKey(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TrustedKey_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_TrustedKey_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TrustedKey: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let TrustedKey: u32 = unsafe { ::core::mem::transmute(TrustedKey) };
            TrustedKey as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type KEY_TRUST_INFORMATION = _KEY_TRUST_INFORMATION;
pub type PKEY_TRUST_INFORMATION = *mut _KEY_TRUST_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_NAME_INFORMATION {
    pub Name: UNICODE_STRING,
}
pub type OBJECT_NAME_INFORMATION = _OBJECT_NAME_INFORMATION;
pub type POBJECT_NAME_INFORMATION = *mut _OBJECT_NAME_INFORMATION;
pub const _SECTION_INHERIT_ViewShare: _SECTION_INHERIT = 1;
pub const _SECTION_INHERIT_ViewUnmap: _SECTION_INHERIT = 2;
pub type _SECTION_INHERIT = core::ffi::c_int;
pub use self::_SECTION_INHERIT as SECTION_INHERIT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEM_ADDRESS_REQUIREMENTS {
    pub LowestStartingAddress: PVOID,
    pub HighestEndingAddress: PVOID,
    pub Alignment: SIZE_T,
}
pub type MEM_ADDRESS_REQUIREMENTS = _MEM_ADDRESS_REQUIREMENTS;
pub type PMEM_ADDRESS_REQUIREMENTS = *mut _MEM_ADDRESS_REQUIREMENTS;
pub const MEM_EXTENDED_PARAMETER_TYPE_MemExtendedParameterInvalidType: MEM_EXTENDED_PARAMETER_TYPE =
    0;
pub const MEM_EXTENDED_PARAMETER_TYPE_MemExtendedParameterAddressRequirements:
MEM_EXTENDED_PARAMETER_TYPE = 1;
pub const MEM_EXTENDED_PARAMETER_TYPE_MemExtendedParameterNumaNode: MEM_EXTENDED_PARAMETER_TYPE = 2;
pub const MEM_EXTENDED_PARAMETER_TYPE_MemExtendedParameterPartitionHandle:
MEM_EXTENDED_PARAMETER_TYPE = 3;
pub const MEM_EXTENDED_PARAMETER_TYPE_MemExtendedParameterUserPhysicalHandle:
MEM_EXTENDED_PARAMETER_TYPE = 4;
pub const MEM_EXTENDED_PARAMETER_TYPE_MemExtendedParameterAttributeFlags:
MEM_EXTENDED_PARAMETER_TYPE = 5;
pub const MEM_EXTENDED_PARAMETER_TYPE_MemExtendedParameterImageMachine:
MEM_EXTENDED_PARAMETER_TYPE = 6;
pub const MEM_EXTENDED_PARAMETER_TYPE_MemExtendedParameterMax: MEM_EXTENDED_PARAMETER_TYPE = 7;
pub type MEM_EXTENDED_PARAMETER_TYPE = core::ffi::c_int;
pub type PMEM_EXTENDED_PARAMETER_TYPE = *mut MEM_EXTENDED_PARAMETER_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MEM_EXTENDED_PARAMETER {
    pub __bindgen_anon_1: MEM_EXTENDED_PARAMETER__bindgen_ty_1,
    pub __bindgen_anon_2: MEM_EXTENDED_PARAMETER__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MEM_EXTENDED_PARAMETER__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl MEM_EXTENDED_PARAMETER__bindgen_ty_1 {
    #[inline]
    pub fn Type(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Type(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Type_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Type_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 56u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 56u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                56u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                56u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(Type: ULONG64, Reserved: ULONG64) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let Type: u64 = unsafe { ::core::mem::transmute(Type) };
            Type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 56u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MEM_EXTENDED_PARAMETER__bindgen_ty_2 {
    pub ULong64: ULONG64,
    pub Pointer: PVOID,
    pub Size: SIZE_T,
    pub Handle: HANDLE,
    pub ULong: ULONG,
}
pub type PMEM_EXTENDED_PARAMETER = *mut MEM_EXTENDED_PARAMETER;
pub const _MEM_DEDICATED_ATTRIBUTE_TYPE_MemDedicatedAttributeReadBandwidth:
_MEM_DEDICATED_ATTRIBUTE_TYPE = 0;
pub const _MEM_DEDICATED_ATTRIBUTE_TYPE_MemDedicatedAttributeReadLatency:
_MEM_DEDICATED_ATTRIBUTE_TYPE = 1;
pub const _MEM_DEDICATED_ATTRIBUTE_TYPE_MemDedicatedAttributeWriteBandwidth:
_MEM_DEDICATED_ATTRIBUTE_TYPE = 2;
pub const _MEM_DEDICATED_ATTRIBUTE_TYPE_MemDedicatedAttributeWriteLatency:
_MEM_DEDICATED_ATTRIBUTE_TYPE = 3;
pub const _MEM_DEDICATED_ATTRIBUTE_TYPE_MemDedicatedAttributeMax: _MEM_DEDICATED_ATTRIBUTE_TYPE = 4;
pub type _MEM_DEDICATED_ATTRIBUTE_TYPE = core::ffi::c_int;
pub use self::_MEM_DEDICATED_ATTRIBUTE_TYPE as MEM_DEDICATED_ATTRIBUTE_TYPE;
pub type PMEM_DEDICATED_ATTRIBUTE_TYPE = *mut _MEM_DEDICATED_ATTRIBUTE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_PARTITION_DEDICATED_MEMORY_OPEN_INFORMATION {
    pub DedicatedMemoryTypeId: ULONG64,
    pub HandleAttributes: ULONG,
    pub DesiredAccess: ACCESS_MASK,
    pub DedicatedMemoryPartitionHandle: HANDLE,
}
pub type MEMORY_PARTITION_DEDICATED_MEMORY_OPEN_INFORMATION =
_MEMORY_PARTITION_DEDICATED_MEMORY_OPEN_INFORMATION;
pub type PMEMORY_PARTITION_DEDICATED_MEMORY_OPEN_INFORMATION =
*mut _MEMORY_PARTITION_DEDICATED_MEMORY_OPEN_INFORMATION;
pub const MEM_SECTION_EXTENDED_PARAMETER_TYPE_MemSectionExtendedParameterInvalidType:
MEM_SECTION_EXTENDED_PARAMETER_TYPE = 0;
pub const MEM_SECTION_EXTENDED_PARAMETER_TYPE_MemSectionExtendedParameterUserPhysicalFlags:
MEM_SECTION_EXTENDED_PARAMETER_TYPE = 1;
pub const MEM_SECTION_EXTENDED_PARAMETER_TYPE_MemSectionExtendedParameterNumaNode:
MEM_SECTION_EXTENDED_PARAMETER_TYPE = 2;
pub const MEM_SECTION_EXTENDED_PARAMETER_TYPE_MemSectionExtendedParameterSigningLevel:
MEM_SECTION_EXTENDED_PARAMETER_TYPE = 3;
pub const MEM_SECTION_EXTENDED_PARAMETER_TYPE_MemSectionExtendedParameterMax:
MEM_SECTION_EXTENDED_PARAMETER_TYPE = 4;
pub type MEM_SECTION_EXTENDED_PARAMETER_TYPE = core::ffi::c_int;
pub type PMEM_SECTION_EXTENDED_PARAMETER_TYPE = *mut MEM_SECTION_EXTENDED_PARAMETER_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLIENT_ID {
    pub UniqueProcess: HANDLE,
    pub UniqueThread: HANDLE,
}
pub type CLIENT_ID = _CLIENT_ID;
pub type PCLIENT_ID = *mut CLIENT_ID;
pub const _PARTITION_INFORMATION_CLASS_SystemMemoryPartitionInformation:
_PARTITION_INFORMATION_CLASS = 0;
pub const _PARTITION_INFORMATION_CLASS_SystemMemoryPartitionDedicatedMemoryInformation:
_PARTITION_INFORMATION_CLASS = 9;
pub const _PARTITION_INFORMATION_CLASS_SystemMemoryPartitionOpenDedicatedMemory:
_PARTITION_INFORMATION_CLASS = 10;
pub type _PARTITION_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_PARTITION_INFORMATION_CLASS as PARTITION_INFORMATION_CLASS;
pub type PPARTITION_INFORMATION_CLASS = *mut _PARTITION_INFORMATION_CLASS;
unsafe extern "C" {
    pub fn NtManagePartition(
        TargetHandle: HANDLE,
        SourceHandle: HANDLE,
        PartitionInformationClass: PARTITION_INFORMATION_CLASS,
        PartitionInformation: PVOID,
        PartitionInformationLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub static GUID_MAX_POWER_SAVINGS: GUID;
}
unsafe extern "C" {
    pub static GUID_MIN_POWER_SAVINGS: GUID;
}
unsafe extern "C" {
    pub static GUID_TYPICAL_POWER_SAVINGS: GUID;
}
unsafe extern "C" {
    pub static NO_SUBGROUP_GUID: GUID;
}
unsafe extern "C" {
    pub static ALL_POWERSCHEMES_GUID: GUID;
}
unsafe extern "C" {
    pub static GUID_POWERSCHEME_PERSONALITY: GUID;
}
unsafe extern "C" {
    pub static GUID_ACTIVE_POWERSCHEME: GUID;
}
unsafe extern "C" {
    pub static GUID_IDLE_RESILIENCY_SUBGROUP: GUID;
}
unsafe extern "C" {
    pub static GUID_IDLE_RESILIENCY_PERIOD: GUID;
}
unsafe extern "C" {
    pub static GUID_DEEP_SLEEP_ENABLED: GUID;
}
unsafe extern "C" {
    pub static GUID_DEEP_SLEEP_PLATFORM_STATE: GUID;
}
unsafe extern "C" {
    pub static GUID_DISK_COALESCING_POWERDOWN_TIMEOUT: GUID;
}
unsafe extern "C" {
    pub static GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT: GUID;
}
unsafe extern "C" {
    pub static GUID_VIDEO_SUBGROUP: GUID;
}
unsafe extern "C" {
    pub static GUID_VIDEO_POWERDOWN_TIMEOUT: GUID;
}
unsafe extern "C" {
    pub static GUID_VIDEO_ANNOYANCE_TIMEOUT: GUID;
}
unsafe extern "C" {
    pub static GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE: GUID;
}
unsafe extern "C" {
    pub static GUID_VIDEO_DIM_TIMEOUT: GUID;
}
unsafe extern "C" {
    pub static GUID_VIDEO_ADAPTIVE_POWERDOWN: GUID;
}
unsafe extern "C" {
    pub static GUID_MONITOR_POWER_ON: GUID;
}
unsafe extern "C" {
    pub static GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS: GUID;
}
unsafe extern "C" {
    pub static GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS: GUID;
}
unsafe extern "C" {
    pub static GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS: GUID;
}
unsafe extern "C" {
    pub static GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS: GUID;
}
unsafe extern "C" {
    pub static GUID_CONSOLE_DISPLAY_STATE: GUID;
}
unsafe extern "C" {
    pub static GUID_ALLOW_DISPLAY_REQUIRED: GUID;
}
unsafe extern "C" {
    pub static GUID_VIDEO_CONSOLE_LOCK_TIMEOUT: GUID;
}
unsafe extern "C" {
    pub static GUID_ADVANCED_COLOR_QUALITY_BIAS: GUID;
}
unsafe extern "C" {
    pub static GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP: GUID;
}
unsafe extern "C" {
    pub static GUID_NON_ADAPTIVE_INPUT_TIMEOUT: GUID;
}
unsafe extern "C" {
    pub static GUID_ADAPTIVE_INPUT_CONTROLLER_STATE: GUID;
}
unsafe extern "C" {
    pub static GUID_DISK_SUBGROUP: GUID;
}
unsafe extern "C" {
    pub static GUID_DISK_MAX_POWER: GUID;
}
unsafe extern "C" {
    pub static GUID_DISK_POWERDOWN_TIMEOUT: GUID;
}
unsafe extern "C" {
    pub static GUID_DISK_IDLE_TIMEOUT: GUID;
}
unsafe extern "C" {
    pub static GUID_DISK_BURST_IGNORE_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_DISK_ADAPTIVE_POWERDOWN: GUID;
}
unsafe extern "C" {
    pub static GUID_DISK_NVME_NOPPME: GUID;
}
unsafe extern "C" {
    pub static GUID_SLEEP_SUBGROUP: GUID;
}
unsafe extern "C" {
    pub static GUID_SLEEP_IDLE_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_STANDBY_TIMEOUT: GUID;
}
unsafe extern "C" {
    pub static GUID_UNATTEND_SLEEP_TIMEOUT: GUID;
}
unsafe extern "C" {
    pub static GUID_HIBERNATE_TIMEOUT: GUID;
}
unsafe extern "C" {
    pub static GUID_HIBERNATE_FASTS4_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_CRITICAL_POWER_TRANSITION: GUID;
}
unsafe extern "C" {
    pub static GUID_SYSTEM_AWAYMODE: GUID;
}
unsafe extern "C" {
    pub static GUID_ALLOW_AWAYMODE: GUID;
}
unsafe extern "C" {
    pub static GUID_USER_PRESENCE_PREDICTION: GUID;
}
unsafe extern "C" {
    pub static GUID_STANDBY_BUDGET_GRACE_PERIOD: GUID;
}
unsafe extern "C" {
    pub static GUID_STANDBY_BUDGET_PERCENT: GUID;
}
unsafe extern "C" {
    pub static GUID_STANDBY_RESERVE_GRACE_PERIOD: GUID;
}
unsafe extern "C" {
    pub static GUID_STANDBY_RESERVE_TIME: GUID;
}
unsafe extern "C" {
    pub static GUID_STANDBY_RESET_PERCENT: GUID;
}
unsafe extern "C" {
    pub static GUID_HUPR_ADAPTIVE_AWAY_DISPLAY_TIMEOUT: GUID;
}
unsafe extern "C" {
    pub static GUID_HUPR_ADAPTIVE_INATTENTIVE_DIM_TIMEOUT: GUID;
}
unsafe extern "C" {
    pub static GUID_HUPR_ADAPTIVE_INATTENTIVE_DISPLAY_TIMEOUT: GUID;
}
unsafe extern "C" {
    pub static GUID_HUPR_ADAPTIVE_AWAY_DIM_TIMEOUT: GUID;
}
unsafe extern "C" {
    pub static GUID_ALLOW_STANDBY_STATES: GUID;
}
unsafe extern "C" {
    pub static GUID_ALLOW_RTC_WAKE: GUID;
}
unsafe extern "C" {
    pub static GUID_LEGACY_RTC_MITIGATION: GUID;
}
unsafe extern "C" {
    pub static GUID_ALLOW_SYSTEM_REQUIRED: GUID;
}
unsafe extern "C" {
    pub static GUID_POWER_SAVING_STATUS: GUID;
}
unsafe extern "C" {
    pub static GUID_ENERGY_SAVER_SUBGROUP: GUID;
}
unsafe extern "C" {
    pub static GUID_ENERGY_SAVER_BATTERY_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_ENERGY_SAVER_BRIGHTNESS: GUID;
}
unsafe extern "C" {
    pub static GUID_ENERGY_SAVER_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_SYSTEM_BUTTON_SUBGROUP: GUID;
}
unsafe extern "C" {
    pub static GUID_POWERBUTTON_ACTION: GUID;
}
unsafe extern "C" {
    pub static GUID_SLEEPBUTTON_ACTION: GUID;
}
unsafe extern "C" {
    pub static GUID_USERINTERFACEBUTTON_ACTION: GUID;
}
unsafe extern "C" {
    pub static GUID_LIDCLOSE_ACTION: GUID;
}
unsafe extern "C" {
    pub static GUID_LIDOPEN_POWERSTATE: GUID;
}
unsafe extern "C" {
    pub static GUID_BATTERY_SUBGROUP: GUID;
}
unsafe extern "C" {
    pub static GUID_BATTERY_DISCHARGE_ACTION_0: GUID;
}
unsafe extern "C" {
    pub static GUID_BATTERY_DISCHARGE_LEVEL_0: GUID;
}
unsafe extern "C" {
    pub static GUID_BATTERY_DISCHARGE_FLAGS_0: GUID;
}
unsafe extern "C" {
    pub static GUID_BATTERY_DISCHARGE_ACTION_1: GUID;
}
unsafe extern "C" {
    pub static GUID_BATTERY_DISCHARGE_LEVEL_1: GUID;
}
unsafe extern "C" {
    pub static GUID_BATTERY_DISCHARGE_FLAGS_1: GUID;
}
unsafe extern "C" {
    pub static GUID_BATTERY_DISCHARGE_ACTION_2: GUID;
}
unsafe extern "C" {
    pub static GUID_BATTERY_DISCHARGE_LEVEL_2: GUID;
}
unsafe extern "C" {
    pub static GUID_BATTERY_DISCHARGE_FLAGS_2: GUID;
}
unsafe extern "C" {
    pub static GUID_BATTERY_DISCHARGE_ACTION_3: GUID;
}
unsafe extern "C" {
    pub static GUID_BATTERY_DISCHARGE_LEVEL_3: GUID;
}
unsafe extern "C" {
    pub static GUID_BATTERY_DISCHARGE_FLAGS_3: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_SETTINGS_SUBGROUP: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_THROTTLE_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_THROTTLE_MAXIMUM: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_THROTTLE_MAXIMUM_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_THROTTLE_MINIMUM: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_THROTTLE_MINIMUM_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_FREQUENCY_LIMIT: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_FREQUENCY_LIMIT_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_ALLOW_THROTTLING: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_IDLESTATE_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERFSTATE_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_INCREASE_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_INCREASE_THRESHOLD_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_DECREASE_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_DECREASE_THRESHOLD_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_INCREASE_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_INCREASE_POLICY_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_DECREASE_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_DECREASE_POLICY_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_INCREASE_TIME: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_INCREASE_TIME_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_DECREASE_TIME: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_DECREASE_TIME_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_TIME_CHECK: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_BOOST_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_BOOST_MODE: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_AUTONOMOUS_MODE: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_ENERGY_PERFORMANCE_PREFERENCE: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_ENERGY_PERFORMANCE_PREFERENCE_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_AUTONOMOUS_ACTIVITY_WINDOW: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_DUTY_CYCLING: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_IDLE_ALLOW_SCALING: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_IDLE_DISABLE: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_IDLE_STATE_MAXIMUM: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_IDLE_TIME_CHECK: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_IDLE_DEMOTE_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_IDLE_PROMOTE_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_INCREASE_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_DECREASE_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_INCREASE_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_DECREASE_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_MAX_CORES: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_MAX_CORES_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_MIN_CORES: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_MIN_CORES_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_INCREASE_TIME: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_DECREASE_TIME: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_DECREASE_FACTOR: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_AFFINITY_WEIGHTING: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_DECREASE_FACTOR: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_WEIGHTING: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PARKING_CORE_OVERRIDE: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PARKING_PERF_STATE: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PARKING_PERF_STATE_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PARKING_CONCURRENCY_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PARKING_HEADROOM_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PARKING_DISTRIBUTION_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_SOFT_PARKING_LATENCY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_HISTORY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_HISTORY_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_INCREASE_HISTORY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_DECREASE_HISTORY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_CORE_PARKING_HISTORY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_LATENCY_HINT: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_LATENCY_HINT_PERF: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_LATENCY_HINT_PERF_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_MODULE_PARKING_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_COMPLEX_PARKING_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_SMT_UNPARKING_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_DISTRIBUTE_UTILITY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_HETEROGENEOUS_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_HETERO_DECREASE_TIME: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_HETERO_INCREASE_TIME: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_HETERO_DECREASE_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_HETERO_DECREASE_THRESHOLD_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_HETERO_INCREASE_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_HETERO_INCREASE_THRESHOLD_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CLASS0_FLOOR_PERF: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CLASS1_INITIAL_PERF: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_THREAD_SCHEDULING_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_SHORT_THREAD_SCHEDULING_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_SHORT_THREAD_RUNTIME_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_SHORT_THREAD_ARCH_CLASS_UPPER_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_SHORT_THREAD_ARCH_CLASS_LOWER_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_LONG_THREAD_ARCH_CLASS_UPPER_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_LONG_THREAD_ARCH_CLASS_LOWER_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_SYSTEM_COOLING_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_DISABLE_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_DISABLE_THRESHOLD_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_ENABLE_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_ENABLE_THRESHOLD_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_DISABLE_TIME: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_DISABLE_TIME_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_ENABLE_TIME: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_ENABLE_TIME_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_EPP_CEILING: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_EPP_CEILING_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_PERF_FLOOR: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_PERF_FLOOR_1: GUID;
}
unsafe extern "C" {
    pub static GUID_LOCK_CONSOLE_ON_WAKE: GUID;
}
unsafe extern "C" {
    pub static GUID_DEVICE_IDLE_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_CONNECTIVITY_IN_STANDBY: GUID;
}
unsafe extern "C" {
    pub static GUID_DISCONNECTED_STANDBY_MODE: GUID;
}
unsafe extern "C" {
    pub static GUID_ACDC_POWER_SOURCE: GUID;
}
unsafe extern "C" {
    pub static GUID_LIDSWITCH_STATE_CHANGE: GUID;
}
unsafe extern "C" {
    pub static GUID_LIDSWITCH_STATE_RELIABILITY: GUID;
}
unsafe extern "C" {
    pub static GUID_BATTERY_PERCENTAGE_REMAINING: GUID;
}
unsafe extern "C" {
    pub static GUID_BATTERY_COUNT: GUID;
}
unsafe extern "C" {
    pub static GUID_GLOBAL_USER_PRESENCE: GUID;
}
unsafe extern "C" {
    pub static GUID_SESSION_DISPLAY_STATUS: GUID;
}
unsafe extern "C" {
    pub static GUID_SESSION_USER_PRESENCE: GUID;
}
unsafe extern "C" {
    pub static GUID_IDLE_BACKGROUND_TASK: GUID;
}
unsafe extern "C" {
    pub static GUID_BACKGROUND_TASK_NOTIFICATION: GUID;
}
unsafe extern "C" {
    pub static GUID_APPLAUNCH_BUTTON: GUID;
}
unsafe extern "C" {
    pub static GUID_PCIEXPRESS_SETTINGS_SUBGROUP: GUID;
}
unsafe extern "C" {
    pub static GUID_PCIEXPRESS_ASPM_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_ENABLE_SWITCH_FORCED_SHUTDOWN: GUID;
}
unsafe extern "C" {
    pub static GUID_INTSTEER_SUBGROUP: GUID;
}
unsafe extern "C" {
    pub static GUID_INTSTEER_MODE: GUID;
}
unsafe extern "C" {
    pub static GUID_INTSTEER_LOAD_PER_PROC_TRIGGER: GUID;
}
unsafe extern "C" {
    pub static GUID_INTSTEER_TIME_UNPARK_TRIGGER: GUID;
}
unsafe extern "C" {
    pub static GUID_GRAPHICS_SUBGROUP: GUID;
}
unsafe extern "C" {
    pub static GUID_GPU_PREFERENCE_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_MIXED_REALITY_MODE: GUID;
}
unsafe extern "C" {
    pub static GUID_SPR_ACTIVE_SESSION_CHANGE: GUID;
}
pub const _SYSTEM_POWER_STATE_PowerSystemUnspecified: _SYSTEM_POWER_STATE = 0;
pub const _SYSTEM_POWER_STATE_PowerSystemWorking: _SYSTEM_POWER_STATE = 1;
pub const _SYSTEM_POWER_STATE_PowerSystemSleeping1: _SYSTEM_POWER_STATE = 2;
pub const _SYSTEM_POWER_STATE_PowerSystemSleeping2: _SYSTEM_POWER_STATE = 3;
pub const _SYSTEM_POWER_STATE_PowerSystemSleeping3: _SYSTEM_POWER_STATE = 4;
pub const _SYSTEM_POWER_STATE_PowerSystemHibernate: _SYSTEM_POWER_STATE = 5;
pub const _SYSTEM_POWER_STATE_PowerSystemShutdown: _SYSTEM_POWER_STATE = 6;
pub const _SYSTEM_POWER_STATE_PowerSystemMaximum: _SYSTEM_POWER_STATE = 7;
pub type _SYSTEM_POWER_STATE = core::ffi::c_int;
pub use self::_SYSTEM_POWER_STATE as SYSTEM_POWER_STATE;
pub type PSYSTEM_POWER_STATE = *mut _SYSTEM_POWER_STATE;
pub const POWER_ACTION_PowerActionNone: POWER_ACTION = 0;
pub const POWER_ACTION_PowerActionReserved: POWER_ACTION = 1;
pub const POWER_ACTION_PowerActionSleep: POWER_ACTION = 2;
pub const POWER_ACTION_PowerActionHibernate: POWER_ACTION = 3;
pub const POWER_ACTION_PowerActionShutdown: POWER_ACTION = 4;
pub const POWER_ACTION_PowerActionShutdownReset: POWER_ACTION = 5;
pub const POWER_ACTION_PowerActionShutdownOff: POWER_ACTION = 6;
pub const POWER_ACTION_PowerActionWarmEject: POWER_ACTION = 7;
pub const POWER_ACTION_PowerActionDisplayOff: POWER_ACTION = 8;
pub type POWER_ACTION = core::ffi::c_int;
pub type PPOWER_ACTION = *mut POWER_ACTION;
pub const _DEVICE_POWER_STATE_PowerDeviceUnspecified: _DEVICE_POWER_STATE = 0;
pub const _DEVICE_POWER_STATE_PowerDeviceD0: _DEVICE_POWER_STATE = 1;
pub const _DEVICE_POWER_STATE_PowerDeviceD1: _DEVICE_POWER_STATE = 2;
pub const _DEVICE_POWER_STATE_PowerDeviceD2: _DEVICE_POWER_STATE = 3;
pub const _DEVICE_POWER_STATE_PowerDeviceD3: _DEVICE_POWER_STATE = 4;
pub const _DEVICE_POWER_STATE_PowerDeviceMaximum: _DEVICE_POWER_STATE = 5;
pub type _DEVICE_POWER_STATE = core::ffi::c_int;
pub use self::_DEVICE_POWER_STATE as DEVICE_POWER_STATE;
pub type PDEVICE_POWER_STATE = *mut _DEVICE_POWER_STATE;
pub const _MONITOR_DISPLAY_STATE_PowerMonitorOff: _MONITOR_DISPLAY_STATE = 0;
pub const _MONITOR_DISPLAY_STATE_PowerMonitorOn: _MONITOR_DISPLAY_STATE = 1;
pub const _MONITOR_DISPLAY_STATE_PowerMonitorDim: _MONITOR_DISPLAY_STATE = 2;
pub type _MONITOR_DISPLAY_STATE = core::ffi::c_int;
pub use self::_MONITOR_DISPLAY_STATE as MONITOR_DISPLAY_STATE;
pub type PMONITOR_DISPLAY_STATE = *mut _MONITOR_DISPLAY_STATE;
pub const _USER_ACTIVITY_PRESENCE_PowerUserPresent: _USER_ACTIVITY_PRESENCE = 0;
pub const _USER_ACTIVITY_PRESENCE_PowerUserNotPresent: _USER_ACTIVITY_PRESENCE = 1;
pub const _USER_ACTIVITY_PRESENCE_PowerUserInactive: _USER_ACTIVITY_PRESENCE = 2;
pub const _USER_ACTIVITY_PRESENCE_PowerUserMaximum: _USER_ACTIVITY_PRESENCE = 3;
pub const _USER_ACTIVITY_PRESENCE_PowerUserInvalid: _USER_ACTIVITY_PRESENCE = 3;
pub type _USER_ACTIVITY_PRESENCE = core::ffi::c_int;
pub use self::_USER_ACTIVITY_PRESENCE as USER_ACTIVITY_PRESENCE;
pub type PUSER_ACTIVITY_PRESENCE = *mut _USER_ACTIVITY_PRESENCE;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _POWER_STATE {
    pub SystemState: SYSTEM_POWER_STATE,
    pub DeviceState: DEVICE_POWER_STATE,
}
pub type POWER_STATE = _POWER_STATE;
pub type PPOWER_STATE = *mut _POWER_STATE;
pub const _POWER_STATE_TYPE_SystemPowerState: _POWER_STATE_TYPE = 0;
pub const _POWER_STATE_TYPE_DevicePowerState: _POWER_STATE_TYPE = 1;
pub type _POWER_STATE_TYPE = core::ffi::c_int;
pub use self::_POWER_STATE_TYPE as POWER_STATE_TYPE;
pub type PPOWER_STATE_TYPE = *mut _POWER_STATE_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_POWER_STATE_CONTEXT {
    pub __bindgen_anon_1: _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1 {
    pub __bindgen_anon_1: _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1,
    pub ContextAsUlong: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TargetSystemState(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_TargetSystemState(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TargetSystemState_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_TargetSystemState_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EffectiveSystemState(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_EffectiveSystemState(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EffectiveSystemState_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_EffectiveSystemState_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CurrentSystemState(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_CurrentSystemState(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CurrentSystemState_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CurrentSystemState_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IgnoreHibernationPath(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IgnoreHibernationPath(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IgnoreHibernationPath_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IgnoreHibernationPath_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PseudoTransition(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PseudoTransition(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PseudoTransition_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PseudoTransition_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn KernelSoftReboot(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_KernelSoftReboot(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn KernelSoftReboot_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_KernelSoftReboot_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DirectedDripsTransition(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DirectedDripsTransition(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DirectedDripsTransition_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DirectedDripsTransition_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Reserved1: ULONG,
        TargetSystemState: ULONG,
        EffectiveSystemState: ULONG,
        CurrentSystemState: ULONG,
        IgnoreHibernationPath: ULONG,
        PseudoTransition: ULONG,
        KernelSoftReboot: ULONG,
        DirectedDripsTransition: ULONG,
        Reserved2: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let TargetSystemState: u32 = unsafe { ::core::mem::transmute(TargetSystemState) };
            TargetSystemState as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let EffectiveSystemState: u32 = unsafe { ::core::mem::transmute(EffectiveSystemState) };
            EffectiveSystemState as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let CurrentSystemState: u32 = unsafe { ::core::mem::transmute(CurrentSystemState) };
            CurrentSystemState as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let IgnoreHibernationPath: u32 =
                unsafe { ::core::mem::transmute(IgnoreHibernationPath) };
            IgnoreHibernationPath as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let PseudoTransition: u32 = unsafe { ::core::mem::transmute(PseudoTransition) };
            PseudoTransition as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let KernelSoftReboot: u32 = unsafe { ::core::mem::transmute(KernelSoftReboot) };
            KernelSoftReboot as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let DirectedDripsTransition: u32 =
                unsafe { ::core::mem::transmute(DirectedDripsTransition) };
            DirectedDripsTransition as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let Reserved2: u32 = unsafe { ::core::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type SYSTEM_POWER_STATE_CONTEXT = _SYSTEM_POWER_STATE_CONTEXT;
pub type PSYSTEM_POWER_STATE_CONTEXT = *mut _SYSTEM_POWER_STATE_CONTEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _COUNTED_REASON_CONTEXT {
    pub Version: ULONG,
    pub Flags: ULONG,
    pub __bindgen_anon_1: _COUNTED_REASON_CONTEXT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _COUNTED_REASON_CONTEXT__bindgen_ty_1 {
    pub __bindgen_anon_1: _COUNTED_REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1,
    pub SimpleString: UNICODE_STRING,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _COUNTED_REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    pub ResourceFileName: UNICODE_STRING,
    pub ResourceReasonId: USHORT,
    pub StringCount: ULONG,
    pub ReasonStrings: PUNICODE_STRING,
}
pub type COUNTED_REASON_CONTEXT = _COUNTED_REASON_CONTEXT;
pub type PCOUNTED_REASON_CONTEXT = *mut _COUNTED_REASON_CONTEXT;
pub type EXECUTION_STATE = ULONG;
pub type PEXECUTION_STATE = *mut ULONG;
pub const LATENCY_TIME_LT_DONT_CARE: LATENCY_TIME = 0;
pub const LATENCY_TIME_LT_LOWEST_LATENCY: LATENCY_TIME = 1;
pub type LATENCY_TIME = core::ffi::c_int;
pub const _POWER_REQUEST_TYPE_PowerRequestDisplayRequired: _POWER_REQUEST_TYPE = 0;
pub const _POWER_REQUEST_TYPE_PowerRequestSystemRequired: _POWER_REQUEST_TYPE = 1;
pub const _POWER_REQUEST_TYPE_PowerRequestAwayModeRequired: _POWER_REQUEST_TYPE = 2;
pub const _POWER_REQUEST_TYPE_PowerRequestExecutionRequired: _POWER_REQUEST_TYPE = 3;
pub type _POWER_REQUEST_TYPE = core::ffi::c_int;
pub use self::_POWER_REQUEST_TYPE as POWER_REQUEST_TYPE;
pub type PPOWER_REQUEST_TYPE = *mut _POWER_REQUEST_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CM_Power_Data_s {
    pub PD_Size: ULONG,
    pub PD_MostRecentPowerState: DEVICE_POWER_STATE,
    pub PD_Capabilities: ULONG,
    pub PD_D1Latency: ULONG,
    pub PD_D2Latency: ULONG,
    pub PD_D3Latency: ULONG,
    pub PD_PowerStateMapping: [DEVICE_POWER_STATE; 7usize],
    pub PD_DeepestSystemWake: SYSTEM_POWER_STATE,
}
pub type CM_POWER_DATA = CM_Power_Data_s;
pub type PCM_POWER_DATA = *mut CM_Power_Data_s;
pub const POWER_INFORMATION_LEVEL_SystemPowerPolicyAc: POWER_INFORMATION_LEVEL = 0;
pub const POWER_INFORMATION_LEVEL_SystemPowerPolicyDc: POWER_INFORMATION_LEVEL = 1;
pub const POWER_INFORMATION_LEVEL_VerifySystemPolicyAc: POWER_INFORMATION_LEVEL = 2;
pub const POWER_INFORMATION_LEVEL_VerifySystemPolicyDc: POWER_INFORMATION_LEVEL = 3;
pub const POWER_INFORMATION_LEVEL_SystemPowerCapabilities: POWER_INFORMATION_LEVEL = 4;
pub const POWER_INFORMATION_LEVEL_SystemBatteryState: POWER_INFORMATION_LEVEL = 5;
pub const POWER_INFORMATION_LEVEL_SystemPowerStateHandler: POWER_INFORMATION_LEVEL = 6;
pub const POWER_INFORMATION_LEVEL_ProcessorStateHandler: POWER_INFORMATION_LEVEL = 7;
pub const POWER_INFORMATION_LEVEL_SystemPowerPolicyCurrent: POWER_INFORMATION_LEVEL = 8;
pub const POWER_INFORMATION_LEVEL_AdministratorPowerPolicy: POWER_INFORMATION_LEVEL = 9;
pub const POWER_INFORMATION_LEVEL_SystemReserveHiberFile: POWER_INFORMATION_LEVEL = 10;
pub const POWER_INFORMATION_LEVEL_ProcessorInformation: POWER_INFORMATION_LEVEL = 11;
pub const POWER_INFORMATION_LEVEL_SystemPowerInformation: POWER_INFORMATION_LEVEL = 12;
pub const POWER_INFORMATION_LEVEL_ProcessorStateHandler2: POWER_INFORMATION_LEVEL = 13;
pub const POWER_INFORMATION_LEVEL_LastWakeTime: POWER_INFORMATION_LEVEL = 14;
pub const POWER_INFORMATION_LEVEL_LastSleepTime: POWER_INFORMATION_LEVEL = 15;
pub const POWER_INFORMATION_LEVEL_SystemExecutionState: POWER_INFORMATION_LEVEL = 16;
pub const POWER_INFORMATION_LEVEL_SystemPowerStateNotifyHandler: POWER_INFORMATION_LEVEL = 17;
pub const POWER_INFORMATION_LEVEL_ProcessorPowerPolicyAc: POWER_INFORMATION_LEVEL = 18;
pub const POWER_INFORMATION_LEVEL_ProcessorPowerPolicyDc: POWER_INFORMATION_LEVEL = 19;
pub const POWER_INFORMATION_LEVEL_VerifyProcessorPowerPolicyAc: POWER_INFORMATION_LEVEL = 20;
pub const POWER_INFORMATION_LEVEL_VerifyProcessorPowerPolicyDc: POWER_INFORMATION_LEVEL = 21;
pub const POWER_INFORMATION_LEVEL_ProcessorPowerPolicyCurrent: POWER_INFORMATION_LEVEL = 22;
pub const POWER_INFORMATION_LEVEL_SystemPowerStateLogging: POWER_INFORMATION_LEVEL = 23;
pub const POWER_INFORMATION_LEVEL_SystemPowerLoggingEntry: POWER_INFORMATION_LEVEL = 24;
pub const POWER_INFORMATION_LEVEL_SetPowerSettingValue: POWER_INFORMATION_LEVEL = 25;
pub const POWER_INFORMATION_LEVEL_NotifyUserPowerSetting: POWER_INFORMATION_LEVEL = 26;
pub const POWER_INFORMATION_LEVEL_PowerInformationLevelUnused0: POWER_INFORMATION_LEVEL = 27;
pub const POWER_INFORMATION_LEVEL_SystemMonitorHiberBootPowerOff: POWER_INFORMATION_LEVEL = 28;
pub const POWER_INFORMATION_LEVEL_SystemVideoState: POWER_INFORMATION_LEVEL = 29;
pub const POWER_INFORMATION_LEVEL_TraceApplicationPowerMessage: POWER_INFORMATION_LEVEL = 30;
pub const POWER_INFORMATION_LEVEL_TraceApplicationPowerMessageEnd: POWER_INFORMATION_LEVEL = 31;
pub const POWER_INFORMATION_LEVEL_ProcessorPerfStates: POWER_INFORMATION_LEVEL = 32;
pub const POWER_INFORMATION_LEVEL_ProcessorIdleStates: POWER_INFORMATION_LEVEL = 33;
pub const POWER_INFORMATION_LEVEL_ProcessorCap: POWER_INFORMATION_LEVEL = 34;
pub const POWER_INFORMATION_LEVEL_SystemWakeSource: POWER_INFORMATION_LEVEL = 35;
pub const POWER_INFORMATION_LEVEL_SystemHiberFileInformation: POWER_INFORMATION_LEVEL = 36;
pub const POWER_INFORMATION_LEVEL_TraceServicePowerMessage: POWER_INFORMATION_LEVEL = 37;
pub const POWER_INFORMATION_LEVEL_ProcessorLoad: POWER_INFORMATION_LEVEL = 38;
pub const POWER_INFORMATION_LEVEL_PowerShutdownNotification: POWER_INFORMATION_LEVEL = 39;
pub const POWER_INFORMATION_LEVEL_MonitorCapabilities: POWER_INFORMATION_LEVEL = 40;
pub const POWER_INFORMATION_LEVEL_SessionPowerInit: POWER_INFORMATION_LEVEL = 41;
pub const POWER_INFORMATION_LEVEL_SessionDisplayState: POWER_INFORMATION_LEVEL = 42;
pub const POWER_INFORMATION_LEVEL_PowerRequestCreate: POWER_INFORMATION_LEVEL = 43;
pub const POWER_INFORMATION_LEVEL_PowerRequestAction: POWER_INFORMATION_LEVEL = 44;
pub const POWER_INFORMATION_LEVEL_GetPowerRequestList: POWER_INFORMATION_LEVEL = 45;
pub const POWER_INFORMATION_LEVEL_ProcessorInformationEx: POWER_INFORMATION_LEVEL = 46;
pub const POWER_INFORMATION_LEVEL_NotifyUserModeLegacyPowerEvent: POWER_INFORMATION_LEVEL = 47;
pub const POWER_INFORMATION_LEVEL_GroupPark: POWER_INFORMATION_LEVEL = 48;
pub const POWER_INFORMATION_LEVEL_ProcessorIdleDomains: POWER_INFORMATION_LEVEL = 49;
pub const POWER_INFORMATION_LEVEL_WakeTimerList: POWER_INFORMATION_LEVEL = 50;
pub const POWER_INFORMATION_LEVEL_SystemHiberFileSize: POWER_INFORMATION_LEVEL = 51;
pub const POWER_INFORMATION_LEVEL_ProcessorIdleStatesHv: POWER_INFORMATION_LEVEL = 52;
pub const POWER_INFORMATION_LEVEL_ProcessorPerfStatesHv: POWER_INFORMATION_LEVEL = 53;
pub const POWER_INFORMATION_LEVEL_ProcessorPerfCapHv: POWER_INFORMATION_LEVEL = 54;
pub const POWER_INFORMATION_LEVEL_ProcessorSetIdle: POWER_INFORMATION_LEVEL = 55;
pub const POWER_INFORMATION_LEVEL_LogicalProcessorIdling: POWER_INFORMATION_LEVEL = 56;
pub const POWER_INFORMATION_LEVEL_UserPresence: POWER_INFORMATION_LEVEL = 57;
pub const POWER_INFORMATION_LEVEL_PowerSettingNotificationName: POWER_INFORMATION_LEVEL = 58;
pub const POWER_INFORMATION_LEVEL_GetPowerSettingValue: POWER_INFORMATION_LEVEL = 59;
pub const POWER_INFORMATION_LEVEL_IdleResiliency: POWER_INFORMATION_LEVEL = 60;
pub const POWER_INFORMATION_LEVEL_SessionRITState: POWER_INFORMATION_LEVEL = 61;
pub const POWER_INFORMATION_LEVEL_SessionConnectNotification: POWER_INFORMATION_LEVEL = 62;
pub const POWER_INFORMATION_LEVEL_SessionPowerCleanup: POWER_INFORMATION_LEVEL = 63;
pub const POWER_INFORMATION_LEVEL_SessionLockState: POWER_INFORMATION_LEVEL = 64;
pub const POWER_INFORMATION_LEVEL_SystemHiberbootState: POWER_INFORMATION_LEVEL = 65;
pub const POWER_INFORMATION_LEVEL_PlatformInformation: POWER_INFORMATION_LEVEL = 66;
pub const POWER_INFORMATION_LEVEL_PdcInvocation: POWER_INFORMATION_LEVEL = 67;
pub const POWER_INFORMATION_LEVEL_MonitorInvocation: POWER_INFORMATION_LEVEL = 68;
pub const POWER_INFORMATION_LEVEL_FirmwareTableInformationRegistered: POWER_INFORMATION_LEVEL = 69;
pub const POWER_INFORMATION_LEVEL_SetShutdownSelectedTime: POWER_INFORMATION_LEVEL = 70;
pub const POWER_INFORMATION_LEVEL_SuspendResumeInvocation: POWER_INFORMATION_LEVEL = 71;
pub const POWER_INFORMATION_LEVEL_PlmPowerRequestCreate: POWER_INFORMATION_LEVEL = 72;
pub const POWER_INFORMATION_LEVEL_ScreenOff: POWER_INFORMATION_LEVEL = 73;
pub const POWER_INFORMATION_LEVEL_CsDeviceNotification: POWER_INFORMATION_LEVEL = 74;
pub const POWER_INFORMATION_LEVEL_PlatformRole: POWER_INFORMATION_LEVEL = 75;
pub const POWER_INFORMATION_LEVEL_LastResumePerformance: POWER_INFORMATION_LEVEL = 76;
pub const POWER_INFORMATION_LEVEL_DisplayBurst: POWER_INFORMATION_LEVEL = 77;
pub const POWER_INFORMATION_LEVEL_ExitLatencySamplingPercentage: POWER_INFORMATION_LEVEL = 78;
pub const POWER_INFORMATION_LEVEL_RegisterSpmPowerSettings: POWER_INFORMATION_LEVEL = 79;
pub const POWER_INFORMATION_LEVEL_PlatformIdleStates: POWER_INFORMATION_LEVEL = 80;
pub const POWER_INFORMATION_LEVEL_ProcessorIdleVeto: POWER_INFORMATION_LEVEL = 81;
pub const POWER_INFORMATION_LEVEL_PlatformIdleVeto: POWER_INFORMATION_LEVEL = 82;
pub const POWER_INFORMATION_LEVEL_SystemBatteryStatePrecise: POWER_INFORMATION_LEVEL = 83;
pub const POWER_INFORMATION_LEVEL_ThermalEvent: POWER_INFORMATION_LEVEL = 84;
pub const POWER_INFORMATION_LEVEL_PowerRequestActionInternal: POWER_INFORMATION_LEVEL = 85;
pub const POWER_INFORMATION_LEVEL_BatteryDeviceState: POWER_INFORMATION_LEVEL = 86;
pub const POWER_INFORMATION_LEVEL_PowerInformationInternal: POWER_INFORMATION_LEVEL = 87;
pub const POWER_INFORMATION_LEVEL_ThermalStandby: POWER_INFORMATION_LEVEL = 88;
pub const POWER_INFORMATION_LEVEL_SystemHiberFileType: POWER_INFORMATION_LEVEL = 89;
pub const POWER_INFORMATION_LEVEL_PhysicalPowerButtonPress: POWER_INFORMATION_LEVEL = 90;
pub const POWER_INFORMATION_LEVEL_QueryPotentialDripsConstraint: POWER_INFORMATION_LEVEL = 91;
pub const POWER_INFORMATION_LEVEL_EnergyTrackerCreate: POWER_INFORMATION_LEVEL = 92;
pub const POWER_INFORMATION_LEVEL_EnergyTrackerQuery: POWER_INFORMATION_LEVEL = 93;
pub const POWER_INFORMATION_LEVEL_UpdateBlackBoxRecorder: POWER_INFORMATION_LEVEL = 94;
pub const POWER_INFORMATION_LEVEL_SessionAllowExternalDmaDevices: POWER_INFORMATION_LEVEL = 95;
pub const POWER_INFORMATION_LEVEL_SendSuspendResumeNotification: POWER_INFORMATION_LEVEL = 96;
pub const POWER_INFORMATION_LEVEL_BlackBoxRecorderDirectAccessBuffer: POWER_INFORMATION_LEVEL = 97;
pub const POWER_INFORMATION_LEVEL_PowerInformationLevelMaximum: POWER_INFORMATION_LEVEL = 98;
pub type POWER_INFORMATION_LEVEL = core::ffi::c_int;
pub const POWER_USER_PRESENCE_TYPE_UserNotPresent: POWER_USER_PRESENCE_TYPE = 0;
pub const POWER_USER_PRESENCE_TYPE_UserPresent: POWER_USER_PRESENCE_TYPE = 1;
pub const POWER_USER_PRESENCE_TYPE_UserUnknown: POWER_USER_PRESENCE_TYPE = 255;
pub type POWER_USER_PRESENCE_TYPE = core::ffi::c_int;
pub type PPOWER_USER_PRESENCE_TYPE = *mut POWER_USER_PRESENCE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_USER_PRESENCE {
    pub UserPresence: POWER_USER_PRESENCE_TYPE,
}
pub type POWER_USER_PRESENCE = _POWER_USER_PRESENCE;
pub type PPOWER_USER_PRESENCE = *mut _POWER_USER_PRESENCE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_SESSION_CONNECT {
    pub Connected: BOOLEAN,
    pub Console: BOOLEAN,
}
pub type POWER_SESSION_CONNECT = _POWER_SESSION_CONNECT;
pub type PPOWER_SESSION_CONNECT = *mut _POWER_SESSION_CONNECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_SESSION_TIMEOUTS {
    pub InputTimeout: ULONG,
    pub DisplayTimeout: ULONG,
}
pub type POWER_SESSION_TIMEOUTS = _POWER_SESSION_TIMEOUTS;
pub type PPOWER_SESSION_TIMEOUTS = *mut _POWER_SESSION_TIMEOUTS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_SESSION_RIT_STATE {
    pub Active: BOOLEAN,
    pub LastInputTime: ULONG64,
}
pub type POWER_SESSION_RIT_STATE = _POWER_SESSION_RIT_STATE;
pub type PPOWER_SESSION_RIT_STATE = *mut _POWER_SESSION_RIT_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_SESSION_WINLOGON {
    pub SessionId: ULONG,
    pub Console: BOOLEAN,
    pub Locked: BOOLEAN,
}
pub type POWER_SESSION_WINLOGON = _POWER_SESSION_WINLOGON;
pub type PPOWER_SESSION_WINLOGON = *mut _POWER_SESSION_WINLOGON;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES {
    pub IsAllowed: BOOLEAN,
}
pub type POWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES = _POWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES;
pub type PPOWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES = *mut _POWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_IDLE_RESILIENCY {
    pub CoalescingTimeout: ULONG,
    pub IdleResiliencyPeriod: ULONG,
}
pub type POWER_IDLE_RESILIENCY = _POWER_IDLE_RESILIENCY;
pub type PPOWER_IDLE_RESILIENCY = *mut _POWER_IDLE_RESILIENCY;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUnknown: POWER_MONITOR_REQUEST_REASON =
    0;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPowerButton:
POWER_MONITOR_REQUEST_REASON = 1;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonRemoteConnection:
POWER_MONITOR_REQUEST_REASON = 2;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonScMonitorpower:
POWER_MONITOR_REQUEST_REASON = 3;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInput: POWER_MONITOR_REQUEST_REASON =
    4;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonAcDcDisplayBurst:
POWER_MONITOR_REQUEST_REASON = 5;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserDisplayBurst:
POWER_MONITOR_REQUEST_REASON = 6;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPoSetSystemState:
POWER_MONITOR_REQUEST_REASON = 7;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonSetThreadExecutionState:
POWER_MONITOR_REQUEST_REASON = 8;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonFullWake: POWER_MONITOR_REQUEST_REASON =
    9;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonSessionUnlock:
POWER_MONITOR_REQUEST_REASON = 10;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonScreenOffRequest:
POWER_MONITOR_REQUEST_REASON = 11;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonIdleTimeout:
POWER_MONITOR_REQUEST_REASON = 12;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPolicyChange:
POWER_MONITOR_REQUEST_REASON = 13;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonSleepButton:
POWER_MONITOR_REQUEST_REASON = 14;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonLid: POWER_MONITOR_REQUEST_REASON = 15;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonBatteryCountChange:
POWER_MONITOR_REQUEST_REASON = 16;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonGracePeriod:
POWER_MONITOR_REQUEST_REASON = 17;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPnP: POWER_MONITOR_REQUEST_REASON = 18;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonDP: POWER_MONITOR_REQUEST_REASON = 19;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonSxTransition:
POWER_MONITOR_REQUEST_REASON = 20;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonSystemIdle:
POWER_MONITOR_REQUEST_REASON = 21;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonNearProximity:
POWER_MONITOR_REQUEST_REASON = 22;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonThermalStandby:
POWER_MONITOR_REQUEST_REASON = 23;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonResumePdc: POWER_MONITOR_REQUEST_REASON =
    24;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonResumeS4: POWER_MONITOR_REQUEST_REASON =
    25;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonTerminal: POWER_MONITOR_REQUEST_REASON =
    26;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPdcSignal: POWER_MONITOR_REQUEST_REASON =
    27;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonAcDcDisplayBurstSuppressed:
POWER_MONITOR_REQUEST_REASON = 28;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonSystemStateEntered:
POWER_MONITOR_REQUEST_REASON = 29;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonWinrt: POWER_MONITOR_REQUEST_REASON = 30;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputKeyboard:
POWER_MONITOR_REQUEST_REASON = 31;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputMouse:
POWER_MONITOR_REQUEST_REASON = 32;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputTouchpad:
POWER_MONITOR_REQUEST_REASON = 33;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputPen:
POWER_MONITOR_REQUEST_REASON = 34;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputAccelerometer:
POWER_MONITOR_REQUEST_REASON = 35;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputHid:
POWER_MONITOR_REQUEST_REASON = 36;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputPoUserPresent:
POWER_MONITOR_REQUEST_REASON = 37;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputSessionSwitch:
POWER_MONITOR_REQUEST_REASON = 38;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputInitialization:
POWER_MONITOR_REQUEST_REASON = 39;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPdcSignalWindowsMobilePwrNotif:
POWER_MONITOR_REQUEST_REASON = 40;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPdcSignalWindowsMobileShell:
POWER_MONITOR_REQUEST_REASON = 41;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPdcSignalHeyCortana:
POWER_MONITOR_REQUEST_REASON = 42;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPdcSignalHolographicShell:
POWER_MONITOR_REQUEST_REASON = 43;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPdcSignalFingerprint:
POWER_MONITOR_REQUEST_REASON = 44;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonDirectedDrips:
POWER_MONITOR_REQUEST_REASON = 45;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonDim: POWER_MONITOR_REQUEST_REASON = 46;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonBuiltinPanel:
POWER_MONITOR_REQUEST_REASON = 47;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonDisplayRequiredUnDim:
POWER_MONITOR_REQUEST_REASON = 48;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonBatteryCountChangeSuppressed:
POWER_MONITOR_REQUEST_REASON = 49;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonResumeModernStandby:
POWER_MONITOR_REQUEST_REASON = 50;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonTerminalInit:
POWER_MONITOR_REQUEST_REASON = 51;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPdcSignalSensorsHumanPresence:
POWER_MONITOR_REQUEST_REASON = 52;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonBatteryPreCritical:
POWER_MONITOR_REQUEST_REASON = 53;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputTouch:
POWER_MONITOR_REQUEST_REASON = 54;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonMax: POWER_MONITOR_REQUEST_REASON = 55;
pub type POWER_MONITOR_REQUEST_REASON = core::ffi::c_int;
pub const _POWER_MONITOR_REQUEST_TYPE_MonitorRequestTypeOff: _POWER_MONITOR_REQUEST_TYPE = 0;
pub const _POWER_MONITOR_REQUEST_TYPE_MonitorRequestTypeOnAndPresent: _POWER_MONITOR_REQUEST_TYPE =
    1;
pub const _POWER_MONITOR_REQUEST_TYPE_MonitorRequestTypeToggleOn: _POWER_MONITOR_REQUEST_TYPE = 2;
pub type _POWER_MONITOR_REQUEST_TYPE = core::ffi::c_int;
pub use self::_POWER_MONITOR_REQUEST_TYPE as POWER_MONITOR_REQUEST_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_MONITOR_INVOCATION {
    pub Console: BOOLEAN,
    pub RequestReason: POWER_MONITOR_REQUEST_REASON,
}
pub type POWER_MONITOR_INVOCATION = _POWER_MONITOR_INVOCATION;
pub type PPOWER_MONITOR_INVOCATION = *mut _POWER_MONITOR_INVOCATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RESUME_PERFORMANCE {
    pub PostTimeMs: ULONG,
    pub TotalResumeTimeMs: ULONGLONG,
    pub ResumeCompleteTimestamp: ULONGLONG,
}
pub type RESUME_PERFORMANCE = _RESUME_PERFORMANCE;
pub type PRESUME_PERFORMANCE = *mut _RESUME_PERFORMANCE;
pub const SYSTEM_POWER_CONDITION_PoAc: SYSTEM_POWER_CONDITION = 0;
pub const SYSTEM_POWER_CONDITION_PoDc: SYSTEM_POWER_CONDITION = 1;
pub const SYSTEM_POWER_CONDITION_PoHot: SYSTEM_POWER_CONDITION = 2;
pub const SYSTEM_POWER_CONDITION_PoConditionMaximum: SYSTEM_POWER_CONDITION = 3;
pub type SYSTEM_POWER_CONDITION = core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SET_POWER_SETTING_VALUE {
    pub Version: ULONG,
    pub Guid: GUID,
    pub PowerCondition: SYSTEM_POWER_CONDITION,
    pub DataLength: ULONG,
    pub Data: [UCHAR; 1usize],
}
pub type PSET_POWER_SETTING_VALUE = *mut SET_POWER_SETTING_VALUE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NOTIFY_USER_POWER_SETTING {
    pub Guid: GUID,
}
pub type PNOTIFY_USER_POWER_SETTING = *mut NOTIFY_USER_POWER_SETTING;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _APPLICATIONLAUNCH_SETTING_VALUE {
    pub ActivationTime: LARGE_INTEGER,
    pub Flags: ULONG,
    pub ButtonInstanceID: ULONG,
}
pub type APPLICATIONLAUNCH_SETTING_VALUE = _APPLICATIONLAUNCH_SETTING_VALUE;
pub type PAPPLICATIONLAUNCH_SETTING_VALUE = *mut _APPLICATIONLAUNCH_SETTING_VALUE;
pub const _POWER_PLATFORM_ROLE_PlatformRoleUnspecified: _POWER_PLATFORM_ROLE = 0;
pub const _POWER_PLATFORM_ROLE_PlatformRoleDesktop: _POWER_PLATFORM_ROLE = 1;
pub const _POWER_PLATFORM_ROLE_PlatformRoleMobile: _POWER_PLATFORM_ROLE = 2;
pub const _POWER_PLATFORM_ROLE_PlatformRoleWorkstation: _POWER_PLATFORM_ROLE = 3;
pub const _POWER_PLATFORM_ROLE_PlatformRoleEnterpriseServer: _POWER_PLATFORM_ROLE = 4;
pub const _POWER_PLATFORM_ROLE_PlatformRoleSOHOServer: _POWER_PLATFORM_ROLE = 5;
pub const _POWER_PLATFORM_ROLE_PlatformRoleAppliancePC: _POWER_PLATFORM_ROLE = 6;
pub const _POWER_PLATFORM_ROLE_PlatformRolePerformanceServer: _POWER_PLATFORM_ROLE = 7;
pub const _POWER_PLATFORM_ROLE_PlatformRoleSlate: _POWER_PLATFORM_ROLE = 8;
pub const _POWER_PLATFORM_ROLE_PlatformRoleMaximum: _POWER_PLATFORM_ROLE = 9;
pub type _POWER_PLATFORM_ROLE = core::ffi::c_int;
pub use self::_POWER_PLATFORM_ROLE as POWER_PLATFORM_ROLE;
pub type PPOWER_PLATFORM_ROLE = *mut _POWER_PLATFORM_ROLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_PLATFORM_INFORMATION {
    pub AoAc: BOOLEAN,
}
pub type POWER_PLATFORM_INFORMATION = _POWER_PLATFORM_INFORMATION;
pub type PPOWER_PLATFORM_INFORMATION = *mut _POWER_PLATFORM_INFORMATION;
pub const POWER_SETTING_ALTITUDE_ALTITUDE_GROUP_POLICY: POWER_SETTING_ALTITUDE = 0;
pub const POWER_SETTING_ALTITUDE_ALTITUDE_USER: POWER_SETTING_ALTITUDE = 1;
pub const POWER_SETTING_ALTITUDE_ALTITUDE_RUNTIME_OVERRIDE: POWER_SETTING_ALTITUDE = 2;
pub const POWER_SETTING_ALTITUDE_ALTITUDE_PROVISIONING: POWER_SETTING_ALTITUDE = 3;
pub const POWER_SETTING_ALTITUDE_ALTITUDE_OEM_CUSTOMIZATION: POWER_SETTING_ALTITUDE = 4;
pub const POWER_SETTING_ALTITUDE_ALTITUDE_INTERNAL_OVERRIDE: POWER_SETTING_ALTITUDE = 5;
pub const POWER_SETTING_ALTITUDE_ALTITUDE_OS_DEFAULT: POWER_SETTING_ALTITUDE = 6;
pub type POWER_SETTING_ALTITUDE = core::ffi::c_int;
pub type PPOWER_SETTING_ALTITUDE = *mut POWER_SETTING_ALTITUDE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BATTERY_REPORTING_SCALE {
    pub Granularity: ULONG,
    pub Capacity: ULONG,
}
pub type PBATTERY_REPORTING_SCALE = *mut BATTERY_REPORTING_SCALE;
unsafe extern "C" {
    pub fn NtPowerInformation(
        InformationLevel: POWER_INFORMATION_LEVEL,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
    ) -> NTSTATUS;
}
pub const _CM_SERVICE_NODE_TYPE_DriverType: _CM_SERVICE_NODE_TYPE = 1;
pub const _CM_SERVICE_NODE_TYPE_FileSystemType: _CM_SERVICE_NODE_TYPE = 2;
pub const _CM_SERVICE_NODE_TYPE_Win32ServiceOwnProcess: _CM_SERVICE_NODE_TYPE = 16;
pub const _CM_SERVICE_NODE_TYPE_Win32ServiceShareProcess: _CM_SERVICE_NODE_TYPE = 32;
pub const _CM_SERVICE_NODE_TYPE_AdapterType: _CM_SERVICE_NODE_TYPE = 4;
pub const _CM_SERVICE_NODE_TYPE_RecognizerType: _CM_SERVICE_NODE_TYPE = 8;
pub type _CM_SERVICE_NODE_TYPE = core::ffi::c_int;
pub use self::_CM_SERVICE_NODE_TYPE as SERVICE_NODE_TYPE;
pub const _CM_SERVICE_LOAD_TYPE_BootLoad: _CM_SERVICE_LOAD_TYPE = 0;
pub const _CM_SERVICE_LOAD_TYPE_SystemLoad: _CM_SERVICE_LOAD_TYPE = 1;
pub const _CM_SERVICE_LOAD_TYPE_AutoLoad: _CM_SERVICE_LOAD_TYPE = 2;
pub const _CM_SERVICE_LOAD_TYPE_DemandLoad: _CM_SERVICE_LOAD_TYPE = 3;
pub const _CM_SERVICE_LOAD_TYPE_DisableLoad: _CM_SERVICE_LOAD_TYPE = 4;
pub type _CM_SERVICE_LOAD_TYPE = core::ffi::c_int;
pub use self::_CM_SERVICE_LOAD_TYPE as SERVICE_LOAD_TYPE;
pub const _CM_ERROR_CONTROL_TYPE_IgnoreError: _CM_ERROR_CONTROL_TYPE = 0;
pub const _CM_ERROR_CONTROL_TYPE_NormalError: _CM_ERROR_CONTROL_TYPE = 1;
pub const _CM_ERROR_CONTROL_TYPE_SevereError: _CM_ERROR_CONTROL_TYPE = 2;
pub const _CM_ERROR_CONTROL_TYPE_CriticalError: _CM_ERROR_CONTROL_TYPE = 3;
pub type _CM_ERROR_CONTROL_TYPE = core::ffi::c_int;
pub use self::_CM_ERROR_CONTROL_TYPE as SERVICE_ERROR_TYPE;
pub type CM_RESOURCE_TYPE = core::ffi::c_int;
pub const _CM_SHARE_DISPOSITION_CmResourceShareUndetermined: _CM_SHARE_DISPOSITION = 0;
pub const _CM_SHARE_DISPOSITION_CmResourceShareDeviceExclusive: _CM_SHARE_DISPOSITION = 1;
pub const _CM_SHARE_DISPOSITION_CmResourceShareDriverExclusive: _CM_SHARE_DISPOSITION = 2;
pub const _CM_SHARE_DISPOSITION_CmResourceShareShared: _CM_SHARE_DISPOSITION = 3;
pub type _CM_SHARE_DISPOSITION = core::ffi::c_int;
pub use self::_CM_SHARE_DISPOSITION as CM_SHARE_DISPOSITION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
    pub Type: UCHAR,
    pub ShareDisposition: UCHAR,
    pub Flags: USHORT,
    pub u: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1 {
    pub Generic: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
    pub Port: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2,
    pub Interrupt: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3,
    pub MessageInterrupt: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4,
    pub Memory: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5,
    pub Dma: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6,
    pub DmaV3: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7,
    pub DevicePrivate: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8,
    pub BusNumber: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9,
    pub DeviceSpecificData: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10,
    pub Memory40: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11,
    pub Memory48: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12,
    pub Memory64: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13,
    pub Connection: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length: ULONG,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length: ULONG,
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 {
    pub Level: ULONG,
    pub Vector: ULONG,
    pub Affinity: KAFFINITY,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4 {
    pub __bindgen_anon_1: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    pub Raw:
        _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
    pub Translated:
        _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    pub Reserved: USHORT,
    pub MessageCount: USHORT,
    pub Vector: ULONG,
    pub Affinity: KAFFINITY,
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2 {
    pub Level: ULONG,
    pub Vector: ULONG,
    pub Affinity: KAFFINITY,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6 {
    pub Channel: ULONG,
    pub Port: ULONG,
    pub Reserved1: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7 {
    pub Channel: ULONG,
    pub RequestLine: ULONG,
    pub TransferWidth: UCHAR,
    pub Reserved1: UCHAR,
    pub Reserved2: UCHAR,
    pub Reserved3: UCHAR,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8 {
    pub Data: [ULONG; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9 {
    pub Start: ULONG,
    pub Length: ULONG,
    pub Reserved: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10 {
    pub DataSize: ULONG,
    pub Reserved1: ULONG,
    pub Reserved2: ULONG,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length40: ULONG,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length48: ULONG,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length64: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14 {
    pub Class: UCHAR,
    pub Type: UCHAR,
    pub Reserved1: UCHAR,
    pub Reserved2: UCHAR,
    pub IdLowPart: ULONG,
    pub IdHighPart: ULONG,
}
pub type CM_PARTIAL_RESOURCE_DESCRIPTOR = _CM_PARTIAL_RESOURCE_DESCRIPTOR;
pub type PCM_PARTIAL_RESOURCE_DESCRIPTOR = *mut _CM_PARTIAL_RESOURCE_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_LIST {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub Count: ULONG,
    pub PartialDescriptors: [CM_PARTIAL_RESOURCE_DESCRIPTOR; 1usize],
}
pub type CM_PARTIAL_RESOURCE_LIST = _CM_PARTIAL_RESOURCE_LIST;
pub type PCM_PARTIAL_RESOURCE_LIST = *mut _CM_PARTIAL_RESOURCE_LIST;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_FULL_RESOURCE_DESCRIPTOR {
    pub InterfaceType: INTERFACE_TYPE,
    pub BusNumber: ULONG,
    pub PartialResourceList: CM_PARTIAL_RESOURCE_LIST,
}
pub type CM_FULL_RESOURCE_DESCRIPTOR = _CM_FULL_RESOURCE_DESCRIPTOR;
pub type PCM_FULL_RESOURCE_DESCRIPTOR = *mut _CM_FULL_RESOURCE_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_RESOURCE_LIST {
    pub Count: ULONG,
    pub List: [CM_FULL_RESOURCE_DESCRIPTOR; 1usize],
}
pub type CM_RESOURCE_LIST = _CM_RESOURCE_LIST;
pub type PCM_RESOURCE_LIST = *mut _CM_RESOURCE_LIST;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_FLAGS {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _DEVICE_FLAGS {
    #[inline]
    pub fn Failed(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Failed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Failed_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Failed_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReadOnly(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReadOnly(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReadOnly_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReadOnly_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Removable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Removable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Removable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Removable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ConsoleIn(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ConsoleIn(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ConsoleIn_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ConsoleIn_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ConsoleOut(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ConsoleOut(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ConsoleOut_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ConsoleOut_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Input(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Input(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Input_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Input_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Output(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Output(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Output_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Output_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Failed: ULONG,
        ReadOnly: ULONG,
        Removable: ULONG,
        ConsoleIn: ULONG,
        ConsoleOut: ULONG,
        Input: ULONG,
        Output: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Failed: u32 = unsafe { ::core::mem::transmute(Failed) };
            Failed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ReadOnly: u32 = unsafe { ::core::mem::transmute(ReadOnly) };
            ReadOnly as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Removable: u32 = unsafe { ::core::mem::transmute(Removable) };
            Removable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ConsoleIn: u32 = unsafe { ::core::mem::transmute(ConsoleIn) };
            ConsoleIn as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ConsoleOut: u32 = unsafe { ::core::mem::transmute(ConsoleOut) };
            ConsoleOut as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Input: u32 = unsafe { ::core::mem::transmute(Input) };
            Input as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Output: u32 = unsafe { ::core::mem::transmute(Output) };
            Output as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type DEVICE_FLAGS = _DEVICE_FLAGS;
pub type PDEVICE_FLAGS = *mut _DEVICE_FLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_COMPONENT_INFORMATION {
    pub Flags: DEVICE_FLAGS,
    pub Version: ULONG,
    pub Key: ULONG,
    pub AffinityMask: KAFFINITY,
}
pub type CM_COMPONENT_INFORMATION = _CM_COMPONENT_INFORMATION;
pub type PCM_COMPONENT_INFORMATION = *mut _CM_COMPONENT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_ROM_BLOCK {
    pub Address: ULONG,
    pub Size: ULONG,
}
pub type CM_ROM_BLOCK = _CM_ROM_BLOCK;
pub type PCM_ROM_BLOCK = *mut _CM_ROM_BLOCK;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_INT13_DRIVE_PARAMETER {
    pub DriveSelect: USHORT,
    pub MaxCylinders: ULONG,
    pub SectorsPerTrack: USHORT,
    pub MaxHeads: USHORT,
    pub NumberDrives: USHORT,
}
pub type CM_INT13_DRIVE_PARAMETER = _CM_INT13_DRIVE_PARAMETER;
pub type PCM_INT13_DRIVE_PARAMETER = *mut _CM_INT13_DRIVE_PARAMETER;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_MCA_POS_DATA {
    pub AdapterId: USHORT,
    pub PosData1: UCHAR,
    pub PosData2: UCHAR,
    pub PosData3: UCHAR,
    pub PosData4: UCHAR,
}
pub type CM_MCA_POS_DATA = _CM_MCA_POS_DATA;
pub type PCM_MCA_POS_DATA = *mut _CM_MCA_POS_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EISA_MEMORY_TYPE {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _EISA_MEMORY_TYPE {
    #[inline]
    pub fn ReadWrite(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ReadWrite(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReadWrite_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ReadWrite_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Cached(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Cached(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Cached_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Cached_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved0(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved0_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved0_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Type(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Type(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Type_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Type_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Shared(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Shared(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Shared_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Shared_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MoreEntries(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MoreEntries(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MoreEntries_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_MoreEntries_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ReadWrite: UCHAR,
        Cached: UCHAR,
        Reserved0: UCHAR,
        Type: UCHAR,
        Shared: UCHAR,
        Reserved1: UCHAR,
        MoreEntries: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ReadWrite: u8 = unsafe { ::core::mem::transmute(ReadWrite) };
            ReadWrite as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Cached: u8 = unsafe { ::core::mem::transmute(Cached) };
            Cached as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Reserved0: u8 = unsafe { ::core::mem::transmute(Reserved0) };
            Reserved0 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let Type: u8 = unsafe { ::core::mem::transmute(Type) };
            Type as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Shared: u8 = unsafe { ::core::mem::transmute(Shared) };
            Shared as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Reserved1: u8 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let MoreEntries: u8 = unsafe { ::core::mem::transmute(MoreEntries) };
            MoreEntries as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type EISA_MEMORY_TYPE = _EISA_MEMORY_TYPE;
pub type PEISA_MEMORY_TYPE = *mut _EISA_MEMORY_TYPE;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _EISA_MEMORY_CONFIGURATION {
    pub ConfigurationByte: EISA_MEMORY_TYPE,
    pub DataSize: UCHAR,
    pub AddressLowWord: USHORT,
    pub AddressHighByte: UCHAR,
    pub MemorySize: USHORT,
}
pub type EISA_MEMORY_CONFIGURATION = _EISA_MEMORY_CONFIGURATION;
pub type PEISA_MEMORY_CONFIGURATION = *mut _EISA_MEMORY_CONFIGURATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EISA_IRQ_DESCRIPTOR {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _EISA_IRQ_DESCRIPTOR {
    #[inline]
    pub fn Interrupt(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_Interrupt(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Interrupt_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Interrupt_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LevelTriggered(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_LevelTriggered(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LevelTriggered_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_LevelTriggered_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Shared(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Shared(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Shared_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Shared_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MoreEntries(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MoreEntries(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MoreEntries_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_MoreEntries_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Interrupt: UCHAR,
        Reserved: UCHAR,
        LevelTriggered: UCHAR,
        Shared: UCHAR,
        MoreEntries: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let Interrupt: u8 = unsafe { ::core::mem::transmute(Interrupt) };
            Interrupt as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Reserved: u8 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let LevelTriggered: u8 = unsafe { ::core::mem::transmute(LevelTriggered) };
            LevelTriggered as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Shared: u8 = unsafe { ::core::mem::transmute(Shared) };
            Shared as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let MoreEntries: u8 = unsafe { ::core::mem::transmute(MoreEntries) };
            MoreEntries as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type EISA_IRQ_DESCRIPTOR = _EISA_IRQ_DESCRIPTOR;
pub type PEISA_IRQ_DESCRIPTOR = *mut _EISA_IRQ_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EISA_IRQ_CONFIGURATION {
    pub ConfigurationByte: EISA_IRQ_DESCRIPTOR,
    pub Reserved: UCHAR,
}
pub type EISA_IRQ_CONFIGURATION = _EISA_IRQ_CONFIGURATION;
pub type PEISA_IRQ_CONFIGURATION = *mut _EISA_IRQ_CONFIGURATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DMA_CONFIGURATION_BYTE0 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _DMA_CONFIGURATION_BYTE0 {
    #[inline]
    pub fn Channel(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_Channel(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Channel_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Channel_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Shared(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Shared(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Shared_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Shared_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MoreEntries(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MoreEntries(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MoreEntries_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_MoreEntries_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Channel: UCHAR,
        Reserved: UCHAR,
        Shared: UCHAR,
        MoreEntries: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let Channel: u8 = unsafe { ::core::mem::transmute(Channel) };
            Channel as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let Reserved: u8 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Shared: u8 = unsafe { ::core::mem::transmute(Shared) };
            Shared as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let MoreEntries: u8 = unsafe { ::core::mem::transmute(MoreEntries) };
            MoreEntries as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type DMA_CONFIGURATION_BYTE0 = _DMA_CONFIGURATION_BYTE0;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DMA_CONFIGURATION_BYTE1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _DMA_CONFIGURATION_BYTE1 {
    #[inline]
    pub fn Reserved0(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved0_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved0_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TransferSize(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_TransferSize(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TransferSize_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_TransferSize_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Timing(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Timing(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Timing_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Timing_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Reserved0: UCHAR,
        TransferSize: UCHAR,
        Timing: UCHAR,
        Reserved1: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let Reserved0: u8 = unsafe { ::core::mem::transmute(Reserved0) };
            Reserved0 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let TransferSize: u8 = unsafe { ::core::mem::transmute(TransferSize) };
            TransferSize as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let Timing: u8 = unsafe { ::core::mem::transmute(Timing) };
            Timing as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let Reserved1: u8 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type DMA_CONFIGURATION_BYTE1 = _DMA_CONFIGURATION_BYTE1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EISA_DMA_CONFIGURATION {
    pub ConfigurationByte0: DMA_CONFIGURATION_BYTE0,
    pub ConfigurationByte1: DMA_CONFIGURATION_BYTE1,
}
pub type EISA_DMA_CONFIGURATION = _EISA_DMA_CONFIGURATION;
pub type PEISA_DMA_CONFIGURATION = *mut _EISA_DMA_CONFIGURATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EISA_PORT_DESCRIPTOR {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _EISA_PORT_DESCRIPTOR {
    #[inline]
    pub fn NumberPorts(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_NumberPorts(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NumberPorts_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                5u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_NumberPorts_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Shared(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Shared(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Shared_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Shared_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MoreEntries(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MoreEntries(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MoreEntries_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_MoreEntries_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NumberPorts: UCHAR,
        Reserved: UCHAR,
        Shared: UCHAR,
        MoreEntries: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let NumberPorts: u8 = unsafe { ::core::mem::transmute(NumberPorts) };
            NumberPorts as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Reserved: u8 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Shared: u8 = unsafe { ::core::mem::transmute(Shared) };
            Shared as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let MoreEntries: u8 = unsafe { ::core::mem::transmute(MoreEntries) };
            MoreEntries as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type EISA_PORT_DESCRIPTOR = _EISA_PORT_DESCRIPTOR;
pub type PEISA_PORT_DESCRIPTOR = *mut _EISA_PORT_DESCRIPTOR;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _EISA_PORT_CONFIGURATION {
    pub Configuration: EISA_PORT_DESCRIPTOR,
    pub PortAddress: USHORT,
}
pub type EISA_PORT_CONFIGURATION = _EISA_PORT_CONFIGURATION;
pub type PEISA_PORT_CONFIGURATION = *mut _EISA_PORT_CONFIGURATION;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_EISA_SLOT_INFORMATION {
    pub ReturnCode: UCHAR,
    pub ReturnFlags: UCHAR,
    pub MajorRevision: UCHAR,
    pub MinorRevision: UCHAR,
    pub Checksum: USHORT,
    pub NumberFunctions: UCHAR,
    pub FunctionInformation: UCHAR,
    pub CompressedId: ULONG,
}
pub type CM_EISA_SLOT_INFORMATION = _CM_EISA_SLOT_INFORMATION;
pub type PCM_EISA_SLOT_INFORMATION = *mut _CM_EISA_SLOT_INFORMATION;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_EISA_FUNCTION_INFORMATION {
    pub CompressedId: ULONG,
    pub IdSlotFlags1: UCHAR,
    pub IdSlotFlags2: UCHAR,
    pub MinorRevision: UCHAR,
    pub MajorRevision: UCHAR,
    pub Selections: [UCHAR; 26usize],
    pub FunctionFlags: UCHAR,
    pub TypeString: [UCHAR; 80usize],
    pub EisaMemory: [EISA_MEMORY_CONFIGURATION; 9usize],
    pub EisaIrq: [EISA_IRQ_CONFIGURATION; 7usize],
    pub EisaDma: [EISA_DMA_CONFIGURATION; 4usize],
    pub EisaPort: [EISA_PORT_CONFIGURATION; 20usize],
    pub InitializationData: [UCHAR; 60usize],
}
pub type CM_EISA_FUNCTION_INFORMATION = _CM_EISA_FUNCTION_INFORMATION;
pub type PCM_EISA_FUNCTION_INFORMATION = *mut _CM_EISA_FUNCTION_INFORMATION;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PNP_BIOS_DEVICE_NODE {
    pub Size: USHORT,
    pub Node: UCHAR,
    pub ProductId: ULONG,
    pub DeviceType: [UCHAR; 3usize],
    pub DeviceAttributes: USHORT,
}
pub type CM_PNP_BIOS_DEVICE_NODE = _CM_PNP_BIOS_DEVICE_NODE;
pub type PCM_PNP_BIOS_DEVICE_NODE = *mut _CM_PNP_BIOS_DEVICE_NODE;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PNP_BIOS_INSTALLATION_CHECK {
    pub Signature: [UCHAR; 4usize],
    pub Revision: UCHAR,
    pub Length: UCHAR,
    pub ControlField: USHORT,
    pub Checksum: UCHAR,
    pub EventFlagAddress: ULONG,
    pub RealModeEntryOffset: USHORT,
    pub RealModeEntrySegment: USHORT,
    pub ProtectedModeEntryOffset: USHORT,
    pub ProtectedModeCodeBaseAddress: ULONG,
    pub OemDeviceId: ULONG,
    pub RealModeDataBaseAddress: USHORT,
    pub ProtectedModeDataBaseAddress: ULONG,
}
pub type CM_PNP_BIOS_INSTALLATION_CHECK = _CM_PNP_BIOS_INSTALLATION_CHECK;
pub type PCM_PNP_BIOS_INSTALLATION_CHECK = *mut _CM_PNP_BIOS_INSTALLATION_CHECK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_SCSI_DEVICE_DATA {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub HostIdentifier: UCHAR,
}
pub type CM_SCSI_DEVICE_DATA = _CM_SCSI_DEVICE_DATA;
pub type PCM_SCSI_DEVICE_DATA = *mut _CM_SCSI_DEVICE_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_VIDEO_DEVICE_DATA {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub VideoClock: ULONG,
}
pub type CM_VIDEO_DEVICE_DATA = _CM_VIDEO_DEVICE_DATA;
pub type PCM_VIDEO_DEVICE_DATA = *mut _CM_VIDEO_DEVICE_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_SONIC_DEVICE_DATA {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub DataConfigurationRegister: USHORT,
    pub EthernetAddress: [UCHAR; 8usize],
}
pub type CM_SONIC_DEVICE_DATA = _CM_SONIC_DEVICE_DATA;
pub type PCM_SONIC_DEVICE_DATA = *mut _CM_SONIC_DEVICE_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_SERIAL_DEVICE_DATA {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub BaudClock: ULONG,
}
pub type CM_SERIAL_DEVICE_DATA = _CM_SERIAL_DEVICE_DATA;
pub type PCM_SERIAL_DEVICE_DATA = *mut _CM_SERIAL_DEVICE_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_MONITOR_DEVICE_DATA {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub HorizontalScreenSize: USHORT,
    pub VerticalScreenSize: USHORT,
    pub HorizontalResolution: USHORT,
    pub VerticalResolution: USHORT,
    pub HorizontalDisplayTimeLow: USHORT,
    pub HorizontalDisplayTime: USHORT,
    pub HorizontalDisplayTimeHigh: USHORT,
    pub HorizontalBackPorchLow: USHORT,
    pub HorizontalBackPorch: USHORT,
    pub HorizontalBackPorchHigh: USHORT,
    pub HorizontalFrontPorchLow: USHORT,
    pub HorizontalFrontPorch: USHORT,
    pub HorizontalFrontPorchHigh: USHORT,
    pub HorizontalSyncLow: USHORT,
    pub HorizontalSync: USHORT,
    pub HorizontalSyncHigh: USHORT,
    pub VerticalBackPorchLow: USHORT,
    pub VerticalBackPorch: USHORT,
    pub VerticalBackPorchHigh: USHORT,
    pub VerticalFrontPorchLow: USHORT,
    pub VerticalFrontPorch: USHORT,
    pub VerticalFrontPorchHigh: USHORT,
    pub VerticalSyncLow: USHORT,
    pub VerticalSync: USHORT,
    pub VerticalSyncHigh: USHORT,
}
pub type CM_MONITOR_DEVICE_DATA = _CM_MONITOR_DEVICE_DATA;
pub type PCM_MONITOR_DEVICE_DATA = *mut _CM_MONITOR_DEVICE_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_FLOPPY_DEVICE_DATA {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub Size: [CHAR; 8usize],
    pub MaxDensity: ULONG,
    pub MountDensity: ULONG,
    pub StepRateHeadUnloadTime: UCHAR,
    pub HeadLoadTime: UCHAR,
    pub MotorOffTime: UCHAR,
    pub SectorLengthCode: UCHAR,
    pub SectorPerTrack: UCHAR,
    pub ReadWriteGapLength: UCHAR,
    pub DataTransferLength: UCHAR,
    pub FormatGapLength: UCHAR,
    pub FormatFillCharacter: UCHAR,
    pub HeadSettleTime: UCHAR,
    pub MotorSettleTime: UCHAR,
    pub MaximumTrackValue: UCHAR,
    pub DataTransferRate: UCHAR,
}
pub type CM_FLOPPY_DEVICE_DATA = _CM_FLOPPY_DEVICE_DATA;
pub type PCM_FLOPPY_DEVICE_DATA = *mut _CM_FLOPPY_DEVICE_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_KEYBOARD_DEVICE_DATA {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub Type: UCHAR,
    pub Subtype: UCHAR,
    pub KeyboardFlags: USHORT,
}
pub type CM_KEYBOARD_DEVICE_DATA = _CM_KEYBOARD_DEVICE_DATA;
pub type PCM_KEYBOARD_DEVICE_DATA = *mut _CM_KEYBOARD_DEVICE_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_DISK_GEOMETRY_DEVICE_DATA {
    pub BytesPerSector: ULONG,
    pub NumberOfCylinders: ULONG,
    pub SectorsPerTrack: ULONG,
    pub NumberOfHeads: ULONG,
}
pub type CM_DISK_GEOMETRY_DEVICE_DATA = _CM_DISK_GEOMETRY_DEVICE_DATA;
pub type PCM_DISK_GEOMETRY_DEVICE_DATA = *mut _CM_DISK_GEOMETRY_DEVICE_DATA;
pub const _IRQ_DEVICE_POLICY_IrqPolicyMachineDefault: _IRQ_DEVICE_POLICY = 0;
pub const _IRQ_DEVICE_POLICY_IrqPolicyAllCloseProcessors: _IRQ_DEVICE_POLICY = 1;
pub const _IRQ_DEVICE_POLICY_IrqPolicyOneCloseProcessor: _IRQ_DEVICE_POLICY = 2;
pub const _IRQ_DEVICE_POLICY_IrqPolicyAllProcessorsInMachine: _IRQ_DEVICE_POLICY = 3;
pub const _IRQ_DEVICE_POLICY_IrqPolicySpecifiedProcessors: _IRQ_DEVICE_POLICY = 4;
pub const _IRQ_DEVICE_POLICY_IrqPolicySpreadMessagesAcrossAllProcessors: _IRQ_DEVICE_POLICY = 5;
pub const _IRQ_DEVICE_POLICY_IrqPolicyAllProcessorsInMachineWhenSteered: _IRQ_DEVICE_POLICY = 6;
pub type _IRQ_DEVICE_POLICY = core::ffi::c_int;
pub use self::_IRQ_DEVICE_POLICY as IRQ_DEVICE_POLICY;
pub type PIRQ_DEVICE_POLICY = *mut _IRQ_DEVICE_POLICY;
pub const _IRQ_PRIORITY_IrqPriorityUndefined: _IRQ_PRIORITY = 0;
pub const _IRQ_PRIORITY_IrqPriorityLow: _IRQ_PRIORITY = 1;
pub const _IRQ_PRIORITY_IrqPriorityNormal: _IRQ_PRIORITY = 2;
pub const _IRQ_PRIORITY_IrqPriorityHigh: _IRQ_PRIORITY = 3;
pub type _IRQ_PRIORITY = core::ffi::c_int;
pub use self::_IRQ_PRIORITY as IRQ_PRIORITY;
pub type PIRQ_PRIORITY = *mut _IRQ_PRIORITY;
pub const _IRQ_GROUP_POLICY_GroupAffinityAllGroupZero: _IRQ_GROUP_POLICY = 0;
pub const _IRQ_GROUP_POLICY_GroupAffinityDontCare: _IRQ_GROUP_POLICY = 1;
pub type _IRQ_GROUP_POLICY = core::ffi::c_int;
pub use self::_IRQ_GROUP_POLICY as IRQ_GROUP_POLICY;
pub type PIRQ_GROUP_POLICY = *mut _IRQ_GROUP_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR {
    pub Option: UCHAR,
    pub Type: UCHAR,
    pub ShareDisposition: UCHAR,
    pub Spare1: UCHAR,
    pub Flags: USHORT,
    pub Spare2: USHORT,
    pub u: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1 {
    pub Port: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
    pub Memory: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2,
    pub Interrupt: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3,
    pub Dma: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4,
    pub DmaV3: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5,
    pub Generic: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6,
    pub DevicePrivate: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7,
    pub BusNumber: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8,
    pub ConfigData: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9,
    pub Memory40: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10,
    pub Memory48: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11,
    pub Memory64: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12,
    pub Connection: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    pub Length: ULONG,
    pub Alignment: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
    pub Length: ULONG,
    pub Alignment: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 {
    pub MinimumVector: ULONG,
    pub MaximumVector: ULONG,
    pub AffinityPolicy: IRQ_DEVICE_POLICY,
    pub PriorityPolicy: IRQ_PRIORITY,
    pub TargetedProcessors: KAFFINITY,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4 {
    pub MinimumChannel: ULONG,
    pub MaximumChannel: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5 {
    pub RequestLine: ULONG,
    pub Reserved: ULONG,
    pub Channel: ULONG,
    pub TransferWidth: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6 {
    pub Length: ULONG,
    pub Alignment: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7 {
    pub Data: [ULONG; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8 {
    pub Length: ULONG,
    pub MinBusNumber: ULONG,
    pub MaxBusNumber: ULONG,
    pub Reserved: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9 {
    pub Priority: ULONG,
    pub Reserved1: ULONG,
    pub Reserved2: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10 {
    pub Length40: ULONG,
    pub Alignment40: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11 {
    pub Length48: ULONG,
    pub Alignment48: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12 {
    pub Length64: ULONG,
    pub Alignment64: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13 {
    pub Class: UCHAR,
    pub Type: UCHAR,
    pub Reserved1: UCHAR,
    pub Reserved2: UCHAR,
    pub IdLowPart: ULONG,
    pub IdHighPart: ULONG,
}
pub type IO_RESOURCE_DESCRIPTOR = _IO_RESOURCE_DESCRIPTOR;
pub type PIO_RESOURCE_DESCRIPTOR = *mut _IO_RESOURCE_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_LIST {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub Count: ULONG,
    pub Descriptors: [IO_RESOURCE_DESCRIPTOR; 1usize],
}
pub type IO_RESOURCE_LIST = _IO_RESOURCE_LIST;
pub type PIO_RESOURCE_LIST = *mut _IO_RESOURCE_LIST;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_REQUIREMENTS_LIST {
    pub ListSize: ULONG,
    pub InterfaceType: INTERFACE_TYPE,
    pub BusNumber: ULONG,
    pub SlotNumber: ULONG,
    pub Reserved: [ULONG; 3usize],
    pub AlternativeLists: ULONG,
    pub List: [IO_RESOURCE_LIST; 1usize],
}
pub type IO_RESOURCE_REQUIREMENTS_LIST = _IO_RESOURCE_REQUIREMENTS_LIST;
pub type PIO_RESOURCE_REQUIREMENTS_LIST = *mut _IO_RESOURCE_REQUIREMENTS_LIST;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SLIST_ENTRY {
    pub Next: *mut _SLIST_ENTRY,
}
pub type SLIST_ENTRY = _SLIST_ENTRY;
pub type PSLIST_ENTRY = *mut _SLIST_ENTRY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _SLIST_HEADER {
    pub __bindgen_anon_1: _SLIST_HEADER__bindgen_ty_1,
    pub HeaderX64: _SLIST_HEADER__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SLIST_HEADER__bindgen_ty_1 {
    pub Alignment: ULONGLONG,
    pub Region: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SLIST_HEADER__bindgen_ty_2 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
}
impl _SLIST_HEADER__bindgen_ty_2 {
    #[inline]
    pub fn Depth(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_Depth(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Depth_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Depth_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Sequence(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 48u8) as u64) }
    }
    #[inline]
    pub fn set_Sequence(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 48u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Sequence_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                48u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Sequence_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                48u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(64usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(64usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                64usize,
                4u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                64usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NextEntry(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(68usize, 60u8) as u64) }
    }
    #[inline]
    pub fn set_NextEntry(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(68usize, 60u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NextEntry_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                68usize,
                60u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_NextEntry_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                68usize,
                60u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Depth: ULONGLONG,
        Sequence: ULONGLONG,
        Reserved: ULONGLONG,
        NextEntry: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let Depth: u64 = unsafe { ::core::mem::transmute(Depth) };
            Depth as u64
        });
        __bindgen_bitfield_unit.set(16usize, 48u8, {
            let Sequence: u64 = unsafe { ::core::mem::transmute(Sequence) };
            Sequence as u64
        });
        __bindgen_bitfield_unit.set(64usize, 4u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(68usize, 60u8, {
            let NextEntry: u64 = unsafe { ::core::mem::transmute(NextEntry) };
            NextEntry as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type SLIST_HEADER = _SLIST_HEADER;
pub type PSLIST_HEADER = *mut _SLIST_HEADER;
unsafe extern "C" {
    pub fn RtlAssert(
        VoidFailedAssertion: PVOID,
        VoidFileName: PVOID,
        LineNumber: ULONG,
        MutableMessage: PSTR,
    );
}
unsafe extern "C" {
    pub fn __fastfail(Code: core::ffi::c_uint) -> !;
}
unsafe extern "C" {
    pub fn RtlIntegerToUnicodeString(
        Value: ULONG,
        Base: ULONG,
        String: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlInt64ToUnicodeString(
        Value: ULONGLONG,
        Base: ULONG,
        String: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlUnicodeStringToInteger(
        String: PCUNICODE_STRING,
        Base: ULONG,
        Value: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlUnicodeStringToInt64(
        String: PCUNICODE_STRING,
        Base: ULONG,
        Number: PLONG64,
        EndPointer: *mut PWSTR,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub static mut NlsMbCodePageTag: *mut BOOLEAN;
}
unsafe extern "C" {
    pub static mut NlsMbOemCodePageTag: *mut BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlInitString(DestinationString: PSTRING, SourceString: PCSZ);
}
unsafe extern "C" {
    pub fn RtlInitAnsiString(DestinationString: PANSI_STRING, SourceString: PCSZ);
}
unsafe extern "C" {
    pub fn RtlInitUTF8String(DestinationString: PUTF8_STRING, SourceString: PCSZ);
}
unsafe extern "C" {
    pub fn RtlInitUnicodeString(DestinationString: PUNICODE_STRING, SourceString: PCWSTR);
}
pub type PRTL_QUERY_REGISTRY_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: PWSTR,
        arg2: ULONG,
        arg3: PVOID,
        arg4: ULONG,
        arg5: PVOID,
        arg6: PVOID,
    ) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_QUERY_REGISTRY_TABLE {
    pub QueryRoutine: PRTL_QUERY_REGISTRY_ROUTINE,
    pub Flags: ULONG,
    pub Name: PWSTR,
    pub EntryContext: PVOID,
    pub DefaultType: ULONG,
    pub DefaultData: PVOID,
    pub DefaultLength: ULONG,
}
pub type RTL_QUERY_REGISTRY_TABLE = _RTL_QUERY_REGISTRY_TABLE;
pub type PRTL_QUERY_REGISTRY_TABLE = *mut _RTL_QUERY_REGISTRY_TABLE;
unsafe extern "C" {
    pub fn RtlQueryRegistryValues(
        RelativeTo: ULONG,
        Path: PCWSTR,
        QueryTable: PRTL_QUERY_REGISTRY_TABLE,
        Context: PVOID,
        Environment: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmGetSystemRoutineAddress(SystemRoutineName: PUNICODE_STRING) -> PVOID;
}
unsafe extern "C" {
    pub fn RtlWriteRegistryValue(
        RelativeTo: ULONG,
        Path: PCWSTR,
        ValueName: PCWSTR,
        ValueType: ULONG,
        ValueData: PVOID,
        ValueLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlDeleteRegistryValue(RelativeTo: ULONG, Path: PCWSTR, ValueName: PCWSTR) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlCreateRegistryKey(RelativeTo: ULONG, Path: PWSTR) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlCheckRegistryKey(RelativeTo: ULONG, Path: PWSTR) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlInitAnsiStringEx(DestinationString: PANSI_STRING, SourceString: PCSZ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlInitStringEx(DestinationString: PSTRING, SourceString: PCSZ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlInitUTF8StringEx(DestinationString: PUTF8_STRING, SourceString: PCSZ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlAnsiStringToUnicodeString(
        DestinationString: PUNICODE_STRING,
        SourceString: PCANSI_STRING,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlUnicodeStringToAnsiString(
        DestinationString: PANSI_STRING,
        SourceString: PCUNICODE_STRING,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlCompareUnicodeStrings(
        String1: PCWCH,
        String1Length: SIZE_T,
        String2: PCWCH,
        String2Length: SIZE_T,
        CaseInSensitive: BOOLEAN,
    ) -> LONG;
}
unsafe extern "C" {
    pub fn RtlCompareUnicodeString(
        String1: PCUNICODE_STRING,
        String2: PCUNICODE_STRING,
        CaseInSensitive: BOOLEAN,
    ) -> LONG;
}
unsafe extern "C" {
    pub fn RtlEqualUnicodeString(
        String1: PCUNICODE_STRING,
        String2: PCUNICODE_STRING,
        CaseInSensitive: BOOLEAN,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlHashUnicodeString(
        String: PCUNICODE_STRING,
        CaseInSensitive: BOOLEAN,
        HashAlgorithm: ULONG,
        HashValue: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlCopyUnicodeString(DestinationString: PUNICODE_STRING, SourceString: PCUNICODE_STRING);
}
unsafe extern "C" {
    pub fn RtlAppendUnicodeStringToString(
        Destination: PUNICODE_STRING,
        Source: PCUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlAppendUnicodeToString(Destination: PUNICODE_STRING, Source: PCWSTR) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlUpcaseUnicodeChar(SourceCharacter: WCHAR) -> WCHAR;
}
unsafe extern "C" {
    pub fn RtlDowncaseUnicodeChar(SourceCharacter: WCHAR) -> WCHAR;
}
unsafe extern "C" {
    pub fn RtlFreeUnicodeString(UnicodeString: PUNICODE_STRING);
}
unsafe extern "C" {
    pub fn RtlFreeAnsiString(AnsiString: PANSI_STRING);
}
unsafe extern "C" {
    pub fn RtlFreeUTF8String(utf8String: PUTF8_STRING);
}
unsafe extern "C" {
    pub fn RtlxUnicodeStringToAnsiSize(UnicodeString: PCUNICODE_STRING) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlxAnsiStringToUnicodeSize(AnsiString: PCANSI_STRING) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlUnicodeToUTF8N(
        UTF8StringDestination: PCHAR,
        UTF8StringMaxByteCount: ULONG,
        UTF8StringActualByteCount: PULONG,
        UnicodeStringSource: PCWCH,
        UnicodeStringByteCount: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlUTF8ToUnicodeN(
        UnicodeStringDestination: PWSTR,
        UnicodeStringMaxByteCount: ULONG,
        UnicodeStringActualByteCount: PULONG,
        UTF8StringSource: PCCH,
        UTF8StringByteCount: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlUnicodeStringToUTF8String(
        DestinationString: PUTF8_STRING,
        SourceString: PCUNICODE_STRING,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlUTF8StringToUnicodeString(
        DestinationString: PUNICODE_STRING,
        SourceString: PUTF8_STRING,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlStringFromGUID(Guid: *const GUID, GuidString: PUNICODE_STRING) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlGUIDFromString(GuidString: PCUNICODE_STRING, Guid: *mut GUID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlGenerateClass5Guid(
        NamespaceGuid: *const GUID,
        Buffer: PVOID,
        BufferSize: ULONG,
        Guid: *mut GUID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlCopyMemoryNonTemporal(
        Destination: *mut core::ffi::c_void,
        Source: *const core::ffi::c_void,
        Length: SIZE_T,
    );
}
unsafe extern "C" {
    pub fn RtlFillMemoryNonTemporal(
        Destination: *mut core::ffi::c_void,
        Length: SIZE_T,
        Value: UCHAR,
    );
}
unsafe extern "C" {
    pub fn RtlPrefetchMemoryNonTemporal(Source: PVOID, Length: SIZE_T);
}
unsafe extern "C" {
    pub fn DbgBreakPointWithStatus(Status: ULONG);
}
unsafe extern "C" {
    pub fn DbgPrint(Format: PCSTR, ...) -> ULONG;
}
unsafe extern "C" {
    pub fn DbgPrintEx(ComponentId: ULONG, Level: ULONG, Format: PCSTR, ...) -> ULONG;
}
unsafe extern "C" {
    pub fn vDbgPrintEx(ComponentId: ULONG, Level: ULONG, Format: PCCH, arglist: va_list) -> ULONG;
}
unsafe extern "C" {
    pub fn vDbgPrintExWithPrefix(
        Prefix: PCCH,
        ComponentId: ULONG,
        Level: ULONG,
        Format: PCCH,
        arglist: va_list,
    ) -> ULONG;
}
unsafe extern "C" {
    pub fn DbgPrintReturnControlC(Format: PCCH, ...) -> ULONG;
}
unsafe extern "C" {
    pub fn DbgQueryDebugFilterState(ComponentId: ULONG, Level: ULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn DbgSetDebugFilterState(ComponentId: ULONG, Level: ULONG, State: BOOLEAN) -> NTSTATUS;
}
pub type PDEBUG_PRINT_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Output: PSTRING, ComponentId: ULONG, Level: ULONG)>;
unsafe extern "C" {
    pub fn DbgSetDebugPrintCallback(
        DebugPrintCallback: PDEBUG_PRINT_CALLBACK,
        Enable: BOOLEAN,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TIME_FIELDS {
    pub Year: CSHORT,
    pub Month: CSHORT,
    pub Day: CSHORT,
    pub Hour: CSHORT,
    pub Minute: CSHORT,
    pub Second: CSHORT,
    pub Milliseconds: CSHORT,
    pub Weekday: CSHORT,
}
pub type TIME_FIELDS = _TIME_FIELDS;
pub type PTIME_FIELDS = *mut TIME_FIELDS;
unsafe extern "C" {
    pub fn RtlTimeToTimeFields(Time: PLARGE_INTEGER, TimeFields: PTIME_FIELDS);
}
unsafe extern "C" {
    pub fn RtlTimeFieldsToTime(TimeFields: PTIME_FIELDS, Time: PLARGE_INTEGER) -> BOOLEAN;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_BITMAP {
    pub SizeOfBitMap: ULONG,
    pub Buffer: PULONG,
}
pub type RTL_BITMAP = _RTL_BITMAP;
pub type PRTL_BITMAP = *mut RTL_BITMAP;
unsafe extern "C" {
    pub fn RtlInitializeBitMap(
        BitMapHeader: PRTL_BITMAP,
        BitMapBuffer: PULONG,
        SizeOfBitMap: ULONG,
    );
}
unsafe extern "C" {
    pub fn RtlClearBit(BitMapHeader: PRTL_BITMAP, BitNumber: ULONG);
}
unsafe extern "C" {
    pub fn RtlSetBit(BitMapHeader: PRTL_BITMAP, BitNumber: ULONG);
}
unsafe extern "C" {
    pub fn RtlTestBit(BitMapHeader: PRTL_BITMAP, BitNumber: ULONG) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlClearAllBits(BitMapHeader: PRTL_BITMAP);
}
unsafe extern "C" {
    pub fn RtlSetAllBits(BitMapHeader: PRTL_BITMAP);
}
unsafe extern "C" {
    pub fn RtlFindClearBits(
        BitMapHeader: PRTL_BITMAP,
        NumberToFind: ULONG,
        HintIndex: ULONG,
    ) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlFindSetBits(
        BitMapHeader: PRTL_BITMAP,
        NumberToFind: ULONG,
        HintIndex: ULONG,
    ) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlFindClearBitsAndSet(
        BitMapHeader: PRTL_BITMAP,
        NumberToFind: ULONG,
        HintIndex: ULONG,
    ) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlFindSetBitsAndClear(
        BitMapHeader: PRTL_BITMAP,
        NumberToFind: ULONG,
        HintIndex: ULONG,
    ) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlClearBits(BitMapHeader: PRTL_BITMAP, StartingIndex: ULONG, NumberToClear: ULONG);
}
unsafe extern "C" {
    pub fn RtlSetBits(BitMapHeader: PRTL_BITMAP, StartingIndex: ULONG, NumberToSet: ULONG);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_BITMAP_RUN {
    pub StartingIndex: ULONG,
    pub NumberOfBits: ULONG,
}
pub type RTL_BITMAP_RUN = _RTL_BITMAP_RUN;
pub type PRTL_BITMAP_RUN = *mut RTL_BITMAP_RUN;
unsafe extern "C" {
    pub fn RtlFindClearRuns(
        BitMapHeader: PRTL_BITMAP,
        RunArray: PRTL_BITMAP_RUN,
        SizeOfRunArray: ULONG,
        LocateLongestRuns: BOOLEAN,
    ) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlFindLongestRunClear(BitMapHeader: PRTL_BITMAP, StartingIndex: PULONG) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlFindFirstRunClear(BitMapHeader: PRTL_BITMAP, StartingIndex: PULONG) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlNumberOfClearBitsInRange(
        BitMapHeader: PRTL_BITMAP,
        StartingIndex: ULONG,
        Length: ULONG,
    ) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlNumberOfSetBitsInRange(
        BitMapHeader: PRTL_BITMAP,
        StartingIndex: ULONG,
        Length: ULONG,
    ) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlNumberOfClearBits(BitMapHeader: PRTL_BITMAP) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlNumberOfSetBits(BitMapHeader: PRTL_BITMAP) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlAreBitsClear(
        BitMapHeader: PRTL_BITMAP,
        StartingIndex: ULONG,
        Length: ULONG,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlAreBitsSet(BitMapHeader: PRTL_BITMAP, StartingIndex: ULONG, Length: ULONG)
                         -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlFindNextForwardRunClear(
        BitMapHeader: PRTL_BITMAP,
        FromIndex: ULONG,
        StartingRunIndex: PULONG,
    ) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlFindLastBackwardRunClear(
        BitMapHeader: PRTL_BITMAP,
        FromIndex: ULONG,
        StartingRunIndex: PULONG,
    ) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlFindLeastSignificantBit(Set: ULONGLONG) -> CCHAR;
}
unsafe extern "C" {
    pub fn RtlFindMostSignificantBit(Set: ULONGLONG) -> CCHAR;
}
unsafe extern "C" {
    pub fn RtlNumberOfSetBitsUlongPtr(Target: ULONG_PTR) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlCopyBitMap(Source: PRTL_BITMAP, Destination: PRTL_BITMAP, TargetBit: ULONG);
}
unsafe extern "C" {
    pub fn RtlExtractBitMap(
        Source: PRTL_BITMAP,
        Destination: PRTL_BITMAP,
        TargetBit: ULONG,
        NumberOfBits: ULONG,
    );
}
unsafe extern "C" {
    pub fn RtlCreateSecurityDescriptor(
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        Revision: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlValidSecurityDescriptor(SecurityDescriptor: PSECURITY_DESCRIPTOR) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlLengthSecurityDescriptor(SecurityDescriptor: PSECURITY_DESCRIPTOR) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlValidRelativeSecurityDescriptor(
        SecurityDescriptorInput: PSECURITY_DESCRIPTOR,
        SecurityDescriptorLength: ULONG,
        RequiredInformation: SECURITY_INFORMATION,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlSetDaclSecurityDescriptor(
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        DaclPresent: BOOLEAN,
        Dacl: PACL,
        DaclDefaulted: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn _byteswap_ushort(arg1: core::ffi::c_ushort) -> core::ffi::c_ushort;
}
unsafe extern "C" {
    pub fn _byteswap_ulong(arg1: core::ffi::c_ulong) -> core::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn _byteswap_uint64(arg1: core::ffi::c_ulonglong) -> core::ffi::c_ulonglong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OSVERSIONINFOA {
    pub dwOSVersionInfoSize: ULONG,
    pub dwMajorVersion: ULONG,
    pub dwMinorVersion: ULONG,
    pub dwBuildNumber: ULONG,
    pub dwPlatformId: ULONG,
    pub szCSDVersion: [CHAR; 128usize],
}
pub type OSVERSIONINFOA = _OSVERSIONINFOA;
pub type POSVERSIONINFOA = *mut _OSVERSIONINFOA;
pub type LPOSVERSIONINFOA = *mut _OSVERSIONINFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OSVERSIONINFOW {
    pub dwOSVersionInfoSize: ULONG,
    pub dwMajorVersion: ULONG,
    pub dwMinorVersion: ULONG,
    pub dwBuildNumber: ULONG,
    pub dwPlatformId: ULONG,
    pub szCSDVersion: [WCHAR; 128usize],
}
pub type OSVERSIONINFOW = _OSVERSIONINFOW;
pub type POSVERSIONINFOW = *mut _OSVERSIONINFOW;
pub type LPOSVERSIONINFOW = *mut _OSVERSIONINFOW;
pub type RTL_OSVERSIONINFOW = _OSVERSIONINFOW;
pub type PRTL_OSVERSIONINFOW = *mut _OSVERSIONINFOW;
pub type OSVERSIONINFO = OSVERSIONINFOA;
pub type POSVERSIONINFO = POSVERSIONINFOA;
pub type LPOSVERSIONINFO = LPOSVERSIONINFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OSVERSIONINFOEXA {
    pub dwOSVersionInfoSize: ULONG,
    pub dwMajorVersion: ULONG,
    pub dwMinorVersion: ULONG,
    pub dwBuildNumber: ULONG,
    pub dwPlatformId: ULONG,
    pub szCSDVersion: [CHAR; 128usize],
    pub wServicePackMajor: USHORT,
    pub wServicePackMinor: USHORT,
    pub wSuiteMask: USHORT,
    pub wProductType: UCHAR,
    pub wReserved: UCHAR,
}
pub type OSVERSIONINFOEXA = _OSVERSIONINFOEXA;
pub type POSVERSIONINFOEXA = *mut _OSVERSIONINFOEXA;
pub type LPOSVERSIONINFOEXA = *mut _OSVERSIONINFOEXA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OSVERSIONINFOEXW {
    pub dwOSVersionInfoSize: ULONG,
    pub dwMajorVersion: ULONG,
    pub dwMinorVersion: ULONG,
    pub dwBuildNumber: ULONG,
    pub dwPlatformId: ULONG,
    pub szCSDVersion: [WCHAR; 128usize],
    pub wServicePackMajor: USHORT,
    pub wServicePackMinor: USHORT,
    pub wSuiteMask: USHORT,
    pub wProductType: UCHAR,
    pub wReserved: UCHAR,
}
pub type OSVERSIONINFOEXW = _OSVERSIONINFOEXW;
pub type POSVERSIONINFOEXW = *mut _OSVERSIONINFOEXW;
pub type LPOSVERSIONINFOEXW = *mut _OSVERSIONINFOEXW;
pub type RTL_OSVERSIONINFOEXW = _OSVERSIONINFOEXW;
pub type PRTL_OSVERSIONINFOEXW = *mut _OSVERSIONINFOEXW;
pub type OSVERSIONINFOEX = OSVERSIONINFOEXA;
pub type POSVERSIONINFOEX = POSVERSIONINFOEXA;
pub type LPOSVERSIONINFOEX = LPOSVERSIONINFOEXA;
unsafe extern "C" {
    pub fn VerSetConditionMask(
        ConditionMask: ULONGLONG,
        TypeMask: ULONG,
        Condition: UCHAR,
    ) -> ULONGLONG;
}
unsafe extern "C" {
    pub fn RtlGetVersion(lpVersionInformation: PRTL_OSVERSIONINFOW) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlVerifyVersionInfo(
        VersionInfo: PRTL_OSVERSIONINFOEXW,
        TypeMask: ULONG,
        ConditionMask: ULONGLONG,
    ) -> NTSTATUS;
}
pub type PFN_RTL_IS_NTDDI_VERSION_AVAILABLE =
::core::option::Option<unsafe extern "C" fn(Version: ULONG) -> BOOLEAN>;
pub type PFN_RTL_IS_SERVICE_PACK_VERSION_INSTALLED =
::core::option::Option<unsafe extern "C" fn(Version: ULONG) -> BOOLEAN>;
unsafe extern "C" {
    pub fn RtlIsNtDdiVersionAvailable(Version: ULONG) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlIsServicePackVersionInstalled(Version: ULONG) -> BOOLEAN;
}
pub const _DPFLTR_TYPE_DPFLTR_SYSTEM_ID: _DPFLTR_TYPE = 0;
pub const _DPFLTR_TYPE_DPFLTR_SMSS_ID: _DPFLTR_TYPE = 1;
pub const _DPFLTR_TYPE_DPFLTR_SETUP_ID: _DPFLTR_TYPE = 2;
pub const _DPFLTR_TYPE_DPFLTR_NTFS_ID: _DPFLTR_TYPE = 3;
pub const _DPFLTR_TYPE_DPFLTR_FSTUB_ID: _DPFLTR_TYPE = 4;
pub const _DPFLTR_TYPE_DPFLTR_CRASHDUMP_ID: _DPFLTR_TYPE = 5;
pub const _DPFLTR_TYPE_DPFLTR_CDAUDIO_ID: _DPFLTR_TYPE = 6;
pub const _DPFLTR_TYPE_DPFLTR_CDROM_ID: _DPFLTR_TYPE = 7;
pub const _DPFLTR_TYPE_DPFLTR_CLASSPNP_ID: _DPFLTR_TYPE = 8;
pub const _DPFLTR_TYPE_DPFLTR_DISK_ID: _DPFLTR_TYPE = 9;
pub const _DPFLTR_TYPE_DPFLTR_REDBOOK_ID: _DPFLTR_TYPE = 10;
pub const _DPFLTR_TYPE_DPFLTR_STORPROP_ID: _DPFLTR_TYPE = 11;
pub const _DPFLTR_TYPE_DPFLTR_SCSIPORT_ID: _DPFLTR_TYPE = 12;
pub const _DPFLTR_TYPE_DPFLTR_SCSIMINIPORT_ID: _DPFLTR_TYPE = 13;
pub const _DPFLTR_TYPE_DPFLTR_CONFIG_ID: _DPFLTR_TYPE = 14;
pub const _DPFLTR_TYPE_DPFLTR_I8042PRT_ID: _DPFLTR_TYPE = 15;
pub const _DPFLTR_TYPE_DPFLTR_SERMOUSE_ID: _DPFLTR_TYPE = 16;
pub const _DPFLTR_TYPE_DPFLTR_LSERMOUS_ID: _DPFLTR_TYPE = 17;
pub const _DPFLTR_TYPE_DPFLTR_KBDHID_ID: _DPFLTR_TYPE = 18;
pub const _DPFLTR_TYPE_DPFLTR_MOUHID_ID: _DPFLTR_TYPE = 19;
pub const _DPFLTR_TYPE_DPFLTR_KBDCLASS_ID: _DPFLTR_TYPE = 20;
pub const _DPFLTR_TYPE_DPFLTR_MOUCLASS_ID: _DPFLTR_TYPE = 21;
pub const _DPFLTR_TYPE_DPFLTR_TWOTRACK_ID: _DPFLTR_TYPE = 22;
pub const _DPFLTR_TYPE_DPFLTR_WMILIB_ID: _DPFLTR_TYPE = 23;
pub const _DPFLTR_TYPE_DPFLTR_ACPI_ID: _DPFLTR_TYPE = 24;
pub const _DPFLTR_TYPE_DPFLTR_AMLI_ID: _DPFLTR_TYPE = 25;
pub const _DPFLTR_TYPE_DPFLTR_HALIA64_ID: _DPFLTR_TYPE = 26;
pub const _DPFLTR_TYPE_DPFLTR_VIDEO_ID: _DPFLTR_TYPE = 27;
pub const _DPFLTR_TYPE_DPFLTR_SVCHOST_ID: _DPFLTR_TYPE = 28;
pub const _DPFLTR_TYPE_DPFLTR_VIDEOPRT_ID: _DPFLTR_TYPE = 29;
pub const _DPFLTR_TYPE_DPFLTR_TCPIP_ID: _DPFLTR_TYPE = 30;
pub const _DPFLTR_TYPE_DPFLTR_DMSYNTH_ID: _DPFLTR_TYPE = 31;
pub const _DPFLTR_TYPE_DPFLTR_NTOSPNP_ID: _DPFLTR_TYPE = 32;
pub const _DPFLTR_TYPE_DPFLTR_FASTFAT_ID: _DPFLTR_TYPE = 33;
pub const _DPFLTR_TYPE_DPFLTR_SAMSS_ID: _DPFLTR_TYPE = 34;
pub const _DPFLTR_TYPE_DPFLTR_PNPMGR_ID: _DPFLTR_TYPE = 35;
pub const _DPFLTR_TYPE_DPFLTR_NETAPI_ID: _DPFLTR_TYPE = 36;
pub const _DPFLTR_TYPE_DPFLTR_SCSERVER_ID: _DPFLTR_TYPE = 37;
pub const _DPFLTR_TYPE_DPFLTR_SCCLIENT_ID: _DPFLTR_TYPE = 38;
pub const _DPFLTR_TYPE_DPFLTR_SERIAL_ID: _DPFLTR_TYPE = 39;
pub const _DPFLTR_TYPE_DPFLTR_SERENUM_ID: _DPFLTR_TYPE = 40;
pub const _DPFLTR_TYPE_DPFLTR_UHCD_ID: _DPFLTR_TYPE = 41;
pub const _DPFLTR_TYPE_DPFLTR_RPCPROXY_ID: _DPFLTR_TYPE = 42;
pub const _DPFLTR_TYPE_DPFLTR_AUTOCHK_ID: _DPFLTR_TYPE = 43;
pub const _DPFLTR_TYPE_DPFLTR_DCOMSS_ID: _DPFLTR_TYPE = 44;
pub const _DPFLTR_TYPE_DPFLTR_UNIMODEM_ID: _DPFLTR_TYPE = 45;
pub const _DPFLTR_TYPE_DPFLTR_SIS_ID: _DPFLTR_TYPE = 46;
pub const _DPFLTR_TYPE_DPFLTR_FLTMGR_ID: _DPFLTR_TYPE = 47;
pub const _DPFLTR_TYPE_DPFLTR_WMICORE_ID: _DPFLTR_TYPE = 48;
pub const _DPFLTR_TYPE_DPFLTR_BURNENG_ID: _DPFLTR_TYPE = 49;
pub const _DPFLTR_TYPE_DPFLTR_IMAPI_ID: _DPFLTR_TYPE = 50;
pub const _DPFLTR_TYPE_DPFLTR_SXS_ID: _DPFLTR_TYPE = 51;
pub const _DPFLTR_TYPE_DPFLTR_FUSION_ID: _DPFLTR_TYPE = 52;
pub const _DPFLTR_TYPE_DPFLTR_IDLETASK_ID: _DPFLTR_TYPE = 53;
pub const _DPFLTR_TYPE_DPFLTR_SOFTPCI_ID: _DPFLTR_TYPE = 54;
pub const _DPFLTR_TYPE_DPFLTR_TAPE_ID: _DPFLTR_TYPE = 55;
pub const _DPFLTR_TYPE_DPFLTR_MCHGR_ID: _DPFLTR_TYPE = 56;
pub const _DPFLTR_TYPE_DPFLTR_IDEP_ID: _DPFLTR_TYPE = 57;
pub const _DPFLTR_TYPE_DPFLTR_PCIIDE_ID: _DPFLTR_TYPE = 58;
pub const _DPFLTR_TYPE_DPFLTR_FLOPPY_ID: _DPFLTR_TYPE = 59;
pub const _DPFLTR_TYPE_DPFLTR_FDC_ID: _DPFLTR_TYPE = 60;
pub const _DPFLTR_TYPE_DPFLTR_TERMSRV_ID: _DPFLTR_TYPE = 61;
pub const _DPFLTR_TYPE_DPFLTR_W32TIME_ID: _DPFLTR_TYPE = 62;
pub const _DPFLTR_TYPE_DPFLTR_PREFETCHER_ID: _DPFLTR_TYPE = 63;
pub const _DPFLTR_TYPE_DPFLTR_RSFILTER_ID: _DPFLTR_TYPE = 64;
pub const _DPFLTR_TYPE_DPFLTR_FCPORT_ID: _DPFLTR_TYPE = 65;
pub const _DPFLTR_TYPE_DPFLTR_PCI_ID: _DPFLTR_TYPE = 66;
pub const _DPFLTR_TYPE_DPFLTR_DMIO_ID: _DPFLTR_TYPE = 67;
pub const _DPFLTR_TYPE_DPFLTR_DMCONFIG_ID: _DPFLTR_TYPE = 68;
pub const _DPFLTR_TYPE_DPFLTR_DMADMIN_ID: _DPFLTR_TYPE = 69;
pub const _DPFLTR_TYPE_DPFLTR_WSOCKTRANSPORT_ID: _DPFLTR_TYPE = 70;
pub const _DPFLTR_TYPE_DPFLTR_VSS_ID: _DPFLTR_TYPE = 71;
pub const _DPFLTR_TYPE_DPFLTR_PNPMEM_ID: _DPFLTR_TYPE = 72;
pub const _DPFLTR_TYPE_DPFLTR_PROCESSOR_ID: _DPFLTR_TYPE = 73;
pub const _DPFLTR_TYPE_DPFLTR_DMSERVER_ID: _DPFLTR_TYPE = 74;
pub const _DPFLTR_TYPE_DPFLTR_SR_ID: _DPFLTR_TYPE = 75;
pub const _DPFLTR_TYPE_DPFLTR_INFINIBAND_ID: _DPFLTR_TYPE = 76;
pub const _DPFLTR_TYPE_DPFLTR_IHVDRIVER_ID: _DPFLTR_TYPE = 77;
pub const _DPFLTR_TYPE_DPFLTR_IHVVIDEO_ID: _DPFLTR_TYPE = 78;
pub const _DPFLTR_TYPE_DPFLTR_IHVAUDIO_ID: _DPFLTR_TYPE = 79;
pub const _DPFLTR_TYPE_DPFLTR_IHVNETWORK_ID: _DPFLTR_TYPE = 80;
pub const _DPFLTR_TYPE_DPFLTR_IHVSTREAMING_ID: _DPFLTR_TYPE = 81;
pub const _DPFLTR_TYPE_DPFLTR_IHVBUS_ID: _DPFLTR_TYPE = 82;
pub const _DPFLTR_TYPE_DPFLTR_HPS_ID: _DPFLTR_TYPE = 83;
pub const _DPFLTR_TYPE_DPFLTR_RTLTHREADPOOL_ID: _DPFLTR_TYPE = 84;
pub const _DPFLTR_TYPE_DPFLTR_LDR_ID: _DPFLTR_TYPE = 85;
pub const _DPFLTR_TYPE_DPFLTR_TCPIP6_ID: _DPFLTR_TYPE = 86;
pub const _DPFLTR_TYPE_DPFLTR_ISAPNP_ID: _DPFLTR_TYPE = 87;
pub const _DPFLTR_TYPE_DPFLTR_SHPC_ID: _DPFLTR_TYPE = 88;
pub const _DPFLTR_TYPE_DPFLTR_STORPORT_ID: _DPFLTR_TYPE = 89;
pub const _DPFLTR_TYPE_DPFLTR_STORMINIPORT_ID: _DPFLTR_TYPE = 90;
pub const _DPFLTR_TYPE_DPFLTR_PRINTSPOOLER_ID: _DPFLTR_TYPE = 91;
pub const _DPFLTR_TYPE_DPFLTR_VSSDYNDISK_ID: _DPFLTR_TYPE = 92;
pub const _DPFLTR_TYPE_DPFLTR_VERIFIER_ID: _DPFLTR_TYPE = 93;
pub const _DPFLTR_TYPE_DPFLTR_VDS_ID: _DPFLTR_TYPE = 94;
pub const _DPFLTR_TYPE_DPFLTR_VDSBAS_ID: _DPFLTR_TYPE = 95;
pub const _DPFLTR_TYPE_DPFLTR_VDSDYN_ID: _DPFLTR_TYPE = 96;
pub const _DPFLTR_TYPE_DPFLTR_VDSDYNDR_ID: _DPFLTR_TYPE = 97;
pub const _DPFLTR_TYPE_DPFLTR_VDSLDR_ID: _DPFLTR_TYPE = 98;
pub const _DPFLTR_TYPE_DPFLTR_VDSUTIL_ID: _DPFLTR_TYPE = 99;
pub const _DPFLTR_TYPE_DPFLTR_DFRGIFC_ID: _DPFLTR_TYPE = 100;
pub const _DPFLTR_TYPE_DPFLTR_DEFAULT_ID: _DPFLTR_TYPE = 101;
pub const _DPFLTR_TYPE_DPFLTR_MM_ID: _DPFLTR_TYPE = 102;
pub const _DPFLTR_TYPE_DPFLTR_DFSC_ID: _DPFLTR_TYPE = 103;
pub const _DPFLTR_TYPE_DPFLTR_WOW64_ID: _DPFLTR_TYPE = 104;
pub const _DPFLTR_TYPE_DPFLTR_ALPC_ID: _DPFLTR_TYPE = 105;
pub const _DPFLTR_TYPE_DPFLTR_WDI_ID: _DPFLTR_TYPE = 106;
pub const _DPFLTR_TYPE_DPFLTR_PERFLIB_ID: _DPFLTR_TYPE = 107;
pub const _DPFLTR_TYPE_DPFLTR_KTM_ID: _DPFLTR_TYPE = 108;
pub const _DPFLTR_TYPE_DPFLTR_IOSTRESS_ID: _DPFLTR_TYPE = 109;
pub const _DPFLTR_TYPE_DPFLTR_HEAP_ID: _DPFLTR_TYPE = 110;
pub const _DPFLTR_TYPE_DPFLTR_WHEA_ID: _DPFLTR_TYPE = 111;
pub const _DPFLTR_TYPE_DPFLTR_USERGDI_ID: _DPFLTR_TYPE = 112;
pub const _DPFLTR_TYPE_DPFLTR_MMCSS_ID: _DPFLTR_TYPE = 113;
pub const _DPFLTR_TYPE_DPFLTR_TPM_ID: _DPFLTR_TYPE = 114;
pub const _DPFLTR_TYPE_DPFLTR_THREADORDER_ID: _DPFLTR_TYPE = 115;
pub const _DPFLTR_TYPE_DPFLTR_ENVIRON_ID: _DPFLTR_TYPE = 116;
pub const _DPFLTR_TYPE_DPFLTR_EMS_ID: _DPFLTR_TYPE = 117;
pub const _DPFLTR_TYPE_DPFLTR_WDT_ID: _DPFLTR_TYPE = 118;
pub const _DPFLTR_TYPE_DPFLTR_FVEVOL_ID: _DPFLTR_TYPE = 119;
pub const _DPFLTR_TYPE_DPFLTR_NDIS_ID: _DPFLTR_TYPE = 120;
pub const _DPFLTR_TYPE_DPFLTR_NVCTRACE_ID: _DPFLTR_TYPE = 121;
pub const _DPFLTR_TYPE_DPFLTR_LUAFV_ID: _DPFLTR_TYPE = 122;
pub const _DPFLTR_TYPE_DPFLTR_APPCOMPAT_ID: _DPFLTR_TYPE = 123;
pub const _DPFLTR_TYPE_DPFLTR_USBSTOR_ID: _DPFLTR_TYPE = 124;
pub const _DPFLTR_TYPE_DPFLTR_SBP2PORT_ID: _DPFLTR_TYPE = 125;
pub const _DPFLTR_TYPE_DPFLTR_COVERAGE_ID: _DPFLTR_TYPE = 126;
pub const _DPFLTR_TYPE_DPFLTR_CACHEMGR_ID: _DPFLTR_TYPE = 127;
pub const _DPFLTR_TYPE_DPFLTR_MOUNTMGR_ID: _DPFLTR_TYPE = 128;
pub const _DPFLTR_TYPE_DPFLTR_CFR_ID: _DPFLTR_TYPE = 129;
pub const _DPFLTR_TYPE_DPFLTR_TXF_ID: _DPFLTR_TYPE = 130;
pub const _DPFLTR_TYPE_DPFLTR_KSECDD_ID: _DPFLTR_TYPE = 131;
pub const _DPFLTR_TYPE_DPFLTR_FLTREGRESS_ID: _DPFLTR_TYPE = 132;
pub const _DPFLTR_TYPE_DPFLTR_MPIO_ID: _DPFLTR_TYPE = 133;
pub const _DPFLTR_TYPE_DPFLTR_MSDSM_ID: _DPFLTR_TYPE = 134;
pub const _DPFLTR_TYPE_DPFLTR_UDFS_ID: _DPFLTR_TYPE = 135;
pub const _DPFLTR_TYPE_DPFLTR_PSHED_ID: _DPFLTR_TYPE = 136;
pub const _DPFLTR_TYPE_DPFLTR_STORVSP_ID: _DPFLTR_TYPE = 137;
pub const _DPFLTR_TYPE_DPFLTR_LSASS_ID: _DPFLTR_TYPE = 138;
pub const _DPFLTR_TYPE_DPFLTR_SSPICLI_ID: _DPFLTR_TYPE = 139;
pub const _DPFLTR_TYPE_DPFLTR_CNG_ID: _DPFLTR_TYPE = 140;
pub const _DPFLTR_TYPE_DPFLTR_EXFAT_ID: _DPFLTR_TYPE = 141;
pub const _DPFLTR_TYPE_DPFLTR_FILETRACE_ID: _DPFLTR_TYPE = 142;
pub const _DPFLTR_TYPE_DPFLTR_XSAVE_ID: _DPFLTR_TYPE = 143;
pub const _DPFLTR_TYPE_DPFLTR_SE_ID: _DPFLTR_TYPE = 144;
pub const _DPFLTR_TYPE_DPFLTR_DRIVEEXTENDER_ID: _DPFLTR_TYPE = 145;
pub const _DPFLTR_TYPE_DPFLTR_POWER_ID: _DPFLTR_TYPE = 146;
pub const _DPFLTR_TYPE_DPFLTR_CRASHDUMPXHCI_ID: _DPFLTR_TYPE = 147;
pub const _DPFLTR_TYPE_DPFLTR_GPIO_ID: _DPFLTR_TYPE = 148;
pub const _DPFLTR_TYPE_DPFLTR_REFS_ID: _DPFLTR_TYPE = 149;
pub const _DPFLTR_TYPE_DPFLTR_WER_ID: _DPFLTR_TYPE = 150;
pub const _DPFLTR_TYPE_DPFLTR_CAPIMG_ID: _DPFLTR_TYPE = 151;
pub const _DPFLTR_TYPE_DPFLTR_VPCI_ID: _DPFLTR_TYPE = 152;
pub const _DPFLTR_TYPE_DPFLTR_STORAGECLASSMEMORY_ID: _DPFLTR_TYPE = 153;
pub const _DPFLTR_TYPE_DPFLTR_FSLIB_ID: _DPFLTR_TYPE = 154;
pub const _DPFLTR_TYPE_DPFLTR_ENDOFTABLE_ID: _DPFLTR_TYPE = 155;
pub type _DPFLTR_TYPE = core::ffi::c_int;
pub use self::_DPFLTR_TYPE as DPFLTR_TYPE;
unsafe extern "C" {
    pub fn RtlIoEncodeMemIoResource(
        Descriptor: PIO_RESOURCE_DESCRIPTOR,
        Type: UCHAR,
        Length: ULONGLONG,
        Alignment: ULONGLONG,
        MinimumAddress: ULONGLONG,
        MaximumAddress: ULONGLONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlCmEncodeMemIoResource(
        Descriptor: PCM_PARTIAL_RESOURCE_DESCRIPTOR,
        Type: UCHAR,
        Length: ULONGLONG,
        Start: ULONGLONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlIoDecodeMemIoResource(
        Descriptor: PIO_RESOURCE_DESCRIPTOR,
        Alignment: PULONGLONG,
        MinimumAddress: PULONGLONG,
        MaximumAddress: PULONGLONG,
    ) -> ULONGLONG;
}
unsafe extern "C" {
    pub fn RtlCmDecodeMemIoResource(
        Descriptor: PCM_PARTIAL_RESOURCE_DESCRIPTOR,
        Start: PULONGLONG,
    ) -> ULONGLONG;
}
unsafe extern "C" {
    pub fn RtlFindClosestEncodableLength(
        SourceLength: ULONGLONG,
        TargetLength: PULONGLONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlIsUntrustedObject(
        Handle: HANDLE,
        Object: PVOID,
        UntrustedObject: PBOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlQueryValidationRunlevel(ComponentName: PCUNICODE_STRING) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlCrc32(Buffer: *const core::ffi::c_void, Size: usize, InitialCrc: ULONG) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlCrc64(
        Buffer: *const core::ffi::c_void,
        Size: usize,
        InitialCrc: ULONGLONG,
    ) -> ULONGLONG;
}
pub const _OS_DEPLOYEMENT_STATE_VALUES_OS_DEPLOYMENT_STANDARD: _OS_DEPLOYEMENT_STATE_VALUES = 1;
pub const _OS_DEPLOYEMENT_STATE_VALUES_OS_DEPLOYMENT_COMPACT: _OS_DEPLOYEMENT_STATE_VALUES = 2;
pub type _OS_DEPLOYEMENT_STATE_VALUES = core::ffi::c_int;
pub use self::_OS_DEPLOYEMENT_STATE_VALUES as OS_DEPLOYEMENT_STATE_VALUES;
unsafe extern "C" {
    pub fn RtlOsDeploymentState(Flags: ULONG) -> OS_DEPLOYEMENT_STATE_VALUES;
}
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeNone: _IMAGE_POLICY_ENTRY_TYPE = 0;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeBool: _IMAGE_POLICY_ENTRY_TYPE = 1;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeInt8: _IMAGE_POLICY_ENTRY_TYPE = 2;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeUInt8: _IMAGE_POLICY_ENTRY_TYPE = 3;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeInt16: _IMAGE_POLICY_ENTRY_TYPE = 4;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeUInt16: _IMAGE_POLICY_ENTRY_TYPE = 5;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeInt32: _IMAGE_POLICY_ENTRY_TYPE = 6;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeUInt32: _IMAGE_POLICY_ENTRY_TYPE = 7;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeInt64: _IMAGE_POLICY_ENTRY_TYPE = 8;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeUInt64: _IMAGE_POLICY_ENTRY_TYPE = 9;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeAnsiString: _IMAGE_POLICY_ENTRY_TYPE = 10;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeUnicodeString: _IMAGE_POLICY_ENTRY_TYPE = 11;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeOverride: _IMAGE_POLICY_ENTRY_TYPE = 12;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeMaximum: _IMAGE_POLICY_ENTRY_TYPE = 13;
pub type _IMAGE_POLICY_ENTRY_TYPE = core::ffi::c_int;
pub use self::_IMAGE_POLICY_ENTRY_TYPE as IMAGE_POLICY_ENTRY_TYPE;
pub const _IMAGE_POLICY_ID_ImagePolicyIdNone: _IMAGE_POLICY_ID = 0;
pub const _IMAGE_POLICY_ID_ImagePolicyIdEtw: _IMAGE_POLICY_ID = 1;
pub const _IMAGE_POLICY_ID_ImagePolicyIdDebug: _IMAGE_POLICY_ID = 2;
pub const _IMAGE_POLICY_ID_ImagePolicyIdCrashDump: _IMAGE_POLICY_ID = 3;
pub const _IMAGE_POLICY_ID_ImagePolicyIdCrashDumpKey: _IMAGE_POLICY_ID = 4;
pub const _IMAGE_POLICY_ID_ImagePolicyIdCrashDumpKeyGuid: _IMAGE_POLICY_ID = 5;
pub const _IMAGE_POLICY_ID_ImagePolicyIdParentSd: _IMAGE_POLICY_ID = 6;
pub const _IMAGE_POLICY_ID_ImagePolicyIdParentSdRev: _IMAGE_POLICY_ID = 7;
pub const _IMAGE_POLICY_ID_ImagePolicyIdSvn: _IMAGE_POLICY_ID = 8;
pub const _IMAGE_POLICY_ID_ImagePolicyIdDeviceId: _IMAGE_POLICY_ID = 9;
pub const _IMAGE_POLICY_ID_ImagePolicyIdCapability: _IMAGE_POLICY_ID = 10;
pub const _IMAGE_POLICY_ID_ImagePolicyIdScenarioId: _IMAGE_POLICY_ID = 11;
pub const _IMAGE_POLICY_ID_ImagePolicyIdMaximum: _IMAGE_POLICY_ID = 12;
pub type _IMAGE_POLICY_ID = core::ffi::c_int;
pub use self::_IMAGE_POLICY_ID as IMAGE_POLICY_ID;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_POLICY_ENTRY {
    pub Type: IMAGE_POLICY_ENTRY_TYPE,
    pub PolicyId: IMAGE_POLICY_ID,
    pub u: _IMAGE_POLICY_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_POLICY_ENTRY__bindgen_ty_1 {
    pub None: *const core::ffi::c_void,
    pub BoolValue: BOOLEAN,
    pub Int8Value: INT8,
    pub UInt8Value: UINT8,
    pub Int16Value: INT16,
    pub UInt16Value: UINT16,
    pub Int32Value: INT32,
    pub UInt32Value: UINT32,
    pub Int64Value: INT64,
    pub UInt64Value: UINT64,
    pub AnsiStringValue: PCSTR,
    pub UnicodeStringValue: PCWSTR,
}
pub type IMAGE_POLICY_ENTRY = _IMAGE_POLICY_ENTRY;
pub type PCIMAGE_POLICY_ENTRY = *const IMAGE_POLICY_ENTRY;
#[repr(C)]
pub struct _IMAGE_POLICY_METADATA {
    pub Version: UCHAR,
    pub Reserved0: [UCHAR; 7usize],
    pub ApplicationId: ULONGLONG,
    pub Policies: __IncompleteArrayField<IMAGE_POLICY_ENTRY>,
}
pub type IMAGE_POLICY_METADATA = _IMAGE_POLICY_METADATA;
pub type PCIMAGE_POLICY_METADATA = *const IMAGE_POLICY_METADATA;
unsafe extern "C" {
    pub fn RtlCompareMemory(
        Source1: *const core::ffi::c_void,
        Source2: *const core::ffi::c_void,
        Length: SIZE_T,
    ) -> SIZE_T;
}
pub type UOW = GUID;
pub type PUOW = *mut GUID;
pub type CRM_PROTOCOL_ID = GUID;
pub type PCRM_PROTOCOL_ID = *mut GUID;
pub type NOTIFICATION_MASK = ULONG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION {
    pub TransactionKey: PVOID,
    pub TransactionNotification: ULONG,
    pub TmVirtualClock: LARGE_INTEGER,
    pub ArgumentLength: ULONG,
}
pub type TRANSACTION_NOTIFICATION = _TRANSACTION_NOTIFICATION;
pub type PTRANSACTION_NOTIFICATION = *mut _TRANSACTION_NOTIFICATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT {
    pub EnlistmentId: GUID,
    pub UOW: UOW,
}
pub type TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT = _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT =
*mut _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT {
    pub TmIdentity: GUID,
    pub Flags: ULONG,
}
pub type TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT = _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT =
*mut _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT;
pub type SAVEPOINT_ID = ULONG;
pub type PSAVEPOINT_ID = *mut ULONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT {
    pub SavepointId: SAVEPOINT_ID,
}
pub type TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT = _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT =
*mut _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT {
    pub PropagationCookie: ULONG,
    pub UOW: GUID,
    pub TmIdentity: GUID,
    pub BufferLength: ULONG,
}
pub type TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT = _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT =
*mut _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT {
    pub MarshalCookie: ULONG,
    pub UOW: GUID,
}
pub type TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT = _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT =
*mut _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT;
pub type TRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT = TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT =
*mut TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KCRM_MARSHAL_HEADER {
    pub VersionMajor: ULONG,
    pub VersionMinor: ULONG,
    pub NumProtocols: ULONG,
    pub Unused: ULONG,
}
pub type KCRM_MARSHAL_HEADER = _KCRM_MARSHAL_HEADER;
pub type PKCRM_MARSHAL_HEADER = *mut _KCRM_MARSHAL_HEADER;
pub type PRKCRM_MARSHAL_HEADER = *mut _KCRM_MARSHAL_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KCRM_TRANSACTION_BLOB {
    pub UOW: UOW,
    pub TmIdentity: GUID,
    pub IsolationLevel: ULONG,
    pub IsolationFlags: ULONG,
    pub Timeout: ULONG,
    pub Description: [WCHAR; 64usize],
}
pub type KCRM_TRANSACTION_BLOB = _KCRM_TRANSACTION_BLOB;
pub type PKCRM_TRANSACTION_BLOB = *mut _KCRM_TRANSACTION_BLOB;
pub type PRKCRM_TRANSACTION_BLOB = *mut _KCRM_TRANSACTION_BLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KCRM_PROTOCOL_BLOB {
    pub ProtocolId: CRM_PROTOCOL_ID,
    pub StaticInfoLength: ULONG,
    pub TransactionIdInfoLength: ULONG,
    pub Unused1: ULONG,
    pub Unused2: ULONG,
}
pub type KCRM_PROTOCOL_BLOB = _KCRM_PROTOCOL_BLOB;
pub type PKCRM_PROTOCOL_BLOB = *mut _KCRM_PROTOCOL_BLOB;
pub type PRKCRM_PROTOCOL_BLOB = *mut _KCRM_PROTOCOL_BLOB;
pub const _TRANSACTION_OUTCOME_TransactionOutcomeUndetermined: _TRANSACTION_OUTCOME = 1;
pub const _TRANSACTION_OUTCOME_TransactionOutcomeCommitted: _TRANSACTION_OUTCOME = 2;
pub const _TRANSACTION_OUTCOME_TransactionOutcomeAborted: _TRANSACTION_OUTCOME = 3;
pub type _TRANSACTION_OUTCOME = core::ffi::c_int;
pub use self::_TRANSACTION_OUTCOME as TRANSACTION_OUTCOME;
pub const _TRANSACTION_STATE_TransactionStateNormal: _TRANSACTION_STATE = 1;
pub const _TRANSACTION_STATE_TransactionStateIndoubt: _TRANSACTION_STATE = 2;
pub const _TRANSACTION_STATE_TransactionStateCommittedNotify: _TRANSACTION_STATE = 3;
pub type _TRANSACTION_STATE = core::ffi::c_int;
pub use self::_TRANSACTION_STATE as TRANSACTION_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_BASIC_INFORMATION {
    pub TransactionId: GUID,
    pub State: ULONG,
    pub Outcome: ULONG,
}
pub type TRANSACTION_BASIC_INFORMATION = _TRANSACTION_BASIC_INFORMATION;
pub type PTRANSACTION_BASIC_INFORMATION = *mut _TRANSACTION_BASIC_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TRANSACTIONMANAGER_BASIC_INFORMATION {
    pub TmIdentity: GUID,
    pub VirtualClock: LARGE_INTEGER,
}
pub type TRANSACTIONMANAGER_BASIC_INFORMATION = _TRANSACTIONMANAGER_BASIC_INFORMATION;
pub type PTRANSACTIONMANAGER_BASIC_INFORMATION = *mut _TRANSACTIONMANAGER_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTIONMANAGER_LOG_INFORMATION {
    pub LogIdentity: GUID,
}
pub type TRANSACTIONMANAGER_LOG_INFORMATION = _TRANSACTIONMANAGER_LOG_INFORMATION;
pub type PTRANSACTIONMANAGER_LOG_INFORMATION = *mut _TRANSACTIONMANAGER_LOG_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTIONMANAGER_LOGPATH_INFORMATION {
    pub LogPathLength: ULONG,
    pub LogPath: [WCHAR; 1usize],
}
pub type TRANSACTIONMANAGER_LOGPATH_INFORMATION = _TRANSACTIONMANAGER_LOGPATH_INFORMATION;
pub type PTRANSACTIONMANAGER_LOGPATH_INFORMATION = *mut _TRANSACTIONMANAGER_LOGPATH_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTIONMANAGER_RECOVERY_INFORMATION {
    pub LastRecoveredLsn: ULONGLONG,
}
pub type TRANSACTIONMANAGER_RECOVERY_INFORMATION = _TRANSACTIONMANAGER_RECOVERY_INFORMATION;
pub type PTRANSACTIONMANAGER_RECOVERY_INFORMATION = *mut _TRANSACTIONMANAGER_RECOVERY_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TRANSACTION_PROPERTIES_INFORMATION {
    pub IsolationLevel: ULONG,
    pub IsolationFlags: ULONG,
    pub Timeout: LARGE_INTEGER,
    pub Outcome: ULONG,
    pub DescriptionLength: ULONG,
    pub Description: [WCHAR; 1usize],
}
pub type TRANSACTION_PROPERTIES_INFORMATION = _TRANSACTION_PROPERTIES_INFORMATION;
pub type PTRANSACTION_PROPERTIES_INFORMATION = *mut _TRANSACTION_PROPERTIES_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_BIND_INFORMATION {
    pub TmHandle: HANDLE,
}
pub type TRANSACTION_BIND_INFORMATION = _TRANSACTION_BIND_INFORMATION;
pub type PTRANSACTION_BIND_INFORMATION = *mut _TRANSACTION_BIND_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_ENLISTMENT_PAIR {
    pub EnlistmentId: GUID,
    pub ResourceManagerId: GUID,
}
pub type TRANSACTION_ENLISTMENT_PAIR = _TRANSACTION_ENLISTMENT_PAIR;
pub type PTRANSACTION_ENLISTMENT_PAIR = *mut _TRANSACTION_ENLISTMENT_PAIR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_ENLISTMENTS_INFORMATION {
    pub NumberOfEnlistments: ULONG,
    pub EnlistmentPair: [TRANSACTION_ENLISTMENT_PAIR; 1usize],
}
pub type TRANSACTION_ENLISTMENTS_INFORMATION = _TRANSACTION_ENLISTMENTS_INFORMATION;
pub type PTRANSACTION_ENLISTMENTS_INFORMATION = *mut _TRANSACTION_ENLISTMENTS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION {
    pub SuperiorEnlistmentPair: TRANSACTION_ENLISTMENT_PAIR,
}
pub type TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION = _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION;
pub type PTRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION =
*mut _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RESOURCEMANAGER_BASIC_INFORMATION {
    pub ResourceManagerId: GUID,
    pub DescriptionLength: ULONG,
    pub Description: [WCHAR; 1usize],
}
pub type RESOURCEMANAGER_BASIC_INFORMATION = _RESOURCEMANAGER_BASIC_INFORMATION;
pub type PRESOURCEMANAGER_BASIC_INFORMATION = *mut _RESOURCEMANAGER_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RESOURCEMANAGER_COMPLETION_INFORMATION {
    pub IoCompletionPortHandle: HANDLE,
    pub CompletionKey: ULONG_PTR,
}
pub type RESOURCEMANAGER_COMPLETION_INFORMATION = _RESOURCEMANAGER_COMPLETION_INFORMATION;
pub type PRESOURCEMANAGER_COMPLETION_INFORMATION = *mut _RESOURCEMANAGER_COMPLETION_INFORMATION;
pub const _TRANSACTION_INFORMATION_CLASS_TransactionBasicInformation:
_TRANSACTION_INFORMATION_CLASS = 0;
pub const _TRANSACTION_INFORMATION_CLASS_TransactionPropertiesInformation:
_TRANSACTION_INFORMATION_CLASS = 1;
pub const _TRANSACTION_INFORMATION_CLASS_TransactionEnlistmentInformation:
_TRANSACTION_INFORMATION_CLASS = 2;
pub const _TRANSACTION_INFORMATION_CLASS_TransactionSuperiorEnlistmentInformation:
_TRANSACTION_INFORMATION_CLASS = 3;
pub type _TRANSACTION_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_TRANSACTION_INFORMATION_CLASS as TRANSACTION_INFORMATION_CLASS;
pub const _TRANSACTIONMANAGER_INFORMATION_CLASS_TransactionManagerBasicInformation:
_TRANSACTIONMANAGER_INFORMATION_CLASS = 0;
pub const _TRANSACTIONMANAGER_INFORMATION_CLASS_TransactionManagerLogInformation:
_TRANSACTIONMANAGER_INFORMATION_CLASS = 1;
pub const _TRANSACTIONMANAGER_INFORMATION_CLASS_TransactionManagerLogPathInformation:
_TRANSACTIONMANAGER_INFORMATION_CLASS = 2;
pub const _TRANSACTIONMANAGER_INFORMATION_CLASS_TransactionManagerRecoveryInformation:
_TRANSACTIONMANAGER_INFORMATION_CLASS = 4;
pub type _TRANSACTIONMANAGER_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_TRANSACTIONMANAGER_INFORMATION_CLASS as TRANSACTIONMANAGER_INFORMATION_CLASS;
pub const _RESOURCEMANAGER_INFORMATION_CLASS_ResourceManagerBasicInformation:
_RESOURCEMANAGER_INFORMATION_CLASS = 0;
pub const _RESOURCEMANAGER_INFORMATION_CLASS_ResourceManagerCompletionInformation:
_RESOURCEMANAGER_INFORMATION_CLASS = 1;
pub type _RESOURCEMANAGER_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_RESOURCEMANAGER_INFORMATION_CLASS as RESOURCEMANAGER_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENLISTMENT_BASIC_INFORMATION {
    pub EnlistmentId: GUID,
    pub TransactionId: GUID,
    pub ResourceManagerId: GUID,
}
pub type ENLISTMENT_BASIC_INFORMATION = _ENLISTMENT_BASIC_INFORMATION;
pub type PENLISTMENT_BASIC_INFORMATION = *mut _ENLISTMENT_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENLISTMENT_CRM_INFORMATION {
    pub CrmTransactionManagerId: GUID,
    pub CrmResourceManagerId: GUID,
    pub CrmEnlistmentId: GUID,
}
pub type ENLISTMENT_CRM_INFORMATION = _ENLISTMENT_CRM_INFORMATION;
pub type PENLISTMENT_CRM_INFORMATION = *mut _ENLISTMENT_CRM_INFORMATION;
pub const _ENLISTMENT_INFORMATION_CLASS_EnlistmentBasicInformation: _ENLISTMENT_INFORMATION_CLASS =
    0;
pub const _ENLISTMENT_INFORMATION_CLASS_EnlistmentRecoveryInformation:
_ENLISTMENT_INFORMATION_CLASS = 1;
pub const _ENLISTMENT_INFORMATION_CLASS_EnlistmentCrmInformation: _ENLISTMENT_INFORMATION_CLASS = 2;
pub type _ENLISTMENT_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_ENLISTMENT_INFORMATION_CLASS as ENLISTMENT_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_LIST_ENTRY {
    pub UOW: UOW,
}
pub type TRANSACTION_LIST_ENTRY = _TRANSACTION_LIST_ENTRY;
pub type PTRANSACTION_LIST_ENTRY = *mut _TRANSACTION_LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_LIST_INFORMATION {
    pub NumberOfTransactions: ULONG,
    pub TransactionInformation: [TRANSACTION_LIST_ENTRY; 1usize],
}
pub type TRANSACTION_LIST_INFORMATION = _TRANSACTION_LIST_INFORMATION;
pub type PTRANSACTION_LIST_INFORMATION = *mut _TRANSACTION_LIST_INFORMATION;
pub const _KTMOBJECT_TYPE_KTMOBJECT_TRANSACTION: _KTMOBJECT_TYPE = 0;
pub const _KTMOBJECT_TYPE_KTMOBJECT_TRANSACTION_MANAGER: _KTMOBJECT_TYPE = 1;
pub const _KTMOBJECT_TYPE_KTMOBJECT_RESOURCE_MANAGER: _KTMOBJECT_TYPE = 2;
pub const _KTMOBJECT_TYPE_KTMOBJECT_ENLISTMENT: _KTMOBJECT_TYPE = 3;
pub const _KTMOBJECT_TYPE_KTMOBJECT_INVALID: _KTMOBJECT_TYPE = 4;
pub type _KTMOBJECT_TYPE = core::ffi::c_int;
pub use self::_KTMOBJECT_TYPE as KTMOBJECT_TYPE;
pub type PKTMOBJECT_TYPE = *mut _KTMOBJECT_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTMOBJECT_CURSOR {
    pub LastQuery: GUID,
    pub ObjectIdCount: ULONG,
    pub ObjectIds: [GUID; 1usize],
}
pub type KTMOBJECT_CURSOR = _KTMOBJECT_CURSOR;
pub type PKTMOBJECT_CURSOR = *mut _KTMOBJECT_CURSOR;
unsafe extern "C" {
    pub fn NtCreateTransactionManager(
        TmHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        LogFileName: PUNICODE_STRING,
        CreateOptions: ULONG,
        CommitStrength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtOpenTransactionManager(
        TmHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        LogFileName: PUNICODE_STRING,
        TmIdentity: LPGUID,
        OpenOptions: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtRenameTransactionManager(
        LogFileName: PUNICODE_STRING,
        ExistingTransactionManagerGuid: LPGUID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtRollforwardTransactionManager(
        TransactionManagerHandle: HANDLE,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtRecoverTransactionManager(TransactionManagerHandle: HANDLE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtQueryInformationTransactionManager(
        TransactionManagerHandle: HANDLE,
        TransactionManagerInformationClass: TRANSACTIONMANAGER_INFORMATION_CLASS,
        TransactionManagerInformation: PVOID,
        TransactionManagerInformationLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtSetInformationTransactionManager(
        TmHandle: HANDLE,
        TransactionManagerInformationClass: TRANSACTIONMANAGER_INFORMATION_CLASS,
        TransactionManagerInformation: PVOID,
        TransactionManagerInformationLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtEnumerateTransactionObject(
        RootObjectHandle: HANDLE,
        QueryType: KTMOBJECT_TYPE,
        ObjectCursor: PKTMOBJECT_CURSOR,
        ObjectCursorLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
pub type PFN_NT_CREATE_TRANSACTION = ::core::option::Option<
    unsafe extern "C" fn(
        TransactionHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        Uow: LPGUID,
        TmHandle: HANDLE,
        CreateOptions: ULONG,
        IsolationLevel: ULONG,
        IsolationFlags: ULONG,
        Timeout: PLARGE_INTEGER,
        Description: PUNICODE_STRING,
    ) -> NTSTATUS,
>;
unsafe extern "C" {
    pub fn NtCreateTransaction(
        TransactionHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        Uow: LPGUID,
        TmHandle: HANDLE,
        CreateOptions: ULONG,
        IsolationLevel: ULONG,
        IsolationFlags: ULONG,
        Timeout: PLARGE_INTEGER,
        Description: PUNICODE_STRING,
    ) -> NTSTATUS;
}
pub type PFN_NT_OPEN_TRANSACTION = ::core::option::Option<
    unsafe extern "C" fn(
        TransactionHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        Uow: LPGUID,
        TmHandle: HANDLE,
    ) -> NTSTATUS,
>;
unsafe extern "C" {
    pub fn NtOpenTransaction(
        TransactionHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        Uow: LPGUID,
        TmHandle: HANDLE,
    ) -> NTSTATUS;
}
pub type PFN_NT_QUERY_INFORMATION_TRANSACTION = ::core::option::Option<
    unsafe extern "C" fn(
        TransactionHandle: HANDLE,
        TransactionInformationClass: TRANSACTION_INFORMATION_CLASS,
        TransactionInformation: PVOID,
        TransactionInformationLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS,
>;
unsafe extern "C" {
    pub fn NtQueryInformationTransaction(
        TransactionHandle: HANDLE,
        TransactionInformationClass: TRANSACTION_INFORMATION_CLASS,
        TransactionInformation: PVOID,
        TransactionInformationLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
pub type PFN_NT_SET_INFORMATION_TRANSACTION = ::core::option::Option<
    unsafe extern "C" fn(
        TransactionHandle: HANDLE,
        TransactionInformationClass: TRANSACTION_INFORMATION_CLASS,
        TransactionInformation: PVOID,
        TransactionInformationLength: ULONG,
    ) -> NTSTATUS,
>;
unsafe extern "C" {
    pub fn NtSetInformationTransaction(
        TransactionHandle: HANDLE,
        TransactionInformationClass: TRANSACTION_INFORMATION_CLASS,
        TransactionInformation: PVOID,
        TransactionInformationLength: ULONG,
    ) -> NTSTATUS;
}
pub type PFN_NT_COMMIT_TRANSACTION = ::core::option::Option<
    unsafe extern "C" fn(TransactionHandle: HANDLE, Wait: BOOLEAN) -> NTSTATUS,
>;
unsafe extern "C" {
    pub fn NtCommitTransaction(TransactionHandle: HANDLE, Wait: BOOLEAN) -> NTSTATUS;
}
pub type PFN_NT_ROLLBACK_TRANSACTION = ::core::option::Option<
    unsafe extern "C" fn(TransactionHandle: HANDLE, Wait: BOOLEAN) -> NTSTATUS,
>;
unsafe extern "C" {
    pub fn NtRollbackTransaction(TransactionHandle: HANDLE, Wait: BOOLEAN) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtCreateEnlistment(
        EnlistmentHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ResourceManagerHandle: HANDLE,
        TransactionHandle: HANDLE,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        CreateOptions: ULONG,
        NotificationMask: NOTIFICATION_MASK,
        EnlistmentKey: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtOpenEnlistment(
        EnlistmentHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ResourceManagerHandle: HANDLE,
        EnlistmentGuid: LPGUID,
        ObjectAttributes: POBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtQueryInformationEnlistment(
        EnlistmentHandle: HANDLE,
        EnlistmentInformationClass: ENLISTMENT_INFORMATION_CLASS,
        EnlistmentInformation: PVOID,
        EnlistmentInformationLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtSetInformationEnlistment(
        EnlistmentHandle: HANDLE,
        EnlistmentInformationClass: ENLISTMENT_INFORMATION_CLASS,
        EnlistmentInformation: PVOID,
        EnlistmentInformationLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtRecoverEnlistment(EnlistmentHandle: HANDLE, EnlistmentKey: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtPrePrepareEnlistment(
        EnlistmentHandle: HANDLE,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtPrepareEnlistment(
        EnlistmentHandle: HANDLE,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtCommitEnlistment(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER)
                              -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtRollbackEnlistment(
        EnlistmentHandle: HANDLE,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtPrePrepareComplete(
        EnlistmentHandle: HANDLE,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtPrepareComplete(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtCommitComplete(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtReadOnlyEnlistment(
        EnlistmentHandle: HANDLE,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtRollbackComplete(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER)
                              -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtSinglePhaseReject(
        EnlistmentHandle: HANDLE,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtCreateResourceManager(
        ResourceManagerHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        TmHandle: HANDLE,
        RmGuid: LPGUID,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        CreateOptions: ULONG,
        Description: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtOpenResourceManager(
        ResourceManagerHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        TmHandle: HANDLE,
        ResourceManagerGuid: LPGUID,
        ObjectAttributes: POBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtRecoverResourceManager(ResourceManagerHandle: HANDLE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtGetNotificationResourceManager(
        ResourceManagerHandle: HANDLE,
        TransactionNotification: PTRANSACTION_NOTIFICATION,
        NotificationLength: ULONG,
        Timeout: PLARGE_INTEGER,
        ReturnLength: PULONG,
        Asynchronous: ULONG,
        AsynchronousContext: ULONG_PTR,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtQueryInformationResourceManager(
        ResourceManagerHandle: HANDLE,
        ResourceManagerInformationClass: RESOURCEMANAGER_INFORMATION_CLASS,
        ResourceManagerInformation: PVOID,
        ResourceManagerInformationLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtSetInformationResourceManager(
        ResourceManagerHandle: HANDLE,
        ResourceManagerInformationClass: RESOURCEMANAGER_INFORMATION_CLASS,
        ResourceManagerInformation: PVOID,
        ResourceManagerInformationLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtRegisterProtocolAddressInformation(
        ResourceManager: HANDLE,
        ProtocolId: PCRM_PROTOCOL_ID,
        ProtocolInformationSize: ULONG,
        ProtocolInformation: PVOID,
        CreateOptions: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtPropagationComplete(
        ResourceManagerHandle: HANDLE,
        RequestCookie: ULONG,
        BufferLength: ULONG,
        Buffer: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtPropagationFailed(
        ResourceManagerHandle: HANDLE,
        RequestCookie: ULONG,
        PropStatus: NTSTATUS,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub static mut NtGlobalFlag: ULONG;
}
unsafe extern "C" {
    pub static mut NtGlobalFlag2: ULONG;
}
pub use self::_POOL_TYPE as POOL_TYPE;
pub type POOL_FLAGS = ULONG64;
pub type ALLOCATE_FUNCTION = ::core::option::Option<
    unsafe extern "C" fn(PoolType: POOL_TYPE, NumberOfBytes: SIZE_T, Tag: ULONG) -> PVOID,
>;
pub type PALLOCATE_FUNCTION = ALLOCATE_FUNCTION;
pub type FREE_FUNCTION = ::core::option::Option<unsafe extern "C" fn(Buffer: PVOID)>;
pub type PFREE_FUNCTION = FREE_FUNCTION;
pub type PLOOKASIDE_LIST_EX = *mut _LOOKASIDE_LIST_EX;
pub type ALLOCATE_FUNCTION_EX = ::core::option::Option<
    unsafe extern "C" fn(
        PoolType: POOL_TYPE,
        NumberOfBytes: SIZE_T,
        Tag: ULONG,
        Lookaside: PLOOKASIDE_LIST_EX,
    ) -> PVOID,
>;
pub type PALLOCATE_FUNCTION_EX = ALLOCATE_FUNCTION_EX;
pub type FREE_FUNCTION_EX =
::core::option::Option<unsafe extern "C" fn(Buffer: PVOID, Lookaside: PLOOKASIDE_LIST_EX)>;
pub type PFREE_FUNCTION_EX = FREE_FUNCTION_EX;
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct _GENERAL_LOOKASIDE {
    pub __bindgen_anon_1: _GENERAL_LOOKASIDE__bindgen_ty_1,
    pub Depth: USHORT,
    pub MaximumDepth: USHORT,
    pub TotalAllocates: ULONG,
    pub __bindgen_anon_2: _GENERAL_LOOKASIDE__bindgen_ty_2,
    pub TotalFrees: ULONG,
    pub __bindgen_anon_3: _GENERAL_LOOKASIDE__bindgen_ty_3,
    pub Type: POOL_TYPE,
    pub Tag: ULONG,
    pub Size: ULONG,
    pub __bindgen_anon_4: _GENERAL_LOOKASIDE__bindgen_ty_4,
    pub __bindgen_anon_5: _GENERAL_LOOKASIDE__bindgen_ty_5,
    pub ListEntry: LIST_ENTRY,
    pub LastTotalAllocates: ULONG,
    pub __bindgen_anon_6: _GENERAL_LOOKASIDE__bindgen_ty_6,
    pub Future: [ULONG; 2usize],
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE__bindgen_ty_1 {
    pub ListHead: SLIST_HEADER,
    pub SingleListHead: SINGLE_LIST_ENTRY,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE__bindgen_ty_2 {
    pub AllocateMisses: ULONG,
    pub AllocateHits: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE__bindgen_ty_3 {
    pub FreeMisses: ULONG,
    pub FreeHits: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE__bindgen_ty_4 {
    pub AllocateEx: PALLOCATE_FUNCTION_EX,
    pub Allocate: PALLOCATE_FUNCTION,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE__bindgen_ty_5 {
    pub FreeEx: PFREE_FUNCTION_EX,
    pub Free: PFREE_FUNCTION,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE__bindgen_ty_6 {
    pub LastAllocateMisses: ULONG,
    pub LastAllocateHits: ULONG,
}
pub type GENERAL_LOOKASIDE = _GENERAL_LOOKASIDE;
pub type PGENERAL_LOOKASIDE = *mut GENERAL_LOOKASIDE;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _GENERAL_LOOKASIDE_POOL {
    pub __bindgen_anon_1: _GENERAL_LOOKASIDE_POOL__bindgen_ty_1,
    pub Depth: USHORT,
    pub MaximumDepth: USHORT,
    pub TotalAllocates: ULONG,
    pub __bindgen_anon_2: _GENERAL_LOOKASIDE_POOL__bindgen_ty_2,
    pub TotalFrees: ULONG,
    pub __bindgen_anon_3: _GENERAL_LOOKASIDE_POOL__bindgen_ty_3,
    pub Type: POOL_TYPE,
    pub Tag: ULONG,
    pub Size: ULONG,
    pub __bindgen_anon_4: _GENERAL_LOOKASIDE_POOL__bindgen_ty_4,
    pub __bindgen_anon_5: _GENERAL_LOOKASIDE_POOL__bindgen_ty_5,
    pub ListEntry: LIST_ENTRY,
    pub LastTotalAllocates: ULONG,
    pub __bindgen_anon_6: _GENERAL_LOOKASIDE_POOL__bindgen_ty_6,
    pub Future: [ULONG; 2usize],
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE_POOL__bindgen_ty_1 {
    pub ListHead: SLIST_HEADER,
    pub SingleListHead: SINGLE_LIST_ENTRY,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE_POOL__bindgen_ty_2 {
    pub AllocateMisses: ULONG,
    pub AllocateHits: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE_POOL__bindgen_ty_3 {
    pub FreeMisses: ULONG,
    pub FreeHits: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE_POOL__bindgen_ty_4 {
    pub AllocateEx: PALLOCATE_FUNCTION_EX,
    pub Allocate: PALLOCATE_FUNCTION,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE_POOL__bindgen_ty_5 {
    pub FreeEx: PFREE_FUNCTION_EX,
    pub Free: PFREE_FUNCTION,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE_POOL__bindgen_ty_6 {
    pub LastAllocateMisses: ULONG,
    pub LastAllocateHits: ULONG,
}
pub type GENERAL_LOOKASIDE_POOL = _GENERAL_LOOKASIDE_POOL;
pub type PGENERAL_LOOKASIDE_POOL = *mut _GENERAL_LOOKASIDE_POOL;
pub type KPROCESSOR_MODE = CCHAR;
pub const _MODE_KernelMode: _MODE = 0;
pub const _MODE_UserMode: _MODE = 1;
pub const _MODE_MaximumMode: _MODE = 2;
pub type _MODE = core::ffi::c_int;
pub use self::_MODE as MODE;
pub type KSYNCHRONIZE_ROUTINE =
::core::option::Option<unsafe extern "C" fn(SynchronizeContext: PVOID) -> BOOLEAN>;
pub type PKSYNCHRONIZE_ROUTINE = KSYNCHRONIZE_ROUTINE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KAPC {
    pub Type: UCHAR,
    pub AllFlags: UCHAR,
    pub Size: UCHAR,
    pub SpareByte1: UCHAR,
    pub SpareLong0: ULONG,
    pub Thread: *mut _KTHREAD,
    pub ApcListEntry: LIST_ENTRY,
    pub Reserved: [PVOID; 3usize],
    pub NormalContext: PVOID,
    pub SystemArgument1: PVOID,
    pub SystemArgument2: PVOID,
    pub ApcStateIndex: CCHAR,
    pub ApcMode: KPROCESSOR_MODE,
    pub Inserted: BOOLEAN,
}
pub type KAPC = _KAPC;
pub type PKAPC = *mut _KAPC;
pub type PRKAPC = *mut _KAPC;
pub type KDEFERRED_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(
        Dpc: *mut _KDPC,
        DeferredContext: PVOID,
        SystemArgument1: PVOID,
        SystemArgument2: PVOID,
    ),
>;
pub type PKDEFERRED_ROUTINE = KDEFERRED_ROUTINE;
pub const _KDPC_IMPORTANCE_LowImportance: _KDPC_IMPORTANCE = 0;
pub const _KDPC_IMPORTANCE_MediumImportance: _KDPC_IMPORTANCE = 1;
pub const _KDPC_IMPORTANCE_HighImportance: _KDPC_IMPORTANCE = 2;
pub const _KDPC_IMPORTANCE_MediumHighImportance: _KDPC_IMPORTANCE = 3;
pub type _KDPC_IMPORTANCE = core::ffi::c_int;
pub use self::_KDPC_IMPORTANCE as KDPC_IMPORTANCE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KDPC {
    pub __bindgen_anon_1: _KDPC__bindgen_ty_1,
    pub DpcListEntry: SINGLE_LIST_ENTRY,
    pub ProcessorHistory: KAFFINITY,
    pub DeferredRoutine: PKDEFERRED_ROUTINE,
    pub DeferredContext: PVOID,
    pub SystemArgument1: PVOID,
    pub SystemArgument2: PVOID,
    pub DpcData: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KDPC__bindgen_ty_1 {
    pub TargetInfoAsUlong: ULONG,
    pub __bindgen_anon_1: _KDPC__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KDPC__bindgen_ty_1__bindgen_ty_1 {
    pub Type: UCHAR,
    pub Importance: UCHAR,
    pub Number: USHORT,
}
pub type KDPC = _KDPC;
pub type PKDPC = *mut _KDPC;
pub type PRKDPC = *mut _KDPC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MDL {
    pub Next: *mut _MDL,
    pub Size: CSHORT,
    pub MdlFlags: CSHORT,
    pub Process: *mut _EPROCESS,
    pub MappedSystemVa: PVOID,
    pub StartVa: PVOID,
    pub ByteCount: ULONG,
    pub ByteOffset: ULONG,
}
pub type MDL = _MDL;
pub type PMDL = *mut _MDL;
pub type PMDLX = *mut MDL;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPATCHER_HEADER {
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1,
    pub SignalState: LONG,
    pub WaitListHead: LIST_ENTRY,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1 {
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3,
    pub __bindgen_anon_4: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4,
    pub __bindgen_anon_5: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5,
    pub __bindgen_anon_6: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6,
    pub __bindgen_anon_7: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1 {
    pub Lock: LONG,
    pub LockNV: LONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2 {
    pub Type: UCHAR,
    pub Signalling: UCHAR,
    pub Size: UCHAR,
    pub Reserved1: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3 {
    pub TimerType: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1,
    pub Hand: UCHAR,
    pub __bindgen_anon_2: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    pub TimerControlFlags: UCHAR,
    pub __bindgen_anon_1:
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Absolute(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Absolute(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Absolute_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Absolute_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Wake(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Wake(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Wake_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Wake_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EncodedTolerableDelay(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_EncodedTolerableDelay(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EncodedTolerableDelay_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                6u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_EncodedTolerableDelay_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Absolute: UCHAR,
        Wake: UCHAR,
        EncodedTolerableDelay: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Absolute: u8 = unsafe { ::core::mem::transmute(Absolute) };
            Absolute as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Wake: u8 = unsafe { ::core::mem::transmute(Wake) };
            Wake as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let EncodedTolerableDelay: u8 =
                unsafe { ::core::mem::transmute(EncodedTolerableDelay) };
            EncodedTolerableDelay as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2 {
    pub TimerMiscFlags: UCHAR,
    pub __bindgen_anon_1:
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn Index(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_Index(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Index_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                6u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Index_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Inserted(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Inserted(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Inserted_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Inserted_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Expired(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Expired(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Expired_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Expired_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Index: UCHAR,
        Inserted: UCHAR,
        Expired: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let Index: u8 = unsafe { ::core::mem::transmute(Index) };
            Index as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Inserted: u8 = unsafe { ::core::mem::transmute(Inserted) };
            Inserted as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Expired: u8 = unsafe { ::core::mem::transmute(Expired) };
            Expired as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4 {
    pub Timer2Type: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
    pub Timer2ComponentId: UCHAR,
    pub Timer2RelativeId: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    pub Timer2Flags: UCHAR,
    pub __bindgen_anon_1:
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Timer2Inserted(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2Inserted(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Timer2Inserted_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Timer2Inserted_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Timer2Expiring(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2Expiring(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Timer2Expiring_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Timer2Expiring_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Timer2CancelPending(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2CancelPending(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Timer2CancelPending_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Timer2CancelPending_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Timer2SetPending(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2SetPending(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Timer2SetPending_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Timer2SetPending_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Timer2Running(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2Running(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Timer2Running_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Timer2Running_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Timer2Disabled(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2Disabled(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Timer2Disabled_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Timer2Disabled_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Timer2ReservedFlags(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2ReservedFlags(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Timer2ReservedFlags_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Timer2ReservedFlags_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Timer2Inserted: UCHAR,
        Timer2Expiring: UCHAR,
        Timer2CancelPending: UCHAR,
        Timer2SetPending: UCHAR,
        Timer2Running: UCHAR,
        Timer2Disabled: UCHAR,
        Timer2ReservedFlags: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Timer2Inserted: u8 = unsafe { ::core::mem::transmute(Timer2Inserted) };
            Timer2Inserted as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Timer2Expiring: u8 = unsafe { ::core::mem::transmute(Timer2Expiring) };
            Timer2Expiring as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Timer2CancelPending: u8 = unsafe { ::core::mem::transmute(Timer2CancelPending) };
            Timer2CancelPending as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Timer2SetPending: u8 = unsafe { ::core::mem::transmute(Timer2SetPending) };
            Timer2SetPending as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Timer2Running: u8 = unsafe { ::core::mem::transmute(Timer2Running) };
            Timer2Running as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Timer2Disabled: u8 = unsafe { ::core::mem::transmute(Timer2Disabled) };
            Timer2Disabled as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let Timer2ReservedFlags: u8 = unsafe { ::core::mem::transmute(Timer2ReservedFlags) };
            Timer2ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5 {
    pub QueueType: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
    pub QueueSize: UCHAR,
    pub QueueReserved: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub QueueControlFlags: UCHAR,
    pub __bindgen_anon_1:
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Abandoned(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Abandoned(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Abandoned_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Abandoned_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DisableIncrement(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DisableIncrement(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DisableIncrement_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_DisableIncrement_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn QueueReservedControlFlags(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_QueueReservedControlFlags(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn QueueReservedControlFlags_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                6u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_QueueReservedControlFlags_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Abandoned: UCHAR,
        DisableIncrement: UCHAR,
        QueueReservedControlFlags: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Abandoned: u8 = unsafe { ::core::mem::transmute(Abandoned) };
            Abandoned as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DisableIncrement: u8 = unsafe { ::core::mem::transmute(DisableIncrement) };
            DisableIncrement as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let QueueReservedControlFlags: u8 =
                unsafe { ::core::mem::transmute(QueueReservedControlFlags) };
            QueueReservedControlFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6 {
    pub ThreadType: UCHAR,
    pub ThreadReserved: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1,
    pub __bindgen_anon_2: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1 {
    pub ThreadControlFlags: UCHAR,
    pub __bindgen_anon_1:
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn CycleProfiling(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CycleProfiling(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CycleProfiling_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_CycleProfiling_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CounterProfiling(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CounterProfiling(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CounterProfiling_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_CounterProfiling_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn GroupScheduling(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_GroupScheduling(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn GroupScheduling_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_GroupScheduling_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AffinitySet(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AffinitySet(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AffinitySet_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_AffinitySet_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Tagged(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Tagged(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Tagged_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Tagged_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EnergyProfiling(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_EnergyProfiling(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EnergyProfiling_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_EnergyProfiling_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SchedulerAssist(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SchedulerAssist(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SchedulerAssist_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_SchedulerAssist_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ThreadReservedControlFlags(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ThreadReservedControlFlags(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ThreadReservedControlFlags_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ThreadReservedControlFlags_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CycleProfiling: UCHAR,
        CounterProfiling: UCHAR,
        GroupScheduling: UCHAR,
        AffinitySet: UCHAR,
        Tagged: UCHAR,
        EnergyProfiling: UCHAR,
        SchedulerAssist: UCHAR,
        ThreadReservedControlFlags: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CycleProfiling: u8 = unsafe { ::core::mem::transmute(CycleProfiling) };
            CycleProfiling as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CounterProfiling: u8 = unsafe { ::core::mem::transmute(CounterProfiling) };
            CounterProfiling as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let GroupScheduling: u8 = unsafe { ::core::mem::transmute(GroupScheduling) };
            GroupScheduling as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AffinitySet: u8 = unsafe { ::core::mem::transmute(AffinitySet) };
            AffinitySet as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Tagged: u8 = unsafe { ::core::mem::transmute(Tagged) };
            Tagged as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let EnergyProfiling: u8 = unsafe { ::core::mem::transmute(EnergyProfiling) };
            EnergyProfiling as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SchedulerAssist: u8 = unsafe { ::core::mem::transmute(SchedulerAssist) };
            SchedulerAssist as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ThreadReservedControlFlags: u8 =
                unsafe { ::core::mem::transmute(ThreadReservedControlFlags) };
            ThreadReservedControlFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2 {
    pub DebugActive: UCHAR,
    pub __bindgen_anon_1:
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn ActiveDR7(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ActiveDR7(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ActiveDR7_raw(this: *const Self) -> BOOLEAN {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ActiveDR7_raw(this: *mut Self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Instrumented(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Instrumented(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Instrumented_raw(this: *const Self) -> BOOLEAN {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Instrumented_raw(this: *mut Self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Minimal(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Minimal(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Minimal_raw(this: *const Self) -> BOOLEAN {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Minimal_raw(this: *mut Self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved4(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved4(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved4_raw(this: *const Self) -> BOOLEAN {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved4_raw(this: *mut Self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AltSyscall(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AltSyscall(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AltSyscall_raw(this: *const Self) -> BOOLEAN {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_AltSyscall_raw(this: *mut Self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Emulation(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Emulation(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Emulation_raw(this: *const Self) -> BOOLEAN {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Emulation_raw(this: *mut Self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved5(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved5(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved5_raw(this: *const Self) -> BOOLEAN {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved5_raw(this: *mut Self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ActiveDR7: BOOLEAN,
        Instrumented: BOOLEAN,
        Minimal: BOOLEAN,
        Reserved4: BOOLEAN,
        AltSyscall: BOOLEAN,
        Emulation: BOOLEAN,
        Reserved5: BOOLEAN,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ActiveDR7: u8 = unsafe { ::core::mem::transmute(ActiveDR7) };
            ActiveDR7 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Instrumented: u8 = unsafe { ::core::mem::transmute(Instrumented) };
            Instrumented as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Minimal: u8 = unsafe { ::core::mem::transmute(Minimal) };
            Minimal as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let Reserved4: u8 = unsafe { ::core::mem::transmute(Reserved4) };
            Reserved4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let AltSyscall: u8 = unsafe { ::core::mem::transmute(AltSyscall) };
            AltSyscall as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Emulation: u8 = unsafe { ::core::mem::transmute(Emulation) };
            Emulation as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Reserved5: u8 = unsafe { ::core::mem::transmute(Reserved5) };
            Reserved5 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7 {
    pub MutantType: UCHAR,
    pub MutantSize: UCHAR,
    pub DpcActive: BOOLEAN,
    pub MutantReserved: UCHAR,
}
pub type DISPATCHER_HEADER = _DISPATCHER_HEADER;
pub type PDISPATCHER_HEADER = *mut _DISPATCHER_HEADER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KEVENT {
    pub Header: DISPATCHER_HEADER,
}
pub type KEVENT = _KEVENT;
pub type PKEVENT = *mut _KEVENT;
pub type PRKEVENT = *mut _KEVENT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KGATE {
    pub Header: DISPATCHER_HEADER,
}
pub type KGATE = _KGATE;
pub type PKGATE = *mut _KGATE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KTIMER {
    pub Header: DISPATCHER_HEADER,
    pub DueTime: ULARGE_INTEGER,
    pub TimerListEntry: LIST_ENTRY,
    pub Dpc: *mut _KDPC,
    pub Processor: USHORT,
    pub TimerType: USHORT,
    pub Period: ULONG,
}
pub type KTIMER = _KTIMER;
pub type PKTIMER = *mut _KTIMER;
pub type PRKTIMER = *mut _KTIMER;
pub const _LOCK_OPERATION_IoReadAccess: _LOCK_OPERATION = 0;
pub const _LOCK_OPERATION_IoWriteAccess: _LOCK_OPERATION = 1;
pub const _LOCK_OPERATION_IoModifyAccess: _LOCK_OPERATION = 2;
pub type _LOCK_OPERATION = core::ffi::c_int;
pub use self::_LOCK_OPERATION as LOCK_OPERATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FAST_MUTEX {
    pub Count: LONG,
    pub Owner: PVOID,
    pub Contention: ULONG,
    pub Event: KEVENT,
    pub OldIrql: ULONG,
}
pub type FAST_MUTEX = _FAST_MUTEX;
pub type PFAST_MUTEX = *mut _FAST_MUTEX;
pub type KGUARDED_MUTEX = _FAST_MUTEX;
pub type PKGUARDED_MUTEX = *mut _FAST_MUTEX;
unsafe extern "C" {
    pub fn __inbyte(Port: USHORT) -> UCHAR;
}
unsafe extern "C" {
    pub fn __inword(Port: USHORT) -> USHORT;
}
unsafe extern "C" {
    pub fn __indword(Port: USHORT) -> ULONG;
}
unsafe extern "C" {
    pub fn __outbyte(Port: USHORT, Data: UCHAR);
}
unsafe extern "C" {
    pub fn __outword(Port: USHORT, Data: USHORT);
}
unsafe extern "C" {
    pub fn __outdword(Port: USHORT, Data: ULONG);
}
unsafe extern "C" {
    pub fn __inbytestring(Port: USHORT, Buffer: PUCHAR, Count: ULONG);
}
unsafe extern "C" {
    pub fn __inwordstring(Port: USHORT, Buffer: PUSHORT, Count: ULONG);
}
unsafe extern "C" {
    pub fn __indwordstring(Port: USHORT, Buffer: PULONG, Count: ULONG);
}
unsafe extern "C" {
    pub fn __outbytestring(Port: USHORT, Buffer: PUCHAR, Count: ULONG);
}
unsafe extern "C" {
    pub fn __outwordstring(Port: USHORT, Buffer: PUSHORT, Count: ULONG);
}
unsafe extern "C" {
    pub fn __outdwordstring(Port: USHORT, Buffer: PULONG, Count: ULONG);
}
pub type PFN_COUNT = ULONG;
pub type SPFN_NUMBER = LONG64;
pub type PSPFN_NUMBER = *mut LONG64;
pub type PFN_NUMBER = ULONG64;
pub type PPFN_NUMBER = *mut ULONG64;
unsafe extern "C" {
    pub fn __readcr8() -> ULONG64;
}
unsafe extern "C" {
    pub fn __writecr8(Data: ULONG64);
}
unsafe extern "C" {
    pub fn KeFlushIoBuffers(Mdl: PMDL, ReadOperation: BOOLEAN, DmaOperation: BOOLEAN);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KFLOATING_SAVE {
    pub Dummy: ULONG,
}
pub type KFLOATING_SAVE = _KFLOATING_SAVE;
pub type PKFLOATING_SAVE = *mut _KFLOATING_SAVE;
unsafe extern "C" {
    pub fn KeGetCurrentIrql() -> KIRQL;
}
unsafe extern "C" {
    pub fn KeLowerIrql(NewIrql: KIRQL);
}
unsafe extern "C" {
    pub fn KfRaiseIrql(NewIrql: KIRQL) -> KIRQL;
}
pub const _FIRMWARE_TYPE_FirmwareTypeUnknown: _FIRMWARE_TYPE = 0;
pub const _FIRMWARE_TYPE_FirmwareTypeBios: _FIRMWARE_TYPE = 1;
pub const _FIRMWARE_TYPE_FirmwareTypeUefi: _FIRMWARE_TYPE = 2;
pub const _FIRMWARE_TYPE_FirmwareTypeMax: _FIRMWARE_TYPE = 3;
pub type _FIRMWARE_TYPE = core::ffi::c_int;
pub use self::_FIRMWARE_TYPE as FIRMWARE_TYPE;
pub type PFIRMWARE_TYPE = *mut _FIRMWARE_TYPE;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationProcessorCore: _LOGICAL_PROCESSOR_RELATIONSHIP =
    0;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationNumaNode: _LOGICAL_PROCESSOR_RELATIONSHIP = 1;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationCache: _LOGICAL_PROCESSOR_RELATIONSHIP = 2;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationProcessorPackage:
_LOGICAL_PROCESSOR_RELATIONSHIP = 3;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationGroup: _LOGICAL_PROCESSOR_RELATIONSHIP = 4;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationProcessorDie: _LOGICAL_PROCESSOR_RELATIONSHIP = 5;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationNumaNodeEx: _LOGICAL_PROCESSOR_RELATIONSHIP = 6;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationProcessorModule: _LOGICAL_PROCESSOR_RELATIONSHIP =
    7;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationAll: _LOGICAL_PROCESSOR_RELATIONSHIP = 65535;
pub type _LOGICAL_PROCESSOR_RELATIONSHIP = core::ffi::c_int;
pub use self::_LOGICAL_PROCESSOR_RELATIONSHIP as LOGICAL_PROCESSOR_RELATIONSHIP;
pub const _PROCESSOR_CACHE_TYPE_CacheUnified: _PROCESSOR_CACHE_TYPE = 0;
pub const _PROCESSOR_CACHE_TYPE_CacheInstruction: _PROCESSOR_CACHE_TYPE = 1;
pub const _PROCESSOR_CACHE_TYPE_CacheData: _PROCESSOR_CACHE_TYPE = 2;
pub const _PROCESSOR_CACHE_TYPE_CacheTrace: _PROCESSOR_CACHE_TYPE = 3;
pub type _PROCESSOR_CACHE_TYPE = core::ffi::c_int;
pub use self::_PROCESSOR_CACHE_TYPE as PROCESSOR_CACHE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CACHE_DESCRIPTOR {
    pub Level: UCHAR,
    pub Associativity: UCHAR,
    pub LineSize: USHORT,
    pub Size: ULONG,
    pub Type: PROCESSOR_CACHE_TYPE,
}
pub type CACHE_DESCRIPTOR = _CACHE_DESCRIPTOR;
pub type PCACHE_DESCRIPTOR = *mut _CACHE_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION {
    pub ProcessorMask: ULONG_PTR,
    pub Relationship: LOGICAL_PROCESSOR_RELATIONSHIP,
    pub __bindgen_anon_1: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1 {
    pub ProcessorCore: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1,
    pub NumaNode: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2,
    pub Cache: CACHE_DESCRIPTOR,
    pub Reserved: [ULONGLONG; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub Flags: UCHAR,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2 {
    pub NodeNumber: ULONG,
}
pub type SYSTEM_LOGICAL_PROCESSOR_INFORMATION = _SYSTEM_LOGICAL_PROCESSOR_INFORMATION;
pub type PSYSTEM_LOGICAL_PROCESSOR_INFORMATION = *mut _SYSTEM_LOGICAL_PROCESSOR_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESSOR_RELATIONSHIP {
    pub Flags: UCHAR,
    pub EfficiencyClass: UCHAR,
    pub Reserved: [UCHAR; 20usize],
    pub GroupCount: USHORT,
    pub GroupMask: [GROUP_AFFINITY; 1usize],
}
pub type PROCESSOR_RELATIONSHIP = _PROCESSOR_RELATIONSHIP;
pub type PPROCESSOR_RELATIONSHIP = *mut _PROCESSOR_RELATIONSHIP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NUMA_NODE_RELATIONSHIP {
    pub NodeNumber: ULONG,
    pub Reserved: [UCHAR; 18usize],
    pub GroupCount: USHORT,
    pub __bindgen_anon_1: _NUMA_NODE_RELATIONSHIP__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NUMA_NODE_RELATIONSHIP__bindgen_ty_1 {
    pub GroupMask: GROUP_AFFINITY,
    pub GroupMasks: [GROUP_AFFINITY; 1usize],
}
pub type NUMA_NODE_RELATIONSHIP = _NUMA_NODE_RELATIONSHIP;
pub type PNUMA_NODE_RELATIONSHIP = *mut _NUMA_NODE_RELATIONSHIP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CACHE_RELATIONSHIP {
    pub Level: UCHAR,
    pub Associativity: UCHAR,
    pub LineSize: USHORT,
    pub CacheSize: ULONG,
    pub Type: PROCESSOR_CACHE_TYPE,
    pub Reserved: [UCHAR; 18usize],
    pub GroupCount: USHORT,
    pub __bindgen_anon_1: _CACHE_RELATIONSHIP__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CACHE_RELATIONSHIP__bindgen_ty_1 {
    pub GroupMask: GROUP_AFFINITY,
    pub GroupMasks: [GROUP_AFFINITY; 1usize],
}
pub type CACHE_RELATIONSHIP = _CACHE_RELATIONSHIP;
pub type PCACHE_RELATIONSHIP = *mut _CACHE_RELATIONSHIP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESSOR_GROUP_INFO {
    pub MaximumProcessorCount: UCHAR,
    pub ActiveProcessorCount: UCHAR,
    pub Reserved: [UCHAR; 38usize],
    pub ActiveProcessorMask: KAFFINITY,
}
pub type PROCESSOR_GROUP_INFO = _PROCESSOR_GROUP_INFO;
pub type PPROCESSOR_GROUP_INFO = *mut _PROCESSOR_GROUP_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GROUP_RELATIONSHIP {
    pub MaximumGroupCount: USHORT,
    pub ActiveGroupCount: USHORT,
    pub Reserved: [UCHAR; 20usize],
    pub GroupInfo: [PROCESSOR_GROUP_INFO; 1usize],
}
pub type GROUP_RELATIONSHIP = _GROUP_RELATIONSHIP;
pub type PGROUP_RELATIONSHIP = *mut _GROUP_RELATIONSHIP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
    pub Relationship: LOGICAL_PROCESSOR_RELATIONSHIP,
    pub Size: ULONG,
    pub __bindgen_anon_1: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1 {
    pub Processor: PROCESSOR_RELATIONSHIP,
    pub NumaNode: NUMA_NODE_RELATIONSHIP,
    pub Cache: CACHE_RELATIONSHIP,
    pub Group: GROUP_RELATIONSHIP,
}
pub type SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX = _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;
pub type PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX = *mut _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;
pub const _CPU_SET_INFORMATION_TYPE_CpuSetInformation: _CPU_SET_INFORMATION_TYPE = 0;
pub type _CPU_SET_INFORMATION_TYPE = core::ffi::c_int;
pub use self::_CPU_SET_INFORMATION_TYPE as CPU_SET_INFORMATION_TYPE;
pub type PCPU_SET_INFORMATION_TYPE = *mut _CPU_SET_INFORMATION_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_CPU_SET_INFORMATION {
    pub Size: ULONG,
    pub Type: CPU_SET_INFORMATION_TYPE,
    pub __bindgen_anon_1: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1 {
    pub CpuSet: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub Id: ULONG,
    pub Group: USHORT,
    pub LogicalProcessorIndex: UCHAR,
    pub CoreIndex: UCHAR,
    pub LastLevelCacheIndex: UCHAR,
    pub NumaNodeIndex: UCHAR,
    pub EfficiencyClass: UCHAR,
    pub __bindgen_anon_1: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
    pub AllocationTag: ULONG64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub AllFlags: UCHAR,
    pub __bindgen_anon_1:
        _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Parked(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Parked(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Parked_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Parked_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Allocated(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Allocated(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Allocated_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Allocated_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AllocatedToTargetProcess(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AllocatedToTargetProcess(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AllocatedToTargetProcess_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_AllocatedToTargetProcess_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RealTime(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RealTime(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RealTime_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_RealTime_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReservedFlags_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Parked: UCHAR,
        Allocated: UCHAR,
        AllocatedToTargetProcess: UCHAR,
        RealTime: UCHAR,
        ReservedFlags: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Parked: u8 = unsafe { ::core::mem::transmute(Parked) };
            Parked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Allocated: u8 = unsafe { ::core::mem::transmute(Allocated) };
            Allocated as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let AllocatedToTargetProcess: u8 =
                unsafe { ::core::mem::transmute(AllocatedToTargetProcess) };
            AllocatedToTargetProcess as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let RealTime: u8 = unsafe { ::core::mem::transmute(RealTime) };
            RealTime as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let ReservedFlags: u8 = unsafe { ::core::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub Reserved: ULONG,
    pub SchedulingClass: UCHAR,
}
pub type SYSTEM_CPU_SET_INFORMATION = _SYSTEM_CPU_SET_INFORMATION;
pub type PSYSTEM_CPU_SET_INFORMATION = *mut _SYSTEM_CPU_SET_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_POOL_ZEROING_INFORMATION {
    pub PoolZeroingSupportPresent: BOOLEAN,
}
pub type SYSTEM_POOL_ZEROING_INFORMATION = _SYSTEM_POOL_ZEROING_INFORMATION;
pub type PSYSTEM_POOL_ZEROING_INFORMATION = *mut _SYSTEM_POOL_ZEROING_INFORMATION;
pub const _ALTERNATIVE_ARCHITECTURE_TYPE_StandardDesign: _ALTERNATIVE_ARCHITECTURE_TYPE = 0;
pub const _ALTERNATIVE_ARCHITECTURE_TYPE_NEC98x86: _ALTERNATIVE_ARCHITECTURE_TYPE = 1;
pub const _ALTERNATIVE_ARCHITECTURE_TYPE_EndAlternatives: _ALTERNATIVE_ARCHITECTURE_TYPE = 2;
pub type _ALTERNATIVE_ARCHITECTURE_TYPE = core::ffi::c_int;
pub use self::_ALTERNATIVE_ARCHITECTURE_TYPE as ALTERNATIVE_ARCHITECTURE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_RECORD {
    pub ExceptionCode: NTSTATUS,
    pub ExceptionFlags: ULONG,
    pub ExceptionRecord: *mut _EXCEPTION_RECORD,
    pub ExceptionAddress: PVOID,
    pub NumberParameters: ULONG,
    pub ExceptionInformation: [ULONG_PTR; 15usize],
}
pub type EXCEPTION_RECORD = _EXCEPTION_RECORD;
pub type PEXCEPTION_RECORD = *mut EXCEPTION_RECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_RECORD32 {
    pub ExceptionCode: NTSTATUS,
    pub ExceptionFlags: ULONG,
    pub ExceptionRecord: ULONG,
    pub ExceptionAddress: ULONG,
    pub NumberParameters: ULONG,
    pub ExceptionInformation: [ULONG; 15usize],
}
pub type EXCEPTION_RECORD32 = _EXCEPTION_RECORD32;
pub type PEXCEPTION_RECORD32 = *mut _EXCEPTION_RECORD32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_RECORD64 {
    pub ExceptionCode: NTSTATUS,
    pub ExceptionFlags: ULONG,
    pub ExceptionRecord: ULONG64,
    pub ExceptionAddress: ULONG64,
    pub NumberParameters: ULONG,
    pub __unusedAlignment: ULONG,
    pub ExceptionInformation: [ULONG64; 15usize],
}
pub type EXCEPTION_RECORD64 = _EXCEPTION_RECORD64;
pub type PEXCEPTION_RECORD64 = *mut _EXCEPTION_RECORD64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_POINTERS {
    pub ExceptionRecord: PEXCEPTION_RECORD,
    pub ContextRecord: PCONTEXT,
}
pub type EXCEPTION_POINTERS = _EXCEPTION_POINTERS;
pub type PEXCEPTION_POINTERS = *mut _EXCEPTION_POINTERS;
pub const _KINTERRUPT_MODE_LevelSensitive: _KINTERRUPT_MODE = 0;
pub const _KINTERRUPT_MODE_Latched: _KINTERRUPT_MODE = 1;
pub type _KINTERRUPT_MODE = core::ffi::c_int;
pub use self::_KINTERRUPT_MODE as KINTERRUPT_MODE;
pub const _KINTERRUPT_POLARITY_InterruptPolarityUnknown: _KINTERRUPT_POLARITY = 0;
pub const _KINTERRUPT_POLARITY_InterruptActiveHigh: _KINTERRUPT_POLARITY = 1;
pub const _KINTERRUPT_POLARITY_InterruptRisingEdge: _KINTERRUPT_POLARITY = 1;
pub const _KINTERRUPT_POLARITY_InterruptActiveLow: _KINTERRUPT_POLARITY = 2;
pub const _KINTERRUPT_POLARITY_InterruptFallingEdge: _KINTERRUPT_POLARITY = 2;
pub const _KINTERRUPT_POLARITY_InterruptActiveBoth: _KINTERRUPT_POLARITY = 3;
pub const _KINTERRUPT_POLARITY_InterruptActiveBothTriggerLow: _KINTERRUPT_POLARITY = 3;
pub const _KINTERRUPT_POLARITY_InterruptActiveBothTriggerHigh: _KINTERRUPT_POLARITY = 4;
pub type _KINTERRUPT_POLARITY = core::ffi::c_int;
pub use self::_KINTERRUPT_POLARITY as KINTERRUPT_POLARITY;
pub type PKINTERRUPT_POLARITY = *mut _KINTERRUPT_POLARITY;
pub const _KWAIT_REASON_Executive: _KWAIT_REASON = 0;
pub const _KWAIT_REASON_FreePage: _KWAIT_REASON = 1;
pub const _KWAIT_REASON_PageIn: _KWAIT_REASON = 2;
pub const _KWAIT_REASON_PoolAllocation: _KWAIT_REASON = 3;
pub const _KWAIT_REASON_DelayExecution: _KWAIT_REASON = 4;
pub const _KWAIT_REASON_Suspended: _KWAIT_REASON = 5;
pub const _KWAIT_REASON_UserRequest: _KWAIT_REASON = 6;
pub const _KWAIT_REASON_WrExecutive: _KWAIT_REASON = 7;
pub const _KWAIT_REASON_WrFreePage: _KWAIT_REASON = 8;
pub const _KWAIT_REASON_WrPageIn: _KWAIT_REASON = 9;
pub const _KWAIT_REASON_WrPoolAllocation: _KWAIT_REASON = 10;
pub const _KWAIT_REASON_WrDelayExecution: _KWAIT_REASON = 11;
pub const _KWAIT_REASON_WrSuspended: _KWAIT_REASON = 12;
pub const _KWAIT_REASON_WrUserRequest: _KWAIT_REASON = 13;
pub const _KWAIT_REASON_WrSpare0: _KWAIT_REASON = 14;
pub const _KWAIT_REASON_WrQueue: _KWAIT_REASON = 15;
pub const _KWAIT_REASON_WrLpcReceive: _KWAIT_REASON = 16;
pub const _KWAIT_REASON_WrLpcReply: _KWAIT_REASON = 17;
pub const _KWAIT_REASON_WrVirtualMemory: _KWAIT_REASON = 18;
pub const _KWAIT_REASON_WrPageOut: _KWAIT_REASON = 19;
pub const _KWAIT_REASON_WrRendezvous: _KWAIT_REASON = 20;
pub const _KWAIT_REASON_WrKeyedEvent: _KWAIT_REASON = 21;
pub const _KWAIT_REASON_WrTerminated: _KWAIT_REASON = 22;
pub const _KWAIT_REASON_WrProcessInSwap: _KWAIT_REASON = 23;
pub const _KWAIT_REASON_WrCpuRateControl: _KWAIT_REASON = 24;
pub const _KWAIT_REASON_WrCalloutStack: _KWAIT_REASON = 25;
pub const _KWAIT_REASON_WrKernel: _KWAIT_REASON = 26;
pub const _KWAIT_REASON_WrResource: _KWAIT_REASON = 27;
pub const _KWAIT_REASON_WrPushLock: _KWAIT_REASON = 28;
pub const _KWAIT_REASON_WrMutex: _KWAIT_REASON = 29;
pub const _KWAIT_REASON_WrQuantumEnd: _KWAIT_REASON = 30;
pub const _KWAIT_REASON_WrDispatchInt: _KWAIT_REASON = 31;
pub const _KWAIT_REASON_WrPreempted: _KWAIT_REASON = 32;
pub const _KWAIT_REASON_WrYieldExecution: _KWAIT_REASON = 33;
pub const _KWAIT_REASON_WrFastMutex: _KWAIT_REASON = 34;
pub const _KWAIT_REASON_WrGuardedMutex: _KWAIT_REASON = 35;
pub const _KWAIT_REASON_WrRundown: _KWAIT_REASON = 36;
pub const _KWAIT_REASON_WrAlertByThreadId: _KWAIT_REASON = 37;
pub const _KWAIT_REASON_WrDeferredPreempt: _KWAIT_REASON = 38;
pub const _KWAIT_REASON_WrPhysicalFault: _KWAIT_REASON = 39;
pub const _KWAIT_REASON_WrIoRing: _KWAIT_REASON = 40;
pub const _KWAIT_REASON_WrMdlCache: _KWAIT_REASON = 41;
pub const _KWAIT_REASON_MaximumWaitReason: _KWAIT_REASON = 42;
pub type _KWAIT_REASON = core::ffi::c_int;
pub use self::_KWAIT_REASON as KWAIT_REASON;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KWAIT_BLOCK {
    pub WaitListEntry: LIST_ENTRY,
    pub WaitType: UCHAR,
    pub BlockState: UCHAR,
    pub WaitKey: USHORT,
    pub SpareLong: LONG,
    pub __bindgen_anon_1: _KWAIT_BLOCK__bindgen_ty_1,
    pub Object: PVOID,
    pub SparePtr: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KWAIT_BLOCK__bindgen_ty_1 {
    pub Thread: *mut _KTHREAD,
    pub NotificationQueue: *mut _KQUEUE,
    pub Dpc: *mut _KDPC,
}
pub type KWAIT_BLOCK = _KWAIT_BLOCK;
pub type PKWAIT_BLOCK = *mut _KWAIT_BLOCK;
pub type PRKWAIT_BLOCK = *mut _KWAIT_BLOCK;
pub type KSTART_ROUTINE = ::core::option::Option<unsafe extern "C" fn(StartContext: PVOID)>;
pub type PKSTART_ROUTINE = KSTART_ROUTINE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KDEVICE_QUEUE {
    pub Type: CSHORT,
    pub Size: CSHORT,
    pub DeviceListHead: LIST_ENTRY,
    pub Lock: KSPIN_LOCK,
    pub __bindgen_anon_1: _KDEVICE_QUEUE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KDEVICE_QUEUE__bindgen_ty_1 {
    pub Busy: BOOLEAN,
    pub __bindgen_anon_1: _KDEVICE_QUEUE__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KDEVICE_QUEUE__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _KDEVICE_QUEUE__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Reserved(&self) -> LONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: LONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> LONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: LONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Hint(&self) -> LONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 56u8) as u64) }
    }
    #[inline]
    pub fn set_Hint(&mut self, val: LONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 56u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Hint_raw(this: *const Self) -> LONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                56u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Hint_raw(this: *mut Self, val: LONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                56u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(Reserved: LONG64, Hint: LONG64) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(8usize, 56u8, {
            let Hint: u64 = unsafe { ::core::mem::transmute(Hint) };
            Hint as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type KDEVICE_QUEUE = _KDEVICE_QUEUE;
pub type PKDEVICE_QUEUE = *mut _KDEVICE_QUEUE;
pub type PRKDEVICE_QUEUE = *mut _KDEVICE_QUEUE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KDEVICE_QUEUE_ENTRY {
    pub DeviceListEntry: LIST_ENTRY,
    pub SortKey: ULONG,
    pub Inserted: BOOLEAN,
}
pub type KDEVICE_QUEUE_ENTRY = _KDEVICE_QUEUE_ENTRY;
pub type PKDEVICE_QUEUE_ENTRY = *mut _KDEVICE_QUEUE_ENTRY;
pub type PRKDEVICE_QUEUE_ENTRY = *mut _KDEVICE_QUEUE_ENTRY;
pub type KSERVICE_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(Interrupt: *mut _KINTERRUPT, ServiceContext: PVOID) -> BOOLEAN,
>;
pub type PKSERVICE_ROUTINE = KSERVICE_ROUTINE;
pub type KMESSAGE_SERVICE_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(
        Interrupt: *mut _KINTERRUPT,
        ServiceContext: PVOID,
        MessageID: ULONG,
    ) -> BOOLEAN,
>;
pub type PKMESSAGE_SERVICE_ROUTINE = KMESSAGE_SERVICE_ROUTINE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KMUTANT {
    pub Header: DISPATCHER_HEADER,
    pub MutantListEntry: LIST_ENTRY,
    pub OwnerThread: *mut _KTHREAD,
    pub __bindgen_anon_1: _KMUTANT__bindgen_ty_1,
    pub ApcDisable: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KMUTANT__bindgen_ty_1 {
    pub MutantFlags: UCHAR,
    pub __bindgen_anon_1: _KMUTANT__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KMUTANT__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _KMUTANT__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Abandoned(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Abandoned(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Abandoned_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Abandoned_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Spare1(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_Spare1(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Spare1_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                7u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Spare1_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(Abandoned: UCHAR, Spare1: UCHAR) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Abandoned: u8 = unsafe { ::core::mem::transmute(Abandoned) };
            Abandoned as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let Spare1: u8 = unsafe { ::core::mem::transmute(Spare1) };
            Spare1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type KMUTANT = _KMUTANT;
pub type PKMUTANT = *mut _KMUTANT;
pub type PRKMUTANT = *mut _KMUTANT;
pub type KMUTEX = _KMUTANT;
pub type PKMUTEX = *mut _KMUTANT;
pub type PRKMUTEX = *mut _KMUTANT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KSEMAPHORE {
    pub Header: DISPATCHER_HEADER,
    pub Limit: LONG,
}
pub type KSEMAPHORE = _KSEMAPHORE;
pub type PKSEMAPHORE = *mut _KSEMAPHORE;
pub type PRKSEMAPHORE = *mut _KSEMAPHORE;
unsafe extern "C" {
    pub fn KeInitializeDpc(
        Dpc: PRKDPC,
        DeferredRoutine: PKDEFERRED_ROUTINE,
        DeferredContext: PVOID,
    );
}
unsafe extern "C" {
    pub fn KeInitializeThreadedDpc(
        Dpc: PRKDPC,
        DeferredRoutine: PKDEFERRED_ROUTINE,
        DeferredContext: PVOID,
    );
}
unsafe extern "C" {
    pub fn KeInsertQueueDpc(Dpc: PRKDPC, SystemArgument1: PVOID, SystemArgument2: PVOID)
                            -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeRemoveQueueDpc(Dpc: PRKDPC) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeRemoveQueueDpcEx(Dpc: PRKDPC, WaitIfActive: BOOLEAN) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeInitializeCrashDumpHeader(
        DumpType: ULONG,
        Flags: ULONG,
        Buffer: PVOID,
        BufferSize: ULONG,
        BufferNeeded: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KeSetImportanceDpc(Dpc: PRKDPC, Importance: KDPC_IMPORTANCE);
}
unsafe extern "C" {
    pub fn KeSetTargetProcessorDpc(Dpc: PRKDPC, Number: CCHAR);
}
unsafe extern "C" {
    pub fn KeFlushQueuedDpcs();
}
unsafe extern "C" {
    pub fn KeInitializeDeviceQueue(DeviceQueue: PKDEVICE_QUEUE);
}
unsafe extern "C" {
    pub fn KeInsertDeviceQueue(
        DeviceQueue: PKDEVICE_QUEUE,
        DeviceQueueEntry: PKDEVICE_QUEUE_ENTRY,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeInsertByKeyDeviceQueue(
        DeviceQueue: PKDEVICE_QUEUE,
        DeviceQueueEntry: PKDEVICE_QUEUE_ENTRY,
        SortKey: ULONG,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeRemoveDeviceQueue(DeviceQueue: PKDEVICE_QUEUE) -> PKDEVICE_QUEUE_ENTRY;
}
unsafe extern "C" {
    pub fn KeRemoveByKeyDeviceQueue(
        DeviceQueue: PKDEVICE_QUEUE,
        SortKey: ULONG,
    ) -> PKDEVICE_QUEUE_ENTRY;
}
unsafe extern "C" {
    pub fn KeRemoveByKeyDeviceQueueIfBusy(
        DeviceQueue: PKDEVICE_QUEUE,
        SortKey: ULONG,
    ) -> PKDEVICE_QUEUE_ENTRY;
}
unsafe extern "C" {
    pub fn KeRemoveEntryDeviceQueue(
        DeviceQueue: PKDEVICE_QUEUE,
        DeviceQueueEntry: PKDEVICE_QUEUE_ENTRY,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeSynchronizeExecution(
        Interrupt: PKINTERRUPT,
        SynchronizeRoutine: PKSYNCHRONIZE_ROUTINE,
        SynchronizeContext: PVOID,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeAcquireInterruptSpinLock(Interrupt: PKINTERRUPT) -> KIRQL;
}
unsafe extern "C" {
    pub fn KeReleaseInterruptSpinLock(Interrupt: PKINTERRUPT, OldIrql: KIRQL);
}
unsafe extern "C" {
    pub fn KeInitializeEvent(Event: PRKEVENT, Type: EVENT_TYPE, State: BOOLEAN);
}
unsafe extern "C" {
    pub fn KeClearEvent(Event: PRKEVENT);
}
unsafe extern "C" {
    pub fn KeReadStateEvent(Event: PRKEVENT) -> LONG;
}
unsafe extern "C" {
    pub fn KeResetEvent(Event: PRKEVENT) -> LONG;
}
unsafe extern "C" {
    pub fn KeSetEvent(Event: PRKEVENT, Increment: KPRIORITY, Wait: BOOLEAN) -> LONG;
}
unsafe extern "C" {
    pub fn KeInitializeMutex(Mutex: PRKMUTEX, Level: ULONG);
}
unsafe extern "C" {
    pub fn KeReadStateMutex(Mutex: PRKMUTEX) -> LONG;
}
unsafe extern "C" {
    pub fn KeReleaseMutex(Mutex: PRKMUTEX, Wait: BOOLEAN) -> LONG;
}
unsafe extern "C" {
    pub fn KeInitializeSemaphore(Semaphore: PRKSEMAPHORE, Count: LONG, Limit: LONG);
}
unsafe extern "C" {
    pub fn KeReadStateSemaphore(Semaphore: PRKSEMAPHORE) -> LONG;
}
unsafe extern "C" {
    pub fn KeReleaseSemaphore(
        Semaphore: PRKSEMAPHORE,
        Increment: KPRIORITY,
        Adjustment: LONG,
        Wait: BOOLEAN,
    ) -> LONG;
}
unsafe extern "C" {
    pub fn KeDelayExecutionThread(
        WaitMode: KPROCESSOR_MODE,
        Alertable: BOOLEAN,
        Interval: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KeQueryPriorityThread(Thread: PKTHREAD) -> KPRIORITY;
}
unsafe extern "C" {
    pub fn KeQueryRuntimeThread(Thread: PKTHREAD, UserTime: PULONG) -> ULONG;
}
unsafe extern "C" {
    pub fn KeQueryTotalCycleTimeThread(Thread: PKTHREAD, CycleTimeStamp: PULONG64) -> ULONG64;
}
unsafe extern "C" {
    pub fn KeSetTargetProcessorDpcEx(Dpc: PKDPC, ProcNumber: PPROCESSOR_NUMBER) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KeRevertToUserAffinityThread();
}
unsafe extern "C" {
    pub fn KeSetSystemAffinityThread(Affinity: KAFFINITY);
}
unsafe extern "C" {
    pub fn KeRevertToUserAffinityThreadEx(Affinity: KAFFINITY);
}
unsafe extern "C" {
    pub fn KeSetSystemGroupAffinityThread(
        Affinity: PGROUP_AFFINITY,
        PreviousAffinity: PGROUP_AFFINITY,
    );
}
unsafe extern "C" {
    pub fn KeRevertToUserGroupAffinityThread(PreviousAffinity: PGROUP_AFFINITY);
}
unsafe extern "C" {
    pub fn KeSetSystemAffinityThreadEx(Affinity: KAFFINITY) -> KAFFINITY;
}
unsafe extern "C" {
    pub fn KeSetPriorityThread(Thread: PKTHREAD, Priority: KPRIORITY) -> KPRIORITY;
}
unsafe extern "C" {
    pub fn KeEnterCriticalRegion();
}
unsafe extern "C" {
    pub fn KeLeaveCriticalRegion();
}
unsafe extern "C" {
    pub fn KeEnterGuardedRegion();
}
unsafe extern "C" {
    pub fn KeLeaveGuardedRegion();
}
unsafe extern "C" {
    pub fn KeAreApcsDisabled() -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeInitializeTimer(Timer: PKTIMER);
}
unsafe extern "C" {
    pub fn KeInitializeTimerEx(Timer: PKTIMER, Type: TIMER_TYPE);
}
unsafe extern "C" {
    pub fn KeCancelTimer(arg1: PKTIMER) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeReadStateTimer(Timer: PKTIMER) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeSetTimer(Timer: PKTIMER, DueTime: LARGE_INTEGER, Dpc: PKDPC) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeSetTimerEx(
        Timer: PKTIMER,
        DueTime: LARGE_INTEGER,
        Period: LONG,
        Dpc: PKDPC,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeSetCoalescableTimer(
        Timer: PKTIMER,
        DueTime: LARGE_INTEGER,
        Period: ULONG,
        TolerableDelay: ULONG,
        Dpc: PKDPC,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeWaitForMultipleObjects(
        Count: ULONG,
        Object: *mut PVOID,
        WaitType: WAIT_TYPE,
        WaitReason: KWAIT_REASON,
        WaitMode: KPROCESSOR_MODE,
        Alertable: BOOLEAN,
        Timeout: PLARGE_INTEGER,
        WaitBlockArray: PKWAIT_BLOCK,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KeWaitForSingleObject(
        Object: PVOID,
        WaitReason: KWAIT_REASON,
        WaitMode: KPROCESSOR_MODE,
        Alertable: BOOLEAN,
        Timeout: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
pub type KIPI_BROADCAST_WORKER =
::core::option::Option<unsafe extern "C" fn(Argument: ULONG_PTR) -> ULONG_PTR>;
pub type PKIPI_BROADCAST_WORKER = KIPI_BROADCAST_WORKER;
unsafe extern "C" {
    pub fn KeIpiGenericCall(
        BroadcastFunction: PKIPI_BROADCAST_WORKER,
        Context: ULONG_PTR,
    ) -> ULONG_PTR;
}
unsafe extern "C" {
    pub fn KeInitializeSpinLock(SpinLock: PKSPIN_LOCK);
}
unsafe extern "C" {
    pub fn KeTestSpinLock(SpinLock: PKSPIN_LOCK) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeTryToAcquireSpinLockAtDpcLevel(SpinLock: PKSPIN_LOCK) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeAcquireSpinLockAtDpcLevel(SpinLock: PKSPIN_LOCK);
}
unsafe extern "C" {
    pub fn KeAcquireSpinLockRaiseToDpc(SpinLock: PKSPIN_LOCK) -> KIRQL;
}
unsafe extern "C" {
    pub fn KeReleaseSpinLock(SpinLock: PKSPIN_LOCK, NewIrql: KIRQL);
}
unsafe extern "C" {
    pub fn KeReleaseSpinLockFromDpcLevel(SpinLock: PKSPIN_LOCK);
}
unsafe extern "C" {
    pub fn KeAcquireSpinLockForDpc(SpinLock: PKSPIN_LOCK) -> KIRQL;
}
unsafe extern "C" {
    pub fn KeReleaseSpinLockForDpc(SpinLock: PKSPIN_LOCK, OldIrql: KIRQL);
}
unsafe extern "C" {
    pub fn KeAcquireInStackQueuedSpinLock(SpinLock: PKSPIN_LOCK, LockHandle: PKLOCK_QUEUE_HANDLE);
}
unsafe extern "C" {
    pub fn KeReleaseInStackQueuedSpinLock(LockHandle: PKLOCK_QUEUE_HANDLE);
}
unsafe extern "C" {
    pub fn KeAcquireInStackQueuedSpinLockAtDpcLevel(
        SpinLock: PKSPIN_LOCK,
        LockHandle: PKLOCK_QUEUE_HANDLE,
    );
}
unsafe extern "C" {
    pub fn KeReleaseInStackQueuedSpinLockFromDpcLevel(LockHandle: PKLOCK_QUEUE_HANDLE);
}
unsafe extern "C" {
    pub fn KeAcquireInStackQueuedSpinLockForDpc(
        SpinLock: PKSPIN_LOCK,
        LockHandle: PKLOCK_QUEUE_HANDLE,
    );
}
unsafe extern "C" {
    pub fn KeReleaseInStackQueuedSpinLockForDpc(LockHandle: PKLOCK_QUEUE_HANDLE);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KDPC_WATCHDOG_INFORMATION {
    pub DpcTimeLimit: ULONG,
    pub DpcTimeCount: ULONG,
    pub DpcWatchdogLimit: ULONG,
    pub DpcWatchdogCount: ULONG,
    pub Reserved: ULONG,
}
pub type KDPC_WATCHDOG_INFORMATION = _KDPC_WATCHDOG_INFORMATION;
pub type PKDPC_WATCHDOG_INFORMATION = *mut _KDPC_WATCHDOG_INFORMATION;
unsafe extern "C" {
    pub fn KeQueryDpcWatchdogInformation(
        WatchdogInformation: PKDPC_WATCHDOG_INFORMATION,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KeIsExecutingDpc() -> LOGICAL;
}
pub const _KBUGCHECK_BUFFER_DUMP_STATE_BufferEmpty: _KBUGCHECK_BUFFER_DUMP_STATE = 0;
pub const _KBUGCHECK_BUFFER_DUMP_STATE_BufferInserted: _KBUGCHECK_BUFFER_DUMP_STATE = 1;
pub const _KBUGCHECK_BUFFER_DUMP_STATE_BufferStarted: _KBUGCHECK_BUFFER_DUMP_STATE = 2;
pub const _KBUGCHECK_BUFFER_DUMP_STATE_BufferFinished: _KBUGCHECK_BUFFER_DUMP_STATE = 3;
pub const _KBUGCHECK_BUFFER_DUMP_STATE_BufferIncomplete: _KBUGCHECK_BUFFER_DUMP_STATE = 4;
pub type _KBUGCHECK_BUFFER_DUMP_STATE = core::ffi::c_int;
pub use self::_KBUGCHECK_BUFFER_DUMP_STATE as KBUGCHECK_BUFFER_DUMP_STATE;
pub type KBUGCHECK_CALLBACK_ROUTINE =
::core::option::Option<unsafe extern "C" fn(Buffer: PVOID, Length: ULONG)>;
pub type PKBUGCHECK_CALLBACK_ROUTINE = KBUGCHECK_CALLBACK_ROUTINE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KBUGCHECK_CALLBACK_RECORD {
    pub Entry: LIST_ENTRY,
    pub CallbackRoutine: PKBUGCHECK_CALLBACK_ROUTINE,
    pub Buffer: PVOID,
    pub Length: ULONG,
    pub Component: PUCHAR,
    pub Checksum: ULONG_PTR,
    pub State: UCHAR,
}
pub type KBUGCHECK_CALLBACK_RECORD = _KBUGCHECK_CALLBACK_RECORD;
pub type PKBUGCHECK_CALLBACK_RECORD = *mut _KBUGCHECK_CALLBACK_RECORD;
unsafe extern "C" {
    pub fn KeDeregisterBugCheckCallback(CallbackRecord: PKBUGCHECK_CALLBACK_RECORD) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeRegisterBugCheckCallback(
        CallbackRecord: PKBUGCHECK_CALLBACK_RECORD,
        CallbackRoutine: PKBUGCHECK_CALLBACK_ROUTINE,
        Buffer: PVOID,
        Length: ULONG,
        Component: PUCHAR,
    ) -> BOOLEAN;
}
pub const _KBUGCHECK_CALLBACK_REASON_KbCallbackInvalid: _KBUGCHECK_CALLBACK_REASON = 0;
pub const _KBUGCHECK_CALLBACK_REASON_KbCallbackReserved1: _KBUGCHECK_CALLBACK_REASON = 1;
pub const _KBUGCHECK_CALLBACK_REASON_KbCallbackSecondaryDumpData: _KBUGCHECK_CALLBACK_REASON = 2;
pub const _KBUGCHECK_CALLBACK_REASON_KbCallbackDumpIo: _KBUGCHECK_CALLBACK_REASON = 3;
pub const _KBUGCHECK_CALLBACK_REASON_KbCallbackAddPages: _KBUGCHECK_CALLBACK_REASON = 4;
pub const _KBUGCHECK_CALLBACK_REASON_KbCallbackSecondaryMultiPartDumpData:
_KBUGCHECK_CALLBACK_REASON = 5;
pub const _KBUGCHECK_CALLBACK_REASON_KbCallbackRemovePages: _KBUGCHECK_CALLBACK_REASON = 6;
pub const _KBUGCHECK_CALLBACK_REASON_KbCallbackTriageDumpData: _KBUGCHECK_CALLBACK_REASON = 7;
pub const _KBUGCHECK_CALLBACK_REASON_KbCallbackReserved2: _KBUGCHECK_CALLBACK_REASON = 8;
pub type _KBUGCHECK_CALLBACK_REASON = core::ffi::c_int;
pub use self::_KBUGCHECK_CALLBACK_REASON as KBUGCHECK_CALLBACK_REASON;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KBUGCHECK_REASON_CALLBACK_RECORD {
    _unused: [u8; 0],
}
pub type KBUGCHECK_REASON_CALLBACK_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(
        Reason: KBUGCHECK_CALLBACK_REASON,
        Record: *mut _KBUGCHECK_REASON_CALLBACK_RECORD,
        ReasonSpecificData: PVOID,
        ReasonSpecificDataLength: ULONG,
    ),
>;
pub type PKBUGCHECK_REASON_CALLBACK_ROUTINE = KBUGCHECK_REASON_CALLBACK_ROUTINE;
unsafe extern "C" {
    pub fn BugCheckSecondaryMultiPartDumpDataCallback(
        Reason: KBUGCHECK_CALLBACK_REASON,
        Record: *mut _KBUGCHECK_REASON_CALLBACK_RECORD,
        ReasonSpecificData: PVOID,
        ReasonSpecificDataLength: ULONG,
    );
}
pub type KBUGCHECK_REASON_CALLBACK_RECORD = _KBUGCHECK_REASON_CALLBACK_RECORD;
pub type PKBUGCHECK_REASON_CALLBACK_RECORD = *mut _KBUGCHECK_REASON_CALLBACK_RECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KBUGCHECK_SECONDARY_DUMP_DATA {
    pub InBuffer: PVOID,
    pub InBufferLength: ULONG,
    pub MaximumAllowed: ULONG,
    pub Guid: GUID,
    pub OutBuffer: PVOID,
    pub OutBufferLength: ULONG,
}
pub type KBUGCHECK_SECONDARY_DUMP_DATA = _KBUGCHECK_SECONDARY_DUMP_DATA;
pub type PKBUGCHECK_SECONDARY_DUMP_DATA = *mut _KBUGCHECK_SECONDARY_DUMP_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KBUGCHECK_SECONDARY_DUMP_DATA_EX {
    pub InBuffer: PVOID,
    pub InBufferLength: ULONG,
    pub MaximumAllowed: ULONG,
    pub Guid: GUID,
    pub OutBuffer: PVOID,
    pub OutBufferLength: ULONG,
    pub Context: PVOID,
    pub Flags: ULONG,
    pub DumpType: ULONG,
    pub BugCheckCode: ULONG,
    pub BugCheckParameter1: ULONG_PTR,
    pub BugCheckParameter2: ULONG_PTR,
    pub BugCheckParameter3: ULONG_PTR,
    pub BugCheckParameter4: ULONG_PTR,
}
pub type KBUGCHECK_SECONDARY_DUMP_DATA_EX = _KBUGCHECK_SECONDARY_DUMP_DATA_EX;
pub type PKBUGCHECK_SECONDARY_DUMP_DATA_EX = *mut _KBUGCHECK_SECONDARY_DUMP_DATA_EX;
pub const _KBUGCHECK_DUMP_IO_TYPE_KbDumpIoInvalid: _KBUGCHECK_DUMP_IO_TYPE = 0;
pub const _KBUGCHECK_DUMP_IO_TYPE_KbDumpIoHeader: _KBUGCHECK_DUMP_IO_TYPE = 1;
pub const _KBUGCHECK_DUMP_IO_TYPE_KbDumpIoBody: _KBUGCHECK_DUMP_IO_TYPE = 2;
pub const _KBUGCHECK_DUMP_IO_TYPE_KbDumpIoSecondaryData: _KBUGCHECK_DUMP_IO_TYPE = 3;
pub const _KBUGCHECK_DUMP_IO_TYPE_KbDumpIoComplete: _KBUGCHECK_DUMP_IO_TYPE = 4;
pub type _KBUGCHECK_DUMP_IO_TYPE = core::ffi::c_int;
pub use self::_KBUGCHECK_DUMP_IO_TYPE as KBUGCHECK_DUMP_IO_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KBUGCHECK_DUMP_IO {
    pub Offset: ULONG64,
    pub Buffer: PVOID,
    pub BufferLength: ULONG,
    pub Type: KBUGCHECK_DUMP_IO_TYPE,
}
pub type KBUGCHECK_DUMP_IO = _KBUGCHECK_DUMP_IO;
pub type PKBUGCHECK_DUMP_IO = *mut _KBUGCHECK_DUMP_IO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KBUGCHECK_ADD_PAGES {
    pub Context: PVOID,
    pub Flags: ULONG,
    pub BugCheckCode: ULONG,
    pub Address: ULONG_PTR,
    pub Count: ULONG_PTR,
}
pub type KBUGCHECK_ADD_PAGES = _KBUGCHECK_ADD_PAGES;
pub type PKBUGCHECK_ADD_PAGES = *mut _KBUGCHECK_ADD_PAGES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KBUGCHECK_REMOVE_PAGES {
    pub Context: PVOID,
    pub Flags: ULONG,
    pub BugCheckCode: ULONG,
    pub Address: ULONG_PTR,
    pub Count: ULONG_PTR,
}
pub type KBUGCHECK_REMOVE_PAGES = _KBUGCHECK_REMOVE_PAGES;
pub type PKBUGCHECK_REMOVE_PAGES = *mut _KBUGCHECK_REMOVE_PAGES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KADDRESS_RANGE {
    pub Address: PVOID,
    pub Size: SIZE_T,
}
pub type KADDRESS_RANGE = _KADDRESS_RANGE;
pub type PKADDRESS_RANGE = *mut _KADDRESS_RANGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KADDRESS_RANGE_DESCRIPTOR {
    pub AddressRanges: *const KADDRESS_RANGE,
    pub AddressRangeCount: SIZE_T,
}
pub type KADDRESS_RANGE_DESCRIPTOR = _KADDRESS_RANGE_DESCRIPTOR;
pub type PKADDRESS_RANGE_DESCRIPTOR = *mut _KADDRESS_RANGE_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTRIAGE_DUMP_DATA_ARRAY {
    pub List: LIST_ENTRY,
    pub NumBlocksUsed: ULONG,
    pub NumBlocksTotal: ULONG,
    pub DataSize: ULONG,
    pub MaxDataSize: ULONG,
    pub ComponentNameBufferLength: ULONG,
    pub ComponentName: PUCHAR,
    pub Blocks: [KADDRESS_RANGE; 1usize],
}
pub type KTRIAGE_DUMP_DATA_ARRAY = _KTRIAGE_DUMP_DATA_ARRAY;
pub type PKTRIAGE_DUMP_DATA_ARRAY = *mut _KTRIAGE_DUMP_DATA_ARRAY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KBUGCHECK_TRIAGE_DUMP_DATA {
    pub DataArray: PKTRIAGE_DUMP_DATA_ARRAY,
    pub Flags: ULONG,
    pub MaxVirtMemSize: ULONG,
    pub BugCheckCode: ULONG,
    pub BugCheckParameter1: ULONG_PTR,
    pub BugCheckParameter2: ULONG_PTR,
    pub BugCheckParameter3: ULONG_PTR,
    pub BugCheckParameter4: ULONG_PTR,
}
pub type KBUGCHECK_TRIAGE_DUMP_DATA = _KBUGCHECK_TRIAGE_DUMP_DATA;
pub type PKBUGCHECK_TRIAGE_DUMP_DATA = *mut _KBUGCHECK_TRIAGE_DUMP_DATA;
unsafe extern "C" {
    pub fn KeInitializeTriageDumpDataArray(
        KtriageDumpDataArray: PKTRIAGE_DUMP_DATA_ARRAY,
        Size: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KeAddTriageDumpDataBlock(
        KtriageDumpDataArray: PKTRIAGE_DUMP_DATA_ARRAY,
        Address: PVOID,
        Size: SIZE_T,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KeDeregisterBugCheckReasonCallback(
        CallbackRecord: PKBUGCHECK_REASON_CALLBACK_RECORD,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeRegisterBugCheckReasonCallback(
        CallbackRecord: PKBUGCHECK_REASON_CALLBACK_RECORD,
        CallbackRoutine: PKBUGCHECK_REASON_CALLBACK_ROUTINE,
        Reason: KBUGCHECK_CALLBACK_REASON,
        Component: PUCHAR,
    ) -> BOOLEAN;
}
pub type NMI_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, Handled: BOOLEAN) -> BOOLEAN>;
pub type PNMI_CALLBACK = NMI_CALLBACK;
unsafe extern "C" {
    pub fn KeRegisterNmiCallback(CallbackRoutine: PNMI_CALLBACK, Context: PVOID) -> PVOID;
}
unsafe extern "C" {
    pub fn KeDeregisterNmiCallback(Handle: PVOID) -> NTSTATUS;
}
pub const _BOUND_CALLBACK_STATUS_BoundExceptionContinueSearch: _BOUND_CALLBACK_STATUS = 0;
pub const _BOUND_CALLBACK_STATUS_BoundExceptionHandled: _BOUND_CALLBACK_STATUS = 1;
pub const _BOUND_CALLBACK_STATUS_BoundExceptionError: _BOUND_CALLBACK_STATUS = 2;
pub const _BOUND_CALLBACK_STATUS_BoundExceptionMaximum: _BOUND_CALLBACK_STATUS = 3;
pub type _BOUND_CALLBACK_STATUS = core::ffi::c_int;
pub use self::_BOUND_CALLBACK_STATUS as BOUND_CALLBACK_STATUS;
pub type PBOUND_CALLBACK_STATUS = *mut _BOUND_CALLBACK_STATUS;
pub type BOUND_CALLBACK = ::core::option::Option<unsafe extern "C" fn() -> BOUND_CALLBACK_STATUS>;
pub type PBOUND_CALLBACK = BOUND_CALLBACK;
unsafe extern "C" {
    pub fn KeRegisterBoundCallback(CallbackRoutine: PBOUND_CALLBACK) -> PVOID;
}
unsafe extern "C" {
    pub fn KeDeregisterBoundCallback(Handle: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KeBugCheckEx(
        BugCheckCode: ULONG,
        BugCheckParameter1: ULONG_PTR,
        BugCheckParameter2: ULONG_PTR,
        BugCheckParameter3: ULONG_PTR,
        BugCheckParameter4: ULONG_PTR,
    ) -> !;
}
unsafe extern "C" {
    pub fn KeQuerySystemTimePrecise(CurrentTime: PLARGE_INTEGER);
}
unsafe extern "C" {
    pub fn KeQueryInterruptTimePrecise(QpcTimeStamp: PULONG64) -> ULONG64;
}
unsafe extern "C" {
    pub fn KeQueryUnbiasedInterruptTimePrecise(QpcTimeStamp: PULONG64) -> ULONG64;
}
unsafe extern "C" {
    pub fn KeQueryTimeIncrement() -> ULONG;
}
unsafe extern "C" {
    pub fn KeQueryUnbiasedInterruptTime() -> ULONGLONG;
}
unsafe extern "C" {
    pub fn KeGetRecommendedSharedDataAlignment() -> ULONG;
}
unsafe extern "C" {
    pub fn KeQueryActiveProcessors() -> KAFFINITY;
}
unsafe extern "C" {
    pub fn KeQueryActiveProcessorCount(ActiveProcessors: PKAFFINITY) -> ULONG;
}
unsafe extern "C" {
    pub fn KeQueryActiveProcessorCountEx(GroupNumber: USHORT) -> ULONG;
}
unsafe extern "C" {
    pub fn KeQueryMaximumProcessorCount() -> ULONG;
}
unsafe extern "C" {
    pub fn KeQueryMaximumProcessorCountEx(GroupNumber: USHORT) -> ULONG;
}
unsafe extern "C" {
    pub fn KeQueryActiveGroupCount() -> USHORT;
}
unsafe extern "C" {
    pub fn KeQueryMaximumGroupCount() -> USHORT;
}
unsafe extern "C" {
    pub fn KeQueryGroupAffinity(GroupNumber: USHORT) -> KAFFINITY;
}
unsafe extern "C" {
    pub fn KeGetCurrentProcessorNumberEx(ProcNumber: PPROCESSOR_NUMBER) -> ULONG;
}
unsafe extern "C" {
    pub fn KeQueryNodeActiveAffinity(NodeNumber: USHORT, Affinity: PGROUP_AFFINITY, Count: PUSHORT);
}
unsafe extern "C" {
    pub fn KeQueryNodeMaximumProcessorCount(NodeNumber: USHORT) -> USHORT;
}
unsafe extern "C" {
    pub fn KeQueryHighestNodeNumber() -> USHORT;
}
unsafe extern "C" {
    pub fn KeGetCurrentNodeNumber() -> USHORT;
}
unsafe extern "C" {
    pub fn KeQueryLogicalProcessorRelationship(
        ProcessorNumber: PPROCESSOR_NUMBER,
        RelationshipType: LOGICAL_PROCESSOR_RELATIONSHIP,
        Information: PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX,
        Length: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KeShouldYieldProcessor() -> LOGICAL;
}
unsafe extern "C" {
    pub fn KeQueryNodeActiveAffinity2(
        NodeNumber: USHORT,
        GroupAffinities: PGROUP_AFFINITY,
        GroupAffinitiesCount: USHORT,
        GroupAffinitiesRequired: PUSHORT,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KeQueryNodeActiveProcessorCount(NodeNumber: USHORT) -> ULONG;
}
pub const _MEMORY_CACHING_TYPE_ORIG_MmFrameBufferCached: _MEMORY_CACHING_TYPE_ORIG = 2;
pub type _MEMORY_CACHING_TYPE_ORIG = core::ffi::c_int;
pub use self::_MEMORY_CACHING_TYPE_ORIG as MEMORY_CACHING_TYPE_ORIG;
pub const _MEMORY_CACHING_TYPE_MmNonCached: _MEMORY_CACHING_TYPE = 0;
pub const _MEMORY_CACHING_TYPE_MmCached: _MEMORY_CACHING_TYPE = 1;
pub const _MEMORY_CACHING_TYPE_MmWriteCombined: _MEMORY_CACHING_TYPE = 2;
pub const _MEMORY_CACHING_TYPE_MmHardwareCoherentCached: _MEMORY_CACHING_TYPE = 3;
pub const _MEMORY_CACHING_TYPE_MmNonCachedUnordered: _MEMORY_CACHING_TYPE = 4;
pub const _MEMORY_CACHING_TYPE_MmUSWCCached: _MEMORY_CACHING_TYPE = 5;
pub const _MEMORY_CACHING_TYPE_MmMaximumCacheType: _MEMORY_CACHING_TYPE = 6;
pub const _MEMORY_CACHING_TYPE_MmNotMapped: _MEMORY_CACHING_TYPE = -1;
pub type _MEMORY_CACHING_TYPE = core::ffi::c_int;
pub use self::_MEMORY_CACHING_TYPE as MEMORY_CACHING_TYPE;
unsafe extern "C" {
    pub fn KeAreAllApcsDisabled() -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeInitializeGuardedMutex(Mutex: PKGUARDED_MUTEX);
}
unsafe extern "C" {
    pub fn KeAcquireGuardedMutex(Mutex: PKGUARDED_MUTEX);
}
unsafe extern "C" {
    pub fn KeReleaseGuardedMutex(Mutex: PKGUARDED_MUTEX);
}
unsafe extern "C" {
    pub fn KeTryToAcquireGuardedMutex(Mutex: PKGUARDED_MUTEX) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeAcquireGuardedMutexUnsafe(FastMutex: PKGUARDED_MUTEX);
}
unsafe extern "C" {
    pub fn KeReleaseGuardedMutexUnsafe(FastMutex: PKGUARDED_MUTEX);
}
pub const KE_PROCESSOR_CHANGE_NOTIFY_STATE_KeProcessorAddStartNotify:
KE_PROCESSOR_CHANGE_NOTIFY_STATE = 0;
pub const KE_PROCESSOR_CHANGE_NOTIFY_STATE_KeProcessorAddCompleteNotify:
KE_PROCESSOR_CHANGE_NOTIFY_STATE = 1;
pub const KE_PROCESSOR_CHANGE_NOTIFY_STATE_KeProcessorAddFailureNotify:
KE_PROCESSOR_CHANGE_NOTIFY_STATE = 2;
pub type KE_PROCESSOR_CHANGE_NOTIFY_STATE = core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KE_PROCESSOR_CHANGE_NOTIFY_CONTEXT {
    pub State: KE_PROCESSOR_CHANGE_NOTIFY_STATE,
    pub NtNumber: ULONG,
    pub Status: NTSTATUS,
    pub ProcNumber: PROCESSOR_NUMBER,
}
pub type KE_PROCESSOR_CHANGE_NOTIFY_CONTEXT = _KE_PROCESSOR_CHANGE_NOTIFY_CONTEXT;
pub type PKE_PROCESSOR_CHANGE_NOTIFY_CONTEXT = *mut _KE_PROCESSOR_CHANGE_NOTIFY_CONTEXT;
pub type PROCESSOR_CALLBACK_FUNCTION = ::core::option::Option<
    unsafe extern "C" fn(
        CallbackContext: PVOID,
        ChangeContext: PKE_PROCESSOR_CHANGE_NOTIFY_CONTEXT,
        OperationStatus: PNTSTATUS,
    ),
>;
pub type PPROCESSOR_CALLBACK_FUNCTION = PROCESSOR_CALLBACK_FUNCTION;
unsafe extern "C" {
    pub fn KeRegisterProcessorChangeCallback(
        CallbackFunction: PPROCESSOR_CALLBACK_FUNCTION,
        CallbackContext: PVOID,
        Flags: ULONG,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn KeDeregisterProcessorChangeCallback(CallbackHandle: PVOID);
}
unsafe extern "C" {
    pub fn KeGetProcessorNumberFromIndex(
        ProcIndex: ULONG,
        ProcNumber: PPROCESSOR_NUMBER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KeGetProcessorIndexFromNumber(ProcNumber: PPROCESSOR_NUMBER) -> ULONG;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XSTATE_SAVE {
    pub Prev: *mut _XSTATE_SAVE,
    pub Thread: *mut _KTHREAD,
    pub Level: UCHAR,
    pub XStateContext: XSTATE_CONTEXT,
}
pub type XSTATE_SAVE = _XSTATE_SAVE;
pub type PXSTATE_SAVE = *mut _XSTATE_SAVE;
unsafe extern "C" {
    pub fn KeSaveExtendedProcessorState(Mask: ULONG64, XStateSave: PXSTATE_SAVE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KeRestoreExtendedProcessorState(XStateSave: PXSTATE_SAVE);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXT_SET_PARAMETERS_V0 {
    pub Version: ULONG,
    pub Reserved: ULONG,
    pub NoWakeTolerance: LONGLONG,
}
pub type EXT_SET_PARAMETERS = _EXT_SET_PARAMETERS_V0;
pub type PEXT_SET_PARAMETERS = *mut _EXT_SET_PARAMETERS_V0;
pub type KT2_SET_PARAMETERS = EXT_SET_PARAMETERS;
pub type PKT2_SET_PARAMETERS = *mut EXT_SET_PARAMETERS;
unsafe extern "C" {
    pub fn KeConvertAuxiliaryCounterToPerformanceCounter(
        AuxiliaryCounterValue: ULONG64,
        PerformanceCounterValue: PULONG64,
        ConversionError: PULONG64,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KeConvertPerformanceCounterToAuxiliaryCounter(
        PerformanceCounterValue: ULONG64,
        AuxiliaryCounterValue: PULONG64,
        ConversionError: PULONG64,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KeQueryAuxiliaryCounterFrequency(AuxiliaryCounterFrequency: PULONG64) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KWAIT_CHAIN {
    pub Head: PVOID,
}
pub type KWAIT_CHAIN = _KWAIT_CHAIN;
pub type PKWAIT_CHAIN = *mut _KWAIT_CHAIN;
unsafe extern "C" {
    pub static mut KdDebuggerNotPresent: PBOOLEAN;
}
unsafe extern "C" {
    pub static mut KdDebuggerEnabled: PBOOLEAN;
}
unsafe extern "C" {
    pub fn KdDisableDebugger() -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KdEnableDebugger() -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KdRefreshDebuggerNotPresent() -> BOOLEAN;
}
pub const _KD_OPTION_KD_OPTION_SET_BLOCK_ENABLE: _KD_OPTION = 0;
pub type _KD_OPTION = core::ffi::c_int;
pub use self::_KD_OPTION as KD_OPTION;
unsafe extern "C" {
    pub fn KdChangeOption(
        Option: KD_OPTION,
        InBufferBytes: ULONG,
        InBuffer: PVOID,
        OutBufferBytes: ULONG,
        OutBuffer: PVOID,
        OutBufferNeeded: PULONG,
    ) -> NTSTATUS;
}
pub const _POOL_TYPE_NonPagedPool: _POOL_TYPE = 0;
pub const _POOL_TYPE_NonPagedPoolExecute: _POOL_TYPE = 0;
pub const _POOL_TYPE_PagedPool: _POOL_TYPE = 1;
pub const _POOL_TYPE_NonPagedPoolMustSucceed: _POOL_TYPE = 2;
pub const _POOL_TYPE_DontUseThisType: _POOL_TYPE = 3;
pub const _POOL_TYPE_NonPagedPoolCacheAligned: _POOL_TYPE = 4;
pub const _POOL_TYPE_PagedPoolCacheAligned: _POOL_TYPE = 5;
pub const _POOL_TYPE_NonPagedPoolCacheAlignedMustS: _POOL_TYPE = 6;
pub const _POOL_TYPE_MaxPoolType: _POOL_TYPE = 7;
pub const _POOL_TYPE_NonPagedPoolBase: _POOL_TYPE = 0;
pub const _POOL_TYPE_NonPagedPoolBaseMustSucceed: _POOL_TYPE = 2;
pub const _POOL_TYPE_NonPagedPoolBaseCacheAligned: _POOL_TYPE = 4;
pub const _POOL_TYPE_NonPagedPoolBaseCacheAlignedMustS: _POOL_TYPE = 6;
pub const _POOL_TYPE_NonPagedPoolSession: _POOL_TYPE = 32;
pub const _POOL_TYPE_PagedPoolSession: _POOL_TYPE = 33;
pub const _POOL_TYPE_NonPagedPoolMustSucceedSession: _POOL_TYPE = 34;
pub const _POOL_TYPE_DontUseThisTypeSession: _POOL_TYPE = 35;
pub const _POOL_TYPE_NonPagedPoolCacheAlignedSession: _POOL_TYPE = 36;
pub const _POOL_TYPE_PagedPoolCacheAlignedSession: _POOL_TYPE = 37;
pub const _POOL_TYPE_NonPagedPoolCacheAlignedMustSSession: _POOL_TYPE = 38;
pub const _POOL_TYPE_NonPagedPoolNx: _POOL_TYPE = 512;
pub const _POOL_TYPE_NonPagedPoolNxCacheAligned: _POOL_TYPE = 516;
pub const _POOL_TYPE_NonPagedPoolSessionNx: _POOL_TYPE = 544;
pub type _POOL_TYPE = core::ffi::c_int;
unsafe extern "C" {
    pub fn ExAllocatePool(PoolType: POOL_TYPE, NumberOfBytes: SIZE_T) -> PVOID;
}
unsafe extern "C" {
    pub fn ExAllocatePoolWithQuota(PoolType: POOL_TYPE, NumberOfBytes: SIZE_T) -> PVOID;
}
unsafe extern "C" {
    pub fn ExAllocatePoolWithTag(PoolType: POOL_TYPE, NumberOfBytes: SIZE_T, Tag: ULONG) -> PVOID;
}
pub const _EX_POOL_PRIORITY_LowPoolPriority: _EX_POOL_PRIORITY = 0;
pub const _EX_POOL_PRIORITY_LowPoolPrioritySpecialPoolOverrun: _EX_POOL_PRIORITY = 8;
pub const _EX_POOL_PRIORITY_LowPoolPrioritySpecialPoolUnderrun: _EX_POOL_PRIORITY = 9;
pub const _EX_POOL_PRIORITY_NormalPoolPriority: _EX_POOL_PRIORITY = 16;
pub const _EX_POOL_PRIORITY_NormalPoolPrioritySpecialPoolOverrun: _EX_POOL_PRIORITY = 24;
pub const _EX_POOL_PRIORITY_NormalPoolPrioritySpecialPoolUnderrun: _EX_POOL_PRIORITY = 25;
pub const _EX_POOL_PRIORITY_HighPoolPriority: _EX_POOL_PRIORITY = 32;
pub const _EX_POOL_PRIORITY_HighPoolPrioritySpecialPoolOverrun: _EX_POOL_PRIORITY = 40;
pub const _EX_POOL_PRIORITY_HighPoolPrioritySpecialPoolUnderrun: _EX_POOL_PRIORITY = 41;
pub type _EX_POOL_PRIORITY = core::ffi::c_int;
pub use self::_EX_POOL_PRIORITY as EX_POOL_PRIORITY;
unsafe extern "C" {
    pub fn ExAllocatePoolWithTagPriority(
        PoolType: POOL_TYPE,
        NumberOfBytes: SIZE_T,
        Tag: ULONG,
        Priority: EX_POOL_PRIORITY,
    ) -> PVOID;
}
pub const POOL_EXTENDED_PARAMETER_TYPE_PoolExtendedParameterInvalidType:
POOL_EXTENDED_PARAMETER_TYPE = 0;
pub const POOL_EXTENDED_PARAMETER_TYPE_PoolExtendedParameterPriority: POOL_EXTENDED_PARAMETER_TYPE =
    1;
pub const POOL_EXTENDED_PARAMETER_TYPE_PoolExtendedParameterSecurePool:
POOL_EXTENDED_PARAMETER_TYPE = 2;
pub const POOL_EXTENDED_PARAMETER_TYPE_PoolExtendedParameterNumaNode: POOL_EXTENDED_PARAMETER_TYPE =
    3;
pub const POOL_EXTENDED_PARAMETER_TYPE_PoolExtendedParameterMax: POOL_EXTENDED_PARAMETER_TYPE = 4;
pub type POOL_EXTENDED_PARAMETER_TYPE = core::ffi::c_int;
pub type PPOOL_EXTENDED_PARAMETER_TYPE = *mut POOL_EXTENDED_PARAMETER_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POOL_EXTENDED_PARAMS_SECURE_POOL {
    pub SecurePoolHandle: HANDLE,
    pub Buffer: PVOID,
    pub Cookie: ULONG_PTR,
    pub SecurePoolFlags: ULONG,
}
pub type POOL_EXTENDED_PARAMS_SECURE_POOL = _POOL_EXTENDED_PARAMS_SECURE_POOL;
pub type POOL_NODE_REQUIREMENT = ULONG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POOL_EXTENDED_PARAMETER {
    pub __bindgen_anon_1: _POOL_EXTENDED_PARAMETER__bindgen_ty_1,
    pub __bindgen_anon_2: _POOL_EXTENDED_PARAMETER__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POOL_EXTENDED_PARAMETER__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _POOL_EXTENDED_PARAMETER__bindgen_ty_1 {
    #[inline]
    pub fn Type(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Type(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Type_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Type_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Optional(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Optional(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Optional_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Optional_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 55u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 55u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                55u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                55u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Type: ULONG64,
        Optional: ULONG64,
        Reserved: ULONG64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let Type: u64 = unsafe { ::core::mem::transmute(Type) };
            Type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Optional: u64 = unsafe { ::core::mem::transmute(Optional) };
            Optional as u64
        });
        __bindgen_bitfield_unit.set(9usize, 55u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _POOL_EXTENDED_PARAMETER__bindgen_ty_2 {
    pub Reserved2: ULONG64,
    pub Reserved3: PVOID,
    pub Priority: EX_POOL_PRIORITY,
    pub SecurePoolParams: *mut POOL_EXTENDED_PARAMS_SECURE_POOL,
    pub PreferredNode: POOL_NODE_REQUIREMENT,
}
pub type POOL_EXTENDED_PARAMETER = _POOL_EXTENDED_PARAMETER;
pub type PPOOL_EXTENDED_PARAMETER = *mut _POOL_EXTENDED_PARAMETER;
pub type PCPOOL_EXTENDED_PARAMETER = *const POOL_EXTENDED_PARAMETER;
unsafe extern "C" {
    pub fn ExAllocatePool2(Flags: POOL_FLAGS, NumberOfBytes: SIZE_T, Tag: ULONG) -> PVOID;
}
unsafe extern "C" {
    pub fn ExAllocatePool3(
        Flags: POOL_FLAGS,
        NumberOfBytes: SIZE_T,
        Tag: ULONG,
        ExtendedParameters: PCPOOL_EXTENDED_PARAMETER,
        ExtendedParametersCount: ULONG,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn ExFreePool2(
        P: PVOID,
        Tag: ULONG,
        ExtendedParameters: PCPOOL_EXTENDED_PARAMETER,
        ExtendedParametersCount: ULONG,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POOL_CREATE_EXTENDED_PARAMS {
    pub Version: ULONG,
}
pub type POOL_CREATE_EXTENDED_PARAMS = _POOL_CREATE_EXTENDED_PARAMS;
pub type PPOOL_CREATE_EXTENDED_PARAMS = *mut _POOL_CREATE_EXTENDED_PARAMS;
unsafe extern "C" {
    pub fn ExCreatePool(
        Flags: ULONG,
        Tag: ULONG_PTR,
        Params: *mut POOL_CREATE_EXTENDED_PARAMS,
        PoolHandle: *mut HANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ExDestroyPool(PoolHandle: HANDLE);
}
unsafe extern "C" {
    pub fn ExSecurePoolUpdate(
        SecurePoolHandle: HANDLE,
        Tag: ULONG,
        Allocation: PVOID,
        Cookie: ULONG_PTR,
        Offset: SIZE_T,
        Size: SIZE_T,
        Buffer: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ExSecurePoolValidate(
        SecurePoolHandle: HANDLE,
        Tag: ULONG,
        Allocation: PVOID,
        Cookie: ULONG_PTR,
    ) -> LOGICAL;
}
unsafe extern "C" {
    pub fn ExAllocatePoolWithQuotaTag(
        PoolType: POOL_TYPE,
        NumberOfBytes: SIZE_T,
        Tag: ULONG,
    ) -> PVOID;
}
pub const ExPoolZeroingNativelySupported: BOOLEAN = 0;
unsafe extern "C" {
    pub fn ExFreePool(P: PVOID);
}
unsafe extern "C" {
    pub fn ExFreePoolWithTag(P: PVOID, Tag: ULONG);
}
unsafe extern "C" {
    pub fn ExAcquireFastMutexUnsafe(FastMutex: PFAST_MUTEX);
}
unsafe extern "C" {
    pub fn ExReleaseFastMutexUnsafe(FastMutex: PFAST_MUTEX);
}
unsafe extern "C" {
    pub fn ExAcquireFastMutex(FastMutex: PFAST_MUTEX);
}
unsafe extern "C" {
    pub fn ExReleaseFastMutex(FastMutex: PFAST_MUTEX);
}
unsafe extern "C" {
    pub fn ExTryToAcquireFastMutex(FastMutex: PFAST_MUTEX) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ExInterlockedAddLargeInteger(
        Addend: PLARGE_INTEGER,
        Increment: LARGE_INTEGER,
        Lock: PKSPIN_LOCK,
    ) -> LARGE_INTEGER;
}
unsafe extern "C" {
    pub fn ExInterlockedAddUlong(Addend: PULONG, Increment: ULONG, Lock: PKSPIN_LOCK) -> ULONG;
}
unsafe extern "C" {
    pub fn ExInterlockedInsertHeadList(
        ListHead: PLIST_ENTRY,
        ListEntry: PLIST_ENTRY,
        Lock: PKSPIN_LOCK,
    ) -> PLIST_ENTRY;
}
unsafe extern "C" {
    pub fn ExInterlockedInsertTailList(
        ListHead: PLIST_ENTRY,
        ListEntry: PLIST_ENTRY,
        Lock: PKSPIN_LOCK,
    ) -> PLIST_ENTRY;
}
unsafe extern "C" {
    pub fn ExInterlockedRemoveHeadList(ListHead: PLIST_ENTRY, Lock: PKSPIN_LOCK) -> PLIST_ENTRY;
}
unsafe extern "C" {
    pub fn ExInterlockedPopEntryList(
        ListHead: PSINGLE_LIST_ENTRY,
        Lock: PKSPIN_LOCK,
    ) -> PSINGLE_LIST_ENTRY;
}
unsafe extern "C" {
    pub fn ExInterlockedPushEntryList(
        ListHead: PSINGLE_LIST_ENTRY,
        ListEntry: PSINGLE_LIST_ENTRY,
        Lock: PKSPIN_LOCK,
    ) -> PSINGLE_LIST_ENTRY;
}
unsafe extern "C" {
    pub fn InitializeSListHead(SListHead: PSLIST_HEADER);
}
unsafe extern "C" {
    pub fn FirstEntrySList(SListHead: PSLIST_HEADER) -> PSLIST_ENTRY;
}
unsafe extern "C" {
    pub fn ExQueryDepthSList(SListHead: PSLIST_HEADER) -> USHORT;
}
unsafe extern "C" {
    pub fn ExpInterlockedPopEntrySList(ListHead: PSLIST_HEADER) -> PSLIST_ENTRY;
}
unsafe extern "C" {
    pub fn ExpInterlockedPushEntrySList(
        ListHead: PSLIST_HEADER,
        ListEntry: PSLIST_ENTRY,
    ) -> PSLIST_ENTRY;
}
unsafe extern "C" {
    pub fn ExpInterlockedFlushSList(ListHead: PSLIST_HEADER) -> PSLIST_ENTRY;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _LOOKASIDE_LIST_EX {
    pub L: GENERAL_LOOKASIDE_POOL,
}
pub type LOOKASIDE_LIST_EX = _LOOKASIDE_LIST_EX;
unsafe extern "C" {
    pub fn ExInitializeLookasideListEx(
        Lookaside: PLOOKASIDE_LIST_EX,
        Allocate: PALLOCATE_FUNCTION_EX,
        Free: PFREE_FUNCTION_EX,
        PoolType: POOL_TYPE,
        Flags: ULONG,
        Size: SIZE_T,
        Tag: ULONG,
        Depth: USHORT,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ExDeleteLookasideListEx(Lookaside: PLOOKASIDE_LIST_EX);
}
unsafe extern "C" {
    pub fn ExFlushLookasideListEx(Lookaside: PLOOKASIDE_LIST_EX);
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct _NPAGED_LOOKASIDE_LIST {
    pub L: GENERAL_LOOKASIDE,
}
pub type NPAGED_LOOKASIDE_LIST = _NPAGED_LOOKASIDE_LIST;
pub type PNPAGED_LOOKASIDE_LIST = *mut _NPAGED_LOOKASIDE_LIST;
unsafe extern "C" {
    pub fn ExInitializeNPagedLookasideList(
        Lookaside: PNPAGED_LOOKASIDE_LIST,
        Allocate: PALLOCATE_FUNCTION,
        Free: PFREE_FUNCTION,
        Flags: ULONG,
        Size: SIZE_T,
        Tag: ULONG,
        Depth: USHORT,
    );
}
unsafe extern "C" {
    pub fn ExDeleteNPagedLookasideList(Lookaside: PNPAGED_LOOKASIDE_LIST);
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct _PAGED_LOOKASIDE_LIST {
    pub L: GENERAL_LOOKASIDE,
}
pub type PAGED_LOOKASIDE_LIST = _PAGED_LOOKASIDE_LIST;
pub type PPAGED_LOOKASIDE_LIST = *mut _PAGED_LOOKASIDE_LIST;
unsafe extern "C" {
    pub fn ExInitializePagedLookasideList(
        Lookaside: PPAGED_LOOKASIDE_LIST,
        Allocate: PALLOCATE_FUNCTION,
        Free: PFREE_FUNCTION,
        Flags: ULONG,
        Size: SIZE_T,
        Tag: ULONG,
        Depth: USHORT,
    );
}
unsafe extern "C" {
    pub fn ExDeletePagedLookasideList(Lookaside: PPAGED_LOOKASIDE_LIST);
}
unsafe extern "C" {
    pub fn ProbeForRead(Address: *mut core::ffi::c_void, Length: SIZE_T, Alignment: ULONG);
}
unsafe extern "C" {
    pub fn ExRaiseStatus(Status: NTSTATUS) -> !;
}
unsafe extern "C" {
    pub fn ProbeForWrite(Address: *mut core::ffi::c_void, Length: SIZE_T, Alignment: ULONG);
}
pub const _WORK_QUEUE_TYPE_CriticalWorkQueue: _WORK_QUEUE_TYPE = 0;
pub const _WORK_QUEUE_TYPE_DelayedWorkQueue: _WORK_QUEUE_TYPE = 1;
pub const _WORK_QUEUE_TYPE_HyperCriticalWorkQueue: _WORK_QUEUE_TYPE = 2;
pub const _WORK_QUEUE_TYPE_NormalWorkQueue: _WORK_QUEUE_TYPE = 3;
pub const _WORK_QUEUE_TYPE_BackgroundWorkQueue: _WORK_QUEUE_TYPE = 4;
pub const _WORK_QUEUE_TYPE_RealTimeWorkQueue: _WORK_QUEUE_TYPE = 5;
pub const _WORK_QUEUE_TYPE_SuperCriticalWorkQueue: _WORK_QUEUE_TYPE = 6;
pub const _WORK_QUEUE_TYPE_MaximumWorkQueue: _WORK_QUEUE_TYPE = 7;
pub const _WORK_QUEUE_TYPE_CustomPriorityWorkQueue: _WORK_QUEUE_TYPE = 32;
pub type _WORK_QUEUE_TYPE = core::ffi::c_int;
pub use self::_WORK_QUEUE_TYPE as WORK_QUEUE_TYPE;
pub type WORKER_THREAD_ROUTINE = ::core::option::Option<unsafe extern "C" fn(Parameter: PVOID)>;
pub type PWORKER_THREAD_ROUTINE = WORKER_THREAD_ROUTINE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WORK_QUEUE_ITEM {
    pub List: LIST_ENTRY,
    pub WorkerRoutine: PWORKER_THREAD_ROUTINE,
    pub Parameter: PVOID,
}
pub type WORK_QUEUE_ITEM = _WORK_QUEUE_ITEM;
pub type PWORK_QUEUE_ITEM = *mut _WORK_QUEUE_ITEM;
unsafe extern "C" {
    pub fn ExQueueWorkItem(WorkItem: PWORK_QUEUE_ITEM, QueueType: WORK_QUEUE_TYPE);
}
unsafe extern "C" {
    pub fn ExIsProcessorFeaturePresent(ProcessorFeature: ULONG) -> BOOLEAN;
}
pub type ERESOURCE_THREAD = ULONG_PTR;
pub type PERESOURCE_THREAD = *mut ERESOURCE_THREAD;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OWNER_ENTRY {
    pub OwnerThread: ERESOURCE_THREAD,
    pub __bindgen_anon_1: _OWNER_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OWNER_ENTRY__bindgen_ty_1 {
    pub __bindgen_anon_1: _OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1,
    pub TableSize: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn IoPriorityBoosted(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoPriorityBoosted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IoPriorityBoosted_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IoPriorityBoosted_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn OwnerReferenced(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OwnerReferenced(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn OwnerReferenced_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_OwnerReferenced_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IoQoSPriorityBoosted(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoQoSPriorityBoosted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IoQoSPriorityBoosted_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IoQoSPriorityBoosted_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn OwnerCount(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_OwnerCount(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn OwnerCount_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                29u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_OwnerCount_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                29u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        IoPriorityBoosted: ULONG,
        OwnerReferenced: ULONG,
        IoQoSPriorityBoosted: ULONG,
        OwnerCount: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let IoPriorityBoosted: u32 = unsafe { ::core::mem::transmute(IoPriorityBoosted) };
            IoPriorityBoosted as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let OwnerReferenced: u32 = unsafe { ::core::mem::transmute(OwnerReferenced) };
            OwnerReferenced as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let IoQoSPriorityBoosted: u32 = unsafe { ::core::mem::transmute(IoQoSPriorityBoosted) };
            IoQoSPriorityBoosted as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let OwnerCount: u32 = unsafe { ::core::mem::transmute(OwnerCount) };
            OwnerCount as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type OWNER_ENTRY = _OWNER_ENTRY;
pub type POWNER_ENTRY = *mut _OWNER_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ERESOURCE {
    pub SystemResourcesList: LIST_ENTRY,
    pub OwnerTable: POWNER_ENTRY,
    pub ActiveCount: SHORT,
    pub __bindgen_anon_1: _ERESOURCE__bindgen_ty_1,
    pub SharedWaiters: PVOID,
    pub ExclusiveWaiters: PVOID,
    pub OwnerEntry: OWNER_ENTRY,
    pub ActiveEntries: ULONG,
    pub ContentionCount: ULONG,
    pub NumberOfSharedWaiters: ULONG,
    pub NumberOfExclusiveWaiters: ULONG,
    pub Reserved2: PVOID,
    pub __bindgen_anon_2: _ERESOURCE__bindgen_ty_2,
    pub SpinLock: KSPIN_LOCK,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ERESOURCE__bindgen_ty_1 {
    pub Flag: USHORT,
    pub __bindgen_anon_1: _ERESOURCE__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ERESOURCE__bindgen_ty_1__bindgen_ty_1 {
    pub ReservedLowFlags: UCHAR,
    pub WaiterPriority: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ERESOURCE__bindgen_ty_2 {
    pub Address: PVOID,
    pub CreatorBackTraceIndex: ULONG_PTR,
}
pub type ERESOURCE = _ERESOURCE;
pub type PERESOURCE = *mut _ERESOURCE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RESOURCE_HASH_ENTRY {
    pub ListEntry: LIST_ENTRY,
    pub Address: PVOID,
    pub ContentionCount: ULONG,
    pub Number: ULONG,
}
pub type RESOURCE_HASH_ENTRY = _RESOURCE_HASH_ENTRY;
pub type PRESOURCE_HASH_ENTRY = *mut _RESOURCE_HASH_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RESOURCE_PERFORMANCE_DATA {
    pub ActiveResourceCount: ULONG,
    pub TotalResourceCount: ULONG,
    pub ExclusiveAcquire: ULONG,
    pub SharedFirstLevel: ULONG,
    pub SharedSecondLevel: ULONG,
    pub StarveFirstLevel: ULONG,
    pub StarveSecondLevel: ULONG,
    pub WaitForExclusive: ULONG,
    pub OwnerTableExpands: ULONG,
    pub MaximumTableExpand: ULONG,
    pub HashTable: [LIST_ENTRY; 64usize],
}
pub type RESOURCE_PERFORMANCE_DATA = _RESOURCE_PERFORMANCE_DATA;
pub type PRESOURCE_PERFORMANCE_DATA = *mut _RESOURCE_PERFORMANCE_DATA;
unsafe extern "C" {
    pub fn ExInitializeResourceLite(Resource: PERESOURCE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ExReinitializeResourceLite(Resource: PERESOURCE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ExAcquireResourceSharedLite(Resource: PERESOURCE, Wait: BOOLEAN) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ExEnterCriticalRegionAndAcquireResourceShared(Resource: PERESOURCE) -> PVOID;
}
unsafe extern "C" {
    pub fn ExAcquireResourceExclusiveLite(Resource: PERESOURCE, Wait: BOOLEAN) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ExEnterCriticalRegionAndAcquireResourceExclusive(Resource: PERESOURCE) -> PVOID;
}
unsafe extern "C" {
    pub fn ExAcquireSharedStarveExclusive(Resource: PERESOURCE, Wait: BOOLEAN) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ExAcquireSharedWaitForExclusive(Resource: PERESOURCE, Wait: BOOLEAN) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ExEnterCriticalRegionAndAcquireSharedWaitForExclusive(Resource: PERESOURCE) -> PVOID;
}
unsafe extern "C" {
    pub fn ExReleaseResourceLite(Resource: PERESOURCE);
}
unsafe extern "C" {
    pub fn ExReleaseResourceAndLeaveCriticalRegion(Resource: PERESOURCE);
}
unsafe extern "C" {
    pub fn ExReleaseResourceForThreadLite(Resource: PERESOURCE, ResourceThreadId: ERESOURCE_THREAD);
}
unsafe extern "C" {
    pub fn ExSetResourceOwnerPointer(Resource: PERESOURCE, OwnerPointer: PVOID);
}
unsafe extern "C" {
    pub fn ExSetResourceOwnerPointerEx(Resource: PERESOURCE, OwnerPointer: PVOID, Flags: ULONG);
}
unsafe extern "C" {
    pub fn ExConvertExclusiveToSharedLite(Resource: PERESOURCE);
}
unsafe extern "C" {
    pub fn ExDeleteResourceLite(Resource: PERESOURCE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ExGetExclusiveWaiterCount(Resource: PERESOURCE) -> ULONG;
}
unsafe extern "C" {
    pub fn ExGetSharedWaiterCount(Resource: PERESOURCE) -> ULONG;
}
unsafe extern "C" {
    pub fn ExIsResourceAcquiredExclusiveLite(Resource: PERESOURCE) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ExIsResourceAcquiredSharedLite(Resource: PERESOURCE) -> ULONG;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EX_RUNDOWN_REF {
    pub __bindgen_anon_1: _EX_RUNDOWN_REF__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EX_RUNDOWN_REF__bindgen_ty_1 {
    pub Count: ULONG_PTR,
    pub Ptr: PVOID,
}
pub type EX_RUNDOWN_REF = _EX_RUNDOWN_REF;
pub type PEX_RUNDOWN_REF = *mut _EX_RUNDOWN_REF;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EX_RUNDOWN_REF_CACHE_AWARE {
    _unused: [u8; 0],
}
pub type PEX_RUNDOWN_REF_CACHE_AWARE = *mut _EX_RUNDOWN_REF_CACHE_AWARE;
unsafe extern "C" {
    pub fn ExGetPreviousMode() -> KPROCESSOR_MODE;
}
unsafe extern "C" {
    pub fn ExSetTimerResolution(DesiredTime: ULONG, SetResolution: BOOLEAN) -> ULONG;
}
unsafe extern "C" {
    pub fn ExQueryTimerResolution(MaximumTime: PULONG, MinimumTime: PULONG, CurrentTime: PULONG);
}
unsafe extern "C" {
    pub fn ExSystemTimeToLocalTime(SystemTime: PLARGE_INTEGER, LocalTime: PLARGE_INTEGER);
}
unsafe extern "C" {
    pub fn ExLocalTimeToSystemTime(LocalTime: PLARGE_INTEGER, SystemTime: PLARGE_INTEGER);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EX_TIMER {
    _unused: [u8; 0],
}
pub type PEX_TIMER = *mut _EX_TIMER;
pub type EXT_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Timer: PEX_TIMER, Context: PVOID)>;
pub type PEXT_CALLBACK = EXT_CALLBACK;
pub type EXT_DELETE_CALLBACK = ::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
pub type PEXT_DELETE_CALLBACK = EXT_DELETE_CALLBACK;
pub type PEXT_CANCEL_PARAMETERS = PVOID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXT_DELETE_PARAMETERS {
    pub Version: ULONG,
    pub Reserved: ULONG,
    pub DeleteCallback: PEXT_DELETE_CALLBACK,
    pub DeleteContext: PVOID,
}
pub type EXT_DELETE_PARAMETERS = _EXT_DELETE_PARAMETERS;
pub type PEXT_DELETE_PARAMETERS = *mut _EXT_DELETE_PARAMETERS;
unsafe extern "C" {
    pub fn ExAllocateTimer(
        Callback: PEXT_CALLBACK,
        CallbackContext: PVOID,
        Attributes: ULONG,
    ) -> PEX_TIMER;
}
unsafe extern "C" {
    pub fn ExSetTimer(
        Timer: PEX_TIMER,
        DueTime: LONGLONG,
        Period: LONGLONG,
        Parameters: PEXT_SET_PARAMETERS,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ExCancelTimer(Timer: PEX_TIMER, Parameters: PEXT_CANCEL_PARAMETERS) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ExDeleteTimer(
        Timer: PEX_TIMER,
        Cancel: BOOLEAN,
        Wait: BOOLEAN,
        Parameters: PEXT_DELETE_PARAMETERS,
    ) -> BOOLEAN;
}
pub type CALLBACK_FUNCTION = ::core::option::Option<
    unsafe extern "C" fn(CallbackContext: PVOID, Argument1: PVOID, Argument2: PVOID),
>;
pub type PCALLBACK_FUNCTION = CALLBACK_FUNCTION;
unsafe extern "C" {
    pub fn ExCreateCallback(
        CallbackObject: *mut PCALLBACK_OBJECT,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        Create: BOOLEAN,
        AllowMultipleCallbacks: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ExRegisterCallback(
        CallbackObject: PCALLBACK_OBJECT,
        CallbackFunction: PCALLBACK_FUNCTION,
        CallbackContext: PVOID,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn ExUnregisterCallback(CallbackRegistration: PVOID);
}
unsafe extern "C" {
    pub fn ExNotifyCallback(CallbackObject: PVOID, Argument1: PVOID, Argument2: PVOID);
}
unsafe extern "C" {
    pub fn ExVerifySuite(SuiteType: SUITE_TYPE) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ExInitializeRundownProtection(RunRef: PEX_RUNDOWN_REF);
}
unsafe extern "C" {
    pub fn ExReInitializeRundownProtection(RunRef: PEX_RUNDOWN_REF);
}
unsafe extern "C" {
    pub fn ExAcquireRundownProtection(RunRef: PEX_RUNDOWN_REF) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ExAcquireRundownProtectionEx(RunRef: PEX_RUNDOWN_REF, Count: ULONG) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ExReleaseRundownProtection(RunRef: PEX_RUNDOWN_REF);
}
unsafe extern "C" {
    pub fn ExReleaseRundownProtectionEx(RunRef: PEX_RUNDOWN_REF, Count: ULONG);
}
unsafe extern "C" {
    pub fn ExRundownCompleted(RunRef: PEX_RUNDOWN_REF);
}
unsafe extern "C" {
    pub fn ExWaitForRundownProtectionRelease(RunRef: PEX_RUNDOWN_REF);
}
unsafe extern "C" {
    pub fn ExAllocateCacheAwareRundownProtection(
        PoolType: POOL_TYPE,
        PoolTag: ULONG,
    ) -> PEX_RUNDOWN_REF_CACHE_AWARE;
}
unsafe extern "C" {
    pub fn ExSizeOfRundownProtectionCacheAware() -> SIZE_T;
}
unsafe extern "C" {
    pub fn ExInitializeRundownProtectionCacheAware(
        RunRefCacheAware: PEX_RUNDOWN_REF_CACHE_AWARE,
        RunRefSize: SIZE_T,
    );
}
unsafe extern "C" {
    pub fn ExFreeCacheAwareRundownProtection(RunRefCacheAware: PEX_RUNDOWN_REF_CACHE_AWARE);
}
unsafe extern "C" {
    pub fn ExAcquireRundownProtectionCacheAware(
        RunRefCacheAware: PEX_RUNDOWN_REF_CACHE_AWARE,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ExReleaseRundownProtectionCacheAware(RunRefCacheAware: PEX_RUNDOWN_REF_CACHE_AWARE);
}
unsafe extern "C" {
    pub fn ExAcquireRundownProtectionCacheAwareEx(
        RunRefCacheAware: PEX_RUNDOWN_REF_CACHE_AWARE,
        Count: ULONG,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ExReleaseRundownProtectionCacheAwareEx(
        RunRef: PEX_RUNDOWN_REF_CACHE_AWARE,
        Count: ULONG,
    );
}
unsafe extern "C" {
    pub fn ExWaitForRundownProtectionReleaseCacheAware(RunRef: PEX_RUNDOWN_REF_CACHE_AWARE);
}
unsafe extern "C" {
    pub fn ExReInitializeRundownProtectionCacheAware(RunRefCacheAware: PEX_RUNDOWN_REF_CACHE_AWARE);
}
unsafe extern "C" {
    pub fn ExRundownCompletedCacheAware(RunRefCacheAware: PEX_RUNDOWN_REF_CACHE_AWARE);
}
unsafe extern "C" {
    pub fn ExInitializeRundownProtectionCacheAwareEx(
        RunRefCacheAware: PEX_RUNDOWN_REF_CACHE_AWARE,
        Flags: ULONG,
    );
}
unsafe extern "C" {
    pub fn ExCleanupRundownProtectionCacheAware(RunRefCacheAware: PEX_RUNDOWN_REF_CACHE_AWARE);
}
unsafe extern "C" {
    pub fn ExInitializePushLock(PushLock: PULONG_PTR);
}
unsafe extern "C" {
    pub fn ExAcquirePushLockExclusiveEx(PushLock: PULONG_PTR, Flags: ULONG);
}
unsafe extern "C" {
    pub fn ExAcquirePushLockSharedEx(PushLock: PULONG_PTR, Flags: ULONG);
}
unsafe extern "C" {
    pub fn ExReleasePushLockExclusiveEx(PushLock: PULONG_PTR, Flags: ULONG);
}
unsafe extern "C" {
    pub fn ExReleasePushLockSharedEx(PushLock: PULONG_PTR, Flags: ULONG);
}
unsafe extern "C" {
    pub fn ExInitializeDeviceAts(
        PhysicalDeviceObject: *mut __BindgenOpaqueArray<u8, 0usize>,
        Flags: ULONG,
    ) -> NTSTATUS;
}
pub type EX_SPIN_LOCK = LONG;
pub type PEX_SPIN_LOCK = *mut LONG;
unsafe extern "C" {
    pub fn ExAcquireSpinLockSharedAtDpcLevel(SpinLock: PEX_SPIN_LOCK);
}
unsafe extern "C" {
    pub fn ExAcquireSpinLockShared(SpinLock: PEX_SPIN_LOCK) -> KIRQL;
}
unsafe extern "C" {
    pub fn ExReleaseSpinLockSharedFromDpcLevel(SpinLock: PEX_SPIN_LOCK);
}
unsafe extern "C" {
    pub fn ExReleaseSpinLockShared(SpinLock: PEX_SPIN_LOCK, OldIrql: KIRQL);
}
unsafe extern "C" {
    pub fn ExTryConvertSharedSpinLockExclusive(SpinLock: PEX_SPIN_LOCK) -> LOGICAL;
}
unsafe extern "C" {
    pub fn ExAcquireSpinLockExclusiveAtDpcLevel(SpinLock: PEX_SPIN_LOCK);
}
unsafe extern "C" {
    pub fn ExAcquireSpinLockExclusive(SpinLock: PEX_SPIN_LOCK) -> KIRQL;
}
unsafe extern "C" {
    pub fn ExReleaseSpinLockExclusiveFromDpcLevel(SpinLock: PEX_SPIN_LOCK);
}
unsafe extern "C" {
    pub fn ExReleaseSpinLockExclusive(SpinLock: PEX_SPIN_LOCK, OldIrql: KIRQL);
}
unsafe extern "C" {
    pub fn ExTryAcquireSpinLockSharedAtDpcLevel(SpinLock: PEX_SPIN_LOCK) -> LOGICAL;
}
unsafe extern "C" {
    pub fn ExTryAcquireSpinLockExclusiveAtDpcLevel(SpinLock: PEX_SPIN_LOCK) -> LOGICAL;
}
pub type EX_CALLBACK_FUNCTION = ::core::option::Option<
    unsafe extern "C" fn(CallbackContext: PVOID, Argument1: PVOID, Argument2: PVOID) -> NTSTATUS,
>;
pub type PEX_CALLBACK_FUNCTION = EX_CALLBACK_FUNCTION;
unsafe extern "C" {
    pub fn ExGetFirmwareEnvironmentVariable(
        VariableName: PUNICODE_STRING,
        VendorGuid: LPGUID,
        Value: PVOID,
        ValueLength: PULONG,
        Attributes: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ExSetFirmwareEnvironmentVariable(
        VariableName: PUNICODE_STRING,
        VendorGuid: LPGUID,
        Value: PVOID,
        ValueLength: ULONG,
        Attributes: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ExIsManufacturingModeEnabled() -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ExIsSoftBoot() -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ExGetFirmwareType() -> FIRMWARE_TYPE;
}
unsafe extern "C" {
    pub fn ExEnumerateSystemFirmwareTables(
        FirmwareTableProviderSignature: ULONG,
        FirmwareTableBuffer: PVOID,
        BufferLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ExGetSystemFirmwareTable(
        FirmwareTableProviderSignature: ULONG,
        FirmwareTableID: ULONG,
        FirmwareTableBuffer: PVOID,
        BufferLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
pub const _REG_NOTIFY_CLASS_RegNtDeleteKey: _REG_NOTIFY_CLASS = 0;
pub const _REG_NOTIFY_CLASS_RegNtPreDeleteKey: _REG_NOTIFY_CLASS = 0;
pub const _REG_NOTIFY_CLASS_RegNtSetValueKey: _REG_NOTIFY_CLASS = 1;
pub const _REG_NOTIFY_CLASS_RegNtPreSetValueKey: _REG_NOTIFY_CLASS = 1;
pub const _REG_NOTIFY_CLASS_RegNtDeleteValueKey: _REG_NOTIFY_CLASS = 2;
pub const _REG_NOTIFY_CLASS_RegNtPreDeleteValueKey: _REG_NOTIFY_CLASS = 2;
pub const _REG_NOTIFY_CLASS_RegNtSetInformationKey: _REG_NOTIFY_CLASS = 3;
pub const _REG_NOTIFY_CLASS_RegNtPreSetInformationKey: _REG_NOTIFY_CLASS = 3;
pub const _REG_NOTIFY_CLASS_RegNtRenameKey: _REG_NOTIFY_CLASS = 4;
pub const _REG_NOTIFY_CLASS_RegNtPreRenameKey: _REG_NOTIFY_CLASS = 4;
pub const _REG_NOTIFY_CLASS_RegNtEnumerateKey: _REG_NOTIFY_CLASS = 5;
pub const _REG_NOTIFY_CLASS_RegNtPreEnumerateKey: _REG_NOTIFY_CLASS = 5;
pub const _REG_NOTIFY_CLASS_RegNtEnumerateValueKey: _REG_NOTIFY_CLASS = 6;
pub const _REG_NOTIFY_CLASS_RegNtPreEnumerateValueKey: _REG_NOTIFY_CLASS = 6;
pub const _REG_NOTIFY_CLASS_RegNtQueryKey: _REG_NOTIFY_CLASS = 7;
pub const _REG_NOTIFY_CLASS_RegNtPreQueryKey: _REG_NOTIFY_CLASS = 7;
pub const _REG_NOTIFY_CLASS_RegNtQueryValueKey: _REG_NOTIFY_CLASS = 8;
pub const _REG_NOTIFY_CLASS_RegNtPreQueryValueKey: _REG_NOTIFY_CLASS = 8;
pub const _REG_NOTIFY_CLASS_RegNtQueryMultipleValueKey: _REG_NOTIFY_CLASS = 9;
pub const _REG_NOTIFY_CLASS_RegNtPreQueryMultipleValueKey: _REG_NOTIFY_CLASS = 9;
pub const _REG_NOTIFY_CLASS_RegNtPreCreateKey: _REG_NOTIFY_CLASS = 10;
pub const _REG_NOTIFY_CLASS_RegNtPostCreateKey: _REG_NOTIFY_CLASS = 11;
pub const _REG_NOTIFY_CLASS_RegNtPreOpenKey: _REG_NOTIFY_CLASS = 12;
pub const _REG_NOTIFY_CLASS_RegNtPostOpenKey: _REG_NOTIFY_CLASS = 13;
pub const _REG_NOTIFY_CLASS_RegNtKeyHandleClose: _REG_NOTIFY_CLASS = 14;
pub const _REG_NOTIFY_CLASS_RegNtPreKeyHandleClose: _REG_NOTIFY_CLASS = 14;
pub const _REG_NOTIFY_CLASS_RegNtPostDeleteKey: _REG_NOTIFY_CLASS = 15;
pub const _REG_NOTIFY_CLASS_RegNtPostSetValueKey: _REG_NOTIFY_CLASS = 16;
pub const _REG_NOTIFY_CLASS_RegNtPostDeleteValueKey: _REG_NOTIFY_CLASS = 17;
pub const _REG_NOTIFY_CLASS_RegNtPostSetInformationKey: _REG_NOTIFY_CLASS = 18;
pub const _REG_NOTIFY_CLASS_RegNtPostRenameKey: _REG_NOTIFY_CLASS = 19;
pub const _REG_NOTIFY_CLASS_RegNtPostEnumerateKey: _REG_NOTIFY_CLASS = 20;
pub const _REG_NOTIFY_CLASS_RegNtPostEnumerateValueKey: _REG_NOTIFY_CLASS = 21;
pub const _REG_NOTIFY_CLASS_RegNtPostQueryKey: _REG_NOTIFY_CLASS = 22;
pub const _REG_NOTIFY_CLASS_RegNtPostQueryValueKey: _REG_NOTIFY_CLASS = 23;
pub const _REG_NOTIFY_CLASS_RegNtPostQueryMultipleValueKey: _REG_NOTIFY_CLASS = 24;
pub const _REG_NOTIFY_CLASS_RegNtPostKeyHandleClose: _REG_NOTIFY_CLASS = 25;
pub const _REG_NOTIFY_CLASS_RegNtPreCreateKeyEx: _REG_NOTIFY_CLASS = 26;
pub const _REG_NOTIFY_CLASS_RegNtPostCreateKeyEx: _REG_NOTIFY_CLASS = 27;
pub const _REG_NOTIFY_CLASS_RegNtPreOpenKeyEx: _REG_NOTIFY_CLASS = 28;
pub const _REG_NOTIFY_CLASS_RegNtPostOpenKeyEx: _REG_NOTIFY_CLASS = 29;
pub const _REG_NOTIFY_CLASS_RegNtPreFlushKey: _REG_NOTIFY_CLASS = 30;
pub const _REG_NOTIFY_CLASS_RegNtPostFlushKey: _REG_NOTIFY_CLASS = 31;
pub const _REG_NOTIFY_CLASS_RegNtPreLoadKey: _REG_NOTIFY_CLASS = 32;
pub const _REG_NOTIFY_CLASS_RegNtPostLoadKey: _REG_NOTIFY_CLASS = 33;
pub const _REG_NOTIFY_CLASS_RegNtPreUnLoadKey: _REG_NOTIFY_CLASS = 34;
pub const _REG_NOTIFY_CLASS_RegNtPostUnLoadKey: _REG_NOTIFY_CLASS = 35;
pub const _REG_NOTIFY_CLASS_RegNtPreQueryKeySecurity: _REG_NOTIFY_CLASS = 36;
pub const _REG_NOTIFY_CLASS_RegNtPostQueryKeySecurity: _REG_NOTIFY_CLASS = 37;
pub const _REG_NOTIFY_CLASS_RegNtPreSetKeySecurity: _REG_NOTIFY_CLASS = 38;
pub const _REG_NOTIFY_CLASS_RegNtPostSetKeySecurity: _REG_NOTIFY_CLASS = 39;
pub const _REG_NOTIFY_CLASS_RegNtCallbackObjectContextCleanup: _REG_NOTIFY_CLASS = 40;
pub const _REG_NOTIFY_CLASS_RegNtPreRestoreKey: _REG_NOTIFY_CLASS = 41;
pub const _REG_NOTIFY_CLASS_RegNtPostRestoreKey: _REG_NOTIFY_CLASS = 42;
pub const _REG_NOTIFY_CLASS_RegNtPreSaveKey: _REG_NOTIFY_CLASS = 43;
pub const _REG_NOTIFY_CLASS_RegNtPostSaveKey: _REG_NOTIFY_CLASS = 44;
pub const _REG_NOTIFY_CLASS_RegNtPreReplaceKey: _REG_NOTIFY_CLASS = 45;
pub const _REG_NOTIFY_CLASS_RegNtPostReplaceKey: _REG_NOTIFY_CLASS = 46;
pub const _REG_NOTIFY_CLASS_RegNtPreQueryKeyName: _REG_NOTIFY_CLASS = 47;
pub const _REG_NOTIFY_CLASS_RegNtPostQueryKeyName: _REG_NOTIFY_CLASS = 48;
pub const _REG_NOTIFY_CLASS_RegNtPreSaveMergedKey: _REG_NOTIFY_CLASS = 49;
pub const _REG_NOTIFY_CLASS_RegNtPostSaveMergedKey: _REG_NOTIFY_CLASS = 50;
pub const _REG_NOTIFY_CLASS_MaxRegNtNotifyClass: _REG_NOTIFY_CLASS = 51;
pub type _REG_NOTIFY_CLASS = core::ffi::c_int;
pub use self::_REG_NOTIFY_CLASS as REG_NOTIFY_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_DELETE_KEY_INFORMATION {
    pub Object: PVOID,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_DELETE_KEY_INFORMATION = _REG_DELETE_KEY_INFORMATION;
pub type PREG_DELETE_KEY_INFORMATION = *mut _REG_DELETE_KEY_INFORMATION;
pub type REG_FLUSH_KEY_INFORMATION = _REG_DELETE_KEY_INFORMATION;
pub type PREG_FLUSH_KEY_INFORMATION = *mut _REG_DELETE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_SET_VALUE_KEY_INFORMATION {
    pub Object: PVOID,
    pub ValueName: PUNICODE_STRING,
    pub TitleIndex: ULONG,
    pub Type: ULONG,
    pub Data: PVOID,
    pub DataSize: ULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_SET_VALUE_KEY_INFORMATION = _REG_SET_VALUE_KEY_INFORMATION;
pub type PREG_SET_VALUE_KEY_INFORMATION = *mut _REG_SET_VALUE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_DELETE_VALUE_KEY_INFORMATION {
    pub Object: PVOID,
    pub ValueName: PUNICODE_STRING,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_DELETE_VALUE_KEY_INFORMATION = _REG_DELETE_VALUE_KEY_INFORMATION;
pub type PREG_DELETE_VALUE_KEY_INFORMATION = *mut _REG_DELETE_VALUE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_SET_INFORMATION_KEY_INFORMATION {
    pub Object: PVOID,
    pub KeySetInformationClass: KEY_SET_INFORMATION_CLASS,
    pub KeySetInformation: PVOID,
    pub KeySetInformationLength: ULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_SET_INFORMATION_KEY_INFORMATION = _REG_SET_INFORMATION_KEY_INFORMATION;
pub type PREG_SET_INFORMATION_KEY_INFORMATION = *mut _REG_SET_INFORMATION_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_ENUMERATE_KEY_INFORMATION {
    pub Object: PVOID,
    pub Index: ULONG,
    pub KeyInformationClass: KEY_INFORMATION_CLASS,
    pub KeyInformation: PVOID,
    pub Length: ULONG,
    pub ResultLength: PULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_ENUMERATE_KEY_INFORMATION = _REG_ENUMERATE_KEY_INFORMATION;
pub type PREG_ENUMERATE_KEY_INFORMATION = *mut _REG_ENUMERATE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_ENUMERATE_VALUE_KEY_INFORMATION {
    pub Object: PVOID,
    pub Index: ULONG,
    pub KeyValueInformationClass: KEY_VALUE_INFORMATION_CLASS,
    pub KeyValueInformation: PVOID,
    pub Length: ULONG,
    pub ResultLength: PULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_ENUMERATE_VALUE_KEY_INFORMATION = _REG_ENUMERATE_VALUE_KEY_INFORMATION;
pub type PREG_ENUMERATE_VALUE_KEY_INFORMATION = *mut _REG_ENUMERATE_VALUE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_QUERY_KEY_INFORMATION {
    pub Object: PVOID,
    pub KeyInformationClass: KEY_INFORMATION_CLASS,
    pub KeyInformation: PVOID,
    pub Length: ULONG,
    pub ResultLength: PULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_QUERY_KEY_INFORMATION = _REG_QUERY_KEY_INFORMATION;
pub type PREG_QUERY_KEY_INFORMATION = *mut _REG_QUERY_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_QUERY_VALUE_KEY_INFORMATION {
    pub Object: PVOID,
    pub ValueName: PUNICODE_STRING,
    pub KeyValueInformationClass: KEY_VALUE_INFORMATION_CLASS,
    pub KeyValueInformation: PVOID,
    pub Length: ULONG,
    pub ResultLength: PULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_QUERY_VALUE_KEY_INFORMATION = _REG_QUERY_VALUE_KEY_INFORMATION;
pub type PREG_QUERY_VALUE_KEY_INFORMATION = *mut _REG_QUERY_VALUE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION {
    pub Object: PVOID,
    pub ValueEntries: PKEY_VALUE_ENTRY,
    pub EntryCount: ULONG,
    pub ValueBuffer: PVOID,
    pub BufferLength: PULONG,
    pub RequiredBufferLength: PULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION = _REG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION;
pub type PREG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION = *mut _REG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_RENAME_KEY_INFORMATION {
    pub Object: PVOID,
    pub NewName: PUNICODE_STRING,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_RENAME_KEY_INFORMATION = _REG_RENAME_KEY_INFORMATION;
pub type PREG_RENAME_KEY_INFORMATION = *mut _REG_RENAME_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_KEY_HANDLE_CLOSE_INFORMATION {
    pub Object: PVOID,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_KEY_HANDLE_CLOSE_INFORMATION = _REG_KEY_HANDLE_CLOSE_INFORMATION;
pub type PREG_KEY_HANDLE_CLOSE_INFORMATION = *mut _REG_KEY_HANDLE_CLOSE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_CREATE_KEY_INFORMATION {
    pub CompleteName: PUNICODE_STRING,
    pub RootObject: PVOID,
    pub ObjectType: PVOID,
    pub CreateOptions: ULONG,
    pub Class: PUNICODE_STRING,
    pub SecurityDescriptor: PVOID,
    pub SecurityQualityOfService: PVOID,
    pub DesiredAccess: ACCESS_MASK,
    pub GrantedAccess: ACCESS_MASK,
    pub Disposition: PULONG,
    pub ResultObject: *mut PVOID,
    pub CallContext: PVOID,
    pub RootObjectContext: PVOID,
    pub Transaction: PVOID,
    pub Reserved: PVOID,
}
pub type REG_CREATE_KEY_INFORMATION = _REG_CREATE_KEY_INFORMATION;
pub type REG_OPEN_KEY_INFORMATION = _REG_CREATE_KEY_INFORMATION;
pub type PREG_CREATE_KEY_INFORMATION = *mut _REG_CREATE_KEY_INFORMATION;
pub type PREG_OPEN_KEY_INFORMATION = *mut _REG_CREATE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_CREATE_KEY_INFORMATION_V1 {
    pub CompleteName: PUNICODE_STRING,
    pub RootObject: PVOID,
    pub ObjectType: PVOID,
    pub Options: ULONG,
    pub Class: PUNICODE_STRING,
    pub SecurityDescriptor: PVOID,
    pub SecurityQualityOfService: PVOID,
    pub DesiredAccess: ACCESS_MASK,
    pub GrantedAccess: ACCESS_MASK,
    pub Disposition: PULONG,
    pub ResultObject: *mut PVOID,
    pub CallContext: PVOID,
    pub RootObjectContext: PVOID,
    pub Transaction: PVOID,
    pub Version: ULONG_PTR,
    pub RemainingName: PUNICODE_STRING,
    pub Wow64Flags: ULONG,
    pub Attributes: ULONG,
    pub CheckAccessMode: KPROCESSOR_MODE,
}
pub type REG_CREATE_KEY_INFORMATION_V1 = _REG_CREATE_KEY_INFORMATION_V1;
pub type REG_OPEN_KEY_INFORMATION_V1 = _REG_CREATE_KEY_INFORMATION_V1;
pub type PREG_CREATE_KEY_INFORMATION_V1 = *mut _REG_CREATE_KEY_INFORMATION_V1;
pub type PREG_OPEN_KEY_INFORMATION_V1 = *mut _REG_CREATE_KEY_INFORMATION_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_POST_OPERATION_INFORMATION {
    pub Object: PVOID,
    pub Status: NTSTATUS,
    pub PreInformation: PVOID,
    pub ReturnStatus: NTSTATUS,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_POST_OPERATION_INFORMATION = _REG_POST_OPERATION_INFORMATION;
pub type PREG_POST_OPERATION_INFORMATION = *mut _REG_POST_OPERATION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_PRE_CREATE_KEY_INFORMATION {
    pub CompleteName: PUNICODE_STRING,
}
pub type REG_PRE_CREATE_KEY_INFORMATION = _REG_PRE_CREATE_KEY_INFORMATION;
pub type REG_PRE_OPEN_KEY_INFORMATION = _REG_PRE_CREATE_KEY_INFORMATION;
pub type PREG_PRE_CREATE_KEY_INFORMATION = *mut _REG_PRE_CREATE_KEY_INFORMATION;
pub type PREG_PRE_OPEN_KEY_INFORMATION = *mut _REG_PRE_CREATE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_POST_CREATE_KEY_INFORMATION {
    pub CompleteName: PUNICODE_STRING,
    pub Object: PVOID,
    pub Status: NTSTATUS,
}
pub type REG_POST_CREATE_KEY_INFORMATION = _REG_POST_CREATE_KEY_INFORMATION;
pub type REG_POST_OPEN_KEY_INFORMATION = _REG_POST_CREATE_KEY_INFORMATION;
pub type PREG_POST_CREATE_KEY_INFORMATION = *mut _REG_POST_CREATE_KEY_INFORMATION;
pub type PREG_POST_OPEN_KEY_INFORMATION = *mut _REG_POST_CREATE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_LOAD_KEY_INFORMATION {
    pub Object: PVOID,
    pub KeyName: PUNICODE_STRING,
    pub SourceFile: PUNICODE_STRING,
    pub Flags: ULONG,
    pub TrustClassObject: PVOID,
    pub UserEvent: PVOID,
    pub DesiredAccess: ACCESS_MASK,
    pub RootHandle: PHANDLE,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_LOAD_KEY_INFORMATION = _REG_LOAD_KEY_INFORMATION;
pub type PREG_LOAD_KEY_INFORMATION = *mut _REG_LOAD_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_UNLOAD_KEY_INFORMATION {
    pub Object: PVOID,
    pub UserEvent: PVOID,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_UNLOAD_KEY_INFORMATION = _REG_UNLOAD_KEY_INFORMATION;
pub type PREG_UNLOAD_KEY_INFORMATION = *mut _REG_UNLOAD_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_CALLBACK_CONTEXT_CLEANUP_INFORMATION {
    pub Object: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_CALLBACK_CONTEXT_CLEANUP_INFORMATION = _REG_CALLBACK_CONTEXT_CLEANUP_INFORMATION;
pub type PREG_CALLBACK_CONTEXT_CLEANUP_INFORMATION = *mut _REG_CALLBACK_CONTEXT_CLEANUP_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_QUERY_KEY_SECURITY_INFORMATION {
    pub Object: PVOID,
    pub SecurityInformation: PSECURITY_INFORMATION,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
    pub Length: PULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_QUERY_KEY_SECURITY_INFORMATION = _REG_QUERY_KEY_SECURITY_INFORMATION;
pub type PREG_QUERY_KEY_SECURITY_INFORMATION = *mut _REG_QUERY_KEY_SECURITY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_SET_KEY_SECURITY_INFORMATION {
    pub Object: PVOID,
    pub SecurityInformation: PSECURITY_INFORMATION,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_SET_KEY_SECURITY_INFORMATION = _REG_SET_KEY_SECURITY_INFORMATION;
pub type PREG_SET_KEY_SECURITY_INFORMATION = *mut _REG_SET_KEY_SECURITY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_RESTORE_KEY_INFORMATION {
    pub Object: PVOID,
    pub FileHandle: HANDLE,
    pub Flags: ULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_RESTORE_KEY_INFORMATION = _REG_RESTORE_KEY_INFORMATION;
pub type PREG_RESTORE_KEY_INFORMATION = *mut _REG_RESTORE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_SAVE_KEY_INFORMATION {
    pub Object: PVOID,
    pub FileHandle: HANDLE,
    pub Format: ULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_SAVE_KEY_INFORMATION = _REG_SAVE_KEY_INFORMATION;
pub type PREG_SAVE_KEY_INFORMATION = *mut _REG_SAVE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_REPLACE_KEY_INFORMATION {
    pub Object: PVOID,
    pub OldFileName: PUNICODE_STRING,
    pub NewFileName: PUNICODE_STRING,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_REPLACE_KEY_INFORMATION = _REG_REPLACE_KEY_INFORMATION;
pub type PREG_REPLACE_KEY_INFORMATION = *mut _REG_REPLACE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_QUERY_KEY_NAME {
    pub Object: PVOID,
    pub ObjectNameInfo: POBJECT_NAME_INFORMATION,
    pub Length: ULONG,
    pub ReturnLength: PULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_QUERY_KEY_NAME = _REG_QUERY_KEY_NAME;
pub type PREG_QUERY_KEY_NAME = *mut _REG_QUERY_KEY_NAME;
unsafe extern "C" {
    pub fn CmRegisterCallback(
        Function: PEX_CALLBACK_FUNCTION,
        Context: PVOID,
        Cookie: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn CmUnRegisterCallback(Cookie: LARGE_INTEGER) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn CmRegisterCallbackEx(
        Function: PEX_CALLBACK_FUNCTION,
        Altitude: PCUNICODE_STRING,
        Driver: PVOID,
        Context: PVOID,
        Cookie: PLARGE_INTEGER,
        Reserved: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn CmGetCallbackVersion(Major: PULONG, Minor: PULONG);
}
unsafe extern "C" {
    pub fn CmSetCallbackObjectContext(
        Object: PVOID,
        Cookie: PLARGE_INTEGER,
        NewContext: PVOID,
        OldContext: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn CmCallbackGetKeyObjectID(
        Cookie: PLARGE_INTEGER,
        Object: PVOID,
        ObjectID: PULONG_PTR,
        ObjectName: *mut PCUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn CmGetBoundTransaction(Cookie: PLARGE_INTEGER, Object: PVOID) -> PVOID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_LOAD_KEY_INFORMATION_V2 {
    pub Object: PVOID,
    pub KeyName: PUNICODE_STRING,
    pub SourceFile: PUNICODE_STRING,
    pub Flags: ULONG,
    pub TrustClassObject: PVOID,
    pub UserEvent: PVOID,
    pub DesiredAccess: ACCESS_MASK,
    pub RootHandle: PHANDLE,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Version: ULONG_PTR,
    pub FileAccessToken: PVOID,
}
pub type REG_LOAD_KEY_INFORMATION_V2 = _REG_LOAD_KEY_INFORMATION_V2;
pub type PREG_LOAD_KEY_INFORMATION_V2 = *mut _REG_LOAD_KEY_INFORMATION_V2;
unsafe extern "C" {
    pub fn CmCallbackGetKeyObjectIDEx(
        Cookie: PLARGE_INTEGER,
        Object: PVOID,
        ObjectID: PULONG_PTR,
        ObjectName: *mut PCUNICODE_STRING,
        Flags: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn CmCallbackReleaseKeyObjectIDEx(ObjectName: PCUNICODE_STRING);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_SAVE_MERGED_KEY_INFORMATION {
    pub Object: PVOID,
    pub FileHandle: HANDLE,
    pub HighKeyObject: PVOID,
    pub LowKeyObject: PVOID,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_SAVE_MERGED_KEY_INFORMATION = _REG_SAVE_MERGED_KEY_INFORMATION;
pub type PREG_SAVE_MERGED_KEY_INFORMATION = *mut _REG_SAVE_MERGED_KEY_INFORMATION;
unsafe extern "C" {
    pub static mut Mm64BitPhysicalAddress: PBOOLEAN;
}
unsafe extern "C" {
    pub static mut MmBadPointer: PVOID;
}
pub const _MM_SYSTEM_SIZE_MmSmallSystem: _MM_SYSTEM_SIZE = 0;
pub const _MM_SYSTEM_SIZE_MmMediumSystem: _MM_SYSTEM_SIZE = 1;
pub const _MM_SYSTEM_SIZE_MmLargeSystem: _MM_SYSTEM_SIZE = 2;
pub type _MM_SYSTEM_SIZE = core::ffi::c_int;
pub use self::_MM_SYSTEM_SIZE as MM_SYSTEMSIZE;
unsafe extern "C" {
    pub fn MmQuerySystemSize() -> MM_SYSTEMSIZE;
}
unsafe extern "C" {
    pub fn MmIsVerifierEnabled(VerifierFlags: PULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmAddVerifierThunks(ThunkBuffer: PVOID, ThunkBufferSize: ULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmAddVerifierSpecialThunks(
        EntryRoutine: ULONG_PTR,
        ThunkBuffer: PVOID,
        ThunkBufferSize: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmProbeAndLockSelectedPages(
        MemoryDescriptorList: PMDL,
        SegmentArray: PFILE_SEGMENT_ELEMENT,
        AccessMode: KPROCESSOR_MODE,
        Operation: LOCK_OPERATION,
    );
}
unsafe extern "C" {
    pub fn MmProbeAndLockProcessPages(
        MemoryDescriptorList: PMDL,
        Process: PEPROCESS,
        AccessMode: KPROCESSOR_MODE,
        Operation: LOCK_OPERATION,
    );
}
unsafe extern "C" {
    pub fn MmProbeAndLockPages(
        MemoryDescriptorList: PMDL,
        AccessMode: KPROCESSOR_MODE,
        Operation: LOCK_OPERATION,
    );
}
unsafe extern "C" {
    pub fn MmUnlockPages(MemoryDescriptorList: PMDL);
}
unsafe extern "C" {
    pub fn MmBuildMdlForNonPagedPool(MemoryDescriptorList: PMDL);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MM_PHYSICAL_ADDRESS_LIST {
    pub PhysicalAddress: PHYSICAL_ADDRESS,
    pub NumberOfBytes: SIZE_T,
}
pub type MM_PHYSICAL_ADDRESS_LIST = _MM_PHYSICAL_ADDRESS_LIST;
pub type PMM_PHYSICAL_ADDRESS_LIST = *mut _MM_PHYSICAL_ADDRESS_LIST;
unsafe extern "C" {
    pub fn MmAllocateMdlForIoSpace(
        PhysicalAddressList: PMM_PHYSICAL_ADDRESS_LIST,
        NumberOfEntries: SIZE_T,
        NewMdl: *mut PMDL,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmAreMdlPagesCached(MemoryDescriptorList: PMDL) -> LOGICAL;
}
unsafe extern "C" {
    pub fn MmSetPermanentCacheAttribute(
        StartAddress: PHYSICAL_ADDRESS,
        NumberOfBytes: LARGE_INTEGER,
        CacheType: MEMORY_CACHING_TYPE,
        Flags: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmMapLockedPages(MemoryDescriptorList: PMDL, AccessMode: KPROCESSOR_MODE) -> PVOID;
}
pub type MM_MDL_ROUTINE =
::core::option::Option<unsafe extern "C" fn(DriverContext: PVOID, MappedVa: PVOID)>;
pub type PMM_MDL_ROUTINE = MM_MDL_ROUTINE;
unsafe extern "C" {
    pub fn MmMapMdl(
        MemoryDescriptorList: PMDL,
        Protection: ULONG,
        DriverRoutine: PMM_MDL_ROUTINE,
        DriverContext: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmMapMemoryDumpMdlEx(
        Va: PVOID,
        PageTotal: PFN_NUMBER,
        MemoryDumpMdl: PMDL,
        Flags: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmIsIoSpaceActive(StartAddress: PHYSICAL_ADDRESS, NumberOfBytes: SIZE_T) -> LOGICAL;
}
pub type PMM_GET_SYSTEM_ROUTINE_ADDRESS_EX = ::core::option::Option<
    unsafe extern "C" fn(ModuleName: PUNICODE_STRING, FunctionName: PSTR) -> PVOID,
>;
unsafe extern "C" {
    pub fn MmAdvanceMdl(Mdl: PMDL, NumberOfBytes: ULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmProtectMdlSystemAddress(MemoryDescriptorList: PMDL, NewProtect: ULONG) -> NTSTATUS;
}
pub const _MM_PAGE_PRIORITY_LowPagePriority: _MM_PAGE_PRIORITY = 0;
pub const _MM_PAGE_PRIORITY_NormalPagePriority: _MM_PAGE_PRIORITY = 16;
pub const _MM_PAGE_PRIORITY_HighPagePriority: _MM_PAGE_PRIORITY = 32;
pub type _MM_PAGE_PRIORITY = core::ffi::c_int;
pub use self::_MM_PAGE_PRIORITY as MM_PAGE_PRIORITY;
unsafe extern "C" {
    pub fn MmMapLockedPagesSpecifyCache(
        MemoryDescriptorList: PMDL,
        AccessMode: KPROCESSOR_MODE,
        CacheType: MEMORY_CACHING_TYPE,
        RequestedAddress: PVOID,
        BugCheckOnFailure: ULONG,
        Priority: ULONG,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn MmUnmapLockedPages(BaseAddress: PVOID, MemoryDescriptorList: PMDL);
}
unsafe extern "C" {
    pub fn MmAllocateMappingAddressEx(NumberOfBytes: SIZE_T, PoolTag: ULONG, Flags: ULONG)
                                      -> PVOID;
}
unsafe extern "C" {
    pub fn MmAllocateMappingAddress(NumberOfBytes: SIZE_T, PoolTag: ULONG) -> PVOID;
}
unsafe extern "C" {
    pub fn MmFreeMappingAddress(BaseAddress: PVOID, PoolTag: ULONG);
}
unsafe extern "C" {
    pub fn MmMapLockedPagesWithReservedMapping(
        MappingAddress: PVOID,
        PoolTag: ULONG,
        MemoryDescriptorList: PMDL,
        CacheType: MEMORY_CACHING_TYPE,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn MmUnmapReservedMapping(BaseAddress: PVOID, PoolTag: ULONG, MemoryDescriptorList: PMDL);
}
unsafe extern "C" {
    pub fn MmAllocateNodePagesForMdlEx(
        LowAddress: PHYSICAL_ADDRESS,
        HighAddress: PHYSICAL_ADDRESS,
        SkipBytes: PHYSICAL_ADDRESS,
        TotalBytes: SIZE_T,
        CacheType: MEMORY_CACHING_TYPE,
        IdealNode: ULONG,
        Flags: ULONG,
    ) -> PMDL;
}
pub type MM_NODE_NUMBER_ZERO_BASED = ULONG;
pub type MM_NODE_NUMBER_ONE_BASED = ULONG;
unsafe extern "C" {
    pub fn MmAllocatePartitionNodePagesForMdlEx(
        LowAddress: PHYSICAL_ADDRESS,
        HighAddress: PHYSICAL_ADDRESS,
        SkipBytes: PHYSICAL_ADDRESS,
        TotalBytes: SIZE_T,
        CacheType: MEMORY_CACHING_TYPE,
        IdealNode: MM_NODE_NUMBER_ZERO_BASED,
        Flags: ULONG,
        PartitionObject: PVOID,
    ) -> PMDL;
}
unsafe extern "C" {
    pub fn MmAllocatePagesForMdlEx(
        LowAddress: PHYSICAL_ADDRESS,
        HighAddress: PHYSICAL_ADDRESS,
        SkipBytes: PHYSICAL_ADDRESS,
        TotalBytes: SIZE_T,
        CacheType: MEMORY_CACHING_TYPE,
        Flags: ULONG,
    ) -> PMDL;
}
unsafe extern "C" {
    pub fn MmAllocatePagesForMdl(
        LowAddress: PHYSICAL_ADDRESS,
        HighAddress: PHYSICAL_ADDRESS,
        SkipBytes: PHYSICAL_ADDRESS,
        TotalBytes: SIZE_T,
    ) -> PMDL;
}
unsafe extern "C" {
    pub fn MmFreePagesFromMdlEx(MemoryDescriptorList: PMDL, Flags: ULONG);
}
unsafe extern "C" {
    pub fn MmFreePagesFromMdl(MemoryDescriptorList: PMDL);
}
unsafe extern "C" {
    pub fn MmMapIoSpace(
        PhysicalAddress: PHYSICAL_ADDRESS,
        NumberOfBytes: SIZE_T,
        CacheType: MEMORY_CACHING_TYPE,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn MmUnmapIoSpace(BaseAddress: PVOID, NumberOfBytes: SIZE_T);
}
unsafe extern "C" {
    pub fn MmMapIoSpaceEx(
        PhysicalAddress: PHYSICAL_ADDRESS,
        NumberOfBytes: SIZE_T,
        Protect: ULONG,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn MmAllocateContiguousMemory(
        NumberOfBytes: SIZE_T,
        HighestAcceptableAddress: PHYSICAL_ADDRESS,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn MmAllocateContiguousMemorySpecifyCache(
        NumberOfBytes: SIZE_T,
        LowestAcceptableAddress: PHYSICAL_ADDRESS,
        HighestAcceptableAddress: PHYSICAL_ADDRESS,
        BoundaryAddressMultiple: PHYSICAL_ADDRESS,
        CacheType: MEMORY_CACHING_TYPE,
    ) -> PVOID;
}
pub type NODE_REQUIREMENT = ULONG;
unsafe extern "C" {
    pub fn MmAllocateContiguousMemorySpecifyCacheNode(
        NumberOfBytes: SIZE_T,
        LowestAcceptableAddress: PHYSICAL_ADDRESS,
        HighestAcceptableAddress: PHYSICAL_ADDRESS,
        BoundaryAddressMultiple: PHYSICAL_ADDRESS,
        CacheType: MEMORY_CACHING_TYPE,
        PreferredNode: NODE_REQUIREMENT,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn MmAllocateContiguousNodeMemory(
        NumberOfBytes: SIZE_T,
        LowestAcceptableAddress: PHYSICAL_ADDRESS,
        HighestAcceptableAddress: PHYSICAL_ADDRESS,
        BoundaryAddressMultiple: PHYSICAL_ADDRESS,
        Protect: ULONG,
        PreferredNode: NODE_REQUIREMENT,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn MmAllocateContiguousMemoryEx(
        NumberOfBytes: PSIZE_T,
        LowestAcceptableAddress: PHYSICAL_ADDRESS,
        HighestAcceptableAddress: PHYSICAL_ADDRESS,
        BoundaryAddressMultiple: PHYSICAL_ADDRESS,
        PreferredNode: NODE_REQUIREMENT,
        Protect: ULONG,
        PartitionObject: PVOID,
        Tag: ULONG,
        Flags: ULONG,
        BaseAddress: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmFreeContiguousMemory(BaseAddress: PVOID);
}
unsafe extern "C" {
    pub fn MmFreeContiguousMemorySpecifyCache(
        BaseAddress: PVOID,
        NumberOfBytes: SIZE_T,
        CacheType: MEMORY_CACHING_TYPE,
    );
}
unsafe extern "C" {
    pub fn MmSizeOfMdl(Base: PVOID, Length: SIZE_T) -> SIZE_T;
}
unsafe extern "C" {
    pub fn MmCreateMdl(MemoryDescriptorList: PMDL, Base: PVOID, Length: SIZE_T) -> PMDL;
}
pub const _MM_MDL_PAGE_CONTENTS_STATE_MmMdlPageContentsDynamic: _MM_MDL_PAGE_CONTENTS_STATE = 0;
pub const _MM_MDL_PAGE_CONTENTS_STATE_MmMdlPageContentsInvariant: _MM_MDL_PAGE_CONTENTS_STATE = 1;
pub const _MM_MDL_PAGE_CONTENTS_STATE_MmMdlPageContentsQuery: _MM_MDL_PAGE_CONTENTS_STATE = 2;
pub type _MM_MDL_PAGE_CONTENTS_STATE = core::ffi::c_int;
pub use self::_MM_MDL_PAGE_CONTENTS_STATE as MM_MDL_PAGE_CONTENTS_STATE;
pub use self::_MM_MDL_PAGE_CONTENTS_STATE as PMM_MDL_PAGE_CONTENTS_STATE;
unsafe extern "C" {
    pub fn MmMdlPageContentsState(
        MemoryDescriptorList: PMDL,
        State: MM_MDL_PAGE_CONTENTS_STATE,
    ) -> MM_MDL_PAGE_CONTENTS_STATE;
}
unsafe extern "C" {
    pub fn MmLockPagableDataSection(AddressWithinSection: PVOID) -> PVOID;
}
unsafe extern "C" {
    pub fn MmResetDriverPaging(AddressWithinSection: PVOID);
}
unsafe extern "C" {
    pub fn MmPageEntireDriver(AddressWithinSection: PVOID) -> PVOID;
}
unsafe extern "C" {
    pub fn MmUnlockPagableImageSection(ImageSectionHandle: PVOID);
}
pub type PMM_DLL_INITIALIZE =
::core::option::Option<unsafe extern "C" fn(RegistryPath: PUNICODE_STRING) -> NTSTATUS>;
pub type PMM_DLL_UNLOAD = ::core::option::Option<unsafe extern "C" fn() -> NTSTATUS>;
unsafe extern "C" {
    pub fn MmIsDriverSuspectForVerifier(DriverObject: *mut _DRIVER_OBJECT) -> LOGICAL;
}
unsafe extern "C" {
    pub fn MmIsDriverVerifying(DriverObject: *mut _DRIVER_OBJECT) -> LOGICAL;
}
unsafe extern "C" {
    pub fn MmIsDriverVerifyingByAddress(AddressWithinSection: PVOID) -> LOGICAL;
}
unsafe extern "C" {
    pub fn MmProtectDriverSection(
        AddressWithinSection: PVOID,
        Size: SIZE_T,
        Flags: ULONG,
    ) -> NTSTATUS;
}
pub const _SECURITY_OPERATION_CODE_SetSecurityDescriptor: _SECURITY_OPERATION_CODE = 0;
pub const _SECURITY_OPERATION_CODE_QuerySecurityDescriptor: _SECURITY_OPERATION_CODE = 1;
pub const _SECURITY_OPERATION_CODE_DeleteSecurityDescriptor: _SECURITY_OPERATION_CODE = 2;
pub const _SECURITY_OPERATION_CODE_AssignSecurityDescriptor: _SECURITY_OPERATION_CODE = 3;
pub type _SECURITY_OPERATION_CODE = core::ffi::c_int;
pub use self::_SECURITY_OPERATION_CODE as SECURITY_OPERATION_CODE;
pub type PSECURITY_OPERATION_CODE = *mut _SECURITY_OPERATION_CODE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_SUBJECT_CONTEXT {
    pub ClientToken: PACCESS_TOKEN,
    pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    pub PrimaryToken: PACCESS_TOKEN,
    pub ProcessAuditId: PVOID,
}
pub type SECURITY_SUBJECT_CONTEXT = _SECURITY_SUBJECT_CONTEXT;
pub type PSECURITY_SUBJECT_CONTEXT = *mut _SECURITY_SUBJECT_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _INITIAL_PRIVILEGE_SET {
    pub PrivilegeCount: ULONG,
    pub Control: ULONG,
    pub Privilege: [LUID_AND_ATTRIBUTES; 3usize],
}
pub type INITIAL_PRIVILEGE_SET = _INITIAL_PRIVILEGE_SET;
pub type PINITIAL_PRIVILEGE_SET = *mut _INITIAL_PRIVILEGE_SET;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ACCESS_STATE {
    pub OperationID: LUID,
    pub SecurityEvaluated: BOOLEAN,
    pub GenerateAudit: BOOLEAN,
    pub GenerateOnClose: BOOLEAN,
    pub PrivilegesAllocated: BOOLEAN,
    pub Flags: ULONG,
    pub RemainingDesiredAccess: ACCESS_MASK,
    pub PreviouslyGrantedAccess: ACCESS_MASK,
    pub OriginalDesiredAccess: ACCESS_MASK,
    pub SubjectSecurityContext: SECURITY_SUBJECT_CONTEXT,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
    pub AuxData: PVOID,
    pub Privileges: _ACCESS_STATE__bindgen_ty_1,
    pub AuditPrivileges: BOOLEAN,
    pub ObjectName: UNICODE_STRING,
    pub ObjectTypeName: UNICODE_STRING,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ACCESS_STATE__bindgen_ty_1 {
    pub InitialPrivilegeSet: INITIAL_PRIVILEGE_SET,
    pub PrivilegeSet: PRIVILEGE_SET,
}
pub type ACCESS_STATE = _ACCESS_STATE;
pub type NTFS_DEREF_EXPORTED_SECURITY_DESCRIPTOR = ::core::option::Option<
    unsafe extern "C" fn(Vcb: PVOID, SecurityDescriptor: PSECURITY_DESCRIPTOR),
>;
pub type PNTFS_DEREF_EXPORTED_SECURITY_DESCRIPTOR = NTFS_DEREF_EXPORTED_SECURITY_DESCRIPTOR;
unsafe extern "C" {
    pub fn SeCaptureSubjectContext(SubjectContext: PSECURITY_SUBJECT_CONTEXT);
}
unsafe extern "C" {
    pub fn SeLockSubjectContext(SubjectContext: PSECURITY_SUBJECT_CONTEXT);
}
unsafe extern "C" {
    pub fn SeUnlockSubjectContext(SubjectContext: PSECURITY_SUBJECT_CONTEXT);
}
unsafe extern "C" {
    pub fn SeReleaseSubjectContext(SubjectContext: PSECURITY_SUBJECT_CONTEXT);
}
unsafe extern "C" {
    pub fn SeAssignSecurity(
        ParentDescriptor: PSECURITY_DESCRIPTOR,
        ExplicitDescriptor: PSECURITY_DESCRIPTOR,
        NewDescriptor: *mut PSECURITY_DESCRIPTOR,
        IsDirectoryObject: BOOLEAN,
        SubjectContext: PSECURITY_SUBJECT_CONTEXT,
        GenericMapping: PGENERIC_MAPPING,
        PoolType: POOL_TYPE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeComputeAutoInheritByObjectType(
        ObjectType: PVOID,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        ParentSecurityDescriptor: PSECURITY_DESCRIPTOR,
    ) -> ULONG;
}
unsafe extern "C" {
    pub fn SeAssignSecurityEx(
        ParentDescriptor: PSECURITY_DESCRIPTOR,
        ExplicitDescriptor: PSECURITY_DESCRIPTOR,
        NewDescriptor: *mut PSECURITY_DESCRIPTOR,
        ObjectType: *mut GUID,
        IsDirectoryObject: BOOLEAN,
        AutoInheritFlags: ULONG,
        SubjectContext: PSECURITY_SUBJECT_CONTEXT,
        GenericMapping: PGENERIC_MAPPING,
        PoolType: POOL_TYPE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeDeassignSecurity(SecurityDescriptor: *mut PSECURITY_DESCRIPTOR) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeObjectCreateSaclAccessBits(SecurityDescriptor: PSECURITY_DESCRIPTOR) -> ULONG;
}
unsafe extern "C" {
    pub fn SeAccessCheck(
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        SubjectSecurityContext: PSECURITY_SUBJECT_CONTEXT,
        SubjectContextLocked: BOOLEAN,
        DesiredAccess: ACCESS_MASK,
        PreviouslyGrantedAccess: ACCESS_MASK,
        Privileges: *mut PPRIVILEGE_SET,
        GenericMapping: PGENERIC_MAPPING,
        AccessMode: KPROCESSOR_MODE,
        GrantedAccess: PACCESS_MASK,
        AccessStatus: PNTSTATUS,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn SeSetAuditParameter(
        AuditParameters: PSE_ADT_PARAMETER_ARRAY,
        Type: SE_ADT_PARAMETER_TYPE,
        Index: ULONG,
        Data: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeReportSecurityEvent(
        Flags: ULONG,
        SourceName: PUNICODE_STRING,
        UserSid: PSID,
        AuditParameters: PSE_ADT_PARAMETER_ARRAY,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeValidSecurityDescriptor(
        Length: ULONG,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
    ) -> BOOLEAN;
}
pub const _SE_IMAGE_TYPE_SeImageTypeElamDriver: _SE_IMAGE_TYPE = 0;
pub const _SE_IMAGE_TYPE_SeImageTypeDriver: _SE_IMAGE_TYPE = 1;
pub const _SE_IMAGE_TYPE_SeImageTypePlatformSecureFile: _SE_IMAGE_TYPE = 2;
pub const _SE_IMAGE_TYPE_SeImageTypeDynamicCodeFile: _SE_IMAGE_TYPE = 3;
pub const _SE_IMAGE_TYPE_SeImageTypeMax: _SE_IMAGE_TYPE = 4;
pub type _SE_IMAGE_TYPE = core::ffi::c_int;
pub use self::_SE_IMAGE_TYPE as SE_IMAGE_TYPE;
pub type PSE_IMAGE_TYPE = *mut _SE_IMAGE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BDCB_IMAGE_INFORMATION {
    _unused: [u8; 0],
}
pub type PBDCB_IMAGE_INFORMATION = *mut _BDCB_IMAGE_INFORMATION;
pub type SE_IMAGE_VERIFICATION_CALLBACK_FUNCTION = ::core::option::Option<
    unsafe extern "C" fn(
        CallbackContext: PVOID,
        ImageType: SE_IMAGE_TYPE,
        ImageInformation: PBDCB_IMAGE_INFORMATION,
    ),
>;
pub type PSE_IMAGE_VERIFICATION_CALLBACK_FUNCTION = SE_IMAGE_VERIFICATION_CALLBACK_FUNCTION;
pub const _SE_IMAGE_VERIFICATION_CALLBACK_TYPE_SeImageVerificationCallbackInformational:
_SE_IMAGE_VERIFICATION_CALLBACK_TYPE = 0;
pub type _SE_IMAGE_VERIFICATION_CALLBACK_TYPE = core::ffi::c_int;
pub use self::_SE_IMAGE_VERIFICATION_CALLBACK_TYPE as SE_IMAGE_VERIFICATION_CALLBACK_TYPE;
pub type PSE_IMAGE_VERIFICATION_CALLBACK_TYPE = *mut _SE_IMAGE_VERIFICATION_CALLBACK_TYPE;
pub type SE_IMAGE_VERIFICATION_CALLBACK_TOKEN = PVOID;
pub type PSE_IMAGE_VERIFICATION_CALLBACK_TOKEN = *mut PVOID;
unsafe extern "C" {
    pub fn SeRegisterImageVerificationCallback(
        ImageType: SE_IMAGE_TYPE,
        CallbackType: SE_IMAGE_VERIFICATION_CALLBACK_TYPE,
        CallbackFunction: PSE_IMAGE_VERIFICATION_CALLBACK_FUNCTION,
        CallbackContext: PVOID,
        Token: SE_IMAGE_VERIFICATION_CALLBACK_TOKEN,
        CallbackHandle: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeUnregisterImageVerificationCallback(CallbackHandle: PVOID);
}
unsafe extern "C" {
    pub fn PsCreateSystemThread(
        ThreadHandle: PHANDLE,
        DesiredAccess: ULONG,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        ProcessHandle: HANDLE,
        ClientId: PCLIENT_ID,
        StartRoutine: PKSTART_ROUTINE,
        StartContext: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsTerminateSystemThread(ExitStatus: NTSTATUS) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsWrapApcWow64Thread(ApcContext: *mut PVOID, ApcRoutine: *mut PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsGetVersion(
        MajorVersion: PULONG,
        MinorVersion: PULONG,
        BuildNumber: PULONG,
        CSDVersion: PUNICODE_STRING,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn PsQueryTotalCycleTimeProcess(Process: PEPROCESS, CycleTimeStamp: PULONG64) -> ULONG64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AFFINITY_TOKEN {
    _unused: [u8; 0],
}
pub type PAFFINITY_TOKEN = *mut _AFFINITY_TOKEN;
unsafe extern "C" {
    pub fn PsAllocateAffinityToken(AffinityToken: *mut PAFFINITY_TOKEN) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsFreeAffinityToken(AffinityToken: PAFFINITY_TOKEN);
}
unsafe extern "C" {
    pub fn PsSetSystemMultipleGroupAffinityThread(
        GroupAffinities: PGROUP_AFFINITY,
        GroupCount: USHORT,
        AffinityToken: PAFFINITY_TOKEN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsRevertToUserMultipleGroupAffinityThread(AffinityToken: PAFFINITY_TOKEN);
}
pub const _CREATE_FILE_TYPE_CreateFileTypeNone: _CREATE_FILE_TYPE = 0;
pub const _CREATE_FILE_TYPE_CreateFileTypeNamedPipe: _CREATE_FILE_TYPE = 1;
pub const _CREATE_FILE_TYPE_CreateFileTypeMailslot: _CREATE_FILE_TYPE = 2;
pub type _CREATE_FILE_TYPE = core::ffi::c_int;
pub use self::_CREATE_FILE_TYPE as CREATE_FILE_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NAMED_PIPE_CREATE_PARAMETERS {
    pub NamedPipeType: ULONG,
    pub ReadMode: ULONG,
    pub CompletionMode: ULONG,
    pub MaximumInstances: ULONG,
    pub InboundQuota: ULONG,
    pub OutboundQuota: ULONG,
    pub DefaultTimeout: LARGE_INTEGER,
    pub TimeoutSpecified: BOOLEAN,
}
pub type NAMED_PIPE_CREATE_PARAMETERS = _NAMED_PIPE_CREATE_PARAMETERS;
pub type PNAMED_PIPE_CREATE_PARAMETERS = *mut _NAMED_PIPE_CREATE_PARAMETERS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MAILSLOT_CREATE_PARAMETERS {
    pub MailslotQuota: ULONG,
    pub MaximumMessageSize: ULONG,
    pub ReadTimeout: LARGE_INTEGER,
    pub TimeoutSpecified: BOOLEAN,
}
pub type MAILSLOT_CREATE_PARAMETERS = _MAILSLOT_CREATE_PARAMETERS;
pub type PMAILSLOT_CREATE_PARAMETERS = *mut _MAILSLOT_CREATE_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVE_LAYOUT_INFORMATION {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISK_PARTITION {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCSI_REQUEST_BLOCK {
    _unused: [u8; 0],
}
pub type IO_DPC_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(
        Dpc: PKDPC,
        DeviceObject: *mut _DEVICE_OBJECT,
        Irp: *mut _IRP,
        Context: PVOID,
    ),
>;
pub type PIO_DPC_ROUTINE = IO_DPC_ROUTINE;
pub type IO_TIMER_ROUTINE =
::core::option::Option<unsafe extern "C" fn(DeviceObject: *mut _DEVICE_OBJECT, Context: PVOID)>;
pub type PIO_TIMER_ROUTINE = IO_TIMER_ROUTINE;
pub type DRIVER_INITIALIZE = ::core::option::Option<
    unsafe extern "C" fn(
        DriverObject: *mut _DRIVER_OBJECT,
        RegistryPath: PUNICODE_STRING,
    ) -> NTSTATUS,
>;
pub type PDRIVER_INITIALIZE = DRIVER_INITIALIZE;
pub type DRIVER_CANCEL =
::core::option::Option<unsafe extern "C" fn(DeviceObject: *mut _DEVICE_OBJECT, Irp: *mut _IRP)>;
pub type PDRIVER_CANCEL = DRIVER_CANCEL;
pub type DRIVER_DISPATCH = ::core::option::Option<
    unsafe extern "C" fn(DeviceObject: *mut _DEVICE_OBJECT, Irp: *mut _IRP) -> NTSTATUS,
>;
pub type PDRIVER_DISPATCH = DRIVER_DISPATCH;
pub type DRIVER_DISPATCH_RAISED = DRIVER_DISPATCH;
pub type DRIVER_DISPATCH_PAGED = ::core::option::Option<
    unsafe extern "C" fn(DeviceObject: *mut _DEVICE_OBJECT, Irp: *mut _IRP) -> NTSTATUS,
>;
pub type PDRIVER_DISPATCH_PAGED = DRIVER_DISPATCH_PAGED;
pub type DRIVER_STARTIO =
::core::option::Option<unsafe extern "C" fn(DeviceObject: *mut _DEVICE_OBJECT, Irp: *mut _IRP)>;
pub type PDRIVER_STARTIO = DRIVER_STARTIO;
pub type DRIVER_UNLOAD =
::core::option::Option<unsafe extern "C" fn(DriverObject: *mut _DRIVER_OBJECT)>;
pub type PDRIVER_UNLOAD = DRIVER_UNLOAD;
pub type DRIVER_ADD_DEVICE = ::core::option::Option<
    unsafe extern "C" fn(
        DriverObject: *mut _DRIVER_OBJECT,
        PhysicalDeviceObject: *mut _DEVICE_OBJECT,
    ) -> NTSTATUS,
>;
pub type PDRIVER_ADD_DEVICE = DRIVER_ADD_DEVICE;
pub type FAST_IO_CHECK_IF_POSSIBLE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        Wait: BOOLEAN,
        LockKey: ULONG,
        CheckForReadOperation: BOOLEAN,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_CHECK_IF_POSSIBLE = FAST_IO_CHECK_IF_POSSIBLE;
pub type FAST_IO_READ = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        Wait: BOOLEAN,
        LockKey: ULONG,
        Buffer: PVOID,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_READ = FAST_IO_READ;
pub type FAST_IO_WRITE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        Wait: BOOLEAN,
        LockKey: ULONG,
        Buffer: PVOID,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_WRITE = FAST_IO_WRITE;
pub type FAST_IO_QUERY_BASIC_INFO = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        Wait: BOOLEAN,
        Buffer: PFILE_BASIC_INFORMATION,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_QUERY_BASIC_INFO = FAST_IO_QUERY_BASIC_INFO;
pub type FAST_IO_QUERY_STANDARD_INFO = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        Wait: BOOLEAN,
        Buffer: PFILE_STANDARD_INFORMATION,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_QUERY_STANDARD_INFO = FAST_IO_QUERY_STANDARD_INFO;
pub type FAST_IO_LOCK = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: PLARGE_INTEGER,
        ProcessId: PEPROCESS,
        Key: ULONG,
        FailImmediately: BOOLEAN,
        ExclusiveLock: BOOLEAN,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_LOCK = FAST_IO_LOCK;
pub type FAST_IO_UNLOCK_SINGLE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: PLARGE_INTEGER,
        ProcessId: PEPROCESS,
        Key: ULONG,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_UNLOCK_SINGLE = FAST_IO_UNLOCK_SINGLE;
pub type FAST_IO_UNLOCK_ALL = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        ProcessId: PEPROCESS,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_UNLOCK_ALL = FAST_IO_UNLOCK_ALL;
pub type FAST_IO_UNLOCK_ALL_BY_KEY = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        ProcessId: PVOID,
        Key: ULONG,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_UNLOCK_ALL_BY_KEY = FAST_IO_UNLOCK_ALL_BY_KEY;
pub type FAST_IO_DEVICE_CONTROL = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        Wait: BOOLEAN,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
        IoControlCode: ULONG,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_DEVICE_CONTROL = FAST_IO_DEVICE_CONTROL;
pub type FAST_IO_ACQUIRE_FILE =
::core::option::Option<unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT)>;
pub type PFAST_IO_ACQUIRE_FILE = FAST_IO_ACQUIRE_FILE;
pub type FAST_IO_RELEASE_FILE =
::core::option::Option<unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT)>;
pub type PFAST_IO_RELEASE_FILE = FAST_IO_RELEASE_FILE;
pub type FAST_IO_DETACH_DEVICE = ::core::option::Option<
    unsafe extern "C" fn(SourceDevice: *mut _DEVICE_OBJECT, TargetDevice: *mut _DEVICE_OBJECT),
>;
pub type PFAST_IO_DETACH_DEVICE = FAST_IO_DETACH_DEVICE;
pub type FAST_IO_QUERY_NETWORK_OPEN_INFO = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        Wait: BOOLEAN,
        Buffer: *mut _FILE_NETWORK_OPEN_INFORMATION,
        IoStatus: *mut _IO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_QUERY_NETWORK_OPEN_INFO = FAST_IO_QUERY_NETWORK_OPEN_INFO;
pub type FAST_IO_MDL_READ = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        LockKey: ULONG,
        MdlChain: *mut PMDL,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_MDL_READ = FAST_IO_MDL_READ;
pub type FAST_IO_MDL_READ_COMPLETE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        MdlChain: PMDL,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_MDL_READ_COMPLETE = FAST_IO_MDL_READ_COMPLETE;
pub type FAST_IO_PREPARE_MDL_WRITE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        LockKey: ULONG,
        MdlChain: *mut PMDL,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_PREPARE_MDL_WRITE = FAST_IO_PREPARE_MDL_WRITE;
pub type FAST_IO_MDL_WRITE_COMPLETE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        MdlChain: PMDL,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_MDL_WRITE_COMPLETE = FAST_IO_MDL_WRITE_COMPLETE;
pub type FAST_IO_ACQUIRE_FOR_MOD_WRITE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        EndingOffset: PLARGE_INTEGER,
        ResourceToRelease: *mut *mut _ERESOURCE,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> NTSTATUS,
>;
pub type PFAST_IO_ACQUIRE_FOR_MOD_WRITE = FAST_IO_ACQUIRE_FOR_MOD_WRITE;
pub type FAST_IO_RELEASE_FOR_MOD_WRITE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        ResourceToRelease: *mut _ERESOURCE,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> NTSTATUS,
>;
pub type PFAST_IO_RELEASE_FOR_MOD_WRITE = FAST_IO_RELEASE_FOR_MOD_WRITE;
pub type FAST_IO_ACQUIRE_FOR_CCFLUSH = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> NTSTATUS,
>;
pub type PFAST_IO_ACQUIRE_FOR_CCFLUSH = FAST_IO_ACQUIRE_FOR_CCFLUSH;
pub type FAST_IO_RELEASE_FOR_CCFLUSH = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> NTSTATUS,
>;
pub type PFAST_IO_RELEASE_FOR_CCFLUSH = FAST_IO_RELEASE_FOR_CCFLUSH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _COMPRESSED_DATA_INFO {
    _unused: [u8; 0],
}
pub type FAST_IO_READ_COMPRESSED = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        LockKey: ULONG,
        Buffer: PVOID,
        MdlChain: *mut PMDL,
        IoStatus: PIO_STATUS_BLOCK,
        CompressedDataInfo: *mut _COMPRESSED_DATA_INFO,
        CompressedDataInfoLength: ULONG,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_READ_COMPRESSED = FAST_IO_READ_COMPRESSED;
pub type FAST_IO_WRITE_COMPRESSED = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        LockKey: ULONG,
        Buffer: PVOID,
        MdlChain: *mut PMDL,
        IoStatus: PIO_STATUS_BLOCK,
        CompressedDataInfo: *mut _COMPRESSED_DATA_INFO,
        CompressedDataInfoLength: ULONG,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_WRITE_COMPRESSED = FAST_IO_WRITE_COMPRESSED;
pub type FAST_IO_MDL_READ_COMPLETE_COMPRESSED = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        MdlChain: PMDL,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_MDL_READ_COMPLETE_COMPRESSED = FAST_IO_MDL_READ_COMPLETE_COMPRESSED;
pub type FAST_IO_MDL_WRITE_COMPLETE_COMPRESSED = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        MdlChain: PMDL,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED = FAST_IO_MDL_WRITE_COMPLETE_COMPRESSED;
pub type FAST_IO_QUERY_OPEN = ::core::option::Option<
    unsafe extern "C" fn(
        Irp: *mut _IRP,
        NetworkInformation: PFILE_NETWORK_OPEN_INFORMATION,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_QUERY_OPEN = FAST_IO_QUERY_OPEN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FAST_IO_DISPATCH {
    pub SizeOfFastIoDispatch: ULONG,
    pub FastIoCheckIfPossible: PFAST_IO_CHECK_IF_POSSIBLE,
    pub FastIoRead: PFAST_IO_READ,
    pub FastIoWrite: PFAST_IO_WRITE,
    pub FastIoQueryBasicInfo: PFAST_IO_QUERY_BASIC_INFO,
    pub FastIoQueryStandardInfo: PFAST_IO_QUERY_STANDARD_INFO,
    pub FastIoLock: PFAST_IO_LOCK,
    pub FastIoUnlockSingle: PFAST_IO_UNLOCK_SINGLE,
    pub FastIoUnlockAll: PFAST_IO_UNLOCK_ALL,
    pub FastIoUnlockAllByKey: PFAST_IO_UNLOCK_ALL_BY_KEY,
    pub FastIoDeviceControl: PFAST_IO_DEVICE_CONTROL,
    pub AcquireFileForNtCreateSection: PFAST_IO_ACQUIRE_FILE,
    pub ReleaseFileForNtCreateSection: PFAST_IO_RELEASE_FILE,
    pub FastIoDetachDevice: PFAST_IO_DETACH_DEVICE,
    pub FastIoQueryNetworkOpenInfo: PFAST_IO_QUERY_NETWORK_OPEN_INFO,
    pub AcquireForModWrite: PFAST_IO_ACQUIRE_FOR_MOD_WRITE,
    pub MdlRead: PFAST_IO_MDL_READ,
    pub MdlReadComplete: PFAST_IO_MDL_READ_COMPLETE,
    pub PrepareMdlWrite: PFAST_IO_PREPARE_MDL_WRITE,
    pub MdlWriteComplete: PFAST_IO_MDL_WRITE_COMPLETE,
    pub FastIoReadCompressed: PFAST_IO_READ_COMPRESSED,
    pub FastIoWriteCompressed: PFAST_IO_WRITE_COMPRESSED,
    pub MdlReadCompleteCompressed: PFAST_IO_MDL_READ_COMPLETE_COMPRESSED,
    pub MdlWriteCompleteCompressed: PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED,
    pub FastIoQueryOpen: PFAST_IO_QUERY_OPEN,
    pub ReleaseForModWrite: PFAST_IO_RELEASE_FOR_MOD_WRITE,
    pub AcquireForCcFlush: PFAST_IO_ACQUIRE_FOR_CCFLUSH,
    pub ReleaseForCcFlush: PFAST_IO_RELEASE_FOR_CCFLUSH,
}
pub type FAST_IO_DISPATCH = _FAST_IO_DISPATCH;
pub type PFAST_IO_DISPATCH = *mut _FAST_IO_DISPATCH;
pub const _IO_ALLOCATION_ACTION_KeepObject: _IO_ALLOCATION_ACTION = 1;
pub const _IO_ALLOCATION_ACTION_DeallocateObject: _IO_ALLOCATION_ACTION = 2;
pub const _IO_ALLOCATION_ACTION_DeallocateObjectKeepRegisters: _IO_ALLOCATION_ACTION = 3;
pub type _IO_ALLOCATION_ACTION = core::ffi::c_int;
pub use self::_IO_ALLOCATION_ACTION as IO_ALLOCATION_ACTION;
pub type PIO_ALLOCATION_ACTION = *mut _IO_ALLOCATION_ACTION;
pub type DRIVER_CONTROL = ::core::option::Option<
    unsafe extern "C" fn(
        DeviceObject: *mut _DEVICE_OBJECT,
        Irp: *mut _IRP,
        MapRegisterBase: PVOID,
        Context: PVOID,
    ) -> IO_ALLOCATION_ACTION,
>;
pub type PDRIVER_CONTROL = DRIVER_CONTROL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_SECURITY_CONTEXT {
    pub SecurityQos: PSECURITY_QUALITY_OF_SERVICE,
    pub AccessState: PACCESS_STATE,
    pub DesiredAccess: ACCESS_MASK,
    pub FullCreateOptions: ULONG,
}
pub type IO_SECURITY_CONTEXT = _IO_SECURITY_CONTEXT;
pub type PIO_SECURITY_CONTEXT = *mut _IO_SECURITY_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VPB {
    pub Type: CSHORT,
    pub Size: CSHORT,
    pub Flags: USHORT,
    pub VolumeLabelLength: USHORT,
    pub DeviceObject: *mut _DEVICE_OBJECT,
    pub RealDevice: *mut _DEVICE_OBJECT,
    pub SerialNumber: ULONG,
    pub ReferenceCount: ULONG,
    pub VolumeLabel: [WCHAR; 32usize],
}
pub type VPB = _VPB;
pub type PADAPTER_OBJECT = *mut _DMA_ADAPTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WAIT_CONTEXT_BLOCK {
    pub __bindgen_anon_1: _WAIT_CONTEXT_BLOCK__bindgen_ty_1,
    pub DeviceRoutine: PDRIVER_CONTROL,
    pub DeviceContext: PVOID,
    pub NumberOfMapRegisters: ULONG,
    pub DeviceObject: PVOID,
    pub CurrentIrp: PVOID,
    pub BufferChainingDpc: PKDPC,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WAIT_CONTEXT_BLOCK__bindgen_ty_1 {
    pub WaitQueueEntry: KDEVICE_QUEUE_ENTRY,
    pub __bindgen_anon_1: _WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1 {
    pub DmaWaitEntry: LIST_ENTRY,
    pub NumberOfChannels: ULONG,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn SyncCallback(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SyncCallback(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SyncCallback_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SyncCallback_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DmaContext(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DmaContext(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DmaContext_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DmaContext_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ZeroMapRegisters(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ZeroMapRegisters(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ZeroMapRegisters_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ZeroMapRegisters_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                9u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                9u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NumberOfRemapPages(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_NumberOfRemapPages(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NumberOfRemapPages_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                20u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NumberOfRemapPages_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                20u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SyncCallback: ULONG,
        DmaContext: ULONG,
        ZeroMapRegisters: ULONG,
        Reserved: ULONG,
        NumberOfRemapPages: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SyncCallback: u32 = unsafe { ::core::mem::transmute(SyncCallback) };
            SyncCallback as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DmaContext: u32 = unsafe { ::core::mem::transmute(DmaContext) };
            DmaContext as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ZeroMapRegisters: u32 = unsafe { ::core::mem::transmute(ZeroMapRegisters) };
            ZeroMapRegisters as u64
        });
        __bindgen_bitfield_unit.set(3usize, 9u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let NumberOfRemapPages: u32 = unsafe { ::core::mem::transmute(NumberOfRemapPages) };
            NumberOfRemapPages as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WAIT_CONTEXT_BLOCK = _WAIT_CONTEXT_BLOCK;
pub type PWAIT_CONTEXT_BLOCK = *mut _WAIT_CONTEXT_BLOCK;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _DEVICE_OBJECT {
    pub Type: CSHORT,
    pub Size: USHORT,
    pub ReferenceCount: LONG,
    pub DriverObject: *mut _DRIVER_OBJECT,
    pub NextDevice: *mut _DEVICE_OBJECT,
    pub AttachedDevice: *mut _DEVICE_OBJECT,
    pub CurrentIrp: *mut _IRP,
    pub Timer: PIO_TIMER,
    pub Flags: ULONG,
    pub Characteristics: ULONG,
    pub Vpb: PVPB,
    pub DeviceExtension: PVOID,
    pub DeviceType: ULONG,
    pub StackSize: CCHAR,
    pub Queue: _DEVICE_OBJECT__bindgen_ty_1,
    pub AlignmentRequirement: ULONG,
    pub DeviceQueue: KDEVICE_QUEUE,
    pub Dpc: KDPC,
    pub ActiveThreadCount: ULONG,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
    pub DeviceLock: KEVENT,
    pub SectorSize: USHORT,
    pub Spare1: USHORT,
    pub DeviceObjectExtension: *mut _DEVOBJ_EXTENSION,
    pub Reserved: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DEVICE_OBJECT__bindgen_ty_1 {
    pub ListEntry: LIST_ENTRY,
    pub Wcb: WAIT_CONTEXT_BLOCK,
}
pub type DEVICE_OBJECT = _DEVICE_OBJECT;
pub type PDEVICE_OBJECT = *mut _DEVICE_OBJECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_OBJECT_POWER_EXTENSION {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVOBJ_EXTENSION {
    pub Type: CSHORT,
    pub Size: USHORT,
    pub DeviceObject: PDEVICE_OBJECT,
    pub PowerFlags: ULONG,
    pub Dope: *mut _DEVICE_OBJECT_POWER_EXTENSION,
    pub ExtensionFlags: ULONG,
    pub DeviceNode: PVOID,
    pub AttachedTo: PDEVICE_OBJECT,
    pub StartIoCount: LONG,
    pub StartIoKey: LONG,
    pub StartIoFlags: ULONG,
    pub Vpb: PVPB,
    pub DependencyNode: PVOID,
    pub InterruptContext: PVOID,
    pub InterruptCount: LONG,
    pub VerifierContext: PVOID,
}
pub type DEVOBJ_EXTENSION = _DEVOBJ_EXTENSION;
pub type PDEVOBJ_EXTENSION = *mut _DEVOBJ_EXTENSION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVER_EXTENSION {
    pub DriverObject: *mut _DRIVER_OBJECT,
    pub AddDevice: PDRIVER_ADD_DEVICE,
    pub Count: ULONG,
    pub ServiceKeyName: UNICODE_STRING,
}
pub type DRIVER_EXTENSION = _DRIVER_EXTENSION;
pub type PDRIVER_EXTENSION = *mut _DRIVER_EXTENSION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVER_OBJECT {
    pub Type: CSHORT,
    pub Size: CSHORT,
    pub DeviceObject: PDEVICE_OBJECT,
    pub Flags: ULONG,
    pub DriverStart: PVOID,
    pub DriverSize: ULONG,
    pub DriverSection: PVOID,
    pub DriverExtension: PDRIVER_EXTENSION,
    pub DriverName: UNICODE_STRING,
    pub HardwareDatabase: PUNICODE_STRING,
    pub FastIoDispatch: PFAST_IO_DISPATCH,
    pub DriverInit: PDRIVER_INITIALIZE,
    pub DriverStartIo: PDRIVER_STARTIO,
    pub DriverUnload: PDRIVER_UNLOAD,
    pub MajorFunction: [PDRIVER_DISPATCH; 28usize],
}
pub type DRIVER_OBJECT = _DRIVER_OBJECT;
pub type PDRIVER_OBJECT = *mut _DRIVER_OBJECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECTION_OBJECT_POINTERS {
    pub DataSectionObject: PVOID,
    pub SharedCacheMap: PVOID,
    pub ImageSectionObject: PVOID,
}
pub type SECTION_OBJECT_POINTERS = _SECTION_OBJECT_POINTERS;
pub type PSECTION_OBJECT_POINTERS = *mut SECTION_OBJECT_POINTERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_COMPLETION_CONTEXT {
    pub Port: PVOID,
    pub Key: PVOID,
    pub UsageCount: LONG_PTR,
}
pub type IO_COMPLETION_CONTEXT = _IO_COMPLETION_CONTEXT;
pub type PIO_COMPLETION_CONTEXT = *mut _IO_COMPLETION_CONTEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_OBJECT {
    pub Type: CSHORT,
    pub Size: CSHORT,
    pub DeviceObject: PDEVICE_OBJECT,
    pub Vpb: PVPB,
    pub FsContext: PVOID,
    pub FsContext2: PVOID,
    pub SectionObjectPointer: PSECTION_OBJECT_POINTERS,
    pub PrivateCacheMap: PVOID,
    pub FinalStatus: NTSTATUS,
    pub RelatedFileObject: *mut _FILE_OBJECT,
    pub LockOperation: BOOLEAN,
    pub DeletePending: BOOLEAN,
    pub ReadAccess: BOOLEAN,
    pub WriteAccess: BOOLEAN,
    pub DeleteAccess: BOOLEAN,
    pub SharedRead: BOOLEAN,
    pub SharedWrite: BOOLEAN,
    pub SharedDelete: BOOLEAN,
    pub Flags: ULONG,
    pub FileName: UNICODE_STRING,
    pub CurrentByteOffset: LARGE_INTEGER,
    pub Waiters: ULONG,
    pub Busy: ULONG,
    pub LastLock: PVOID,
    pub Lock: KEVENT,
    pub Event: KEVENT,
    pub CompletionContext: PIO_COMPLETION_CONTEXT,
    pub IrpListLock: KSPIN_LOCK,
    pub IrpList: LIST_ENTRY,
    pub FileObjectExtension: PVOID,
}
pub type FILE_OBJECT = _FILE_OBJECT;
pub type PFILE_OBJECT = *mut _FILE_OBJECT;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _IRP {
    pub Type: CSHORT,
    pub Size: USHORT,
    pub MdlAddress: PMDL,
    pub Flags: ULONG,
    pub AssociatedIrp: _IRP__bindgen_ty_1,
    pub ThreadListEntry: LIST_ENTRY,
    pub IoStatus: IO_STATUS_BLOCK,
    pub RequestorMode: KPROCESSOR_MODE,
    pub PendingReturned: BOOLEAN,
    pub StackCount: CHAR,
    pub CurrentLocation: CHAR,
    pub Cancel: BOOLEAN,
    pub CancelIrql: KIRQL,
    pub ApcEnvironment: CCHAR,
    pub AllocationFlags: UCHAR,
    pub __bindgen_anon_1: _IRP__bindgen_ty_2,
    pub UserEvent: PKEVENT,
    pub Overlay: _IRP__bindgen_ty_3,
    pub CancelRoutine: PDRIVER_CANCEL,
    pub UserBuffer: PVOID,
    pub Tail: _IRP__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_1 {
    pub MasterIrp: *mut _IRP,
    pub IrpCount: LONG,
    pub SystemBuffer: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_2 {
    pub UserIosb: PIO_STATUS_BLOCK,
    pub IoRingContext: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_3 {
    pub AsynchronousParameters: _IRP__bindgen_ty_3__bindgen_ty_1,
    pub AllocationSize: LARGE_INTEGER,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP__bindgen_ty_3__bindgen_ty_1 {
    pub __bindgen_anon_1: _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    pub UserApcRoutine: PIO_APC_ROUTINE,
    pub IssuingProcess: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2 {
    pub UserApcContext: PVOID,
    pub IoRing: *mut _IORING_OBJECT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_4 {
    pub Overlay: _IRP__bindgen_ty_4__bindgen_ty_1,
    pub Apc: KAPC,
    pub CompletionKey: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP__bindgen_ty_4__bindgen_ty_1 {
    pub __bindgen_anon_1: _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
    pub Thread: PETHREAD,
    pub AuxiliaryBuffer: PCHAR,
    pub __bindgen_anon_2: _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2,
    pub OriginalFileObject: PFILE_OBJECT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    pub DeviceQueueEntry: KDEVICE_QUEUE_ENTRY,
    pub __bindgen_anon_1: _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub DriverContext: [PVOID; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2 {
    pub ListEntry: LIST_ENTRY,
    pub __bindgen_anon_1: _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub CurrentStackLocation: *mut _IO_STACK_LOCATION,
    pub PacketType: ULONG,
}
pub type IRP = _IRP;
pub type PIRP = *mut IRP;
pub type IO_COMPLETION_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(DeviceObject: PDEVICE_OBJECT, Irp: PIRP, Context: PVOID) -> NTSTATUS,
>;
pub type PIO_COMPLETION_ROUTINE = IO_COMPLETION_ROUTINE;
pub const _DEVICE_RELATION_TYPE_BusRelations: _DEVICE_RELATION_TYPE = 0;
pub const _DEVICE_RELATION_TYPE_EjectionRelations: _DEVICE_RELATION_TYPE = 1;
pub const _DEVICE_RELATION_TYPE_PowerRelations: _DEVICE_RELATION_TYPE = 2;
pub const _DEVICE_RELATION_TYPE_RemovalRelations: _DEVICE_RELATION_TYPE = 3;
pub const _DEVICE_RELATION_TYPE_TargetDeviceRelation: _DEVICE_RELATION_TYPE = 4;
pub const _DEVICE_RELATION_TYPE_SingleBusRelations: _DEVICE_RELATION_TYPE = 5;
pub const _DEVICE_RELATION_TYPE_TransportRelations: _DEVICE_RELATION_TYPE = 6;
pub type _DEVICE_RELATION_TYPE = core::ffi::c_int;
pub use self::_DEVICE_RELATION_TYPE as DEVICE_RELATION_TYPE;
pub type PDEVICE_RELATION_TYPE = *mut _DEVICE_RELATION_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_RELATIONS {
    pub Count: ULONG,
    pub Objects: [PDEVICE_OBJECT; 1usize],
}
pub type DEVICE_RELATIONS = _DEVICE_RELATIONS;
pub type PDEVICE_RELATIONS = *mut _DEVICE_RELATIONS;
pub const _DEVICE_USAGE_NOTIFICATION_TYPE_DeviceUsageTypeUndefined:
_DEVICE_USAGE_NOTIFICATION_TYPE = 0;
pub const _DEVICE_USAGE_NOTIFICATION_TYPE_DeviceUsageTypePaging: _DEVICE_USAGE_NOTIFICATION_TYPE =
    1;
pub const _DEVICE_USAGE_NOTIFICATION_TYPE_DeviceUsageTypeHibernation:
_DEVICE_USAGE_NOTIFICATION_TYPE = 2;
pub const _DEVICE_USAGE_NOTIFICATION_TYPE_DeviceUsageTypeDumpFile: _DEVICE_USAGE_NOTIFICATION_TYPE =
    3;
pub const _DEVICE_USAGE_NOTIFICATION_TYPE_DeviceUsageTypeBoot: _DEVICE_USAGE_NOTIFICATION_TYPE = 4;
pub const _DEVICE_USAGE_NOTIFICATION_TYPE_DeviceUsageTypePostDisplay:
_DEVICE_USAGE_NOTIFICATION_TYPE = 5;
pub const _DEVICE_USAGE_NOTIFICATION_TYPE_DeviceUsageTypeGuestAssigned:
_DEVICE_USAGE_NOTIFICATION_TYPE = 6;
pub type _DEVICE_USAGE_NOTIFICATION_TYPE = core::ffi::c_int;
pub use self::_DEVICE_USAGE_NOTIFICATION_TYPE as DEVICE_USAGE_NOTIFICATION_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
}
pub type INTERFACE = _INTERFACE;
pub type PINTERFACE = *mut _INTERFACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_CAPABILITIES {
    pub Size: USHORT,
    pub Version: USHORT,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub Address: ULONG,
    pub UINumber: ULONG,
    pub DeviceState: [DEVICE_POWER_STATE; 7usize],
    pub SystemWake: SYSTEM_POWER_STATE,
    pub DeviceWake: DEVICE_POWER_STATE,
    pub D1Latency: ULONG,
    pub D2Latency: ULONG,
    pub D3Latency: ULONG,
}
impl _DEVICE_CAPABILITIES {
    #[inline]
    pub fn DeviceD1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeviceD1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DeviceD1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DeviceD1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DeviceD2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeviceD2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DeviceD2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DeviceD2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LockSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LockSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LockSupported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_LockSupported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EjectSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EjectSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EjectSupported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_EjectSupported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Removable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Removable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Removable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Removable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DockDevice(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DockDevice(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DockDevice_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DockDevice_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UniqueID(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UniqueID(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UniqueID_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UniqueID_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SilentInstall(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SilentInstall(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SilentInstall_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SilentInstall_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RawDeviceOK(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RawDeviceOK(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RawDeviceOK_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RawDeviceOK_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SurpriseRemovalOK(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SurpriseRemovalOK(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SurpriseRemovalOK_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SurpriseRemovalOK_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn WakeFromD0(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeFromD0(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn WakeFromD0_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_WakeFromD0_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn WakeFromD1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeFromD1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn WakeFromD1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_WakeFromD1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn WakeFromD2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeFromD2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn WakeFromD2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_WakeFromD2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn WakeFromD3(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeFromD3(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn WakeFromD3_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_WakeFromD3_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn HardwareDisabled(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HardwareDisabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn HardwareDisabled_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_HardwareDisabled_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NonDynamic(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NonDynamic(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NonDynamic_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NonDynamic_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn WarmEjectSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WarmEjectSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn WarmEjectSupported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_WarmEjectSupported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NoDisplayInUI(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoDisplayInUI(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NoDisplayInUI_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NoDisplayInUI_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn WakeFromInterrupt(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeFromInterrupt(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn WakeFromInterrupt_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_WakeFromInterrupt_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SecureDevice(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SecureDevice(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SecureDevice_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SecureDevice_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ChildOfVgaEnabledBridge(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ChildOfVgaEnabledBridge(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ChildOfVgaEnabledBridge_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ChildOfVgaEnabledBridge_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DecodeIoOnBoot(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DecodeIoOnBoot(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DecodeIoOnBoot_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DecodeIoOnBoot_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                9u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                9u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DeviceD1: ULONG,
        DeviceD2: ULONG,
        LockSupported: ULONG,
        EjectSupported: ULONG,
        Removable: ULONG,
        DockDevice: ULONG,
        UniqueID: ULONG,
        SilentInstall: ULONG,
        RawDeviceOK: ULONG,
        SurpriseRemovalOK: ULONG,
        WakeFromD0: ULONG,
        WakeFromD1: ULONG,
        WakeFromD2: ULONG,
        WakeFromD3: ULONG,
        HardwareDisabled: ULONG,
        NonDynamic: ULONG,
        WarmEjectSupported: ULONG,
        NoDisplayInUI: ULONG,
        Reserved1: ULONG,
        WakeFromInterrupt: ULONG,
        SecureDevice: ULONG,
        ChildOfVgaEnabledBridge: ULONG,
        DecodeIoOnBoot: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DeviceD1: u32 = unsafe { ::core::mem::transmute(DeviceD1) };
            DeviceD1 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DeviceD2: u32 = unsafe { ::core::mem::transmute(DeviceD2) };
            DeviceD2 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let LockSupported: u32 = unsafe { ::core::mem::transmute(LockSupported) };
            LockSupported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let EjectSupported: u32 = unsafe { ::core::mem::transmute(EjectSupported) };
            EjectSupported as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Removable: u32 = unsafe { ::core::mem::transmute(Removable) };
            Removable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DockDevice: u32 = unsafe { ::core::mem::transmute(DockDevice) };
            DockDevice as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let UniqueID: u32 = unsafe { ::core::mem::transmute(UniqueID) };
            UniqueID as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SilentInstall: u32 = unsafe { ::core::mem::transmute(SilentInstall) };
            SilentInstall as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let RawDeviceOK: u32 = unsafe { ::core::mem::transmute(RawDeviceOK) };
            RawDeviceOK as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let SurpriseRemovalOK: u32 = unsafe { ::core::mem::transmute(SurpriseRemovalOK) };
            SurpriseRemovalOK as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let WakeFromD0: u32 = unsafe { ::core::mem::transmute(WakeFromD0) };
            WakeFromD0 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let WakeFromD1: u32 = unsafe { ::core::mem::transmute(WakeFromD1) };
            WakeFromD1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let WakeFromD2: u32 = unsafe { ::core::mem::transmute(WakeFromD2) };
            WakeFromD2 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let WakeFromD3: u32 = unsafe { ::core::mem::transmute(WakeFromD3) };
            WakeFromD3 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let HardwareDisabled: u32 = unsafe { ::core::mem::transmute(HardwareDisabled) };
            HardwareDisabled as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let NonDynamic: u32 = unsafe { ::core::mem::transmute(NonDynamic) };
            NonDynamic as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let WarmEjectSupported: u32 = unsafe { ::core::mem::transmute(WarmEjectSupported) };
            WarmEjectSupported as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let NoDisplayInUI: u32 = unsafe { ::core::mem::transmute(NoDisplayInUI) };
            NoDisplayInUI as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let WakeFromInterrupt: u32 = unsafe { ::core::mem::transmute(WakeFromInterrupt) };
            WakeFromInterrupt as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let SecureDevice: u32 = unsafe { ::core::mem::transmute(SecureDevice) };
            SecureDevice as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let ChildOfVgaEnabledBridge: u32 =
                unsafe { ::core::mem::transmute(ChildOfVgaEnabledBridge) };
            ChildOfVgaEnabledBridge as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let DecodeIoOnBoot: u32 = unsafe { ::core::mem::transmute(DecodeIoOnBoot) };
            DecodeIoOnBoot as u64
        });
        __bindgen_bitfield_unit.set(23usize, 9u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type DEVICE_CAPABILITIES = _DEVICE_CAPABILITIES;
pub type PDEVICE_CAPABILITIES = *mut _DEVICE_CAPABILITIES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_SEQUENCE {
    pub SequenceD1: ULONG,
    pub SequenceD2: ULONG,
    pub SequenceD3: ULONG,
}
pub type POWER_SEQUENCE = _POWER_SEQUENCE;
pub type PPOWER_SEQUENCE = *mut _POWER_SEQUENCE;
pub const BUS_QUERY_ID_TYPE_BusQueryDeviceID: BUS_QUERY_ID_TYPE = 0;
pub const BUS_QUERY_ID_TYPE_BusQueryHardwareIDs: BUS_QUERY_ID_TYPE = 1;
pub const BUS_QUERY_ID_TYPE_BusQueryCompatibleIDs: BUS_QUERY_ID_TYPE = 2;
pub const BUS_QUERY_ID_TYPE_BusQueryInstanceID: BUS_QUERY_ID_TYPE = 3;
pub const BUS_QUERY_ID_TYPE_BusQueryDeviceSerialNumber: BUS_QUERY_ID_TYPE = 4;
pub const BUS_QUERY_ID_TYPE_BusQueryContainerID: BUS_QUERY_ID_TYPE = 5;
pub type BUS_QUERY_ID_TYPE = core::ffi::c_int;
pub type PBUS_QUERY_ID_TYPE = *mut BUS_QUERY_ID_TYPE;
pub type PNP_DEVICE_STATE = ULONG;
pub type PPNP_DEVICE_STATE = *mut ULONG;
pub const DEVICE_TEXT_TYPE_DeviceTextDescription: DEVICE_TEXT_TYPE = 0;
pub const DEVICE_TEXT_TYPE_DeviceTextLocationInformation: DEVICE_TEXT_TYPE = 1;
pub type DEVICE_TEXT_TYPE = core::ffi::c_int;
pub type PDEVICE_TEXT_TYPE = *mut DEVICE_TEXT_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION {
    pub MajorFunction: UCHAR,
    pub MinorFunction: UCHAR,
    pub Flags: UCHAR,
    pub Control: UCHAR,
    pub Parameters: _IO_STACK_LOCATION__bindgen_ty_1,
    pub DeviceObject: PDEVICE_OBJECT,
    pub FileObject: PFILE_OBJECT,
    pub CompletionRoutine: PIO_COMPLETION_ROUTINE,
    pub Context: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STACK_LOCATION__bindgen_ty_1 {
    pub Create: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1,
    pub CreatePipe: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2,
    pub CreateMailslot: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3,
    pub Read: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4,
    pub Write: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5,
    pub QueryDirectory: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6,
    pub NotifyDirectory: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7,
    pub NotifyDirectoryEx: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8,
    pub QueryFile: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9,
    pub SetFile: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10,
    pub QueryEa: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11,
    pub SetEa: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12,
    pub QueryVolume: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13,
    pub SetVolume: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14,
    pub FileSystemControl: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15,
    pub LockControl: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16,
    pub DeviceIoControl: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17,
    pub QuerySecurity: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18,
    pub SetSecurity: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19,
    pub MountVolume: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20,
    pub VerifyVolume: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21,
    pub Scsi: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22,
    pub QueryQuota: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23,
    pub SetQuota: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24,
    pub QueryDeviceRelations: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25,
    pub QueryInterface: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26,
    pub DeviceCapabilities: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27,
    pub FilterResourceRequirements: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28,
    pub ReadWriteConfig: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29,
    pub SetLock: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30,
    pub QueryId: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31,
    pub QueryDeviceText: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32,
    pub UsageNotification: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33,
    pub WaitWake: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34,
    pub PowerSequence: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35,
    pub Power: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36,
    pub StartDevice: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37,
    pub WMI: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38,
    pub Others: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1 {
    pub SecurityContext: PIO_SECURITY_CONTEXT,
    pub Options: ULONG,
    pub __bindgen_padding_0: [u16; 2usize],
    pub FileAttributes: USHORT,
    pub ShareAccess: USHORT,
    pub __bindgen_padding_1: u32,
    pub EaLength: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2 {
    pub SecurityContext: PIO_SECURITY_CONTEXT,
    pub Options: ULONG,
    pub __bindgen_padding_0: [u16; 2usize],
    pub Reserved: USHORT,
    pub ShareAccess: USHORT,
    pub Parameters: PNAMED_PIPE_CREATE_PARAMETERS,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3 {
    pub SecurityContext: PIO_SECURITY_CONTEXT,
    pub Options: ULONG,
    pub __bindgen_padding_0: [u16; 2usize],
    pub Reserved: USHORT,
    pub ShareAccess: USHORT,
    pub Parameters: PMAILSLOT_CREATE_PARAMETERS,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub Key: ULONG,
    pub Flags: ULONG,
    pub ByteOffset: LARGE_INTEGER,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub Key: ULONG,
    pub Flags: ULONG,
    pub ByteOffset: LARGE_INTEGER,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6 {
    pub Length: ULONG,
    pub FileName: PUNICODE_STRING,
    pub FileInformationClass: FILE_INFORMATION_CLASS,
    pub __bindgen_padding_0: u32,
    pub FileIndex: ULONG,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub CompletionFilter: ULONG,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub CompletionFilter: ULONG,
    pub __bindgen_padding_1: u32,
    pub DirectoryNotifyInformationClass: DIRECTORY_NOTIFY_INFORMATION_CLASS,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub FileInformationClass: FILE_INFORMATION_CLASS,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub FileInformationClass: FILE_INFORMATION_CLASS,
    pub FileObject: PFILE_OBJECT,
    pub __bindgen_anon_1: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1 {
    pub __bindgen_anon_1:
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1__bindgen_ty_1,
    pub ClusterCount: ULONG,
    pub DeleteHandle: HANDLE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1__bindgen_ty_1 {
    pub ReplaceIfExists: BOOLEAN,
    pub AdvanceOnly: BOOLEAN,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11 {
    pub Length: ULONG,
    pub EaList: PVOID,
    pub EaListLength: ULONG,
    pub __bindgen_padding_0: u32,
    pub EaIndex: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12 {
    pub Length: ULONG,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub FsInformationClass: FS_INFORMATION_CLASS,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub FsInformationClass: FS_INFORMATION_CLASS,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15 {
    pub OutputBufferLength: ULONG,
    pub __bindgen_padding_0: u32,
    pub InputBufferLength: ULONG,
    pub __bindgen_padding_1: u32,
    pub FsControlCode: ULONG,
    pub Type3InputBuffer: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16 {
    pub Length: PLARGE_INTEGER,
    pub Key: ULONG,
    pub ByteOffset: LARGE_INTEGER,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17 {
    pub OutputBufferLength: ULONG,
    pub __bindgen_padding_0: u32,
    pub InputBufferLength: ULONG,
    pub __bindgen_padding_1: u32,
    pub IoControlCode: ULONG,
    pub Type3InputBuffer: PVOID,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18 {
    pub SecurityInformation: SECURITY_INFORMATION,
    pub __bindgen_padding_0: u32,
    pub Length: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19 {
    pub SecurityInformation: SECURITY_INFORMATION,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20 {
    pub Vpb: PVPB,
    pub DeviceObject: PDEVICE_OBJECT,
    pub OutputBufferLength: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21 {
    pub Vpb: PVPB,
    pub DeviceObject: PDEVICE_OBJECT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22 {
    pub Srb: *mut _SCSI_REQUEST_BLOCK,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23 {
    pub Length: ULONG,
    pub StartSid: PSID,
    pub SidList: PFILE_GET_QUOTA_INFORMATION,
    pub SidListLength: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24 {
    pub Length: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25 {
    pub Type: DEVICE_RELATION_TYPE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26 {
    pub InterfaceType: *const GUID,
    pub Size: USHORT,
    pub Version: USHORT,
    pub Interface: PINTERFACE,
    pub InterfaceSpecificData: PVOID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27 {
    pub Capabilities: PDEVICE_CAPABILITIES,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28 {
    pub IoResourceRequirementList: PIO_RESOURCE_REQUIREMENTS_LIST,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29 {
    pub WhichSpace: ULONG,
    pub Buffer: PVOID,
    pub Offset: ULONG,
    pub __bindgen_padding_0: u32,
    pub Length: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30 {
    pub Lock: BOOLEAN,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31 {
    pub IdType: BUS_QUERY_ID_TYPE,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32 {
    pub DeviceTextType: DEVICE_TEXT_TYPE,
    pub __bindgen_padding_0: u32,
    pub LocaleId: LCID,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33 {
    pub InPath: BOOLEAN,
    pub Reserved: [BOOLEAN; 3usize],
    pub __bindgen_padding_0: u32,
    pub Type: DEVICE_USAGE_NOTIFICATION_TYPE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34 {
    pub PowerState: SYSTEM_POWER_STATE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35 {
    pub PowerSequence: PPOWER_SEQUENCE,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36 {
    pub __bindgen_anon_1: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1,
    pub __bindgen_padding_0: u32,
    pub Type: POWER_STATE_TYPE,
    pub __bindgen_padding_1: u32,
    pub State: POWER_STATE,
    pub __bindgen_padding_2: u32,
    pub ShutdownType: POWER_ACTION,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1 {
    pub SystemContext: ULONG,
    pub SystemPowerStateContext: SYSTEM_POWER_STATE_CONTEXT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37 {
    pub AllocatedResources: PCM_RESOURCE_LIST,
    pub AllocatedResourcesTranslated: PCM_RESOURCE_LIST,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38 {
    pub ProviderId: ULONG_PTR,
    pub DataPath: PVOID,
    pub BufferSize: ULONG,
    pub Buffer: PVOID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39 {
    pub Argument1: PVOID,
    pub Argument2: PVOID,
    pub Argument3: PVOID,
    pub Argument4: PVOID,
}
pub type IO_STACK_LOCATION = _IO_STACK_LOCATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHARE_ACCESS {
    pub OpenCount: ULONG,
    pub Readers: ULONG,
    pub Writers: ULONG,
    pub Deleters: ULONG,
    pub SharedRead: ULONG,
    pub SharedWrite: ULONG,
    pub SharedDelete: ULONG,
}
pub type SHARE_ACCESS = _SHARE_ACCESS;
pub type PSHARE_ACCESS = *mut _SHARE_ACCESS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LINK_SHARE_ACCESS {
    pub OpenCount: ULONG,
    pub Deleters: ULONG,
    pub SharedDelete: ULONG,
}
pub type LINK_SHARE_ACCESS = _LINK_SHARE_ACCESS;
pub type PLINK_SHARE_ACCESS = *mut _LINK_SHARE_ACCESS;
unsafe extern "C" {
    pub fn IoAcquireCancelSpinLock(Irql: PKIRQL);
}
unsafe extern "C" {
    pub fn IoAllocateDriverObjectExtension(
        DriverObject: PDRIVER_OBJECT,
        ClientIdentificationAddress: PVOID,
        DriverObjectExtensionSize: ULONG,
        DriverObjectExtension: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoAllocateErrorLogEntry(IoObject: PVOID, EntrySize: UCHAR) -> PVOID;
}
unsafe extern "C" {
    pub fn IoAllocateIrp(StackSize: CCHAR, ChargeQuota: BOOLEAN) -> PIRP;
}
unsafe extern "C" {
    pub fn IoAllocateIrpEx(
        DeviceObject: PDEVICE_OBJECT,
        StackSize: CCHAR,
        ChargeQuota: BOOLEAN,
    ) -> PIRP;
}
unsafe extern "C" {
    pub fn IoAllocateMdl(
        VirtualAddress: PVOID,
        Length: ULONG,
        SecondaryBuffer: BOOLEAN,
        ChargeQuota: BOOLEAN,
        Irp: PIRP,
    ) -> PMDL;
}
pub const _IO_PAGING_PRIORITY_IoPagingPriorityInvalid: _IO_PAGING_PRIORITY = 0;
pub const _IO_PAGING_PRIORITY_IoPagingPriorityNormal: _IO_PAGING_PRIORITY = 1;
pub const _IO_PAGING_PRIORITY_IoPagingPriorityHigh: _IO_PAGING_PRIORITY = 2;
pub const _IO_PAGING_PRIORITY_IoPagingPriorityReserved1: _IO_PAGING_PRIORITY = 3;
pub const _IO_PAGING_PRIORITY_IoPagingPriorityReserved2: _IO_PAGING_PRIORITY = 4;
pub type _IO_PAGING_PRIORITY = core::ffi::c_int;
pub use self::_IO_PAGING_PRIORITY as IO_PAGING_PRIORITY;
unsafe extern "C" {
    pub fn IoAttachDevice(
        SourceDevice: PDEVICE_OBJECT,
        TargetDevice: PUNICODE_STRING,
        AttachedDevice: *mut PDEVICE_OBJECT,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoAttachDeviceToDeviceStack(
        SourceDevice: PDEVICE_OBJECT,
        TargetDevice: PDEVICE_OBJECT,
    ) -> PDEVICE_OBJECT;
}
unsafe extern "C" {
    pub fn IoBuildAsynchronousFsdRequest(
        MajorFunction: ULONG,
        DeviceObject: PDEVICE_OBJECT,
        Buffer: PVOID,
        Length: ULONG,
        StartingOffset: PLARGE_INTEGER,
        IoStatusBlock: PIO_STATUS_BLOCK,
    ) -> PIRP;
}
unsafe extern "C" {
    pub fn IoBuildDeviceIoControlRequest(
        IoControlCode: ULONG,
        DeviceObject: PDEVICE_OBJECT,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
        InternalDeviceIoControl: BOOLEAN,
        Event: PKEVENT,
        IoStatusBlock: PIO_STATUS_BLOCK,
    ) -> PIRP;
}
unsafe extern "C" {
    pub fn IoBuildPartialMdl(
        SourceMdl: PMDL,
        TargetMdl: PMDL,
        VirtualAddress: PVOID,
        Length: ULONG,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BOOTDISK_INFORMATION {
    pub BootPartitionOffset: LONGLONG,
    pub SystemPartitionOffset: LONGLONG,
    pub BootDeviceSignature: ULONG,
    pub SystemDeviceSignature: ULONG,
}
pub type BOOTDISK_INFORMATION = _BOOTDISK_INFORMATION;
pub type PBOOTDISK_INFORMATION = *mut _BOOTDISK_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BOOTDISK_INFORMATION_EX {
    pub BootPartitionOffset: LONGLONG,
    pub SystemPartitionOffset: LONGLONG,
    pub BootDeviceSignature: ULONG,
    pub SystemDeviceSignature: ULONG,
    pub BootDeviceGuid: GUID,
    pub SystemDeviceGuid: GUID,
    pub BootDeviceIsGpt: BOOLEAN,
    pub SystemDeviceIsGpt: BOOLEAN,
}
pub type BOOTDISK_INFORMATION_EX = _BOOTDISK_INFORMATION_EX;
pub type PBOOTDISK_INFORMATION_EX = *mut _BOOTDISK_INFORMATION_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LOADER_PARTITION_INFORMATION_EX {
    pub PartitionStyle: ULONG,
    pub PartitionNumber: ULONG,
    pub __bindgen_anon_1: _LOADER_PARTITION_INFORMATION_EX__bindgen_ty_1,
    pub Flags: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LOADER_PARTITION_INFORMATION_EX__bindgen_ty_1 {
    pub Signature: ULONG,
    pub DeviceId: GUID,
}
pub type LOADER_PARTITION_INFORMATION_EX = _LOADER_PARTITION_INFORMATION_EX;
pub type PLOADER_PARTITION_INFORMATION_EX = *mut _LOADER_PARTITION_INFORMATION_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _BOOTDISK_INFORMATION_LITE {
    pub NumberEntries: ULONG,
    pub Entries: [LOADER_PARTITION_INFORMATION_EX; 1usize],
}
pub type BOOTDISK_INFORMATION_LITE = _BOOTDISK_INFORMATION_LITE;
pub type PBOOTDISK_INFORMATION_LITE = *mut _BOOTDISK_INFORMATION_LITE;
unsafe extern "C" {
    pub fn IoGetBootDiskInformation(
        BootDiskInformation: PBOOTDISK_INFORMATION,
        Size: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoGetBootDiskInformationLite(
        BootDiskInformation: *mut PBOOTDISK_INFORMATION_LITE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoBuildSynchronousFsdRequest(
        MajorFunction: ULONG,
        DeviceObject: PDEVICE_OBJECT,
        Buffer: PVOID,
        Length: ULONG,
        StartingOffset: PLARGE_INTEGER,
        Event: PKEVENT,
        IoStatusBlock: PIO_STATUS_BLOCK,
    ) -> PIRP;
}
unsafe extern "C" {
    pub fn IofCallDriver(DeviceObject: PDEVICE_OBJECT, Irp: PIRP) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoCancelIrp(Irp: PIRP) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn IoCheckShareAccess(
        DesiredAccess: ACCESS_MASK,
        DesiredShareAccess: ULONG,
        FileObject: PFILE_OBJECT,
        ShareAccess: PSHARE_ACCESS,
        Update: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoCheckShareAccessEx(
        DesiredAccess: ACCESS_MASK,
        DesiredShareAccess: ULONG,
        FileObject: PFILE_OBJECT,
        ShareAccess: PSHARE_ACCESS,
        Update: BOOLEAN,
        WritePermission: PBOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoCheckLinkShareAccess(
        DesiredAccess: ACCESS_MASK,
        DesiredShareAccess: ULONG,
        FileObject: PFILE_OBJECT,
        ShareAccess: PSHARE_ACCESS,
        LinkShareAccess: PLINK_SHARE_ACCESS,
        IoShareAccessFlags: ULONG,
    ) -> NTSTATUS;
}
pub const _IO_COMPLETION_ROUTINE_RESULT_ContinueCompletion: _IO_COMPLETION_ROUTINE_RESULT = 0;
pub const _IO_COMPLETION_ROUTINE_RESULT_StopCompletion: _IO_COMPLETION_ROUTINE_RESULT = -1073741802;
pub type _IO_COMPLETION_ROUTINE_RESULT = core::ffi::c_int;
pub use self::_IO_COMPLETION_ROUTINE_RESULT as IO_COMPLETION_ROUTINE_RESULT;
pub type PIO_COMPLETION_ROUTINE_RESULT = *mut _IO_COMPLETION_ROUTINE_RESULT;
unsafe extern "C" {
    pub fn IofCompleteRequest(Irp: PIRP, PriorityBoost: CCHAR);
}
unsafe extern "C" {
    pub fn IoConnectInterrupt(
        InterruptObject: *mut PKINTERRUPT,
        ServiceRoutine: PKSERVICE_ROUTINE,
        ServiceContext: PVOID,
        SpinLock: PKSPIN_LOCK,
        Vector: ULONG,
        Irql: KIRQL,
        SynchronizeIrql: KIRQL,
        InterruptMode: KINTERRUPT_MODE,
        ShareVector: BOOLEAN,
        ProcessorEnableMask: KAFFINITY,
        FloatingSave: BOOLEAN,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_INTERRUPT_MESSAGE_INFO_ENTRY {
    pub MessageAddress: PHYSICAL_ADDRESS,
    pub TargetProcessorSet: KAFFINITY,
    pub InterruptObject: PKINTERRUPT,
    pub MessageData: ULONG,
    pub Vector: ULONG,
    pub Irql: KIRQL,
    pub Mode: KINTERRUPT_MODE,
    pub Polarity: KINTERRUPT_POLARITY,
}
pub type IO_INTERRUPT_MESSAGE_INFO_ENTRY = _IO_INTERRUPT_MESSAGE_INFO_ENTRY;
pub type PIO_INTERRUPT_MESSAGE_INFO_ENTRY = *mut _IO_INTERRUPT_MESSAGE_INFO_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_INTERRUPT_MESSAGE_INFO {
    pub UnifiedIrql: KIRQL,
    pub MessageCount: ULONG,
    pub MessageInfo: [IO_INTERRUPT_MESSAGE_INFO_ENTRY; 1usize],
}
pub type IO_INTERRUPT_MESSAGE_INFO = _IO_INTERRUPT_MESSAGE_INFO;
pub type PIO_INTERRUPT_MESSAGE_INFO = *mut _IO_INTERRUPT_MESSAGE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS {
    pub PhysicalDeviceObject: PDEVICE_OBJECT,
    pub InterruptObject: *mut PKINTERRUPT,
    pub ServiceRoutine: PKSERVICE_ROUTINE,
    pub ServiceContext: PVOID,
    pub SpinLock: PKSPIN_LOCK,
    pub SynchronizeIrql: KIRQL,
    pub FloatingSave: BOOLEAN,
    pub ShareVector: BOOLEAN,
    pub Vector: ULONG,
    pub Irql: KIRQL,
    pub InterruptMode: KINTERRUPT_MODE,
    pub ProcessorEnableMask: KAFFINITY,
    pub Group: USHORT,
}
pub type IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS =
_IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS;
pub type PIO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS =
*mut _IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS {
    pub PhysicalDeviceObject: PDEVICE_OBJECT,
    pub InterruptObject: *mut PKINTERRUPT,
    pub ServiceRoutine: PKSERVICE_ROUTINE,
    pub ServiceContext: PVOID,
    pub SpinLock: PKSPIN_LOCK,
    pub SynchronizeIrql: KIRQL,
    pub FloatingSave: BOOLEAN,
}
pub type IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS = _IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS;
pub type PIO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS =
*mut _IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS {
    pub PhysicalDeviceObject: PDEVICE_OBJECT,
    pub ConnectionContext: _IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS__bindgen_ty_1,
    pub MessageServiceRoutine: PKMESSAGE_SERVICE_ROUTINE,
    pub ServiceContext: PVOID,
    pub SpinLock: PKSPIN_LOCK,
    pub SynchronizeIrql: KIRQL,
    pub FloatingSave: BOOLEAN,
    pub FallBackServiceRoutine: PKSERVICE_ROUTINE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS__bindgen_ty_1 {
    pub Generic: *mut PVOID,
    pub InterruptMessageTable: *mut PIO_INTERRUPT_MESSAGE_INFO,
    pub InterruptObject: *mut PKINTERRUPT,
}
pub type IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS =
_IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS;
pub type PIO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS =
*mut _IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_CONNECT_INTERRUPT_PARAMETERS {
    pub Version: ULONG,
    pub __bindgen_anon_1: _IO_CONNECT_INTERRUPT_PARAMETERS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_CONNECT_INTERRUPT_PARAMETERS__bindgen_ty_1 {
    pub FullySpecified: IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS,
    pub LineBased: IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS,
    pub MessageBased: IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS,
}
pub type IO_CONNECT_INTERRUPT_PARAMETERS = _IO_CONNECT_INTERRUPT_PARAMETERS;
pub type PIO_CONNECT_INTERRUPT_PARAMETERS = *mut _IO_CONNECT_INTERRUPT_PARAMETERS;
unsafe extern "C" {
    pub fn IoConnectInterruptEx(Parameters: PIO_CONNECT_INTERRUPT_PARAMETERS) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoCreateDevice(
        DriverObject: PDRIVER_OBJECT,
        DeviceExtensionSize: ULONG,
        DeviceName: PUNICODE_STRING,
        DeviceType: ULONG,
        DeviceCharacteristics: ULONG,
        Exclusive: BOOLEAN,
        DeviceObject: *mut PDEVICE_OBJECT,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoIsWdmVersionAvailable(MajorVersion: UCHAR, MinorVersion: UCHAR) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn IoCreateFile(
        FileHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        AllocationSize: PLARGE_INTEGER,
        FileAttributes: ULONG,
        ShareAccess: ULONG,
        Disposition: ULONG,
        CreateOptions: ULONG,
        EaBuffer: PVOID,
        EaLength: ULONG,
        CreateFileType: CREATE_FILE_TYPE,
        InternalParameters: PVOID,
        Options: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoCreateNotificationEvent(EventName: PUNICODE_STRING, EventHandle: PHANDLE) -> PKEVENT;
}
unsafe extern "C" {
    pub fn IoCreateSymbolicLink(
        SymbolicLinkName: PUNICODE_STRING,
        DeviceName: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoCreateSynchronizationEvent(
        EventName: PUNICODE_STRING,
        EventHandle: PHANDLE,
    ) -> PKEVENT;
}
unsafe extern "C" {
    pub fn IoCreateUnprotectedSymbolicLink(
        SymbolicLinkName: PUNICODE_STRING,
        DeviceName: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoDeleteDevice(DeviceObject: PDEVICE_OBJECT);
}
unsafe extern "C" {
    pub fn IoDeleteSymbolicLink(SymbolicLinkName: PUNICODE_STRING) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoDetachDevice(TargetDevice: PDEVICE_OBJECT);
}
unsafe extern "C" {
    pub fn IoDisconnectInterrupt(InterruptObject: PKINTERRUPT);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_DISCONNECT_INTERRUPT_PARAMETERS {
    pub Version: ULONG,
    pub ConnectionContext: _IO_DISCONNECT_INTERRUPT_PARAMETERS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_DISCONNECT_INTERRUPT_PARAMETERS__bindgen_ty_1 {
    pub Generic: PVOID,
    pub InterruptObject: PKINTERRUPT,
    pub InterruptMessageTable: PIO_INTERRUPT_MESSAGE_INFO,
}
pub type IO_DISCONNECT_INTERRUPT_PARAMETERS = _IO_DISCONNECT_INTERRUPT_PARAMETERS;
pub type PIO_DISCONNECT_INTERRUPT_PARAMETERS = *mut _IO_DISCONNECT_INTERRUPT_PARAMETERS;
unsafe extern "C" {
    pub fn IoDisconnectInterruptEx(Parameters: PIO_DISCONNECT_INTERRUPT_PARAMETERS);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS {
    pub Version: ULONG,
    pub ConnectionContext: _IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS__bindgen_ty_1 {
    pub Generic: PVOID,
    pub InterruptObject: PKINTERRUPT,
    pub InterruptMessageTable: PIO_INTERRUPT_MESSAGE_INFO,
}
pub type IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS = _IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS;
pub type PIO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS =
*mut _IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS;
unsafe extern "C" {
    pub fn IoReportInterruptActive(Parameters: PIO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS);
}
unsafe extern "C" {
    pub fn IoReportInterruptInactive(Parameters: PIO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS);
}
unsafe extern "C" {
    pub fn IoGetAffinityInterrupt(
        InterruptObject: PKINTERRUPT,
        GroupAffinity: PGROUP_AFFINITY,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoFreeIrp(Irp: PIRP);
}
unsafe extern "C" {
    pub fn IoFreeMdl(Mdl: PMDL);
}
unsafe extern "C" {
    pub fn IoGetAttachedDeviceReference(DeviceObject: PDEVICE_OBJECT) -> PDEVICE_OBJECT;
}
unsafe extern "C" {
    pub fn IoGetDriverObjectExtension(
        DriverObject: PDRIVER_OBJECT,
        ClientIdentificationAddress: PVOID,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn IoGetCurrentProcess() -> PEPROCESS;
}
unsafe extern "C" {
    pub fn IoGetDeviceObjectPointer(
        ObjectName: PUNICODE_STRING,
        DesiredAccess: ACCESS_MASK,
        FileObject: *mut PFILE_OBJECT,
        DeviceObject: *mut PDEVICE_OBJECT,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoGetDmaAdapter(
        PhysicalDeviceObject: PDEVICE_OBJECT,
        DeviceDescription: *mut _DEVICE_DESCRIPTION,
        NumberOfMapRegisters: PULONG,
    ) -> *mut _DMA_ADAPTER;
}
pub type DMA_IOMMU_INTERFACE = _DMA_IOMMU_INTERFACE;
pub type PDMA_IOMMU_INTERFACE = *mut _DMA_IOMMU_INTERFACE;
unsafe extern "C" {
    pub fn IoGetIommuInterface(Version: ULONG, InterfaceOut: PDMA_IOMMU_INTERFACE) -> NTSTATUS;
}
pub type DMA_IOMMU_INTERFACE_EX = _DMA_IOMMU_INTERFACE_EX;
pub type PDMA_IOMMU_INTERFACE_EX = *mut _DMA_IOMMU_INTERFACE_EX;
unsafe extern "C" {
    pub fn IoGetIommuInterfaceEx(
        Version: ULONG,
        Flags: ULONGLONG,
        InterfaceOut: PDMA_IOMMU_INTERFACE_EX,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoForwardIrpSynchronously(DeviceObject: PDEVICE_OBJECT, Irp: PIRP) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn IoSynchronousCallDriver(DeviceObject: PDEVICE_OBJECT, Irp: PIRP) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoGetInitialStack() -> PVOID;
}
unsafe extern "C" {
    pub fn IoGetStackLimits(LowLimit: PULONG_PTR, HighLimit: PULONG_PTR);
}
unsafe extern "C" {
    pub fn IoWithinStackLimits(RegionStart: ULONG_PTR, RegionSize: SIZE_T) -> LOGICAL;
}
unsafe extern "C" {
    pub fn IoGetRelatedDeviceObject(FileObject: PFILE_OBJECT) -> PDEVICE_OBJECT;
}
unsafe extern "C" {
    pub fn IoGetTopLevelIrp() -> PIRP;
}
unsafe extern "C" {
    pub fn IoInitializeIrp(Irp: PIRP, PacketSize: USHORT, StackSize: CCHAR);
}
unsafe extern "C" {
    pub fn IoCleanupIrp(Irp: PIRP);
}
unsafe extern "C" {
    pub fn IoInitializeIrpEx(
        Irp: PIRP,
        DeviceObject: PDEVICE_OBJECT,
        PacketSize: USHORT,
        StackSize: CCHAR,
    );
}
unsafe extern "C" {
    pub fn IoInitializeTimer(
        DeviceObject: PDEVICE_OBJECT,
        TimerRoutine: PIO_TIMER_ROUTINE,
        Context: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoReuseIrp(Irp: PIRP, Iostatus: NTSTATUS);
}
unsafe extern "C" {
    pub fn IoRegisterShutdownNotification(DeviceObject: PDEVICE_OBJECT) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoRegisterLastChanceShutdownNotification(DeviceObject: PDEVICE_OBJECT) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoReleaseCancelSpinLock(Irql: KIRQL);
}
unsafe extern "C" {
    pub fn IoRemoveShareAccess(FileObject: PFILE_OBJECT, ShareAccess: PSHARE_ACCESS);
}
unsafe extern "C" {
    pub fn IoRemoveLinkShareAccess(
        FileObject: PFILE_OBJECT,
        ShareAccess: PSHARE_ACCESS,
        LinkShareAccess: PLINK_SHARE_ACCESS,
    );
}
unsafe extern "C" {
    pub fn IoRemoveLinkShareAccessEx(
        FileObject: PFILE_OBJECT,
        ShareAccess: PSHARE_ACCESS,
        LinkShareAccess: PLINK_SHARE_ACCESS,
        IoShareAccessFlags: ULONG,
    );
}
unsafe extern "C" {
    pub fn IoSetCompletionRoutineEx(
        DeviceObject: PDEVICE_OBJECT,
        Irp: PIRP,
        CompletionRoutine: PIO_COMPLETION_ROUTINE,
        Context: PVOID,
        InvokeOnSuccess: BOOLEAN,
        InvokeOnError: BOOLEAN,
        InvokeOnCancel: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoSetShareAccess(
        DesiredAccess: ACCESS_MASK,
        DesiredShareAccess: ULONG,
        FileObject: PFILE_OBJECT,
        ShareAccess: PSHARE_ACCESS,
    );
}
unsafe extern "C" {
    pub fn IoSetShareAccessEx(
        DesiredAccess: ACCESS_MASK,
        DesiredShareAccess: ULONG,
        FileObject: PFILE_OBJECT,
        ShareAccess: PSHARE_ACCESS,
        WritePermission: PBOOLEAN,
    );
}
unsafe extern "C" {
    pub fn IoSetLinkShareAccess(
        DesiredAccess: ACCESS_MASK,
        DesiredShareAccess: ULONG,
        FileObject: PFILE_OBJECT,
        ShareAccess: PSHARE_ACCESS,
        LinkShareAccess: PLINK_SHARE_ACCESS,
        IoShareAccessFlags: ULONG,
    );
}
unsafe extern "C" {
    pub fn IoSetTopLevelIrp(Irp: PIRP);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_REMOVE_LOCK_TRACKING_BLOCK {
    _unused: [u8; 0],
}
pub type PIO_REMOVE_LOCK_TRACKING_BLOCK = *mut _IO_REMOVE_LOCK_TRACKING_BLOCK;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_REMOVE_LOCK_COMMON_BLOCK {
    pub Removed: BOOLEAN,
    pub Reserved: [BOOLEAN; 3usize],
    pub IoCount: LONG,
    pub RemoveEvent: KEVENT,
}
pub type IO_REMOVE_LOCK_COMMON_BLOCK = _IO_REMOVE_LOCK_COMMON_BLOCK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_REMOVE_LOCK_DBG_BLOCK {
    pub Signature: LONG,
    pub HighWatermark: ULONG,
    pub MaxLockedTicks: LONGLONG,
    pub AllocateTag: LONG,
    pub LockList: LIST_ENTRY,
    pub Spin: KSPIN_LOCK,
    pub LowMemoryCount: LONG,
    pub Reserved1: [ULONG; 4usize],
    pub Reserved2: PVOID,
    pub Blocks: PIO_REMOVE_LOCK_TRACKING_BLOCK,
}
pub type IO_REMOVE_LOCK_DBG_BLOCK = _IO_REMOVE_LOCK_DBG_BLOCK;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_REMOVE_LOCK {
    pub Common: IO_REMOVE_LOCK_COMMON_BLOCK,
}
pub type IO_REMOVE_LOCK = _IO_REMOVE_LOCK;
pub type PIO_REMOVE_LOCK = *mut _IO_REMOVE_LOCK;
unsafe extern "C" {
    pub fn IoInitializeRemoveLockEx(
        Lock: PIO_REMOVE_LOCK,
        AllocateTag: ULONG,
        MaxLockedMinutes: ULONG,
        HighWatermark: ULONG,
        RemlockSize: ULONG,
    );
}
unsafe extern "C" {
    pub fn IoAcquireRemoveLockEx(
        RemoveLock: PIO_REMOVE_LOCK,
        Tag: PVOID,
        File: PCSTR,
        Line: ULONG,
        RemlockSize: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoReleaseRemoveLockEx(RemoveLock: PIO_REMOVE_LOCK, Tag: PVOID, RemlockSize: ULONG);
}
unsafe extern "C" {
    pub fn IoReleaseRemoveLockAndWaitEx(
        RemoveLock: PIO_REMOVE_LOCK,
        Tag: PVOID,
        RemlockSize: ULONG,
    );
}
unsafe extern "C" {
    pub fn IoSizeOfIrpEx(DeviceObject: PDEVICE_OBJECT, StackSize: CCHAR) -> USHORT;
}
unsafe extern "C" {
    pub fn IoStartNextPacket(DeviceObject: PDEVICE_OBJECT, Cancelable: BOOLEAN);
}
unsafe extern "C" {
    pub fn IoStartNextPacketByKey(DeviceObject: PDEVICE_OBJECT, Cancelable: BOOLEAN, Key: ULONG);
}
unsafe extern "C" {
    pub fn IoStartPacket(
        DeviceObject: PDEVICE_OBJECT,
        Irp: PIRP,
        Key: PULONG,
        CancelFunction: PDRIVER_CANCEL,
    );
}
unsafe extern "C" {
    pub fn IoSetStartIoAttributes(
        DeviceObject: PDEVICE_OBJECT,
        DeferredStartIo: BOOLEAN,
        NonCancelable: BOOLEAN,
    );
}
unsafe extern "C" {
    pub fn IoStartTimer(DeviceObject: PDEVICE_OBJECT);
}
unsafe extern "C" {
    pub fn IoStopTimer(DeviceObject: PDEVICE_OBJECT);
}
unsafe extern "C" {
    pub fn IoUnregisterShutdownNotification(DeviceObject: PDEVICE_OBJECT);
}
unsafe extern "C" {
    pub fn IoUpdateShareAccess(FileObject: PFILE_OBJECT, ShareAccess: PSHARE_ACCESS);
}
unsafe extern "C" {
    pub fn IoUpdateLinkShareAccess(
        FileObject: PFILE_OBJECT,
        ShareAccess: PSHARE_ACCESS,
        LinkShareAccess: PLINK_SHARE_ACCESS,
    );
}
unsafe extern "C" {
    pub fn IoUpdateLinkShareAccessEx(
        FileObject: PFILE_OBJECT,
        ShareAccess: PSHARE_ACCESS,
        LinkShareAccess: PLINK_SHARE_ACCESS,
        IoShareAccessFlags: ULONG,
    );
}
unsafe extern "C" {
    pub fn IoWriteErrorLogEntry(ElEntry: PVOID);
}
unsafe extern "C" {
    pub fn IoCreateSystemThread(
        IoObject: PVOID,
        ThreadHandle: PHANDLE,
        DesiredAccess: ULONG,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        ProcessHandle: HANDLE,
        ClientId: PCLIENT_ID,
        StartRoutine: PKSTART_ROUTINE,
        StartContext: PVOID,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_WORKITEM {
    _unused: [u8; 0],
}
pub type PIO_WORKITEM = *mut _IO_WORKITEM;
pub type IO_WORKITEM_ROUTINE =
::core::option::Option<unsafe extern "C" fn(DeviceObject: PDEVICE_OBJECT, Context: PVOID)>;
pub type PIO_WORKITEM_ROUTINE = IO_WORKITEM_ROUTINE;
unsafe extern "C" {
    pub fn IoAllocateWorkItem(DeviceObject: PDEVICE_OBJECT) -> PIO_WORKITEM;
}
unsafe extern "C" {
    pub fn IoFreeWorkItem(IoWorkItem: PIO_WORKITEM);
}
unsafe extern "C" {
    pub fn IoQueueWorkItem(
        IoWorkItem: PIO_WORKITEM,
        WorkerRoutine: PIO_WORKITEM_ROUTINE,
        QueueType: WORK_QUEUE_TYPE,
        Context: PVOID,
    );
}
pub type IO_WORKITEM_ROUTINE_EX = ::core::option::Option<
    unsafe extern "C" fn(IoObject: PVOID, Context: PVOID, IoWorkItem: PIO_WORKITEM),
>;
pub type PIO_WORKITEM_ROUTINE_EX = IO_WORKITEM_ROUTINE_EX;
unsafe extern "C" {
    pub fn IoQueueWorkItemEx(
        IoWorkItem: PIO_WORKITEM,
        WorkerRoutine: PIO_WORKITEM_ROUTINE_EX,
        QueueType: WORK_QUEUE_TYPE,
        Context: PVOID,
    );
}
unsafe extern "C" {
    pub fn IoSizeofWorkItem() -> ULONG;
}
unsafe extern "C" {
    pub fn IoInitializeWorkItem(IoObject: PVOID, IoWorkItem: PIO_WORKITEM);
}
unsafe extern "C" {
    pub fn IoUninitializeWorkItem(IoWorkItem: PIO_WORKITEM);
}
unsafe extern "C" {
    pub fn IoTryQueueWorkItem(
        IoWorkItem: PIO_WORKITEM,
        WorkerRoutine: PIO_WORKITEM_ROUTINE_EX,
        QueueType: WORK_QUEUE_TYPE,
        Context: PVOID,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn IoWMIRegistrationControl(DeviceObject: PDEVICE_OBJECT, Action: ULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoWMIAllocateInstanceIds(
        Guid: LPCGUID,
        InstanceCount: ULONG,
        FirstInstanceId: *mut ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoWMISuggestInstanceName(
        PhysicalDeviceObject: PDEVICE_OBJECT,
        SymbolicLinkName: PUNICODE_STRING,
        CombineNames: BOOLEAN,
        SuggestedInstanceName: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoWMIWriteEvent(WnodeEventItem: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoWMIDeviceObjectToProviderId(DeviceObject: PDEVICE_OBJECT) -> ULONG;
}
unsafe extern "C" {
    pub fn IoWMIOpenBlock(
        Guid: LPCGUID,
        DesiredAccess: ULONG,
        DataBlockObject: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoWMIQueryAllData(
        DataBlockObject: PVOID,
        InOutBufferSize: PULONG,
        OutBuffer: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoWMIQueryAllDataMultiple(
        DataBlockObjectList: *mut PVOID,
        ObjectCount: ULONG,
        InOutBufferSize: PULONG,
        OutBuffer: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoWMIQuerySingleInstance(
        DataBlockObject: PVOID,
        InstanceName: PUNICODE_STRING,
        InOutBufferSize: PULONG,
        OutBuffer: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoWMIQuerySingleInstanceMultiple(
        DataBlockObjectList: *mut PVOID,
        InstanceNames: PUNICODE_STRING,
        ObjectCount: ULONG,
        InOutBufferSize: PULONG,
        OutBuffer: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoWMISetSingleInstance(
        DataBlockObject: PVOID,
        InstanceName: PUNICODE_STRING,
        Version: ULONG,
        ValueBufferSize: ULONG,
        ValueBuffer: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoWMISetSingleItem(
        DataBlockObject: PVOID,
        InstanceName: PUNICODE_STRING,
        DataItemId: ULONG,
        Version: ULONG,
        ValueBufferSize: ULONG,
        ValueBuffer: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoWMIExecuteMethod(
        DataBlockObject: PVOID,
        InstanceName: PUNICODE_STRING,
        MethodId: ULONG,
        InBufferSize: ULONG,
        OutBufferSize: PULONG,
        InOutBuffer: PUCHAR,
    ) -> NTSTATUS;
}
pub type FWMI_NOTIFICATION_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Wnode: PVOID, Context: PVOID)>;
pub type WMI_NOTIFICATION_CALLBACK = FWMI_NOTIFICATION_CALLBACK;
unsafe extern "C" {
    pub fn IoWMISetNotificationCallback(
        Object: PVOID,
        Callback: WMI_NOTIFICATION_CALLBACK,
        Context: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoWMIHandleToInstanceName(
        DataBlockObject: PVOID,
        FileHandle: HANDLE,
        InstanceName: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoWMIDeviceObjectToInstanceName(
        DataBlockObject: PVOID,
        DeviceObject: PDEVICE_OBJECT,
        InstanceName: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoIs32bitProcess(Irp: PIRP) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn IoIsInitiator32bitProcess(Irp: PIRP) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn IoFreeErrorLogEntry(ElEntry: PVOID);
}
pub type IO_CSQ = _IO_CSQ;
pub type PIO_CSQ = *mut _IO_CSQ;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_CSQ_IRP_CONTEXT {
    pub Type: ULONG,
    pub Irp: PIRP,
    pub Csq: PIO_CSQ,
}
pub type IO_CSQ_IRP_CONTEXT = _IO_CSQ_IRP_CONTEXT;
pub type PIO_CSQ_IRP_CONTEXT = *mut _IO_CSQ_IRP_CONTEXT;
pub type IO_CSQ_INSERT_IRP =
::core::option::Option<unsafe extern "C" fn(Csq: *mut _IO_CSQ, Irp: PIRP)>;
pub type PIO_CSQ_INSERT_IRP = IO_CSQ_INSERT_IRP;
pub type IO_CSQ_INSERT_IRP_EX = ::core::option::Option<
    unsafe extern "C" fn(Csq: *mut _IO_CSQ, Irp: PIRP, InsertContext: PVOID) -> NTSTATUS,
>;
pub type PIO_CSQ_INSERT_IRP_EX = IO_CSQ_INSERT_IRP_EX;
pub type IO_CSQ_REMOVE_IRP = ::core::option::Option<unsafe extern "C" fn(Csq: PIO_CSQ, Irp: PIRP)>;
pub type PIO_CSQ_REMOVE_IRP = IO_CSQ_REMOVE_IRP;
pub type IO_CSQ_PEEK_NEXT_IRP = ::core::option::Option<
    unsafe extern "C" fn(Csq: PIO_CSQ, Irp: PIRP, PeekContext: PVOID) -> PIRP,
>;
pub type PIO_CSQ_PEEK_NEXT_IRP = IO_CSQ_PEEK_NEXT_IRP;
pub type IO_CSQ_ACQUIRE_LOCK =
::core::option::Option<unsafe extern "C" fn(Csq: PIO_CSQ, Irql: PKIRQL)>;
pub type PIO_CSQ_ACQUIRE_LOCK = IO_CSQ_ACQUIRE_LOCK;
pub type IO_CSQ_RELEASE_LOCK =
::core::option::Option<unsafe extern "C" fn(Csq: PIO_CSQ, Irql: KIRQL)>;
pub type PIO_CSQ_RELEASE_LOCK = IO_CSQ_RELEASE_LOCK;
pub type IO_CSQ_COMPLETE_CANCELED_IRP =
::core::option::Option<unsafe extern "C" fn(Csq: PIO_CSQ, Irp: PIRP)>;
pub type PIO_CSQ_COMPLETE_CANCELED_IRP = IO_CSQ_COMPLETE_CANCELED_IRP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_CSQ {
    pub Type: ULONG,
    pub CsqInsertIrp: PIO_CSQ_INSERT_IRP,
    pub CsqRemoveIrp: PIO_CSQ_REMOVE_IRP,
    pub CsqPeekNextIrp: PIO_CSQ_PEEK_NEXT_IRP,
    pub CsqAcquireLock: PIO_CSQ_ACQUIRE_LOCK,
    pub CsqReleaseLock: PIO_CSQ_RELEASE_LOCK,
    pub CsqCompleteCanceledIrp: PIO_CSQ_COMPLETE_CANCELED_IRP,
    pub ReservePointer: PVOID,
}
unsafe extern "C" {
    pub fn IoCsqInitialize(
        Csq: PIO_CSQ,
        CsqInsertIrp: PIO_CSQ_INSERT_IRP,
        CsqRemoveIrp: PIO_CSQ_REMOVE_IRP,
        CsqPeekNextIrp: PIO_CSQ_PEEK_NEXT_IRP,
        CsqAcquireLock: PIO_CSQ_ACQUIRE_LOCK,
        CsqReleaseLock: PIO_CSQ_RELEASE_LOCK,
        CsqCompleteCanceledIrp: PIO_CSQ_COMPLETE_CANCELED_IRP,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoCsqInitializeEx(
        Csq: PIO_CSQ,
        CsqInsertIrp: PIO_CSQ_INSERT_IRP_EX,
        CsqRemoveIrp: PIO_CSQ_REMOVE_IRP,
        CsqPeekNextIrp: PIO_CSQ_PEEK_NEXT_IRP,
        CsqAcquireLock: PIO_CSQ_ACQUIRE_LOCK,
        CsqReleaseLock: PIO_CSQ_RELEASE_LOCK,
        CsqCompleteCanceledIrp: PIO_CSQ_COMPLETE_CANCELED_IRP,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoCsqInsertIrp(Csq: PIO_CSQ, Irp: PIRP, Context: PIO_CSQ_IRP_CONTEXT);
}
unsafe extern "C" {
    pub fn IoCsqInsertIrpEx(
        Csq: PIO_CSQ,
        Irp: PIRP,
        Context: PIO_CSQ_IRP_CONTEXT,
        InsertContext: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoCsqRemoveNextIrp(Csq: PIO_CSQ, PeekContext: PVOID) -> PIRP;
}
unsafe extern "C" {
    pub fn IoCsqRemoveIrp(Csq: PIO_CSQ, Context: PIO_CSQ_IRP_CONTEXT) -> PIRP;
}
unsafe extern "C" {
    pub fn IoValidateDeviceIoControlAccess(Irp: PIRP, RequiredAccess: ULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoGetIoPriorityHint(Irp: PIRP) -> IO_PRIORITY_HINT;
}
unsafe extern "C" {
    pub fn IoSetIoPriorityHint(Irp: PIRP, PriorityHint: IO_PRIORITY_HINT) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoAllocateSfioStreamIdentifier(
        FileObject: PFILE_OBJECT,
        Length: ULONG,
        Signature: PVOID,
        StreamIdentifier: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoGetSfioStreamIdentifier(FileObject: PFILE_OBJECT, Signature: PVOID) -> PVOID;
}
unsafe extern "C" {
    pub fn IoFreeSfioStreamIdentifier(FileObject: PFILE_OBJECT, Signature: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoGetIoAttributionHandle(Irp: PIRP, IoAttributionHandle: *mut PVOID) -> NTSTATUS;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_ATTRIBUTION_INFORMATION {
    pub Version: ULONG,
    pub Flags: _IO_ATTRIBUTION_INFORMATION__bindgen_ty_1,
    pub Length: ULONG,
    pub ServiceStartTime: ULONGLONG,
    pub CurrentTime: ULONGLONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_ATTRIBUTION_INFORMATION__bindgen_ty_1 {
    pub __bindgen_anon_1: _IO_ATTRIBUTION_INFORMATION__bindgen_ty_1__bindgen_ty_1,
    pub AllFlags: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_ATTRIBUTION_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _IO_ATTRIBUTION_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn MajorCode(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_MajorCode(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MajorCode_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MajorCode_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IoStart(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoStart(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IoStart_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IoStart_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn QueueOnly(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_QueueOnly(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn QueueOnly_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_QueueOnly_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IoFailed(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoFailed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IoFailed_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IoFailed_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VirtualDevice(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VirtualDevice(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VirtualDevice_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VirtualDevice_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Spare(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_Spare(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                20u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                20u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MajorCode: ULONG,
        IoStart: ULONG,
        QueueOnly: ULONG,
        IoFailed: ULONG,
        VirtualDevice: ULONG,
        Spare: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let MajorCode: u32 = unsafe { ::core::mem::transmute(MajorCode) };
            MajorCode as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let IoStart: u32 = unsafe { ::core::mem::transmute(IoStart) };
            IoStart as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let QueueOnly: u32 = unsafe { ::core::mem::transmute(QueueOnly) };
            QueueOnly as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let IoFailed: u32 = unsafe { ::core::mem::transmute(IoFailed) };
            IoFailed as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let VirtualDevice: u32 = unsafe { ::core::mem::transmute(VirtualDevice) };
            VirtualDevice as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
            Spare as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type IO_ATTRIBUTION_INFORMATION = _IO_ATTRIBUTION_INFORMATION;
pub type PIO_ATTRIBUTION_INFORMATION = *mut _IO_ATTRIBUTION_INFORMATION;
unsafe extern "C" {
    pub fn IoRecordIoAttribution(
        OpaqueHandle: PVOID,
        AttributionInformation: *mut IO_ATTRIBUTION_INFORMATION,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoSetIoAttributionIrp(Irp: PIRP, AttributionSource: PVOID, Flags: ULONG) -> NTSTATUS;
}
pub const _IO_ACCESS_TYPE_ReadAccess: _IO_ACCESS_TYPE = 0;
pub const _IO_ACCESS_TYPE_WriteAccess: _IO_ACCESS_TYPE = 1;
pub const _IO_ACCESS_TYPE_ModifyAccess: _IO_ACCESS_TYPE = 2;
pub type _IO_ACCESS_TYPE = core::ffi::c_int;
pub use self::_IO_ACCESS_TYPE as IO_ACCESS_TYPE;
pub const _IO_ACCESS_MODE_SequentialAccess: _IO_ACCESS_MODE = 0;
pub const _IO_ACCESS_MODE_RandomAccess: _IO_ACCESS_MODE = 1;
pub type _IO_ACCESS_MODE = core::ffi::c_int;
pub use self::_IO_ACCESS_MODE as IO_ACCESS_MODE;
pub const _IO_CONTAINER_NOTIFICATION_CLASS_IoSessionStateNotification:
_IO_CONTAINER_NOTIFICATION_CLASS = 0;
pub const _IO_CONTAINER_NOTIFICATION_CLASS_IoMaxContainerNotificationClass:
_IO_CONTAINER_NOTIFICATION_CLASS = 1;
pub type _IO_CONTAINER_NOTIFICATION_CLASS = core::ffi::c_int;
pub use self::_IO_CONTAINER_NOTIFICATION_CLASS as IO_CONTAINER_NOTIFICATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_SESSION_STATE_NOTIFICATION {
    pub Size: ULONG,
    pub Flags: ULONG,
    pub IoObject: PVOID,
    pub EventMask: ULONG,
    pub Context: PVOID,
}
pub type IO_SESSION_STATE_NOTIFICATION = _IO_SESSION_STATE_NOTIFICATION;
pub type PIO_SESSION_STATE_NOTIFICATION = *mut _IO_SESSION_STATE_NOTIFICATION;
pub const _IO_CONTAINER_INFORMATION_CLASS_IoSessionStateInformation:
_IO_CONTAINER_INFORMATION_CLASS = 0;
pub const _IO_CONTAINER_INFORMATION_CLASS_IoMaxContainerInformationClass:
_IO_CONTAINER_INFORMATION_CLASS = 1;
pub type _IO_CONTAINER_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_IO_CONTAINER_INFORMATION_CLASS as IO_CONTAINER_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_SESSION_STATE_INFORMATION {
    pub SessionId: ULONG,
    pub SessionState: IO_SESSION_STATE,
    pub LocalSession: BOOLEAN,
}
pub type IO_SESSION_STATE_INFORMATION = _IO_SESSION_STATE_INFORMATION;
pub type PIO_SESSION_STATE_INFORMATION = *mut _IO_SESSION_STATE_INFORMATION;
unsafe extern "C" {
    pub fn IoGetContainerInformation(
        InformationClass: IO_CONTAINER_INFORMATION_CLASS,
        ContainerObject: PVOID,
        Buffer: PVOID,
        BufferLength: ULONG,
    ) -> NTSTATUS;
}
pub type PIO_CONTAINER_NOTIFICATION_FUNCTION =
::core::option::Option<unsafe extern "C" fn() -> NTSTATUS>;
pub type IO_SESSION_NOTIFICATION_FUNCTION = ::core::option::Option<
    unsafe extern "C" fn(
        SessionObject: PVOID,
        IoObject: PVOID,
        Event: ULONG,
        Context: PVOID,
        NotificationPayload: PVOID,
        PayloadLength: ULONG,
    ) -> NTSTATUS,
>;
pub type PIO_SESSION_NOTIFICATION_FUNCTION = IO_SESSION_NOTIFICATION_FUNCTION;
unsafe extern "C" {
    pub fn IoRegisterContainerNotification(
        NotificationClass: IO_CONTAINER_NOTIFICATION_CLASS,
        CallbackFunction: PIO_CONTAINER_NOTIFICATION_FUNCTION,
        NotificationInformation: PVOID,
        NotificationInformationLength: ULONG,
        CallbackRegistration: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoUnregisterContainerNotification(CallbackRegistration: PVOID);
}
unsafe extern "C" {
    pub fn IoReserveKsrPersistentMemory(
        DriverObject: PDRIVER_OBJECT,
        PhysicalDeviceObject: PDEVICE_OBJECT,
        Size: SIZE_T,
        Flags: ULONG,
        DataHandle: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoFreeKsrPersistentMemory(DataHandle: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoQueryKsrPersistentMemorySize(
        DriverObject: PDRIVER_OBJECT,
        PhysicalDeviceObject: PDEVICE_OBJECT,
        BufferSize: PSIZE_T,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoAcquireKsrPersistentMemory(
        DriverObject: PDRIVER_OBJECT,
        PhysicalDeviceObject: PDEVICE_OBJECT,
        Buffer: PVOID,
        Size: PSIZE_T,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoWriteKsrPersistentMemory(DataHandle: PVOID, Buffer: PVOID, Size: SIZE_T) -> NTSTATUS;
}
pub type IO_PERSISTED_MEMORY_ENUMERATION_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        DriverObject: PDRIVER_OBJECT,
        PhysicalDeviceObject: PDEVICE_OBJECT,
        PhysicalDeviceId: PUNICODE_STRING,
        DataTag: PUSHORT,
        DataVersion: PULONG,
        Context: PVOID,
    ) -> NTSTATUS,
>;
pub type PIO_PERSISTED_MEMORY_ENUMERATION_CALLBACK = IO_PERSISTED_MEMORY_ENUMERATION_CALLBACK;
unsafe extern "C" {
    pub fn IoEnumerateKsrPersistentMemoryEx(
        DriverObject: PDRIVER_OBJECT,
        PhysicalDeviceObject: PDEVICE_OBJECT,
        PhysicalDeviceId: PUNICODE_STRING,
        Callback: PIO_PERSISTED_MEMORY_ENUMERATION_CALLBACK,
        CallbackContext: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoReserveKsrPersistentMemoryEx(
        DriverObject: PDRIVER_OBJECT,
        PhysicalDeviceObject: PDEVICE_OBJECT,
        PhysicalDeviceId: PUNICODE_STRING,
        DataTag: PUSHORT,
        DataVersion: ULONG,
        Size: SIZE_T,
        Flags: ULONG,
        DataHandle: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoQueryKsrPersistentMemorySizeEx(
        DriverObject: PDRIVER_OBJECT,
        PhysicalDeviceObject: PDEVICE_OBJECT,
        PhysicalDeviceId: PUNICODE_STRING,
        DataTag: PUSHORT,
        DataVersion: PULONG,
        BufferSize: PSIZE_T,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoAcquireKsrPersistentMemoryEx(
        DriverObject: PDRIVER_OBJECT,
        PhysicalDeviceObject: PDEVICE_OBJECT,
        PhysicalDeviceId: PUNICODE_STRING,
        DataTag: PUSHORT,
        DataVersion: PULONG,
        Buffer: PVOID,
        Size: PSIZE_T,
    ) -> NTSTATUS;
}
pub type TRACEHANDLE = ULONG64;
pub type PTRACEHANDLE = *mut ULONG64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETW_TRACE_SESSION_SETTINGS {
    pub Version: ULONG,
    pub BufferSize: ULONG,
    pub MinimumBuffers: ULONG,
    pub MaximumBuffers: ULONG,
    pub LoggerMode: ULONG,
    pub FlushTimer: ULONG,
    pub FlushThreshold: ULONG,
    pub ClockType: ULONG,
}
pub type ETW_TRACE_SESSION_SETTINGS = _ETW_TRACE_SESSION_SETTINGS;
pub type PETW_TRACE_SESSION_SETTINGS = *mut _ETW_TRACE_SESSION_SETTINGS;
pub const _TRACE_INFORMATION_CLASS_TraceIdClass: _TRACE_INFORMATION_CLASS = 0;
pub const _TRACE_INFORMATION_CLASS_TraceHandleClass: _TRACE_INFORMATION_CLASS = 1;
pub const _TRACE_INFORMATION_CLASS_TraceEnableFlagsClass: _TRACE_INFORMATION_CLASS = 2;
pub const _TRACE_INFORMATION_CLASS_TraceEnableLevelClass: _TRACE_INFORMATION_CLASS = 3;
pub const _TRACE_INFORMATION_CLASS_GlobalLoggerHandleClass: _TRACE_INFORMATION_CLASS = 4;
pub const _TRACE_INFORMATION_CLASS_EventLoggerHandleClass: _TRACE_INFORMATION_CLASS = 5;
pub const _TRACE_INFORMATION_CLASS_AllLoggerHandlesClass: _TRACE_INFORMATION_CLASS = 6;
pub const _TRACE_INFORMATION_CLASS_TraceHandleByNameClass: _TRACE_INFORMATION_CLASS = 7;
pub const _TRACE_INFORMATION_CLASS_LoggerEventsLostClass: _TRACE_INFORMATION_CLASS = 8;
pub const _TRACE_INFORMATION_CLASS_TraceSessionSettingsClass: _TRACE_INFORMATION_CLASS = 9;
pub const _TRACE_INFORMATION_CLASS_LoggerEventsLoggedClass: _TRACE_INFORMATION_CLASS = 10;
pub const _TRACE_INFORMATION_CLASS_DiskIoNotifyRoutinesClass: _TRACE_INFORMATION_CLASS = 11;
pub const _TRACE_INFORMATION_CLASS_TraceInformationClassReserved1: _TRACE_INFORMATION_CLASS = 12;
pub const _TRACE_INFORMATION_CLASS_FltIoNotifyRoutinesClass: _TRACE_INFORMATION_CLASS = 13;
pub const _TRACE_INFORMATION_CLASS_TraceInformationClassReserved2: _TRACE_INFORMATION_CLASS = 14;
pub const _TRACE_INFORMATION_CLASS_WdfNotifyRoutinesClass: _TRACE_INFORMATION_CLASS = 15;
pub const _TRACE_INFORMATION_CLASS_MaxTraceInformationClass: _TRACE_INFORMATION_CLASS = 16;
pub type _TRACE_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_TRACE_INFORMATION_CLASS as TRACE_INFORMATION_CLASS;
unsafe extern "C" {
    pub fn WmiQueryTraceInformation(
        TraceInformationClass: TRACE_INFORMATION_CLASS,
        TraceInformation: PVOID,
        TraceInformationLength: ULONG,
        RequiredLength: PULONG,
        Buffer: PVOID,
    ) -> NTSTATUS;
}
pub type REGHANDLE = ULONGLONG;
pub type PREGHANDLE = *mut ULONGLONG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EVENT_DATA_DESCRIPTOR {
    pub Ptr: ULONGLONG,
    pub Size: ULONG,
    pub __bindgen_anon_1: _EVENT_DATA_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EVENT_DATA_DESCRIPTOR__bindgen_ty_1 {
    pub Reserved: ULONG,
    pub __bindgen_anon_1: _EVENT_DATA_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_DATA_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    pub Type: UCHAR,
    pub Reserved1: UCHAR,
    pub Reserved2: USHORT,
}
pub type EVENT_DATA_DESCRIPTOR = _EVENT_DATA_DESCRIPTOR;
pub type PEVENT_DATA_DESCRIPTOR = *mut _EVENT_DATA_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_DESCRIPTOR {
    pub Id: USHORT,
    pub Version: UCHAR,
    pub Channel: UCHAR,
    pub Level: UCHAR,
    pub Opcode: UCHAR,
    pub Task: USHORT,
    pub Keyword: ULONGLONG,
}
pub type EVENT_DESCRIPTOR = _EVENT_DESCRIPTOR;
pub type PEVENT_DESCRIPTOR = *mut _EVENT_DESCRIPTOR;
pub type PCEVENT_DESCRIPTOR = *const EVENT_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_FILTER_DESCRIPTOR {
    pub Ptr: ULONGLONG,
    pub Size: ULONG,
    pub Type: ULONG,
}
pub type EVENT_FILTER_DESCRIPTOR = _EVENT_FILTER_DESCRIPTOR;
pub type PEVENT_FILTER_DESCRIPTOR = *mut _EVENT_FILTER_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_FILTER_HEADER {
    pub Id: USHORT,
    pub Version: UCHAR,
    pub Reserved: [UCHAR; 5usize],
    pub InstanceId: ULONGLONG,
    pub Size: ULONG,
    pub NextOffset: ULONG,
}
pub type EVENT_FILTER_HEADER = _EVENT_FILTER_HEADER;
pub type PEVENT_FILTER_HEADER = *mut _EVENT_FILTER_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_FILTER_EVENT_ID {
    pub FilterIn: BOOLEAN,
    pub Reserved: UCHAR,
    pub Count: USHORT,
    pub Events: [USHORT; 1usize],
}
pub type EVENT_FILTER_EVENT_ID = _EVENT_FILTER_EVENT_ID;
pub type PEVENT_FILTER_EVENT_ID = *mut _EVENT_FILTER_EVENT_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_FILTER_EVENT_NAME {
    pub MatchAnyKeyword: ULONGLONG,
    pub MatchAllKeyword: ULONGLONG,
    pub Level: UCHAR,
    pub FilterIn: BOOLEAN,
    pub NameCount: USHORT,
    pub Names: [UCHAR; 1usize],
}
pub type EVENT_FILTER_EVENT_NAME = _EVENT_FILTER_EVENT_NAME;
pub type PEVENT_FILTER_EVENT_NAME = *mut _EVENT_FILTER_EVENT_NAME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_FILTER_LEVEL_KW {
    pub MatchAnyKeyword: ULONGLONG,
    pub MatchAllKeyword: ULONGLONG,
    pub Level: UCHAR,
    pub FilterIn: BOOLEAN,
}
pub type EVENT_FILTER_LEVEL_KW = _EVENT_FILTER_LEVEL_KW;
pub type PEVENT_FILTER_LEVEL_KW = *mut _EVENT_FILTER_LEVEL_KW;
pub const _EVENT_INFO_CLASS_EventProviderBinaryTrackInfo: _EVENT_INFO_CLASS = 0;
pub const _EVENT_INFO_CLASS_EventProviderSetReserved1: _EVENT_INFO_CLASS = 1;
pub const _EVENT_INFO_CLASS_EventProviderSetTraits: _EVENT_INFO_CLASS = 2;
pub const _EVENT_INFO_CLASS_EventProviderUseDescriptorType: _EVENT_INFO_CLASS = 3;
pub const _EVENT_INFO_CLASS_MaxEventInfo: _EVENT_INFO_CLASS = 4;
pub type _EVENT_INFO_CLASS = core::ffi::c_int;
pub use self::_EVENT_INFO_CLASS as EVENT_INFO_CLASS;
pub type PETWENABLECALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: LPCGUID,
        arg2: ULONG,
        arg3: UCHAR,
        arg4: ULONGLONG,
        arg5: ULONGLONG,
        arg6: PEVENT_FILTER_DESCRIPTOR,
        arg7: PVOID,
    ),
>;
unsafe extern "C" {
    pub fn EtwRegister(
        ProviderId: LPCGUID,
        EnableCallback: PETWENABLECALLBACK,
        CallbackContext: PVOID,
        RegHandle: PREGHANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn EtwUnregister(RegHandle: REGHANDLE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn EtwSetInformation(
        RegHandle: REGHANDLE,
        InformationClass: EVENT_INFO_CLASS,
        EventInformation: PVOID,
        InformationLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn EtwEventEnabled(RegHandle: REGHANDLE, EventDescriptor: PCEVENT_DESCRIPTOR) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn EtwProviderEnabled(RegHandle: REGHANDLE, Level: UCHAR, Keyword: ULONGLONG) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn EtwActivityIdControl(ControlCode: ULONG, ActivityId: LPGUID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn EtwWrite(
        RegHandle: REGHANDLE,
        EventDescriptor: PCEVENT_DESCRIPTOR,
        ActivityId: LPCGUID,
        UserDataCount: ULONG,
        UserData: PEVENT_DATA_DESCRIPTOR,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn EtwWriteTransfer(
        RegHandle: REGHANDLE,
        EventDescriptor: PCEVENT_DESCRIPTOR,
        ActivityId: LPCGUID,
        RelatedActivityId: LPCGUID,
        UserDataCount: ULONG,
        UserData: PEVENT_DATA_DESCRIPTOR,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn EtwWriteString(
        RegHandle: REGHANDLE,
        Level: UCHAR,
        Keyword: ULONGLONG,
        ActivityId: LPCGUID,
        String: PCWSTR,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn EtwWriteEx(
        RegHandle: REGHANDLE,
        EventDescriptor: PCEVENT_DESCRIPTOR,
        Filter: ULONG64,
        Flags: ULONG,
        ActivityId: LPCGUID,
        RelatedActivityId: LPCGUID,
        UserDataCount: ULONG,
        UserData: PEVENT_DATA_DESCRIPTOR,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeEtwWriteKMCveEvent(
        CveId: PCUNICODE_STRING,
        AdditionalDetails: PCUNICODE_STRING,
    ) -> NTSTATUS;
}
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyDeviceDescription: DEVICE_REGISTRY_PROPERTY = 0;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyHardwareID: DEVICE_REGISTRY_PROPERTY = 1;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyCompatibleIDs: DEVICE_REGISTRY_PROPERTY = 2;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyBootConfiguration: DEVICE_REGISTRY_PROPERTY = 3;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyBootConfigurationTranslated:
DEVICE_REGISTRY_PROPERTY = 4;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyClassName: DEVICE_REGISTRY_PROPERTY = 5;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyClassGuid: DEVICE_REGISTRY_PROPERTY = 6;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyDriverKeyName: DEVICE_REGISTRY_PROPERTY = 7;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyManufacturer: DEVICE_REGISTRY_PROPERTY = 8;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyFriendlyName: DEVICE_REGISTRY_PROPERTY = 9;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyLocationInformation: DEVICE_REGISTRY_PROPERTY = 10;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyPhysicalDeviceObjectName:
DEVICE_REGISTRY_PROPERTY = 11;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyBusTypeGuid: DEVICE_REGISTRY_PROPERTY = 12;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyLegacyBusType: DEVICE_REGISTRY_PROPERTY = 13;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyBusNumber: DEVICE_REGISTRY_PROPERTY = 14;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyEnumeratorName: DEVICE_REGISTRY_PROPERTY = 15;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyAddress: DEVICE_REGISTRY_PROPERTY = 16;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyUINumber: DEVICE_REGISTRY_PROPERTY = 17;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyInstallState: DEVICE_REGISTRY_PROPERTY = 18;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyRemovalPolicy: DEVICE_REGISTRY_PROPERTY = 19;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyResourceRequirements: DEVICE_REGISTRY_PROPERTY =
    20;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyAllocatedResources: DEVICE_REGISTRY_PROPERTY = 21;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyContainerID: DEVICE_REGISTRY_PROPERTY = 22;
pub type DEVICE_REGISTRY_PROPERTY = core::ffi::c_int;
pub type TRANSLATE_BUS_ADDRESS = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        BusAddress: PHYSICAL_ADDRESS,
        Length: ULONG,
        AddressSpace: PULONG,
        TranslatedAddress: PPHYSICAL_ADDRESS,
    ) -> BOOLEAN,
>;
pub type PTRANSLATE_BUS_ADDRESS = TRANSLATE_BUS_ADDRESS;
pub type GET_DMA_ADAPTER = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        DeviceDescriptor: *mut _DEVICE_DESCRIPTION,
        NumberOfMapRegisters: PULONG,
    ) -> *mut _DMA_ADAPTER,
>;
pub type PGET_DMA_ADAPTER = GET_DMA_ADAPTER;
pub type GET_SET_DEVICE_DATA = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        DataType: ULONG,
        Buffer: PVOID,
        Offset: ULONG,
        Length: ULONG,
    ) -> ULONG,
>;
pub type PGET_SET_DEVICE_DATA = GET_SET_DEVICE_DATA;
pub const _DEVICE_INSTALL_STATE_InstallStateInstalled: _DEVICE_INSTALL_STATE = 0;
pub const _DEVICE_INSTALL_STATE_InstallStateNeedsReinstall: _DEVICE_INSTALL_STATE = 1;
pub const _DEVICE_INSTALL_STATE_InstallStateFailedInstall: _DEVICE_INSTALL_STATE = 2;
pub const _DEVICE_INSTALL_STATE_InstallStateFinishInstall: _DEVICE_INSTALL_STATE = 3;
pub type _DEVICE_INSTALL_STATE = core::ffi::c_int;
pub use self::_DEVICE_INSTALL_STATE as DEVICE_INSTALL_STATE;
pub type PDEVICE_INSTALL_STATE = *mut _DEVICE_INSTALL_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PNP_BUS_INFORMATION {
    pub BusTypeGuid: GUID,
    pub LegacyBusType: INTERFACE_TYPE,
    pub BusNumber: ULONG,
}
pub type PNP_BUS_INFORMATION = _PNP_BUS_INFORMATION;
pub type PPNP_BUS_INFORMATION = *mut _PNP_BUS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LEGACY_BUS_INFORMATION {
    pub BusTypeGuid: GUID,
    pub LegacyBusType: INTERFACE_TYPE,
    pub BusNumber: ULONG,
}
pub type LEGACY_BUS_INFORMATION = _LEGACY_BUS_INFORMATION;
pub type PLEGACY_BUS_INFORMATION = *mut _LEGACY_BUS_INFORMATION;
pub const _DEVICE_REMOVAL_POLICY_RemovalPolicyExpectNoRemoval: _DEVICE_REMOVAL_POLICY = 1;
pub const _DEVICE_REMOVAL_POLICY_RemovalPolicyExpectOrderlyRemoval: _DEVICE_REMOVAL_POLICY = 2;
pub const _DEVICE_REMOVAL_POLICY_RemovalPolicyExpectSurpriseRemoval: _DEVICE_REMOVAL_POLICY = 3;
pub type _DEVICE_REMOVAL_POLICY = core::ffi::c_int;
pub use self::_DEVICE_REMOVAL_POLICY as DEVICE_REMOVAL_POLICY;
pub type PDEVICE_REMOVAL_POLICY = *mut _DEVICE_REMOVAL_POLICY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BUS_INTERFACE_STANDARD {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub TranslateBusAddress: PTRANSLATE_BUS_ADDRESS,
    pub GetDmaAdapter: PGET_DMA_ADAPTER,
    pub SetBusData: PGET_SET_DEVICE_DATA,
    pub GetBusData: PGET_SET_DEVICE_DATA,
}
pub type BUS_INTERFACE_STANDARD = _BUS_INTERFACE_STANDARD;
pub type PBUS_INTERFACE_STANDARD = *mut _BUS_INTERFACE_STANDARD;
pub type GET_VIRTUAL_DEVICE_DATA = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        VirtualFunction: USHORT,
        Buffer: PVOID,
        Offset: ULONG,
        Length: ULONG,
    ) -> ULONG,
>;
pub type PGET_VIRTUAL_DEVICE_DATA = GET_VIRTUAL_DEVICE_DATA;
pub type SET_VIRTUAL_DEVICE_DATA = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        VirtualFunction: USHORT,
        Buffer: PVOID,
        Offset: ULONG,
        Length: ULONG,
    ) -> ULONG,
>;
pub type PSET_VIRTUAL_DEVICE_DATA = SET_VIRTUAL_DEVICE_DATA;
pub type GET_VIRTUAL_DEVICE_LOCATION = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        VirtualFunction: USHORT,
        SegmentNumber: PUINT16,
        BusNumber: PUINT8,
        FunctionNumber: PUINT8,
    ) -> NTSTATUS,
>;
pub type PGET_VIRTUAL_DEVICE_LOCATION = GET_VIRTUAL_DEVICE_LOCATION;
pub type GET_VIRTUAL_DEVICE_RESOURCES =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, CapturedBusNumbers: PUINT8)>;
pub type PGET_VIRTUAL_DEVICE_RESOURCES = GET_VIRTUAL_DEVICE_RESOURCES;
pub type ENABLE_VIRTUALIZATION = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        NumVFs: UINT16,
        EnableVfMigration: BOOLEAN,
        EnableMigrationInterrupt: BOOLEAN,
        EnableVirtualization: BOOLEAN,
    ) -> NTSTATUS,
>;
pub type PENABLE_VIRTUALIZATION = ENABLE_VIRTUALIZATION;
pub type GET_VIRTUAL_FUNCTION_PROBED_BARS = ::core::option::Option<
    unsafe extern "C" fn(Context: PVOID, BaseRegisterValues: PULONG) -> NTSTATUS,
>;
pub type PGET_VIRTUAL_FUNCTION_PROBED_BARS = GET_VIRTUAL_FUNCTION_PROBED_BARS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_VIRTUALIZATION_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub SetVirtualFunctionData: PSET_VIRTUAL_DEVICE_DATA,
    pub GetVirtualFunctionData: PGET_VIRTUAL_DEVICE_DATA,
    pub GetLocation: PGET_VIRTUAL_DEVICE_LOCATION,
    pub GetResources: PGET_VIRTUAL_DEVICE_RESOURCES,
    pub EnableVirtualization: PENABLE_VIRTUALIZATION,
    pub GetVirtualFunctionProbedBars: PGET_VIRTUAL_FUNCTION_PROBED_BARS,
}
pub type PCI_VIRTUALIZATION_INTERFACE = _PCI_VIRTUALIZATION_INTERFACE;
pub type PPCI_VIRTUALIZATION_INTERFACE = *mut _PCI_VIRTUALIZATION_INTERFACE;
pub const _PCI_ACS_BIT_PciAcsReserved: _PCI_ACS_BIT = 0;
pub const _PCI_ACS_BIT_PciAcsBitEnable: _PCI_ACS_BIT = 1;
pub const _PCI_ACS_BIT_PciAcsBitDisable: _PCI_ACS_BIT = 2;
pub const _PCI_ACS_BIT_PciAcsBitDontCare: _PCI_ACS_BIT = 3;
pub type _PCI_ACS_BIT = core::ffi::c_int;
pub use self::_PCI_ACS_BIT as PCI_ACS_BIT;
pub type PPCI_ACS_BIT = *mut _PCI_ACS_BIT;
pub type PCI_SET_ACS = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        EnableSourceValidation: PCI_ACS_BIT,
        EnableTranslationBlocking: PCI_ACS_BIT,
        EnableP2PRequestRedirect: PCI_ACS_BIT,
        EnableCompletionRedirect: PCI_ACS_BIT,
        EnableUpstreamForwarding: PCI_ACS_BIT,
        EnableEgressControl: PCI_ACS_BIT,
        EnableDirectTranslatedP2P: PCI_ACS_BIT,
    ) -> NTSTATUS,
>;
pub type PPCI_SET_ACS = PCI_SET_ACS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_SECURITY_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub SetAccessControlServices: PPCI_SET_ACS,
}
pub type PCI_SECURITY_INTERFACE = _PCI_SECURITY_INTERFACE;
pub type PPCI_SECURITY_INTERFACE = *mut _PCI_SECURITY_INTERFACE;
pub type PCI_SET_ACS2 = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        ScenariosToModify: ULONG,
        ScenarioState: ULONG,
    ) -> NTSTATUS,
>;
pub type PPCI_SET_ACS2 = PCI_SET_ACS2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_SECURITY_INTERFACE2 {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub Flags: ULONG,
    pub SupportedScenarios: ULONG,
    pub SetAccessControlServices: PPCI_SET_ACS2,
}
pub type PCI_SECURITY_INTERFACE2 = _PCI_SECURITY_INTERFACE2;
pub type PPCI_SECURITY_INTERFACE2 = *mut _PCI_SECURITY_INTERFACE2;
pub type PCI_SET_ATS =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, EnableAts: BOOLEAN) -> NTSTATUS>;
pub type PPCI_SET_ATS = PCI_SET_ATS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_ATS_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub SetAddressTranslationServices: PPCI_SET_ATS,
    pub InvalidateQueueDepth: UCHAR,
}
pub type PCI_ATS_INTERFACE = _PCI_ATS_INTERFACE;
pub type PPCI_ATS_INTERFACE = *mut _PCI_ATS_INTERFACE;
pub type PREENUMERATE_SELF = ::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REENUMERATE_SELF_INTERFACE_STANDARD {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub SurpriseRemoveAndReenumerateSelf: PREENUMERATE_SELF,
}
pub type REENUMERATE_SELF_INTERFACE_STANDARD = _REENUMERATE_SELF_INTERFACE_STANDARD;
pub type PREENUMERATE_SELF_INTERFACE_STANDARD = *mut _REENUMERATE_SELF_INTERFACE_STANDARD;
pub type PQUERYEXTENDEDADDRESS =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, ExtendedAddress: PULONG64)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PNP_EXTENDED_ADDRESS_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub QueryExtendedAddress: PQUERYEXTENDEDADDRESS,
}
pub type PNP_EXTENDED_ADDRESS_INTERFACE = _PNP_EXTENDED_ADDRESS_INTERFACE;
pub type PPNP_EXTENDED_ADDRESS_INTERFACE = *mut _PNP_EXTENDED_ADDRESS_INTERFACE;
pub type SET_D3COLD_SUPPORT =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, D3ColdSupport: BOOLEAN)>;
pub type PSET_D3COLD_SUPPORT = SET_D3COLD_SUPPORT;
pub const _DEVICE_WAKE_DEPTH_DeviceWakeDepthNotWakeable: _DEVICE_WAKE_DEPTH = 0;
pub const _DEVICE_WAKE_DEPTH_DeviceWakeDepthD0: _DEVICE_WAKE_DEPTH = 1;
pub const _DEVICE_WAKE_DEPTH_DeviceWakeDepthD1: _DEVICE_WAKE_DEPTH = 2;
pub const _DEVICE_WAKE_DEPTH_DeviceWakeDepthD2: _DEVICE_WAKE_DEPTH = 3;
pub const _DEVICE_WAKE_DEPTH_DeviceWakeDepthD3hot: _DEVICE_WAKE_DEPTH = 4;
pub const _DEVICE_WAKE_DEPTH_DeviceWakeDepthD3cold: _DEVICE_WAKE_DEPTH = 5;
pub const _DEVICE_WAKE_DEPTH_DeviceWakeDepthMaximum: _DEVICE_WAKE_DEPTH = 6;
pub type _DEVICE_WAKE_DEPTH = core::ffi::c_int;
pub use self::_DEVICE_WAKE_DEPTH as DEVICE_WAKE_DEPTH;
pub type PDEVICE_WAKE_DEPTH = *mut _DEVICE_WAKE_DEPTH;
pub type GET_IDLE_WAKE_INFO = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        SystemPowerState: SYSTEM_POWER_STATE,
        DeepestWakeableDstate: PDEVICE_WAKE_DEPTH,
    ) -> NTSTATUS,
>;
pub type PGET_IDLE_WAKE_INFO = GET_IDLE_WAKE_INFO;
pub type GET_D3COLD_CAPABILITY = ::core::option::Option<
    unsafe extern "C" fn(Context: PVOID, D3ColdSupported: PBOOLEAN) -> NTSTATUS,
>;
pub type PGET_D3COLD_CAPABILITY = GET_D3COLD_CAPABILITY;
pub const _D3COLD_LAST_TRANSITION_STATUS_LastDStateTransitionStatusUnknown:
_D3COLD_LAST_TRANSITION_STATUS = 0;
pub const _D3COLD_LAST_TRANSITION_STATUS_LastDStateTransitionD3hot: _D3COLD_LAST_TRANSITION_STATUS =
    1;
pub const _D3COLD_LAST_TRANSITION_STATUS_LastDStateTransitionD3cold:
_D3COLD_LAST_TRANSITION_STATUS = 2;
pub type _D3COLD_LAST_TRANSITION_STATUS = core::ffi::c_int;
pub use self::_D3COLD_LAST_TRANSITION_STATUS as D3COLD_LAST_TRANSITION_STATUS;
pub type PD3COLD_LAST_TRANSITION_STATUS = *mut _D3COLD_LAST_TRANSITION_STATUS;
pub type GET_D3COLD_LAST_TRANSITION_STATUS = ::core::option::Option<
    unsafe extern "C" fn(Context: PVOID, LastTransitionStatus: PD3COLD_LAST_TRANSITION_STATUS),
>;
pub type PGET_D3COLD_LAST_TRANSITION_STATUS = GET_D3COLD_LAST_TRANSITION_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _D3COLD_SUPPORT_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub SetD3ColdSupport: PSET_D3COLD_SUPPORT,
    pub GetIdleWakeInfo: PGET_IDLE_WAKE_INFO,
    pub GetD3ColdCapability: PGET_D3COLD_CAPABILITY,
    pub GetBusDriverD3ColdSupport: PGET_D3COLD_CAPABILITY,
    pub GetLastTransitionStatus: PGET_D3COLD_LAST_TRANSITION_STATUS,
}
pub type D3COLD_SUPPORT_INTERFACE = _D3COLD_SUPPORT_INTERFACE;
pub type PD3COLD_SUPPORT_INTERFACE = *mut _D3COLD_SUPPORT_INTERFACE;
pub type D3COLD_REQUEST_CORE_POWER_RAIL =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, CorePowerRailNeeded: BOOLEAN)>;
pub type PD3COLD_REQUEST_CORE_POWER_RAIL = D3COLD_REQUEST_CORE_POWER_RAIL;
pub type D3COLD_REQUEST_AUX_POWER = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        AuxPowerInMilliWatts: ULONG,
        RetryInSeconds: PULONG,
    ) -> NTSTATUS,
>;
pub type PD3COLD_REQUEST_AUX_POWER = D3COLD_REQUEST_AUX_POWER;
pub type D3COLD_REQUEST_PERST_DELAY = ::core::option::Option<
    unsafe extern "C" fn(Context: PVOID, DelayInMicroSeconds: ULONG) -> NTSTATUS,
>;
pub type PD3COLD_REQUEST_PERST_DELAY = D3COLD_REQUEST_PERST_DELAY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _D3COLD_AUX_POWER_AND_TIMING_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub RequestCorePowerRail: PD3COLD_REQUEST_CORE_POWER_RAIL,
    pub RequestAuxPower: PD3COLD_REQUEST_AUX_POWER,
    pub RequestPerstDelay: PD3COLD_REQUEST_PERST_DELAY,
}
pub type D3COLD_AUX_POWER_AND_TIMING_INTERFACE = _D3COLD_AUX_POWER_AND_TIMING_INTERFACE;
pub type PD3COLD_AUX_POWER_AND_TIMING_INTERFACE = *mut _D3COLD_AUX_POWER_AND_TIMING_INTERFACE;
pub type FPGA_BUS_SCAN = ::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
pub type PFPGA_BUS_SCAN = FPGA_BUS_SCAN;
pub type FPGA_CONTROL_LINK =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, Enable: BOOLEAN) -> NTSTATUS>;
pub type PFPGA_CONTROL_LINK = FPGA_CONTROL_LINK;
pub type FPGA_CONTROL_CONFIG_SPACE =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, Enable: BOOLEAN) -> NTSTATUS>;
pub type PFPGA_CONTROL_CONFIG_SPACE = FPGA_CONTROL_CONFIG_SPACE;
pub type FPGA_CONTROL_ERROR_REPORTING = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        UncorrectableMask: ULONG,
        CorrectableMask: ULONG,
        DisableErrorReporting: BOOLEAN,
    ) -> NTSTATUS,
>;
pub type PFPGA_CONTROL_ERROR_REPORTING = FPGA_CONTROL_ERROR_REPORTING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FPGA_CONTROL_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub BusScan: PFPGA_BUS_SCAN,
    pub ControlLink: PFPGA_CONTROL_LINK,
    pub ControlConfigSpace: PFPGA_CONTROL_CONFIG_SPACE,
    pub ControlErrorReporting: PFPGA_CONTROL_ERROR_REPORTING,
}
pub type FPGA_CONTROL_INTERFACE = _FPGA_CONTROL_INTERFACE;
pub type PFPGA_CONTROL_INTERFACE = *mut _FPGA_CONTROL_INTERFACE;
pub type PTM_DEVICE_QUERY_GRANULARITY =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, Granularity: PUCHAR) -> NTSTATUS>;
pub type PPTM_DEVICE_QUERY_GRANULARITY = PTM_DEVICE_QUERY_GRANULARITY;
pub type PTM_DEVICE_QUERY_TIME_SOURCE =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, TimeSource: PULONG) -> NTSTATUS>;
pub type PPTM_DEVICE_QUERY_TIME_SOURCE = PTM_DEVICE_QUERY_TIME_SOURCE;
pub type PTM_DEVICE_ENABLE =
::core::option::Option<unsafe extern "C" fn(Context: PVOID) -> NTSTATUS>;
pub type PPTM_DEVICE_ENABLE = PTM_DEVICE_ENABLE;
pub type PTM_DEVICE_DISABLE =
::core::option::Option<unsafe extern "C" fn(Context: PVOID) -> NTSTATUS>;
pub type PPTM_DEVICE_DISABLE = PTM_DEVICE_DISABLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PTM_CONTROL_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub QueryGranularity: PPTM_DEVICE_QUERY_GRANULARITY,
    pub QueryTimeSource: PPTM_DEVICE_QUERY_TIME_SOURCE,
    pub Enable: PPTM_DEVICE_ENABLE,
    pub Disable: PPTM_DEVICE_DISABLE,
}
pub type PTM_CONTROL_INTERFACE = _PTM_CONTROL_INTERFACE;
pub type PPTM_CONTROL_INTERFACE = *mut _PTM_CONTROL_INTERFACE;
pub type GET_UPDATED_BUS_RESOURCE = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        UpdatedResourceList: *mut PCM_RESOURCE_LIST,
        UpdatedTranslatedResourceList: *mut PCM_RESOURCE_LIST,
    ) -> NTSTATUS,
>;
pub type PGET_UPDATED_BUS_RESOURCE = GET_UPDATED_BUS_RESOURCE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BUS_RESOURCE_UPDATE_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub GetUpdatedBusResource: PGET_UPDATED_BUS_RESOURCE,
}
pub type BUS_RESOURCE_UPDATE_INTERFACE = _BUS_RESOURCE_UPDATE_INTERFACE;
pub type PBUS_RESOURCE_UPDATE_INTERFACE = *mut _BUS_RESOURCE_UPDATE_INTERFACE;
pub const _NPEM_CONTROL_STANDARD_CONTROL_BIT_InitiateReset: _NPEM_CONTROL_STANDARD_CONTROL_BIT = 1;
pub const _NPEM_CONTROL_STANDARD_CONTROL_BIT_OkControl: _NPEM_CONTROL_STANDARD_CONTROL_BIT = 2;
pub const _NPEM_CONTROL_STANDARD_CONTROL_BIT_LocateControl: _NPEM_CONTROL_STANDARD_CONTROL_BIT = 3;
pub const _NPEM_CONTROL_STANDARD_CONTROL_BIT_FailControl: _NPEM_CONTROL_STANDARD_CONTROL_BIT = 4;
pub const _NPEM_CONTROL_STANDARD_CONTROL_BIT_RebuildControl: _NPEM_CONTROL_STANDARD_CONTROL_BIT = 5;
pub const _NPEM_CONTROL_STANDARD_CONTROL_BIT_PFAControl: _NPEM_CONTROL_STANDARD_CONTROL_BIT = 6;
pub const _NPEM_CONTROL_STANDARD_CONTROL_BIT_HotSpareControl: _NPEM_CONTROL_STANDARD_CONTROL_BIT =
    7;
pub const _NPEM_CONTROL_STANDARD_CONTROL_BIT_InACriticalArrayControl:
_NPEM_CONTROL_STANDARD_CONTROL_BIT = 8;
pub const _NPEM_CONTROL_STANDARD_CONTROL_BIT_InAFailedArrayControl:
_NPEM_CONTROL_STANDARD_CONTROL_BIT = 9;
pub const _NPEM_CONTROL_STANDARD_CONTROL_BIT_InvalidDeviceTypeControl:
_NPEM_CONTROL_STANDARD_CONTROL_BIT = 10;
pub const _NPEM_CONTROL_STANDARD_CONTROL_BIT_DisabledControl: _NPEM_CONTROL_STANDARD_CONTROL_BIT =
    11;
pub type _NPEM_CONTROL_STANDARD_CONTROL_BIT = core::ffi::c_int;
pub use self::_NPEM_CONTROL_STANDARD_CONTROL_BIT as NPEM_CONTROL_STANDARD_CONTROL_BIT;
pub type PNPEM_CONTROL_STANDARD_CONTROL_BIT = *mut _NPEM_CONTROL_STANDARD_CONTROL_BIT;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NPEM_CAPABILITY_STANDARD {
    pub __bindgen_anon_1: _NPEM_CAPABILITY_STANDARD__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NPEM_CAPABILITY_STANDARD__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _NPEM_CAPABILITY_STANDARD__bindgen_ty_1 {
    #[inline]
    pub fn Capable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Capable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Capable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Capable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ResetCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ResetCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ResetCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ResetCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn OkCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OkCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn OkCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_OkCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LocateCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LocateCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LocateCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_LocateCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FailCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FailCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FailCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FailCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RebuildCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RebuildCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RebuildCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RebuildCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PFACapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PFACapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PFACapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PFACapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn HotSpareCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HotSpareCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn HotSpareCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_HotSpareCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn InACriticalArrayCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InACriticalArrayCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InACriticalArrayCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_InACriticalArrayCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn InAFailedArrayCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InAFailedArrayCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InAFailedArrayCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_InAFailedArrayCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn InvalidDeviceTypeCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InvalidDeviceTypeCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InvalidDeviceTypeCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_InvalidDeviceTypeCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DisabledCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisabledCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DisabledCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DisabledCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                20u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                20u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Capable: ULONG,
        ResetCapable: ULONG,
        OkCapable: ULONG,
        LocateCapable: ULONG,
        FailCapable: ULONG,
        RebuildCapable: ULONG,
        PFACapable: ULONG,
        HotSpareCapable: ULONG,
        InACriticalArrayCapable: ULONG,
        InAFailedArrayCapable: ULONG,
        InvalidDeviceTypeCapable: ULONG,
        DisabledCapable: ULONG,
        Rsvd: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Capable: u32 = unsafe { ::core::mem::transmute(Capable) };
            Capable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ResetCapable: u32 = unsafe { ::core::mem::transmute(ResetCapable) };
            ResetCapable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let OkCapable: u32 = unsafe { ::core::mem::transmute(OkCapable) };
            OkCapable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let LocateCapable: u32 = unsafe { ::core::mem::transmute(LocateCapable) };
            LocateCapable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let FailCapable: u32 = unsafe { ::core::mem::transmute(FailCapable) };
            FailCapable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let RebuildCapable: u32 = unsafe { ::core::mem::transmute(RebuildCapable) };
            RebuildCapable as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PFACapable: u32 = unsafe { ::core::mem::transmute(PFACapable) };
            PFACapable as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let HotSpareCapable: u32 = unsafe { ::core::mem::transmute(HotSpareCapable) };
            HotSpareCapable as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let InACriticalArrayCapable: u32 =
                unsafe { ::core::mem::transmute(InACriticalArrayCapable) };
            InACriticalArrayCapable as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let InAFailedArrayCapable: u32 =
                unsafe { ::core::mem::transmute(InAFailedArrayCapable) };
            InAFailedArrayCapable as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let InvalidDeviceTypeCapable: u32 =
                unsafe { ::core::mem::transmute(InvalidDeviceTypeCapable) };
            InvalidDeviceTypeCapable as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let DisabledCapable: u32 = unsafe { ::core::mem::transmute(DisabledCapable) };
            DisabledCapable as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let Rsvd: u32 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NPEM_CAPABILITY_STANDARD = _NPEM_CAPABILITY_STANDARD;
pub type PNPEM_CAPABILITY_STANDARD = *mut _NPEM_CAPABILITY_STANDARD;
pub type NPEM_CONTROL_ENABLE_DISABLE =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, EnableNpem: BOOLEAN) -> NTSTATUS>;
pub type PNPEM_CONTROL_ENABLE_DISABLE = NPEM_CONTROL_ENABLE_DISABLE;
pub type NPEM_CONTROL_QUERY_STANDARD_CAPABILITIES = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        StandardCapabilities: PNPEM_CAPABILITY_STANDARD,
    ) -> NTSTATUS,
>;
pub type PNPEM_CONTROL_QUERY_STANDARD_CAPABILITIES = NPEM_CONTROL_QUERY_STANDARD_CAPABILITIES;
pub type NPEM_CONTROL_SET_STANDARD_CONTROL = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        StandardControl: NPEM_CONTROL_STANDARD_CONTROL_BIT,
        Set: BOOLEAN,
    ) -> NTSTATUS,
>;
pub type PNPEM_CONTROL_SET_STANDARD_CONTROL = NPEM_CONTROL_SET_STANDARD_CONTROL;
pub type NPEM_CONTROL_QUERY_CONTROL =
::core::option::Option<unsafe extern "C" fn(Context: PVOID) -> ULONG>;
pub type PNPEM_CONTROL_QUERY_CONTROL = NPEM_CONTROL_QUERY_CONTROL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NPEM_CONTROL_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub SetNpemSupportState: PNPEM_CONTROL_ENABLE_DISABLE,
    pub QueryStandardCapabilities: PNPEM_CONTROL_QUERY_STANDARD_CAPABILITIES,
    pub SetStandardControl: PNPEM_CONTROL_SET_STANDARD_CONTROL,
    pub QueryNpemControl: PNPEM_CONTROL_QUERY_CONTROL,
}
pub type NPEM_CONTROL_INTERFACE = _NPEM_CONTROL_INTERFACE;
pub type PNPEM_CONTROL_INTERFACE = *mut _NPEM_CONTROL_INTERFACE;
pub type PGPE_SERVICE_ROUTINE =
::core::option::Option<unsafe extern "C" fn(arg1: PVOID, arg2: PVOID) -> BOOLEAN>;
pub type PGPE_CONNECT_VECTOR = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: PDEVICE_OBJECT,
        arg2: ULONG,
        arg3: KINTERRUPT_MODE,
        arg4: BOOLEAN,
        arg5: PGPE_SERVICE_ROUTINE,
        arg6: PVOID,
        arg7: PVOID,
    ) -> NTSTATUS,
>;
pub type PGPE_DISCONNECT_VECTOR =
::core::option::Option<unsafe extern "C" fn(arg1: PVOID) -> NTSTATUS>;
pub type PGPE_ENABLE_EVENT =
::core::option::Option<unsafe extern "C" fn(arg1: PDEVICE_OBJECT, arg2: PVOID) -> NTSTATUS>;
pub type PGPE_DISABLE_EVENT =
::core::option::Option<unsafe extern "C" fn(arg1: PDEVICE_OBJECT, arg2: PVOID) -> NTSTATUS>;
pub type PGPE_CLEAR_STATUS =
::core::option::Option<unsafe extern "C" fn(arg1: PDEVICE_OBJECT, arg2: PVOID) -> NTSTATUS>;
pub type PDEVICE_NOTIFY_CALLBACK =
::core::option::Option<unsafe extern "C" fn(arg1: PVOID, arg2: ULONG)>;
pub type PREGISTER_FOR_DEVICE_NOTIFICATIONS = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: PDEVICE_OBJECT,
        arg2: PDEVICE_NOTIFY_CALLBACK,
        arg3: PVOID,
    ) -> NTSTATUS,
>;
pub type PUNREGISTER_FOR_DEVICE_NOTIFICATIONS = ::core::option::Option<
    unsafe extern "C" fn(arg1: PDEVICE_OBJECT, arg2: PDEVICE_NOTIFY_CALLBACK),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACPI_INTERFACE_STANDARD {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub GpeConnectVector: PGPE_CONNECT_VECTOR,
    pub GpeDisconnectVector: PGPE_DISCONNECT_VECTOR,
    pub GpeEnableEvent: PGPE_ENABLE_EVENT,
    pub GpeDisableEvent: PGPE_DISABLE_EVENT,
    pub GpeClearStatus: PGPE_CLEAR_STATUS,
    pub RegisterForDeviceNotifications: PREGISTER_FOR_DEVICE_NOTIFICATIONS,
    pub UnregisterForDeviceNotifications: PUNREGISTER_FOR_DEVICE_NOTIFICATIONS,
}
pub type ACPI_INTERFACE_STANDARD = _ACPI_INTERFACE_STANDARD;
pub type PACPI_INTERFACE_STANDARD = *mut _ACPI_INTERFACE_STANDARD;
pub type PGPE_SERVICE_ROUTINE2 = ::core::option::Option<
    unsafe extern "C" fn(ObjectContext: PVOID, ServiceContext: PVOID) -> BOOLEAN,
>;
pub type PGPE_CONNECT_VECTOR2 = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        GpeNumber: ULONG,
        Mode: KINTERRUPT_MODE,
        Shareable: BOOLEAN,
        ServiceRoutine: PGPE_SERVICE_ROUTINE,
        ServiceContext: PVOID,
        ObjectContext: *mut PVOID,
    ) -> NTSTATUS,
>;
pub type PGPE_DISCONNECT_VECTOR2 =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, ObjectContext: PVOID) -> NTSTATUS>;
pub type PGPE_ENABLE_EVENT2 =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, ObjectContext: PVOID) -> NTSTATUS>;
pub type PGPE_DISABLE_EVENT2 =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, ObjectContext: PVOID) -> NTSTATUS>;
pub type PGPE_CLEAR_STATUS2 =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, ObjectContext: PVOID) -> NTSTATUS>;
pub type PDEVICE_NOTIFY_CALLBACK2 =
::core::option::Option<unsafe extern "C" fn(NotificationContext: PVOID, NotifyCode: ULONG)>;
pub type PREGISTER_FOR_DEVICE_NOTIFICATIONS2 = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        NotificationHandler: PDEVICE_NOTIFY_CALLBACK2,
        NotificationContext: PVOID,
    ) -> NTSTATUS,
>;
pub type PUNREGISTER_FOR_DEVICE_NOTIFICATIONS2 =
::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACPI_INTERFACE_STANDARD2 {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub GpeConnectVector: PGPE_CONNECT_VECTOR2,
    pub GpeDisconnectVector: PGPE_DISCONNECT_VECTOR2,
    pub GpeEnableEvent: PGPE_ENABLE_EVENT2,
    pub GpeDisableEvent: PGPE_DISABLE_EVENT2,
    pub GpeClearStatus: PGPE_CLEAR_STATUS2,
    pub RegisterForDeviceNotifications: PREGISTER_FOR_DEVICE_NOTIFICATIONS2,
    pub UnregisterForDeviceNotifications: PUNREGISTER_FOR_DEVICE_NOTIFICATIONS2,
}
pub type PACPI_INTERFACE_STANDARD2 = *mut ACPI_INTERFACE_STANDARD2;
unsafe extern "C" {
    pub fn IoInvalidateDeviceRelations(DeviceObject: PDEVICE_OBJECT, Type: DEVICE_RELATION_TYPE);
}
unsafe extern "C" {
    pub fn IoRequestDeviceEject(PhysicalDeviceObject: PDEVICE_OBJECT);
}
pub type PIO_DEVICE_EJECT_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Status: NTSTATUS, Context: PVOID)>;
unsafe extern "C" {
    pub fn IoRequestDeviceEjectEx(
        PhysicalDeviceObject: PDEVICE_OBJECT,
        Callback: PIO_DEVICE_EJECT_CALLBACK,
        Context: PVOID,
        DriverObject: PDRIVER_OBJECT,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoGetDeviceProperty(
        DeviceObject: PDEVICE_OBJECT,
        DeviceProperty: DEVICE_REGISTRY_PROPERTY,
        BufferLength: ULONG,
        PropertyBuffer: PVOID,
        ResultLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoOpenDeviceRegistryKey(
        DeviceObject: PDEVICE_OBJECT,
        DevInstKeyType: ULONG,
        DesiredAccess: ACCESS_MASK,
        DeviceRegKey: PHANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoRegisterDeviceInterface(
        PhysicalDeviceObject: PDEVICE_OBJECT,
        InterfaceClassGuid: *const GUID,
        ReferenceString: PUNICODE_STRING,
        SymbolicLinkName: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoOpenDeviceInterfaceRegistryKey(
        SymbolicLinkName: PUNICODE_STRING,
        DesiredAccess: ACCESS_MASK,
        DeviceInterfaceRegKey: PHANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoSetDeviceInterfaceState(
        SymbolicLinkName: PUNICODE_STRING,
        Enable: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoGetDeviceInterfaces(
        InterfaceClassGuid: *const GUID,
        PhysicalDeviceObject: PDEVICE_OBJECT,
        Flags: ULONG,
        SymbolicLinkList: *mut PZZWSTR,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoGetDeviceInterfaceAlias(
        SymbolicLinkName: PUNICODE_STRING,
        AliasInterfaceClassGuid: *const GUID,
        AliasSymbolicLinkName: PUNICODE_STRING,
    ) -> NTSTATUS;
}
pub const _IO_NOTIFICATION_EVENT_CATEGORY_EventCategoryReserved: _IO_NOTIFICATION_EVENT_CATEGORY =
    0;
pub const _IO_NOTIFICATION_EVENT_CATEGORY_EventCategoryHardwareProfileChange:
_IO_NOTIFICATION_EVENT_CATEGORY = 1;
pub const _IO_NOTIFICATION_EVENT_CATEGORY_EventCategoryDeviceInterfaceChange:
_IO_NOTIFICATION_EVENT_CATEGORY = 2;
pub const _IO_NOTIFICATION_EVENT_CATEGORY_EventCategoryTargetDeviceChange:
_IO_NOTIFICATION_EVENT_CATEGORY = 3;
pub const _IO_NOTIFICATION_EVENT_CATEGORY_EventCategoryKernelSoftRestart:
_IO_NOTIFICATION_EVENT_CATEGORY = 4;
pub type _IO_NOTIFICATION_EVENT_CATEGORY = core::ffi::c_int;
pub use self::_IO_NOTIFICATION_EVENT_CATEGORY as IO_NOTIFICATION_EVENT_CATEGORY;
pub type DRIVER_NOTIFICATION_CALLBACK_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(NotificationStructure: PVOID, Context: PVOID) -> NTSTATUS,
>;
pub type PDRIVER_NOTIFICATION_CALLBACK_ROUTINE = DRIVER_NOTIFICATION_CALLBACK_ROUTINE;
unsafe extern "C" {
    pub fn IoRegisterPlugPlayNotification(
        EventCategory: IO_NOTIFICATION_EVENT_CATEGORY,
        EventCategoryFlags: ULONG,
        EventCategoryData: PVOID,
        DriverObject: PDRIVER_OBJECT,
        CallbackRoutine: PDRIVER_NOTIFICATION_CALLBACK_ROUTINE,
        Context: PVOID,
        NotificationEntry: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoUnregisterPlugPlayNotification(NotificationEntry: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoUnregisterPlugPlayNotificationEx(NotificationEntry: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoReportTargetDeviceChange(
        PhysicalDeviceObject: PDEVICE_OBJECT,
        NotificationStructure: PVOID,
    ) -> NTSTATUS;
}
pub type DEVICE_CHANGE_COMPLETE_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
pub type PDEVICE_CHANGE_COMPLETE_CALLBACK = DEVICE_CHANGE_COMPLETE_CALLBACK;
unsafe extern "C" {
    pub fn IoInvalidateDeviceState(PhysicalDeviceObject: PDEVICE_OBJECT);
}
unsafe extern "C" {
    pub fn IoReportTargetDeviceChangeAsynchronous(
        PhysicalDeviceObject: PDEVICE_OBJECT,
        NotificationStructure: PVOID,
        Callback: PDEVICE_CHANGE_COMPLETE_CALLBACK,
        Context: PVOID,
    ) -> NTSTATUS;
}
pub const _DRIVER_DIRECTORY_TYPE_DriverDirectoryImage: _DRIVER_DIRECTORY_TYPE = 0;
pub const _DRIVER_DIRECTORY_TYPE_DriverDirectoryData: _DRIVER_DIRECTORY_TYPE = 1;
pub const _DRIVER_DIRECTORY_TYPE_DriverDirectorySharedData: _DRIVER_DIRECTORY_TYPE = 2;
pub type _DRIVER_DIRECTORY_TYPE = core::ffi::c_int;
pub use self::_DRIVER_DIRECTORY_TYPE as DRIVER_DIRECTORY_TYPE;
pub type PDRIVER_DIRECTORY_TYPE = *mut _DRIVER_DIRECTORY_TYPE;
unsafe extern "C" {
    pub fn IoGetDriverDirectory(
        DriverObject: PDRIVER_OBJECT,
        DirectoryType: DRIVER_DIRECTORY_TYPE,
        Flags: ULONG,
        DriverDirectoryHandle: PHANDLE,
    ) -> NTSTATUS;
}
pub const _DEVICE_DIRECTORY_TYPE_DeviceDirectoryData: _DEVICE_DIRECTORY_TYPE = 0;
pub type _DEVICE_DIRECTORY_TYPE = core::ffi::c_int;
pub use self::_DEVICE_DIRECTORY_TYPE as DEVICE_DIRECTORY_TYPE;
pub type PDEVICE_DIRECTORY_TYPE = *mut _DEVICE_DIRECTORY_TYPE;
unsafe extern "C" {
    pub fn IoGetDeviceDirectory(
        PhysicalDeviceObject: PDEVICE_OBJECT,
        DirectoryType: DEVICE_DIRECTORY_TYPE,
        Flags: ULONG,
        Reserved: PVOID,
        DeviceDirectoryHandle: PHANDLE,
    ) -> NTSTATUS;
}
pub const _DRIVER_REGKEY_TYPE_DriverRegKeyParameters: _DRIVER_REGKEY_TYPE = 0;
pub const _DRIVER_REGKEY_TYPE_DriverRegKeyPersistentState: _DRIVER_REGKEY_TYPE = 1;
pub const _DRIVER_REGKEY_TYPE_DriverRegKeySharedPersistentState: _DRIVER_REGKEY_TYPE = 2;
pub type _DRIVER_REGKEY_TYPE = core::ffi::c_int;
pub use self::_DRIVER_REGKEY_TYPE as DRIVER_REGKEY_TYPE;
pub type PDRIVER_REGKEY_TYPE = *mut _DRIVER_REGKEY_TYPE;
unsafe extern "C" {
    pub fn IoOpenDriverRegistryKey(
        DriverObject: PDRIVER_OBJECT,
        RegKeyType: DRIVER_REGKEY_TYPE,
        DesiredAccess: ACCESS_MASK,
        Flags: ULONG,
        DriverRegKey: PHANDLE,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PLUGPLAY_NOTIFICATION_HEADER {
    pub Version: USHORT,
    pub Size: USHORT,
    pub Event: GUID,
}
pub type PLUGPLAY_NOTIFICATION_HEADER = _PLUGPLAY_NOTIFICATION_HEADER;
pub type PPLUGPLAY_NOTIFICATION_HEADER = *mut _PLUGPLAY_NOTIFICATION_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HWPROFILE_CHANGE_NOTIFICATION {
    pub Version: USHORT,
    pub Size: USHORT,
    pub Event: GUID,
}
pub type HWPROFILE_CHANGE_NOTIFICATION = _HWPROFILE_CHANGE_NOTIFICATION;
pub type PHWPROFILE_CHANGE_NOTIFICATION = *mut _HWPROFILE_CHANGE_NOTIFICATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION {
    pub Version: USHORT,
    pub Size: USHORT,
    pub Event: GUID,
    pub InterfaceClassGuid: GUID,
    pub SymbolicLinkName: PUNICODE_STRING,
}
pub type DEVICE_INTERFACE_CHANGE_NOTIFICATION = _DEVICE_INTERFACE_CHANGE_NOTIFICATION;
pub type PDEVICE_INTERFACE_CHANGE_NOTIFICATION = *mut _DEVICE_INTERFACE_CHANGE_NOTIFICATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TARGET_DEVICE_REMOVAL_NOTIFICATION {
    pub Version: USHORT,
    pub Size: USHORT,
    pub Event: GUID,
    pub FileObject: PFILE_OBJECT,
}
pub type TARGET_DEVICE_REMOVAL_NOTIFICATION = _TARGET_DEVICE_REMOVAL_NOTIFICATION;
pub type PTARGET_DEVICE_REMOVAL_NOTIFICATION = *mut _TARGET_DEVICE_REMOVAL_NOTIFICATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KERNEL_SOFT_RESTART_NOTIFICATION {
    pub Version: USHORT,
    pub Size: USHORT,
    pub Event: GUID,
}
pub type KERNEL_SOFT_RESTART_NOTIFICATION = _KERNEL_SOFT_RESTART_NOTIFICATION;
pub type PKERNEL_SOFT_RESTART_NOTIFICATION = *mut _KERNEL_SOFT_RESTART_NOTIFICATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TARGET_DEVICE_CUSTOM_NOTIFICATION {
    pub Version: USHORT,
    pub Size: USHORT,
    pub Event: GUID,
    pub FileObject: PFILE_OBJECT,
    pub NameBufferOffset: LONG,
    pub CustomDataBuffer: [UCHAR; 1usize],
}
pub type TARGET_DEVICE_CUSTOM_NOTIFICATION = _TARGET_DEVICE_CUSTOM_NOTIFICATION;
pub type PTARGET_DEVICE_CUSTOM_NOTIFICATION = *mut _TARGET_DEVICE_CUSTOM_NOTIFICATION;
pub type DEVPROPTYPE = ULONG;
pub type PDEVPROPTYPE = *mut ULONG;
pub type DEVPROP_BOOLEAN = CHAR;
pub type PDEVPROP_BOOLEAN = *mut CHAR;
pub type DEVPROPGUID = GUID;
pub type PDEVPROPGUID = *mut GUID;
pub type DEVPROPID = ULONG;
pub type PDEVPROPID = *mut ULONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVPROPKEY {
    pub fmtid: DEVPROPGUID,
    pub pid: DEVPROPID,
}
pub type DEVPROPKEY = _DEVPROPKEY;
pub type PDEVPROPKEY = *mut _DEVPROPKEY;
pub const _DEVPROPSTORE_DEVPROP_STORE_SYSTEM: _DEVPROPSTORE = 0;
pub const _DEVPROPSTORE_DEVPROP_STORE_USER: _DEVPROPSTORE = 1;
pub type _DEVPROPSTORE = core::ffi::c_int;
pub use self::_DEVPROPSTORE as DEVPROPSTORE;
pub type PDEVPROPSTORE = *mut _DEVPROPSTORE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVPROPCOMPKEY {
    pub Key: DEVPROPKEY,
    pub Store: DEVPROPSTORE,
    pub LocaleName: PCWSTR,
}
pub type DEVPROPCOMPKEY = _DEVPROPCOMPKEY;
pub type PDEVPROPCOMPKEY = *mut _DEVPROPCOMPKEY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVPROPERTY {
    pub CompKey: DEVPROPCOMPKEY,
    pub Type: DEVPROPTYPE,
    pub BufferSize: ULONG,
    pub Buffer: PVOID,
}
pub type DEVPROPERTY = _DEVPROPERTY;
pub type PDEVPROPERTY = *mut _DEVPROPERTY;
unsafe extern "C" {
    pub fn IoSetDevicePropertyData(
        Pdo: PDEVICE_OBJECT,
        PropertyKey: *const DEVPROPKEY,
        Lcid: LCID,
        Flags: ULONG,
        Type: DEVPROPTYPE,
        Size: ULONG,
        Data: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoGetDevicePropertyData(
        Pdo: PDEVICE_OBJECT,
        PropertyKey: *const DEVPROPKEY,
        Lcid: LCID,
        Flags: ULONG,
        Size: ULONG,
        Data: PVOID,
        RequiredSize: PULONG,
        Type: PDEVPROPTYPE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoSetDeviceInterfacePropertyData(
        SymbolicLinkName: PUNICODE_STRING,
        PropertyKey: *const DEVPROPKEY,
        Lcid: LCID,
        Flags: ULONG,
        Type: DEVPROPTYPE,
        Size: ULONG,
        Data: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoGetDeviceInterfacePropertyData(
        SymbolicLinkName: PUNICODE_STRING,
        PropertyKey: *const DEVPROPKEY,
        Lcid: LCID,
        Flags: ULONG,
        Size: ULONG,
        Data: PVOID,
        RequiredSize: PULONG,
        Type: PDEVPROPTYPE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoGetDeviceNumaNode(Pdo: PDEVICE_OBJECT, NodeNumber: PUSHORT) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoReplacePartitionUnit(
        TargetPdo: PDEVICE_OBJECT,
        SparePdo: PDEVICE_OBJECT,
        Flags: ULONG,
    ) -> NTSTATUS;
}
pub type PPNP_REPLACE_DRIVER_INTERFACE = *mut _PNP_REPLACE_DRIVER_INTERFACE;
pub type PREPLACE_DRIVER_INIT = ::core::option::Option<
    unsafe extern "C" fn(Interface: PPNP_REPLACE_DRIVER_INTERFACE, Unused: PVOID) -> NTSTATUS,
>;
pub type PREPLACE_MAP_MEMORY = ::core::option::Option<
    unsafe extern "C" fn(
        TargetPhysicalAddress: PHYSICAL_ADDRESS,
        SparePhysicalAddress: PHYSICAL_ADDRESS,
        NumberOfBytes: PLARGE_INTEGER,
        TargetAddress: *mut PVOID,
        SpareAddress: *mut PVOID,
    ) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PNP_REPLACE_MEMORY_LIST {
    pub AllocatedCount: ULONG,
    pub Count: ULONG,
    pub TotalLength: ULONGLONG,
    pub Ranges: [_PNP_REPLACE_MEMORY_LIST__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PNP_REPLACE_MEMORY_LIST__bindgen_ty_1 {
    pub Address: PHYSICAL_ADDRESS,
    pub Length: ULONGLONG,
}
pub type PNP_REPLACE_MEMORY_LIST = _PNP_REPLACE_MEMORY_LIST;
pub type PPNP_REPLACE_MEMORY_LIST = *mut _PNP_REPLACE_MEMORY_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PNP_REPLACE_PROCESSOR_LIST {
    pub Affinity: PKAFFINITY,
    pub GroupCount: ULONG,
    pub AllocatedCount: ULONG,
    pub Count: ULONG,
    pub ApicIds: [ULONG; 1usize],
}
pub type PNP_REPLACE_PROCESSOR_LIST = _PNP_REPLACE_PROCESSOR_LIST;
pub type PPNP_REPLACE_PROCESSOR_LIST = *mut _PNP_REPLACE_PROCESSOR_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PNP_REPLACE_PROCESSOR_LIST_V1 {
    pub AffinityMask: KAFFINITY,
    pub AllocatedCount: ULONG,
    pub Count: ULONG,
    pub ApicIds: [ULONG; 1usize],
}
pub type PNP_REPLACE_PROCESSOR_LIST_V1 = _PNP_REPLACE_PROCESSOR_LIST_V1;
pub type PPNP_REPLACE_PROCESSOR_LIST_V1 = *mut _PNP_REPLACE_PROCESSOR_LIST_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PNP_REPLACE_PARAMETERS {
    pub Size: ULONG,
    pub Version: ULONG,
    pub Target: ULONG64,
    pub Spare: ULONG64,
    pub TargetProcessors: PPNP_REPLACE_PROCESSOR_LIST,
    pub SpareProcessors: PPNP_REPLACE_PROCESSOR_LIST,
    pub TargetMemory: PPNP_REPLACE_MEMORY_LIST,
    pub SpareMemory: PPNP_REPLACE_MEMORY_LIST,
    pub MapMemory: PREPLACE_MAP_MEMORY,
}
pub type PNP_REPLACE_PARAMETERS = _PNP_REPLACE_PARAMETERS;
pub type PPNP_REPLACE_PARAMETERS = *mut _PNP_REPLACE_PARAMETERS;
pub type PREPLACE_UNLOAD = ::core::option::Option<unsafe extern "C" fn()>;
pub type PREPLACE_BEGIN = ::core::option::Option<
    unsafe extern "C" fn(Parameters: PPNP_REPLACE_PARAMETERS, Context: *mut PVOID) -> NTSTATUS,
>;
pub type PREPLACE_END = ::core::option::Option<unsafe extern "C" fn(Context: PVOID) -> NTSTATUS>;
pub type PREPLACE_MIRROR_PHYSICAL_MEMORY = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        PhysicalAddress: PHYSICAL_ADDRESS,
        ByteCount: LARGE_INTEGER,
    ) -> NTSTATUS,
>;
pub type PREPLACE_SET_PROCESSOR_ID = ::core::option::Option<
    unsafe extern "C" fn(Context: PVOID, ApicId: ULONG, Target: BOOLEAN) -> NTSTATUS,
>;
pub type PREPLACE_SWAP = ::core::option::Option<unsafe extern "C" fn(Context: PVOID) -> NTSTATUS>;
pub type PREPLACE_INITIATE_HARDWARE_MIRROR =
::core::option::Option<unsafe extern "C" fn(Context: PVOID) -> NTSTATUS>;
pub type PREPLACE_MIRROR_PLATFORM_MEMORY =
::core::option::Option<unsafe extern "C" fn(Context: PVOID) -> NTSTATUS>;
pub type PREPLACE_GET_MEMORY_DESTINATION = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        SourceAddress: PHYSICAL_ADDRESS,
        DestinationAddress: PPHYSICAL_ADDRESS,
    ) -> NTSTATUS,
>;
pub type PREPLACE_ENABLE_DISABLE_HARDWARE_QUIESCE =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, Enable: BOOLEAN) -> NTSTATUS>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PNP_REPLACE_DRIVER_INTERFACE {
    pub Size: ULONG,
    pub Version: ULONG,
    pub Flags: ULONG,
    pub Unload: PREPLACE_UNLOAD,
    pub BeginReplace: PREPLACE_BEGIN,
    pub EndReplace: PREPLACE_END,
    pub MirrorPhysicalMemory: PREPLACE_MIRROR_PHYSICAL_MEMORY,
    pub SetProcessorId: PREPLACE_SET_PROCESSOR_ID,
    pub Swap: PREPLACE_SWAP,
    pub InitiateHardwareMirror: PREPLACE_INITIATE_HARDWARE_MIRROR,
    pub MirrorPlatformMemory: PREPLACE_MIRROR_PLATFORM_MEMORY,
    pub GetMemoryDestination: PREPLACE_GET_MEMORY_DESTINATION,
    pub EnableDisableHardwareQuiesce: PREPLACE_ENABLE_DISABLE_HARDWARE_QUIESCE,
}
pub type PNP_REPLACE_DRIVER_INTERFACE = _PNP_REPLACE_DRIVER_INTERFACE;
pub type PCRASHDUMP_POWER_ON =
::core::option::Option<unsafe extern "C" fn(Context: PVOID) -> NTSTATUS>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRASHDUMP_FUNCTIONS_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub PowerOn: PCRASHDUMP_POWER_ON,
}
pub type CRASHDUMP_FUNCTIONS_INTERFACE = _CRASHDUMP_FUNCTIONS_INTERFACE;
pub type PCRASHDUMP_FUNCTIONS_INTERFACE = *mut _CRASHDUMP_FUNCTIONS_INTERFACE;
pub const _DEVICE_RESET_TYPE_FunctionLevelDeviceReset: _DEVICE_RESET_TYPE = 0;
pub const _DEVICE_RESET_TYPE_PlatformLevelDeviceReset: _DEVICE_RESET_TYPE = 1;
pub type _DEVICE_RESET_TYPE = core::ffi::c_int;
pub use self::_DEVICE_RESET_TYPE as DEVICE_RESET_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DEVICE_BUS_SPECIFIC_RESET_TYPE {
    pub Pci: _DEVICE_BUS_SPECIFIC_RESET_TYPE__bindgen_ty_1,
    pub Acpi: _DEVICE_BUS_SPECIFIC_RESET_TYPE__bindgen_ty_2,
    pub AsULONGLONG: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_BUS_SPECIFIC_RESET_TYPE__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _DEVICE_BUS_SPECIFIC_RESET_TYPE__bindgen_ty_1 {
    #[inline]
    pub fn FunctionLevelDeviceReset(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_FunctionLevelDeviceReset(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FunctionLevelDeviceReset_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_FunctionLevelDeviceReset_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PlatformLevelDeviceReset(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PlatformLevelDeviceReset(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PlatformLevelDeviceReset_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_PlatformLevelDeviceReset_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SecondaryBusReset(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_SecondaryBusReset(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SecondaryBusReset_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_SecondaryBusReset_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 61u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 61u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                61u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                61u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FunctionLevelDeviceReset: ULONGLONG,
        PlatformLevelDeviceReset: ULONGLONG,
        SecondaryBusReset: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let FunctionLevelDeviceReset: u64 =
                unsafe { ::core::mem::transmute(FunctionLevelDeviceReset) };
            FunctionLevelDeviceReset as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PlatformLevelDeviceReset: u64 =
                unsafe { ::core::mem::transmute(PlatformLevelDeviceReset) };
            PlatformLevelDeviceReset as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SecondaryBusReset: u64 = unsafe { ::core::mem::transmute(SecondaryBusReset) };
            SecondaryBusReset as u64
        });
        __bindgen_bitfield_unit.set(3usize, 61u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_BUS_SPECIFIC_RESET_TYPE__bindgen_ty_2 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _DEVICE_BUS_SPECIFIC_RESET_TYPE__bindgen_ty_2 {
    #[inline]
    pub fn FunctionLevelDeviceReset(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_FunctionLevelDeviceReset(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FunctionLevelDeviceReset_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_FunctionLevelDeviceReset_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PlatformLevelDeviceReset(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PlatformLevelDeviceReset(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PlatformLevelDeviceReset_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_PlatformLevelDeviceReset_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 62u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 62u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                62u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                62u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FunctionLevelDeviceReset: ULONGLONG,
        PlatformLevelDeviceReset: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let FunctionLevelDeviceReset: u64 =
                unsafe { ::core::mem::transmute(FunctionLevelDeviceReset) };
            FunctionLevelDeviceReset as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PlatformLevelDeviceReset: u64 =
                unsafe { ::core::mem::transmute(PlatformLevelDeviceReset) };
            PlatformLevelDeviceReset as u64
        });
        __bindgen_bitfield_unit.set(2usize, 62u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type DEVICE_BUS_SPECIFIC_RESET_TYPE = _DEVICE_BUS_SPECIFIC_RESET_TYPE;
pub type PDEVICE_BUS_SPECIFIC_RESET_TYPE = *mut _DEVICE_BUS_SPECIFIC_RESET_TYPE;
pub type DEVICE_RESET_COMPLETION =
::core::option::Option<unsafe extern "C" fn(Status: NTSTATUS, Context: PVOID)>;
pub type PDEVICE_RESET_COMPLETION = DEVICE_RESET_COMPLETION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FUNCTION_LEVEL_DEVICE_RESET_PARAMETERS {
    pub Size: ULONG,
    pub DeviceResetCompletion: PDEVICE_RESET_COMPLETION,
    pub CompletionContext: PVOID,
}
pub type FUNCTION_LEVEL_DEVICE_RESET_PARAMETERS = _FUNCTION_LEVEL_DEVICE_RESET_PARAMETERS;
pub type PFUNCTION_LEVEL_DEVICE_RESET_PARAMETERS = *mut _FUNCTION_LEVEL_DEVICE_RESET_PARAMETERS;
pub type DEVICE_RESET_HANDLER = ::core::option::Option<
    unsafe extern "C" fn(
        InterfaceContext: PVOID,
        ResetType: DEVICE_RESET_TYPE,
        Flags: ULONG,
        ResetParameters: PVOID,
    ) -> NTSTATUS,
>;
pub type PDEVICE_RESET_HANDLER = DEVICE_RESET_HANDLER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DEVICE_BUS_SPECIFIC_RESET_INFO {
    pub BusTypeGuid: GUID,
    pub ResetTypeSupported: DEVICE_BUS_SPECIFIC_RESET_TYPE,
}
pub type DEVICE_BUS_SPECIFIC_RESET_INFO = _DEVICE_BUS_SPECIFIC_RESET_INFO;
pub type PDEVICE_BUS_SPECIFIC_RESET_INFO = *mut _DEVICE_BUS_SPECIFIC_RESET_INFO;
pub type DEVICE_QUERY_BUS_SPECIFIC_RESET_HANDLER = ::core::option::Option<
    unsafe extern "C" fn(
        InterfaceContext: PVOID,
        ResetInfoCount: PULONG,
        ResetInfoSupported: PDEVICE_BUS_SPECIFIC_RESET_INFO,
    ) -> NTSTATUS,
>;
pub type PDEVICE_QUERY_BUS_SPECIFIC_RESET_HANDLER = DEVICE_QUERY_BUS_SPECIFIC_RESET_HANDLER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _BUS_SPECIFIC_RESET_FLAGS {
    pub u: _BUS_SPECIFIC_RESET_FLAGS__bindgen_ty_1,
    pub AsUlonglong: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BUS_SPECIFIC_RESET_FLAGS__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _BUS_SPECIFIC_RESET_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn KeepStackReset(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_KeepStackReset(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn KeepStackReset_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_KeepStackReset_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 63u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 63u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                63u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                63u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        KeepStackReset: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let KeepStackReset: u64 = unsafe { ::core::mem::transmute(KeepStackReset) };
            KeepStackReset as u64
        });
        __bindgen_bitfield_unit.set(1usize, 63u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type BUS_SPECIFIC_RESET_FLAGS = _BUS_SPECIFIC_RESET_FLAGS;
pub type PBUS_SPECIFIC_RESET_FLAGS = *mut _BUS_SPECIFIC_RESET_FLAGS;
pub type DEVICE_BUS_SPECIFIC_RESET_HANDLER = ::core::option::Option<
    unsafe extern "C" fn(
        InterfaceContext: PVOID,
        BusType: *const GUID,
        ResetTypeSelected: DEVICE_BUS_SPECIFIC_RESET_TYPE,
        Flags: PBUS_SPECIFIC_RESET_FLAGS,
        ResetParameters: PVOID,
    ) -> NTSTATUS,
>;
pub type PDEVICE_BUS_SPECIFIC_RESET_HANDLER = DEVICE_BUS_SPECIFIC_RESET_HANDLER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DEVICE_RESET_STATUS_FLAGS {
    pub u: _DEVICE_RESET_STATUS_FLAGS__bindgen_ty_1,
    pub AsUlonglong: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_RESET_STATUS_FLAGS__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _DEVICE_RESET_STATUS_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn KeepStackReset(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_KeepStackReset(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn KeepStackReset_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_KeepStackReset_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RecoveringFromBusError(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RecoveringFromBusError(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RecoveringFromBusError_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_RecoveringFromBusError_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 62u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 62u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                62u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                62u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        KeepStackReset: ULONGLONG,
        RecoveringFromBusError: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let KeepStackReset: u64 = unsafe { ::core::mem::transmute(KeepStackReset) };
            KeepStackReset as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let RecoveringFromBusError: u64 =
                unsafe { ::core::mem::transmute(RecoveringFromBusError) };
            RecoveringFromBusError as u64
        });
        __bindgen_bitfield_unit.set(2usize, 62u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type DEVICE_RESET_STATUS_FLAGS = _DEVICE_RESET_STATUS_FLAGS;
pub type PDEVICE_RESET_STATUS_FLAGS = *mut _DEVICE_RESET_STATUS_FLAGS;
pub type GET_DEVICE_RESET_STATUS = ::core::option::Option<
    unsafe extern "C" fn(
        InterfaceContext: PVOID,
        IsResetting: PBOOLEAN,
        ResetTypeSelected: PDEVICE_BUS_SPECIFIC_RESET_TYPE,
        Flags: PDEVICE_RESET_STATUS_FLAGS,
    ) -> NTSTATUS,
>;
pub type PGET_DEVICE_RESET_STATUS = GET_DEVICE_RESET_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_RESET_INTERFACE_STANDARD {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub DeviceReset: PDEVICE_RESET_HANDLER,
    pub SupportedResetTypes: ULONG,
    pub Reserved: PVOID,
    pub QueryBusSpecificResetInfo: PDEVICE_QUERY_BUS_SPECIFIC_RESET_HANDLER,
    pub DeviceBusSpecificReset: PDEVICE_BUS_SPECIFIC_RESET_HANDLER,
    pub GetDeviceResetStatus: PGET_DEVICE_RESET_STATUS,
}
pub type DEVICE_RESET_INTERFACE_STANDARD = _DEVICE_RESET_INTERFACE_STANDARD;
pub type PDEVICE_RESET_INTERFACE_STANDARD = *mut _DEVICE_RESET_INTERFACE_STANDARD;
pub type SECURE_DRIVER_PROCESS_REFERENCE =
::core::option::Option<unsafe extern "C" fn(InterfaceContext: PVOID) -> PEPROCESS>;
pub type PSECURE_DRIVER_PROCESS_REFERENCE = SECURE_DRIVER_PROCESS_REFERENCE;
pub type SECURE_DRIVER_PROCESS_DEREFERENCE =
::core::option::Option<unsafe extern "C" fn(InterfaceContext: PVOID, Process: PEPROCESS)>;
pub type PSECURE_DRIVER_PROCESS_DEREFERENCE = SECURE_DRIVER_PROCESS_DEREFERENCE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURE_DRIVER_INTERFACE {
    pub InterfaceHeader: INTERFACE,
    pub ProcessReference: PSECURE_DRIVER_PROCESS_REFERENCE,
    pub ProcessDereference: PSECURE_DRIVER_PROCESS_DEREFERENCE,
    pub Reserved: ULONG,
}
pub type SECURE_DRIVER_INTERFACE = _SECURE_DRIVER_INTERFACE;
pub type PSECURE_DRIVER_INTERFACE = *mut _SECURE_DRIVER_INTERFACE;
pub type GET_SDEV_IDENTIFIER =
::core::option::Option<unsafe extern "C" fn(InterfaceContext: PVOID) -> ULONGLONG>;
pub type PGET_SDEV_IDENTIFIER = GET_SDEV_IDENTIFIER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDEV_IDENTIFIER_INTERFACE {
    pub InterfaceHeader: INTERFACE,
    pub GetIdentifier: PGET_SDEV_IDENTIFIER,
}
pub type SDEV_IDENTIFIER_INTERFACE = _SDEV_IDENTIFIER_INTERFACE;
pub type PSDEV_IDENTIFIER_INTERFACE = *mut _SDEV_IDENTIFIER_INTERFACE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DEVICE_DESCRIPTION {
    pub Version: ULONG,
    pub Master: BOOLEAN,
    pub ScatterGather: BOOLEAN,
    pub DemandMode: BOOLEAN,
    pub AutoInitialize: BOOLEAN,
    pub Dma32BitAddresses: BOOLEAN,
    pub IgnoreCount: BOOLEAN,
    pub Reserved1: BOOLEAN,
    pub Dma64BitAddresses: BOOLEAN,
    pub BusNumber: ULONG,
    pub DmaChannel: ULONG,
    pub InterfaceType: INTERFACE_TYPE,
    pub DmaWidth: DMA_WIDTH,
    pub DmaSpeed: DMA_SPEED,
    pub MaximumLength: ULONG,
    pub DmaPort: ULONG,
    pub DmaAddressWidth: ULONG,
    pub DmaControllerInstance: ULONG,
    pub DmaRequestLine: ULONG,
    pub DeviceAddress: PHYSICAL_ADDRESS,
}
pub type DEVICE_DESCRIPTION = _DEVICE_DESCRIPTION;
pub type PDEVICE_DESCRIPTION = *mut _DEVICE_DESCRIPTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DMA_ADAPTER_INFO_V1 {
    pub ReadDmaCounterAvailable: ULONG,
    pub ScatterGatherLimit: ULONG,
    pub DmaAddressWidth: ULONG,
    pub Flags: ULONG,
    pub MinimumTransferUnit: ULONG,
}
pub type DMA_ADAPTER_INFO_V1 = _DMA_ADAPTER_INFO_V1;
pub type PDMA_ADAPTER_INFO_V1 = *mut _DMA_ADAPTER_INFO_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DMA_ADAPTER_INFO_CRASHDUMP {
    pub DeviceDescription: DEVICE_DESCRIPTION,
    pub DeviceIdSize: SIZE_T,
    pub DeviceId: PVOID,
}
pub type DMA_ADAPTER_INFO_CRASHDUMP = _DMA_ADAPTER_INFO_CRASHDUMP;
pub type PDMA_ADAPTER_INFO_CRASHDUMP = *mut _DMA_ADAPTER_INFO_CRASHDUMP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DMA_ADAPTER_INFO {
    pub Version: ULONG,
    pub __bindgen_anon_1: _DMA_ADAPTER_INFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DMA_ADAPTER_INFO__bindgen_ty_1 {
    pub V1: DMA_ADAPTER_INFO_V1,
    pub Crashdump: DMA_ADAPTER_INFO_CRASHDUMP,
}
pub type DMA_ADAPTER_INFO = _DMA_ADAPTER_INFO;
pub type PDMA_ADAPTER_INFO = *mut _DMA_ADAPTER_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DMA_TRANSFER_INFO_V1 {
    pub MapRegisterCount: ULONG,
    pub ScatterGatherElementCount: ULONG,
    pub ScatterGatherListSize: ULONG,
}
pub type DMA_TRANSFER_INFO_V1 = _DMA_TRANSFER_INFO_V1;
pub type PDMA_TRANSFER_INFO_V1 = *mut _DMA_TRANSFER_INFO_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DMA_TRANSFER_INFO_V2 {
    pub MapRegisterCount: ULONG,
    pub ScatterGatherElementCount: ULONG,
    pub ScatterGatherListSize: ULONG,
    pub LogicalPageCount: ULONG,
}
pub type DMA_TRANSFER_INFO_V2 = _DMA_TRANSFER_INFO_V2;
pub type PDMA_TRANSFER_INFO_V2 = *mut _DMA_TRANSFER_INFO_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DMA_TRANSFER_INFO {
    pub Version: ULONG,
    pub __bindgen_anon_1: _DMA_TRANSFER_INFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DMA_TRANSFER_INFO__bindgen_ty_1 {
    pub V1: DMA_TRANSFER_INFO_V1,
    pub V2: DMA_TRANSFER_INFO_V2,
}
pub type DMA_TRANSFER_INFO = _DMA_TRANSFER_INFO;
pub type PDMA_TRANSFER_INFO = *mut _DMA_TRANSFER_INFO;
unsafe extern "C" {
    pub fn KeFlushWriteBuffer();
}
unsafe extern "C" {
    pub fn KeQueryPerformanceCounter(PerformanceFrequency: PLARGE_INTEGER) -> LARGE_INTEGER;
}
unsafe extern "C" {
    pub fn KeStallExecutionProcessor(MicroSeconds: ULONG);
}
pub type PROCESSOR_HALT_ROUTINE =
::core::option::Option<unsafe extern "C" fn(Context: PVOID) -> NTSTATUS>;
pub type PPROCESSOR_HALT_ROUTINE = PROCESSOR_HALT_ROUTINE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IOMMU_DMA_DEVICE {
    _unused: [u8; 0],
}
pub type IOMMU_DMA_DEVICE = _IOMMU_DMA_DEVICE;
pub type PIOMMU_DMA_DEVICE = *mut _IOMMU_DMA_DEVICE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SCATTER_GATHER_ELEMENT {
    pub Address: PHYSICAL_ADDRESS,
    pub Length: ULONG,
    pub Reserved: ULONG_PTR,
}
pub type SCATTER_GATHER_ELEMENT = _SCATTER_GATHER_ELEMENT;
pub type PSCATTER_GATHER_ELEMENT = *mut _SCATTER_GATHER_ELEMENT;
#[repr(C)]
pub struct _SCATTER_GATHER_LIST {
    pub NumberOfElements: ULONG,
    pub Reserved: ULONG_PTR,
    pub Elements: __IncompleteArrayField<SCATTER_GATHER_ELEMENT>,
}
pub type SCATTER_GATHER_LIST = _SCATTER_GATHER_LIST;
pub type PSCATTER_GATHER_LIST = *mut _SCATTER_GATHER_LIST;
pub type PDMA_OPERATIONS = *mut _DMA_OPERATIONS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DMA_ADAPTER {
    pub Version: USHORT,
    pub Size: USHORT,
    pub DmaOperations: PDMA_OPERATIONS,
}
pub type DMA_ADAPTER = _DMA_ADAPTER;
pub type PDMA_ADAPTER = *mut _DMA_ADAPTER;
pub const DMA_COMPLETION_STATUS_DmaComplete: DMA_COMPLETION_STATUS = 0;
pub const DMA_COMPLETION_STATUS_DmaAborted: DMA_COMPLETION_STATUS = 1;
pub const DMA_COMPLETION_STATUS_DmaError: DMA_COMPLETION_STATUS = 2;
pub const DMA_COMPLETION_STATUS_DmaCancelled: DMA_COMPLETION_STATUS = 3;
pub type DMA_COMPLETION_STATUS = core::ffi::c_int;
pub const _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE_CommonBufferConfigTypeLogicalAddressLimits : _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE = 0 ;
pub const _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE_CommonBufferConfigTypeSubSection:
_DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE = 1;
pub const _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE_CommonBufferConfigTypeHardwareAccessPermissions : _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE = 2 ;
pub const _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE_CommonBufferConfigTypeMax:
_DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE = 3;
pub type _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE = core::ffi::c_int;
pub use self::_DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE as DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE;
pub type PDMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE =
*mut _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE;
pub const _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE_CommonBufferHardwareAccessReadOnly : _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE = 0 ;
pub const _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE_CommonBufferHardwareAccessWriteOnly : _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE = 1 ;
pub const _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE_CommonBufferHardwareAccessReadWrite : _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE = 2 ;
pub const _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE_CommonBufferHardwareAccessMax:
_DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE = 3;
pub type _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE = core::ffi::c_int;
pub use self::_DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE as DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE;
pub type PDMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE =
*mut _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION {
    pub ConfigType: DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE,
    pub __bindgen_anon_1: _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION__bindgen_ty_1 {
    pub LogicalAddressLimits: _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION__bindgen_ty_1__bindgen_ty_1,
    pub SubSection: _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION__bindgen_ty_1__bindgen_ty_2,
    pub HardwareAccessType: DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE,
    pub Reserved: [ULONGLONG; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION__bindgen_ty_1__bindgen_ty_1 {
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION__bindgen_ty_1__bindgen_ty_2 {
    pub Offset: ULONGLONG,
    pub Length: ULONG,
}
pub type DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION = _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION;
pub type PDMA_COMMON_BUFFER_EXTENDED_CONFIGURATION = *mut _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION;
pub type PPUT_DMA_ADAPTER = ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER)>;
pub type PALLOCATE_COMMON_BUFFER = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        Length: ULONG,
        LogicalAddress: PPHYSICAL_ADDRESS,
        CacheEnabled: BOOLEAN,
    ) -> PVOID,
>;
pub type PFREE_COMMON_BUFFER = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        Length: ULONG,
        LogicalAddress: PHYSICAL_ADDRESS,
        VirtualAddress: PVOID,
        CacheEnabled: BOOLEAN,
    ),
>;
pub type PALLOCATE_ADAPTER_CHANNEL = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        DeviceObject: PDEVICE_OBJECT,
        NumberOfMapRegisters: ULONG,
        ExecutionRoutine: PDRIVER_CONTROL,
        Context: PVOID,
    ) -> NTSTATUS,
>;
pub type PFLUSH_ADAPTER_BUFFERS = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        Mdl: PMDL,
        MapRegisterBase: PVOID,
        CurrentVa: PVOID,
        Length: ULONG,
        WriteToDevice: BOOLEAN,
    ) -> BOOLEAN,
>;
pub type PFREE_ADAPTER_CHANNEL =
::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER)>;
pub type PFREE_ADAPTER_OBJECT = ::core::option::Option<
    unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER, AllocationAction: IO_ALLOCATION_ACTION),
>;
pub type PFREE_MAP_REGISTERS = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        MapRegisterBase: PVOID,
        NumberOfMapRegisters: ULONG,
    ),
>;
pub type PMAP_TRANSFER = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        Mdl: PMDL,
        MapRegisterBase: PVOID,
        CurrentVa: PVOID,
        Length: PULONG,
        WriteToDevice: BOOLEAN,
    ) -> PHYSICAL_ADDRESS,
>;
pub type PGET_DMA_ALIGNMENT =
::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER) -> ULONG>;
pub type PREAD_DMA_COUNTER =
::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER) -> ULONG>;
pub type DRIVER_LIST_CONTROL = ::core::option::Option<
    unsafe extern "C" fn(
        DeviceObject: *mut _DEVICE_OBJECT,
        Irp: *mut _IRP,
        ScatterGather: PSCATTER_GATHER_LIST,
        Context: PVOID,
    ),
>;
pub type PDRIVER_LIST_CONTROL = DRIVER_LIST_CONTROL;
pub type PGET_SCATTER_GATHER_LIST = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        DeviceObject: PDEVICE_OBJECT,
        Mdl: PMDL,
        CurrentVa: PVOID,
        Length: ULONG,
        ExecutionRoutine: PDRIVER_LIST_CONTROL,
        Context: PVOID,
        WriteToDevice: BOOLEAN,
    ) -> NTSTATUS,
>;
pub type PPUT_SCATTER_GATHER_LIST = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        ScatterGather: PSCATTER_GATHER_LIST,
        WriteToDevice: BOOLEAN,
    ),
>;
pub type PCALCULATE_SCATTER_GATHER_LIST_SIZE = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        Mdl: PMDL,
        CurrentVa: PVOID,
        Length: ULONG,
        ScatterGatherListSize: PULONG,
        pNumberOfMapRegisters: PULONG,
    ) -> NTSTATUS,
>;
pub type PBUILD_SCATTER_GATHER_LIST = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        DeviceObject: PDEVICE_OBJECT,
        Mdl: PMDL,
        CurrentVa: PVOID,
        Length: ULONG,
        ExecutionRoutine: PDRIVER_LIST_CONTROL,
        Context: PVOID,
        WriteToDevice: BOOLEAN,
        ScatterGatherBuffer: PVOID,
        ScatterGatherLength: ULONG,
    ) -> NTSTATUS,
>;
pub type PBUILD_MDL_FROM_SCATTER_GATHER_LIST = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        ScatterGather: PSCATTER_GATHER_LIST,
        OriginalMdl: PMDL,
        TargetMdl: *mut PMDL,
    ) -> NTSTATUS,
>;
pub type PGET_DMA_ADAPTER_INFO = ::core::option::Option<
    unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER, AdapterInfo: PDMA_ADAPTER_INFO) -> NTSTATUS,
>;
pub type PGET_DMA_TRANSFER_INFO = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        Mdl: PMDL,
        Offset: ULONGLONG,
        Length: ULONG,
        WriteOnly: BOOLEAN,
        TransferInfo: PDMA_TRANSFER_INFO,
    ) -> NTSTATUS,
>;
pub type PCONFIGURE_ADAPTER_CHANNEL = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        FunctionNumber: ULONG,
        Context: PVOID,
    ) -> NTSTATUS,
>;
pub type PINITIALIZE_DMA_TRANSFER_CONTEXT = ::core::option::Option<
    unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER, DmaTransferContext: PVOID) -> NTSTATUS,
>;
pub type PALLOCATE_COMMON_BUFFER_EX = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        MaximumAddress: PPHYSICAL_ADDRESS,
        Length: ULONG,
        LogicalAddress: PPHYSICAL_ADDRESS,
        CacheEnabled: BOOLEAN,
        PreferredNode: NODE_REQUIREMENT,
    ) -> PVOID,
>;
pub type PALLOCATE_ADAPTER_CHANNEL_EX = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        DeviceObject: PDEVICE_OBJECT,
        DmaTransferContext: PVOID,
        NumberOfMapRegisters: ULONG,
        Flags: ULONG,
        ExecutionRoutine: PDRIVER_CONTROL,
        ExecutionContext: PVOID,
        MapRegisterBase: *mut PVOID,
    ) -> NTSTATUS,
>;
pub type DMA_COMPLETION_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        DeviceObject: PDEVICE_OBJECT,
        CompletionContext: PVOID,
        Status: DMA_COMPLETION_STATUS,
    ),
>;
pub type PDMA_COMPLETION_ROUTINE = DMA_COMPLETION_ROUTINE;
pub type PMAP_TRANSFER_EX = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        Mdl: PMDL,
        MapRegisterBase: PVOID,
        Offset: ULONGLONG,
        DeviceOffset: ULONG,
        Length: PULONG,
        WriteToDevice: BOOLEAN,
        ScatterGatherBuffer: PSCATTER_GATHER_LIST,
        ScatterGatherBufferLength: ULONG,
        DmaCompletionRoutine: PDMA_COMPLETION_ROUTINE,
        CompletionContext: PVOID,
    ) -> NTSTATUS,
>;
pub type PCANCEL_ADAPTER_CHANNEL = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        DeviceObject: PDEVICE_OBJECT,
        DmaTransferContext: PVOID,
    ) -> BOOLEAN,
>;
pub type PCANCEL_MAPPED_TRANSFER = ::core::option::Option<
    unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER, DmaTransferContext: PVOID) -> NTSTATUS,
>;
pub type PFLUSH_ADAPTER_BUFFERS_EX = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        Mdl: PMDL,
        MapRegisterBase: PVOID,
        Offset: ULONGLONG,
        Length: ULONG,
        WriteToDevice: BOOLEAN,
    ) -> NTSTATUS,
>;
pub type PGET_SCATTER_GATHER_LIST_EX = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        DeviceObject: PDEVICE_OBJECT,
        DmaTransferContext: PVOID,
        Mdl: PMDL,
        Offset: ULONGLONG,
        Length: ULONG,
        Flags: ULONG,
        ExecutionRoutine: PDRIVER_LIST_CONTROL,
        Context: PVOID,
        WriteToDevice: BOOLEAN,
        DmaCompletionRoutine: PDMA_COMPLETION_ROUTINE,
        CompletionContext: PVOID,
        ScatterGatherList: *mut PSCATTER_GATHER_LIST,
    ) -> NTSTATUS,
>;
pub type PBUILD_SCATTER_GATHER_LIST_EX = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        DeviceObject: PDEVICE_OBJECT,
        DmaTransferContext: PVOID,
        Mdl: PMDL,
        Offset: ULONGLONG,
        Length: ULONG,
        Flags: ULONG,
        ExecutionRoutine: PDRIVER_LIST_CONTROL,
        Context: PVOID,
        WriteToDevice: BOOLEAN,
        ScatterGatherBuffer: PVOID,
        ScatterGatherLength: ULONG,
        DmaCompletionRoutine: PDMA_COMPLETION_ROUTINE,
        CompletionContext: PVOID,
        ScatterGatherList: PVOID,
    ) -> NTSTATUS,
>;
pub type PALLOCATE_DOMAIN_COMMON_BUFFER = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        DomainHandle: HANDLE,
        MaximumAddress: PPHYSICAL_ADDRESS,
        Length: ULONG,
        Flags: ULONG,
        CacheType: *mut MEMORY_CACHING_TYPE,
        PreferredNode: NODE_REQUIREMENT,
        LogicalAddress: PPHYSICAL_ADDRESS,
        VirtualAddress: *mut PVOID,
    ) -> NTSTATUS,
>;
pub type PALLOCATE_COMMON_BUFFER_WITH_BOUNDS = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        MinimumAddress: PPHYSICAL_ADDRESS,
        MaximumAddress: PPHYSICAL_ADDRESS,
        Length: ULONG,
        Flags: ULONG,
        CacheType: *mut MEMORY_CACHING_TYPE,
        PreferredNode: NODE_REQUIREMENT,
        LogicalAddress: PPHYSICAL_ADDRESS,
    ) -> PVOID,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DMA_COMMON_BUFFER_VECTOR {
    _unused: [u8; 0],
}
pub type DMA_COMMON_BUFFER_VECTOR = _DMA_COMMON_BUFFER_VECTOR;
pub type PDMA_COMMON_BUFFER_VECTOR = *mut _DMA_COMMON_BUFFER_VECTOR;
pub type PALLOCATE_COMMON_BUFFER_VECTOR = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        LowAddress: PHYSICAL_ADDRESS,
        HighAddress: PHYSICAL_ADDRESS,
        CacheType: MEMORY_CACHING_TYPE,
        IdealNode: NODE_REQUIREMENT,
        Flags: ULONG,
        NumberOfElements: ULONG,
        SizeOfElements: ULONGLONG,
        VectorOut: *mut PDMA_COMMON_BUFFER_VECTOR,
    ) -> NTSTATUS,
>;
pub type PGET_COMMON_BUFFER_FROM_VECTOR_BY_INDEX = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        Vector: PDMA_COMMON_BUFFER_VECTOR,
        Index: ULONG,
        VirtualAddressOut: *mut PVOID,
        LogicalAddressOut: PPHYSICAL_ADDRESS,
    ),
>;
pub type PFREE_COMMON_BUFFER_FROM_VECTOR = ::core::option::Option<
    unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER, Vector: PDMA_COMMON_BUFFER_VECTOR, Index: ULONG),
>;
pub type PFREE_COMMON_BUFFER_VECTOR = ::core::option::Option<
    unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER, Vector: PDMA_COMMON_BUFFER_VECTOR),
>;
pub type PCREATE_COMMON_BUFFER_FROM_MDL = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        Mdl: PMDL,
        ExtendedConfigs: PDMA_COMMON_BUFFER_EXTENDED_CONFIGURATION,
        ExtendedConfigsCount: ULONG,
        LogicalAddress: PPHYSICAL_ADDRESS,
    ) -> NTSTATUS,
>;
pub type PFLUSH_DMA_BUFFER = ::core::option::Option<
    unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER, Mdl: PMDL, ReadOperation: BOOLEAN) -> NTSTATUS,
>;
pub type PJOIN_DMA_DOMAIN = ::core::option::Option<
    unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER, DomainHandle: HANDLE) -> NTSTATUS,
>;
pub type PLEAVE_DMA_DOMAIN =
::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER) -> NTSTATUS>;
pub type PGET_DMA_DOMAIN =
::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER) -> HANDLE>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DMA_OPERATIONS {
    pub Size: ULONG,
    pub PutDmaAdapter: PPUT_DMA_ADAPTER,
    pub AllocateCommonBuffer: PALLOCATE_COMMON_BUFFER,
    pub FreeCommonBuffer: PFREE_COMMON_BUFFER,
    pub AllocateAdapterChannel: PALLOCATE_ADAPTER_CHANNEL,
    pub FlushAdapterBuffers: PFLUSH_ADAPTER_BUFFERS,
    pub FreeAdapterChannel: PFREE_ADAPTER_CHANNEL,
    pub FreeMapRegisters: PFREE_MAP_REGISTERS,
    pub MapTransfer: PMAP_TRANSFER,
    pub GetDmaAlignment: PGET_DMA_ALIGNMENT,
    pub ReadDmaCounter: PREAD_DMA_COUNTER,
    pub GetScatterGatherList: PGET_SCATTER_GATHER_LIST,
    pub PutScatterGatherList: PPUT_SCATTER_GATHER_LIST,
    pub CalculateScatterGatherList: PCALCULATE_SCATTER_GATHER_LIST_SIZE,
    pub BuildScatterGatherList: PBUILD_SCATTER_GATHER_LIST,
    pub BuildMdlFromScatterGatherList: PBUILD_MDL_FROM_SCATTER_GATHER_LIST,
    pub GetDmaAdapterInfo: PGET_DMA_ADAPTER_INFO,
    pub GetDmaTransferInfo: PGET_DMA_TRANSFER_INFO,
    pub InitializeDmaTransferContext: PINITIALIZE_DMA_TRANSFER_CONTEXT,
    pub AllocateCommonBufferEx: PALLOCATE_COMMON_BUFFER_EX,
    pub AllocateAdapterChannelEx: PALLOCATE_ADAPTER_CHANNEL_EX,
    pub ConfigureAdapterChannel: PCONFIGURE_ADAPTER_CHANNEL,
    pub CancelAdapterChannel: PCANCEL_ADAPTER_CHANNEL,
    pub MapTransferEx: PMAP_TRANSFER_EX,
    pub GetScatterGatherListEx: PGET_SCATTER_GATHER_LIST_EX,
    pub BuildScatterGatherListEx: PBUILD_SCATTER_GATHER_LIST_EX,
    pub FlushAdapterBuffersEx: PFLUSH_ADAPTER_BUFFERS_EX,
    pub FreeAdapterObject: PFREE_ADAPTER_OBJECT,
    pub CancelMappedTransfer: PCANCEL_MAPPED_TRANSFER,
    pub AllocateDomainCommonBuffer: PALLOCATE_DOMAIN_COMMON_BUFFER,
    pub FlushDmaBuffer: PFLUSH_DMA_BUFFER,
    pub JoinDmaDomain: PJOIN_DMA_DOMAIN,
    pub LeaveDmaDomain: PLEAVE_DMA_DOMAIN,
    pub GetDmaDomain: PGET_DMA_DOMAIN,
    pub AllocateCommonBufferWithBounds: PALLOCATE_COMMON_BUFFER_WITH_BOUNDS,
    pub AllocateCommonBufferVector: PALLOCATE_COMMON_BUFFER_VECTOR,
    pub GetCommonBufferFromVectorByIndex: PGET_COMMON_BUFFER_FROM_VECTOR_BY_INDEX,
    pub FreeCommonBufferFromVector: PFREE_COMMON_BUFFER_FROM_VECTOR,
    pub FreeCommonBufferVector: PFREE_COMMON_BUFFER_VECTOR,
    pub CreateCommonBufferFromMdl: PCREATE_COMMON_BUFFER_FROM_MDL,
}
pub type DMA_OPERATIONS = _DMA_OPERATIONS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IOMMU_DMA_DOMAIN {
    _unused: [u8; 0],
}
pub type IOMMU_DMA_DOMAIN = _IOMMU_DMA_DOMAIN;
pub type PIOMMU_DMA_DOMAIN = *mut _IOMMU_DMA_DOMAIN;
pub const _FAULT_INFORMATION_ARCH_FaultInformationInvalid: _FAULT_INFORMATION_ARCH = 0;
pub const _FAULT_INFORMATION_ARCH_FaultInformationArm64: _FAULT_INFORMATION_ARCH = 1;
pub const _FAULT_INFORMATION_ARCH_FaultInformationX64: _FAULT_INFORMATION_ARCH = 2;
pub type _FAULT_INFORMATION_ARCH = core::ffi::c_int;
pub use self::_FAULT_INFORMATION_ARCH as FAULT_INFORMATION_ARCH;
pub type PFAULT_INFORMATION_ARCH = *mut _FAULT_INFORMATION_ARCH;
pub const _FAULT_INFORMATION_ARM64_TYPE_UnsupportedUpstreamTransaction:
_FAULT_INFORMATION_ARM64_TYPE = 0;
pub const _FAULT_INFORMATION_ARM64_TYPE_AddressSizeFault: _FAULT_INFORMATION_ARM64_TYPE = 1;
pub const _FAULT_INFORMATION_ARM64_TYPE_TlbMatchConflict: _FAULT_INFORMATION_ARM64_TYPE = 2;
pub const _FAULT_INFORMATION_ARM64_TYPE_ExternalFault: _FAULT_INFORMATION_ARM64_TYPE = 3;
pub const _FAULT_INFORMATION_ARM64_TYPE_PermissionFault: _FAULT_INFORMATION_ARM64_TYPE = 4;
pub const _FAULT_INFORMATION_ARM64_TYPE_AccessFlagFault: _FAULT_INFORMATION_ARM64_TYPE = 5;
pub const _FAULT_INFORMATION_ARM64_TYPE_TranslationFault: _FAULT_INFORMATION_ARM64_TYPE = 6;
pub const _FAULT_INFORMATION_ARM64_TYPE_MaxFaultType: _FAULT_INFORMATION_ARM64_TYPE = 7;
pub type _FAULT_INFORMATION_ARM64_TYPE = core::ffi::c_int;
pub use self::_FAULT_INFORMATION_ARM64_TYPE as FAULT_INFORMATION_ARM64_TYPE;
pub type PFAULT_INFORMATION_ARM64_TYPE = *mut _FAULT_INFORMATION_ARM64_TYPE;
pub use self::_FAULT_INFORMATION_ARM64_TYPE as FAULT_INFORMATION_X64_TYPE;
pub type PFAULT_INFORMATION_X64_TYPE = *mut _FAULT_INFORMATION_ARM64_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FAULT_INFORMATION_X64_FLAGS {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _FAULT_INFORMATION_X64_FLAGS {
    #[inline]
    pub fn FaultAddressValid(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FaultAddressValid(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FaultAddressValid_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FaultAddressValid_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FaultAddressValid: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let FaultAddressValid: u32 = unsafe { ::core::mem::transmute(FaultAddressValid) };
            FaultAddressValid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type FAULT_INFORMATION_X64_FLAGS = _FAULT_INFORMATION_X64_FLAGS;
pub type PFAULT_INFORMATION_X64_FLAGS = *mut _FAULT_INFORMATION_X64_FLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FAULT_INFORMATION_ARM64_FLAGS {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _FAULT_INFORMATION_ARM64_FLAGS {
    #[inline]
    pub fn WriteNotRead(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WriteNotRead(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn WriteNotRead_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_WriteNotRead_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn InstructionNotData(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InstructionNotData(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InstructionNotData_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_InstructionNotData_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Privileged(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Privileged(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Privileged_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Privileged_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FaultAddressValid(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FaultAddressValid(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FaultAddressValid_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FaultAddressValid_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                28u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                28u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        WriteNotRead: ULONG,
        InstructionNotData: ULONG,
        Privileged: ULONG,
        FaultAddressValid: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let WriteNotRead: u32 = unsafe { ::core::mem::transmute(WriteNotRead) };
            WriteNotRead as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let InstructionNotData: u32 = unsafe { ::core::mem::transmute(InstructionNotData) };
            InstructionNotData as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Privileged: u32 = unsafe { ::core::mem::transmute(Privileged) };
            Privileged as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let FaultAddressValid: u32 = unsafe { ::core::mem::transmute(FaultAddressValid) };
            FaultAddressValid as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type FAULT_INFORMATION_ARM64_FLAGS = _FAULT_INFORMATION_ARM64_FLAGS;
pub type PFAULT_INFORMATION_ARM64_FLAGS = *mut _FAULT_INFORMATION_ARM64_FLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FAULT_INFORMATION_X64 {
    pub DomainHandle: PVOID,
    pub FaultAddress: PVOID,
    pub Flags: FAULT_INFORMATION_X64_FLAGS,
    pub Type: FAULT_INFORMATION_X64_TYPE,
    pub IommuBaseAddress: ULONG64,
    pub PciSegment: ULONG,
}
pub type FAULT_INFORMATION_X64 = _FAULT_INFORMATION_X64;
pub type PFAULT_INFORMATION_X64 = *mut _FAULT_INFORMATION_X64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FAULT_INFORMATION_ARM64 {
    pub DomainHandle: PVOID,
    pub FaultAddress: PVOID,
    pub PhysicalDeviceObject: PDEVICE_OBJECT,
    pub InputMappingId: ULONG,
    pub Flags: FAULT_INFORMATION_ARM64_FLAGS,
    pub Type: FAULT_INFORMATION_ARM64_TYPE,
    pub IommuBaseAddress: ULONG64,
}
pub type FAULT_INFORMATION_ARM64 = _FAULT_INFORMATION_ARM64;
pub type PFAULT_INFORMATION_ARM64 = *mut _FAULT_INFORMATION_ARM64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FAULT_INFORMATION {
    pub Type: FAULT_INFORMATION_ARCH,
    pub IsStage1: BOOLEAN,
    pub __bindgen_anon_1: _FAULT_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FAULT_INFORMATION__bindgen_ty_1 {
    pub Arm64: FAULT_INFORMATION_ARM64,
    pub X64: FAULT_INFORMATION_X64,
}
pub type FAULT_INFORMATION = _FAULT_INFORMATION;
pub type PFAULT_INFORMATION = *mut _FAULT_INFORMATION;
pub const _DOMAIN_CONFIGURATION_ARCH_DomainConfigurationArm64: _DOMAIN_CONFIGURATION_ARCH = 0;
pub const _DOMAIN_CONFIGURATION_ARCH_DomainConfigurationX64: _DOMAIN_CONFIGURATION_ARCH = 1;
pub const _DOMAIN_CONFIGURATION_ARCH_DomainConfigurationInvalid: _DOMAIN_CONFIGURATION_ARCH = 2;
pub type _DOMAIN_CONFIGURATION_ARCH = core::ffi::c_int;
pub use self::_DOMAIN_CONFIGURATION_ARCH as DOMAIN_CONFIGURATION_ARCH;
pub type PDOMAIN_CONFIGURATION_ARCH = *mut _DOMAIN_CONFIGURATION_ARCH;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DOMAIN_CONFIGURATION_ARM64 {
    pub Ttbr0: PHYSICAL_ADDRESS,
    pub Ttbr1: PHYSICAL_ADDRESS,
    pub Mair0: ULONG,
    pub Mair1: ULONG,
    pub InputSize0: UCHAR,
    pub InputSize1: UCHAR,
    pub CoherentTableWalks: BOOLEAN,
    pub TranslationEnabled: BOOLEAN,
}
pub type DOMAIN_CONFIGURATION_ARM64 = _DOMAIN_CONFIGURATION_ARM64;
pub type PDOMAIN_CONFIGURATION_ARM64 = *mut _DOMAIN_CONFIGURATION_ARM64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DOMAIN_CONFIGURATION_X64 {
    pub FirstLevelPageTableRoot: PHYSICAL_ADDRESS,
    pub TranslationEnabled: BOOLEAN,
}
pub type DOMAIN_CONFIGURATION_X64 = _DOMAIN_CONFIGURATION_X64;
pub type PDOMAIN_CONFIGURATION_X64 = *mut _DOMAIN_CONFIGURATION_X64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DOMAIN_CONFIGURATION {
    pub Type: DOMAIN_CONFIGURATION_ARCH,
    pub __bindgen_anon_1: _DOMAIN_CONFIGURATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DOMAIN_CONFIGURATION__bindgen_ty_1 {
    pub Arm64: DOMAIN_CONFIGURATION_ARM64,
    pub X64: DOMAIN_CONFIGURATION_X64,
}
pub type DOMAIN_CONFIGURATION = _DOMAIN_CONFIGURATION;
pub type PDOMAIN_CONFIGURATION = *mut _DOMAIN_CONFIGURATION;
pub type IOMMU_DEVICE_FAULT_HANDLER = ::core::option::Option<
    unsafe extern "C" fn(Context: PVOID, FaultInformation: PFAULT_INFORMATION),
>;
pub type PIOMMU_DEVICE_FAULT_HANDLER = IOMMU_DEVICE_FAULT_HANDLER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_FAULT_CONFIGURATION {
    pub FaultHandler: PIOMMU_DEVICE_FAULT_HANDLER,
    pub FaultContext: PVOID,
}
pub type DEVICE_FAULT_CONFIGURATION = _DEVICE_FAULT_CONFIGURATION;
pub type PDEVICE_FAULT_CONFIGURATION = *mut _DEVICE_FAULT_CONFIGURATION;
pub type IOMMU_DMA_LOGICAL_ADDRESS = ULONGLONG;
pub type PIOMMU_DMA_LOGICAL_ADDRESS = *mut ULONGLONG;
pub const _IOMMU_DMA_DOMAIN_TYPE_DomainTypeTranslate: _IOMMU_DMA_DOMAIN_TYPE = 0;
pub const _IOMMU_DMA_DOMAIN_TYPE_DomainTypePassThrough: _IOMMU_DMA_DOMAIN_TYPE = 1;
pub const _IOMMU_DMA_DOMAIN_TYPE_DomainTypeUnmanaged: _IOMMU_DMA_DOMAIN_TYPE = 2;
pub const _IOMMU_DMA_DOMAIN_TYPE_DomainTypeTranslateS1: _IOMMU_DMA_DOMAIN_TYPE = 3;
pub const _IOMMU_DMA_DOMAIN_TYPE_DomainTypeMax: _IOMMU_DMA_DOMAIN_TYPE = 4;
pub type _IOMMU_DMA_DOMAIN_TYPE = core::ffi::c_int;
pub use self::_IOMMU_DMA_DOMAIN_TYPE as IOMMU_DMA_DOMAIN_TYPE;
pub type PIOMMU_DMA_DOMAIN_TYPE = *mut _IOMMU_DMA_DOMAIN_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IOMMU_DMA_DOMAIN_CREATION_FLAGS {
    pub __bindgen_anon_1: _IOMMU_DMA_DOMAIN_CREATION_FLAGS__bindgen_ty_1,
    pub AsUlonglong: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IOMMU_DMA_DOMAIN_CREATION_FLAGS__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _IOMMU_DMA_DOMAIN_CREATION_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 64u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 64u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                64u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                64u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(Reserved: ULONGLONG) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 64u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type IOMMU_DMA_DOMAIN_CREATION_FLAGS = _IOMMU_DMA_DOMAIN_CREATION_FLAGS;
pub type PIOMMU_DMA_DOMAIN_CREATION_FLAGS = *mut _IOMMU_DMA_DOMAIN_CREATION_FLAGS;
pub const _IOMMU_DEVICE_CREATION_CONFIGURATION_TYPE_IommuDeviceCreationConfigTypeNone:
_IOMMU_DEVICE_CREATION_CONFIGURATION_TYPE = 0;
pub const _IOMMU_DEVICE_CREATION_CONFIGURATION_TYPE_IommuDeviceCreationConfigTypeAcpi:
_IOMMU_DEVICE_CREATION_CONFIGURATION_TYPE = 1;
pub const _IOMMU_DEVICE_CREATION_CONFIGURATION_TYPE_IommuDeviceCreationConfigTypeDeviceId:
_IOMMU_DEVICE_CREATION_CONFIGURATION_TYPE = 2;
pub const _IOMMU_DEVICE_CREATION_CONFIGURATION_TYPE_IommuDeviceCreationConfigTypeMax:
_IOMMU_DEVICE_CREATION_CONFIGURATION_TYPE = 3;
pub type _IOMMU_DEVICE_CREATION_CONFIGURATION_TYPE = core::ffi::c_int;
pub use self::_IOMMU_DEVICE_CREATION_CONFIGURATION_TYPE as IOMMU_DEVICE_CREATION_CONFIGURATION_TYPE;
pub type PIOMMU_DEVICE_CREATION_CONFIGURATION_TYPE = *mut _IOMMU_DEVICE_CREATION_CONFIGURATION_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IOMMU_DEVICE_CREATION_CONFIGURATION_ACPI {
    pub InputMappingBase: UINT32,
    pub MappingsCount: UINT32,
}
pub type IOMMU_DEVICE_CREATION_CONFIGURATION_ACPI = _IOMMU_DEVICE_CREATION_CONFIGURATION_ACPI;
pub type PIOMMU_DEVICE_CREATION_CONFIGURATION_ACPI = *mut _IOMMU_DEVICE_CREATION_CONFIGURATION_ACPI;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IOMMU_DEVICE_CREATION_CONFIGURATION {
    pub NextConfiguration: LIST_ENTRY,
    pub ConfigType: IOMMU_DEVICE_CREATION_CONFIGURATION_TYPE,
    pub __bindgen_anon_1: _IOMMU_DEVICE_CREATION_CONFIGURATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IOMMU_DEVICE_CREATION_CONFIGURATION__bindgen_ty_1 {
    pub Acpi: IOMMU_DEVICE_CREATION_CONFIGURATION_ACPI,
    pub DeviceId: PVOID,
}
pub type IOMMU_DEVICE_CREATION_CONFIGURATION = _IOMMU_DEVICE_CREATION_CONFIGURATION;
pub type PIOMMU_DEVICE_CREATION_CONFIGURATION = *mut _IOMMU_DEVICE_CREATION_CONFIGURATION;
pub const _IOMMU_MAP_PHYSICAL_ADDRESS_TYPE_MapPhysicalAddressTypeMdl:
_IOMMU_MAP_PHYSICAL_ADDRESS_TYPE = 0;
pub const _IOMMU_MAP_PHYSICAL_ADDRESS_TYPE_MapPhysicalAddressTypeContiguousRange:
_IOMMU_MAP_PHYSICAL_ADDRESS_TYPE = 1;
pub const _IOMMU_MAP_PHYSICAL_ADDRESS_TYPE_MapPhysicalAddressTypePfn:
_IOMMU_MAP_PHYSICAL_ADDRESS_TYPE = 2;
pub const _IOMMU_MAP_PHYSICAL_ADDRESS_TYPE_MapPhysicalAddressTypeMax:
_IOMMU_MAP_PHYSICAL_ADDRESS_TYPE = 3;
pub type _IOMMU_MAP_PHYSICAL_ADDRESS_TYPE = core::ffi::c_int;
pub use self::_IOMMU_MAP_PHYSICAL_ADDRESS_TYPE as IOMMU_MAP_PHYSICAL_ADDRESS_TYPE;
pub type PIOMMU_MAP_PHYSICAL_ADDRESS_TYPE = *mut _IOMMU_MAP_PHYSICAL_ADDRESS_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IOMMU_MAP_PHYSICAL_ADDRESS {
    pub MapType: IOMMU_MAP_PHYSICAL_ADDRESS_TYPE,
    pub __bindgen_anon_1: _IOMMU_MAP_PHYSICAL_ADDRESS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IOMMU_MAP_PHYSICAL_ADDRESS__bindgen_ty_1 {
    pub Mdl: _IOMMU_MAP_PHYSICAL_ADDRESS__bindgen_ty_1__bindgen_ty_1,
    pub ContiguousRange: _IOMMU_MAP_PHYSICAL_ADDRESS__bindgen_ty_1__bindgen_ty_2,
    pub PfnArray: _IOMMU_MAP_PHYSICAL_ADDRESS__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IOMMU_MAP_PHYSICAL_ADDRESS__bindgen_ty_1__bindgen_ty_1 {
    pub Mdl: PMDL,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IOMMU_MAP_PHYSICAL_ADDRESS__bindgen_ty_1__bindgen_ty_2 {
    pub Base: PHYSICAL_ADDRESS,
    pub Size: SIZE_T,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IOMMU_MAP_PHYSICAL_ADDRESS__bindgen_ty_1__bindgen_ty_3 {
    pub PageFrame: PPFN_NUMBER,
    pub NumberOfPages: SIZE_T,
}
pub type IOMMU_MAP_PHYSICAL_ADDRESS = _IOMMU_MAP_PHYSICAL_ADDRESS;
pub type PIOMMU_MAP_PHYSICAL_ADDRESS = *mut _IOMMU_MAP_PHYSICAL_ADDRESS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IOMMU_DMA_RESERVED_REGION {
    pub RegionNext: *mut _IOMMU_DMA_RESERVED_REGION,
    pub Base: IOMMU_DMA_LOGICAL_ADDRESS,
    pub NumberOfPages: SIZE_T,
    pub ShouldMap: BOOLEAN,
}
pub type IOMMU_DMA_RESERVED_REGION = _IOMMU_DMA_RESERVED_REGION;
pub type PIOMMU_DMA_RESERVED_REGION = *mut _IOMMU_DMA_RESERVED_REGION;
pub const _IOMMU_DMA_LOGICAL_ALLOCATOR_TYPE_IommuDmaLogicalAllocatorNone:
_IOMMU_DMA_LOGICAL_ALLOCATOR_TYPE = 0;
pub const _IOMMU_DMA_LOGICAL_ALLOCATOR_TYPE_IommuDmaLogicalAllocatorBuddy:
_IOMMU_DMA_LOGICAL_ALLOCATOR_TYPE = 1;
pub const _IOMMU_DMA_LOGICAL_ALLOCATOR_TYPE_IommuDmaLogicalAllocatorMax:
_IOMMU_DMA_LOGICAL_ALLOCATOR_TYPE = 2;
pub type _IOMMU_DMA_LOGICAL_ALLOCATOR_TYPE = core::ffi::c_int;
pub use self::_IOMMU_DMA_LOGICAL_ALLOCATOR_TYPE as IOMMU_DMA_LOGICAL_ALLOCATOR_TYPE;
pub type PIOMMU_DMA_LOGICAL_ALLOCATOR_TYPE = *mut _IOMMU_DMA_LOGICAL_ALLOCATOR_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IOMMU_DMA_LOGICAL_ALLOCATOR_CONFIG {
    pub LogicalAllocatorType: IOMMU_DMA_LOGICAL_ALLOCATOR_TYPE,
    pub __bindgen_anon_1: _IOMMU_DMA_LOGICAL_ALLOCATOR_CONFIG__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IOMMU_DMA_LOGICAL_ALLOCATOR_CONFIG__bindgen_ty_1 {
    pub BuddyAllocatorConfig: _IOMMU_DMA_LOGICAL_ALLOCATOR_CONFIG__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IOMMU_DMA_LOGICAL_ALLOCATOR_CONFIG__bindgen_ty_1__bindgen_ty_1 {
    pub AddressWidth: ULONG,
}
pub type IOMMU_DMA_LOGICAL_ALLOCATOR_CONFIG = _IOMMU_DMA_LOGICAL_ALLOCATOR_CONFIG;
pub type PIOMMU_DMA_LOGICAL_ALLOCATOR_CONFIG = *mut _IOMMU_DMA_LOGICAL_ALLOCATOR_CONFIG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IOMMU_DMA_LOGICAL_ADDRESS_TOKEN {
    pub LogicalAddressBase: IOMMU_DMA_LOGICAL_ADDRESS,
    pub Size: SIZE_T,
}
pub type IOMMU_DMA_LOGICAL_ADDRESS_TOKEN = _IOMMU_DMA_LOGICAL_ADDRESS_TOKEN;
pub type PIOMMU_DMA_LOGICAL_ADDRESS_TOKEN = *mut _IOMMU_DMA_LOGICAL_ADDRESS_TOKEN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IOMMU_DMA_LOGICAL_ADDRESS_TOKEN_MAPPED_SEGMENT {
    pub OwningToken: PIOMMU_DMA_LOGICAL_ADDRESS_TOKEN,
    pub Offset: SIZE_T,
    pub Size: SIZE_T,
}
pub type IOMMU_DMA_LOGICAL_ADDRESS_TOKEN_MAPPED_SEGMENT =
_IOMMU_DMA_LOGICAL_ADDRESS_TOKEN_MAPPED_SEGMENT;
pub type PIOMMU_DMA_LOGICAL_ADDRESS_TOKEN_MAPPED_SEGMENT =
*mut _IOMMU_DMA_LOGICAL_ADDRESS_TOKEN_MAPPED_SEGMENT;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IOMMU_INTERFACE_STATE_CHANGE_FIELDS {
    pub __bindgen_anon_1: _IOMMU_INTERFACE_STATE_CHANGE_FIELDS__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IOMMU_INTERFACE_STATE_CHANGE_FIELDS__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _IOMMU_INTERFACE_STATE_CHANGE_FIELDS__bindgen_ty_1 {
    #[inline]
    pub fn AvailableDomainTypes(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AvailableDomainTypes(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AvailableDomainTypes_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AvailableDomainTypes_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AvailableDomainTypes: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let AvailableDomainTypes: u32 = unsafe { ::core::mem::transmute(AvailableDomainTypes) };
            AvailableDomainTypes as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type IOMMU_INTERFACE_STATE_CHANGE_FIELDS = _IOMMU_INTERFACE_STATE_CHANGE_FIELDS;
pub type PIOMMU_INTERFACE_STATE_CHANGE_FIELDS = *mut _IOMMU_INTERFACE_STATE_CHANGE_FIELDS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IOMMU_INTERFACE_STATE_CHANGE {
    pub PresentFields: IOMMU_INTERFACE_STATE_CHANGE_FIELDS,
    pub AvailableDomainTypes: ULONG,
}
pub type IOMMU_INTERFACE_STATE_CHANGE = _IOMMU_INTERFACE_STATE_CHANGE;
pub type PIOMMU_INTERFACE_STATE_CHANGE = *mut _IOMMU_INTERFACE_STATE_CHANGE;
pub type IOMMU_INTERFACE_STATE_CHANGE_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(StateChange: PIOMMU_INTERFACE_STATE_CHANGE, Context: PVOID),
>;
pub type PIOMMU_INTERFACE_STATE_CHANGE_CALLBACK = IOMMU_INTERFACE_STATE_CHANGE_CALLBACK;
pub type IOMMU_DOMAIN_CREATE = ::core::option::Option<
    unsafe extern "C" fn(
        OsManagedPageTable: BOOLEAN,
        DomainOut: *mut PIOMMU_DMA_DOMAIN,
    ) -> NTSTATUS,
>;
pub type PIOMMU_DOMAIN_CREATE = IOMMU_DOMAIN_CREATE;
pub type IOMMU_DOMAIN_DELETE =
::core::option::Option<unsafe extern "C" fn(Domain: PIOMMU_DMA_DOMAIN) -> NTSTATUS>;
pub type PIOMMU_DOMAIN_DELETE = IOMMU_DOMAIN_DELETE;
pub type IOMMU_DOMAIN_ATTACH_DEVICE = ::core::option::Option<
    unsafe extern "C" fn(
        Domain: PIOMMU_DMA_DOMAIN,
        PhysicalDeviceObject: PDEVICE_OBJECT,
        InputMappingIdBase: ULONG,
        MappingCount: ULONG,
    ) -> NTSTATUS,
>;
pub type PIOMMU_DOMAIN_ATTACH_DEVICE = IOMMU_DOMAIN_ATTACH_DEVICE;
pub type IOMMU_DOMAIN_DETACH_DEVICE = ::core::option::Option<
    unsafe extern "C" fn(
        Domain: PIOMMU_DMA_DOMAIN,
        PhysicalDeviceObject: PDEVICE_OBJECT,
        InputMappingId: ULONG,
    ) -> NTSTATUS,
>;
pub type PIOMMU_DOMAIN_DETACH_DEVICE = IOMMU_DOMAIN_DETACH_DEVICE;
pub type IOMMU_SET_DEVICE_FAULT_REPORTING = ::core::option::Option<
    unsafe extern "C" fn(
        PhysicalDeviceObject: PDEVICE_OBJECT,
        InputMappingIdBase: ULONG,
        Enable: BOOLEAN,
        FaultConfig: PDEVICE_FAULT_CONFIGURATION,
    ) -> NTSTATUS,
>;
pub type PIOMMU_SET_DEVICE_FAULT_REPORTING = IOMMU_SET_DEVICE_FAULT_REPORTING;
pub type IOMMU_DOMAIN_CONFIGURE = ::core::option::Option<
    unsafe extern "C" fn(
        Domain: PIOMMU_DMA_DOMAIN,
        Configuration: PDOMAIN_CONFIGURATION,
    ) -> NTSTATUS,
>;
pub type PIOMMU_DOMAIN_CONFIGURE = IOMMU_DOMAIN_CONFIGURE;
pub type IOMMU_FLUSH_DOMAIN =
::core::option::Option<unsafe extern "C" fn(Domain: PIOMMU_DMA_DOMAIN) -> NTSTATUS>;
pub type PIOMMU_FLUSH_DOMAIN = IOMMU_FLUSH_DOMAIN;
pub type IOMMU_FLUSH_DOMAIN_VA_LIST = ::core::option::Option<
    unsafe extern "C" fn(
        Domain: PIOMMU_DMA_DOMAIN,
        LastLevel: BOOLEAN,
        Number: ULONG,
        VaList: PVOID,
    ) -> NTSTATUS,
>;
pub type PIOMMU_FLUSH_DOMAIN_VA_LIST = IOMMU_FLUSH_DOMAIN_VA_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _INPUT_MAPPING_ELEMENT {
    pub InputMappingId: ULONG,
}
pub type INPUT_MAPPING_ELEMENT = _INPUT_MAPPING_ELEMENT;
pub type PINPUT_MAPPING_ELEMENT = *mut _INPUT_MAPPING_ELEMENT;
pub type IOMMU_QUERY_INPUT_MAPPINGS = ::core::option::Option<
    unsafe extern "C" fn(
        PhysicalDeviceObject: PDEVICE_OBJECT,
        Buffer: PINPUT_MAPPING_ELEMENT,
        BufferLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS,
>;
pub type PIOMMU_QUERY_INPUT_MAPPINGS = IOMMU_QUERY_INPUT_MAPPINGS;
pub type IOMMU_MAP_LOGICAL_RANGE = ::core::option::Option<
    unsafe extern "C" fn(
        Domain: PIOMMU_DMA_DOMAIN,
        Permissions: ULONG,
        Mdl: PMDL,
        LogicalAddress: ULONGLONG,
    ) -> NTSTATUS,
>;
pub type PIOMMU_MAP_LOGICAL_RANGE = IOMMU_MAP_LOGICAL_RANGE;
pub type IOMMU_UNMAP_LOGICAL_RANGE = ::core::option::Option<
    unsafe extern "C" fn(
        Domain: PIOMMU_DMA_DOMAIN,
        LogicalAddress: ULONGLONG,
        NumberOfPages: ULONGLONG,
    ) -> NTSTATUS,
>;
pub type PIOMMU_UNMAP_LOGICAL_RANGE = IOMMU_UNMAP_LOGICAL_RANGE;
pub type IOMMU_MAP_IDENTITY_RANGE = ::core::option::Option<
    unsafe extern "C" fn(Domain: PIOMMU_DMA_DOMAIN, Permissions: ULONG, Mdl: PMDL) -> NTSTATUS,
>;
pub type PIOMMU_MAP_IDENTITY_RANGE = IOMMU_MAP_IDENTITY_RANGE;
pub type IOMMU_UNMAP_IDENTITY_RANGE =
::core::option::Option<unsafe extern "C" fn(Domain: PIOMMU_DMA_DOMAIN, Mdl: PMDL) -> NTSTATUS>;
pub type PIOMMU_UNMAP_IDENTITY_RANGE = IOMMU_UNMAP_IDENTITY_RANGE;
pub type IOMMU_DOMAIN_CREATE_EX = ::core::option::Option<
    unsafe extern "C" fn(
        DomainType: IOMMU_DMA_DOMAIN_TYPE,
        Flags: IOMMU_DMA_DOMAIN_CREATION_FLAGS,
        LogicalAllocatorConfig: PIOMMU_DMA_LOGICAL_ALLOCATOR_CONFIG,
        ReservedRegions: PIOMMU_DMA_RESERVED_REGION,
        DomainOut: *mut PIOMMU_DMA_DOMAIN,
    ) -> NTSTATUS,
>;
pub type PIOMMU_DOMAIN_CREATE_EX = IOMMU_DOMAIN_CREATE_EX;
pub type IOMMU_DOMAIN_ATTACH_DEVICE_EX = ::core::option::Option<
    unsafe extern "C" fn(Domain: PIOMMU_DMA_DOMAIN, DmaDevice: PIOMMU_DMA_DEVICE) -> NTSTATUS,
>;
pub type PIOMMU_DOMAIN_ATTACH_DEVICE_EX = IOMMU_DOMAIN_ATTACH_DEVICE_EX;
pub type IOMMU_DOMAIN_DETACH_DEVICE_EX =
::core::option::Option<unsafe extern "C" fn(DmaDevice: PIOMMU_DMA_DEVICE) -> NTSTATUS>;
pub type PIOMMU_DOMAIN_DETACH_DEVICE_EX = IOMMU_DOMAIN_DETACH_DEVICE_EX;
pub type IOMMU_MAP_LOGICAL_RANGE_EX = ::core::option::Option<
    unsafe extern "C" fn(
        Domain: PIOMMU_DMA_DOMAIN,
        Permissions: ULONG,
        PhysicalAddressToMap: PIOMMU_MAP_PHYSICAL_ADDRESS,
        ExplicitLogicalAddress: PIOMMU_DMA_LOGICAL_ADDRESS,
        MinLogicalAddress: PIOMMU_DMA_LOGICAL_ADDRESS,
        MaxLogicalAddress: PIOMMU_DMA_LOGICAL_ADDRESS,
        LogicalAddressOut: PIOMMU_DMA_LOGICAL_ADDRESS,
    ) -> NTSTATUS,
>;
pub type PIOMMU_MAP_LOGICAL_RANGE_EX = IOMMU_MAP_LOGICAL_RANGE_EX;
pub type IOMMU_MAP_IDENTITY_RANGE_EX = ::core::option::Option<
    unsafe extern "C" fn(
        Domain: PIOMMU_DMA_DOMAIN,
        Permissions: ULONG,
        PhysicalAddressToMap: PIOMMU_MAP_PHYSICAL_ADDRESS,
    ) -> NTSTATUS,
>;
pub type PIOMMU_MAP_IDENTITY_RANGE_EX = IOMMU_MAP_IDENTITY_RANGE_EX;
pub type IOMMU_UNMAP_IDENTITY_RANGE_EX = ::core::option::Option<
    unsafe extern "C" fn(
        Domain: PIOMMU_DMA_DOMAIN,
        MappedPhysicalAddress: PIOMMU_MAP_PHYSICAL_ADDRESS,
    ) -> NTSTATUS,
>;
pub type PIOMMU_UNMAP_IDENTITY_RANGE_EX = IOMMU_UNMAP_IDENTITY_RANGE_EX;
pub type IOMMU_DEVICE_QUERY_DOMAIN_TYPES = ::core::option::Option<
    unsafe extern "C" fn(DmaDevice: PIOMMU_DMA_DEVICE, AvailableDomains: PULONG),
>;
pub type PIOMMU_DEVICE_QUERY_DOMAIN_TYPES = IOMMU_DEVICE_QUERY_DOMAIN_TYPES;
pub type IOMMU_REGISTER_INTERFACE_STATE_CHANGE_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        StateChangeCallback: PIOMMU_INTERFACE_STATE_CHANGE_CALLBACK,
        Context: PVOID,
        DmaDevice: PIOMMU_DMA_DEVICE,
        StateFields: PIOMMU_INTERFACE_STATE_CHANGE_FIELDS,
    ) -> NTSTATUS,
>;
pub type PIOMMU_REGISTER_INTERFACE_STATE_CHANGE_CALLBACK =
IOMMU_REGISTER_INTERFACE_STATE_CHANGE_CALLBACK;
pub type IOMMU_UNREGISTER_INTERFACE_STATE_CHANGE_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        StateChangeCallback: PIOMMU_INTERFACE_STATE_CHANGE_CALLBACK,
        DmaDevice: PIOMMU_DMA_DEVICE,
    ) -> NTSTATUS,
>;
pub type PIOMMU_UNREGISTER_INTERFACE_STATE_CHANGE_CALLBACK =
IOMMU_UNREGISTER_INTERFACE_STATE_CHANGE_CALLBACK;
pub type IOMMU_RESERVE_LOGICAL_ADDRESS_RANGE = ::core::option::Option<
    unsafe extern "C" fn(
        Domain: PIOMMU_DMA_DOMAIN,
        Size: SIZE_T,
        ExplicitLogicalAddress: PIOMMU_DMA_LOGICAL_ADDRESS,
        MinLogicalAddress: PIOMMU_DMA_LOGICAL_ADDRESS,
        MaxLogicalAddress: PIOMMU_DMA_LOGICAL_ADDRESS,
        LogicalAddressToken: *mut PIOMMU_DMA_LOGICAL_ADDRESS_TOKEN,
    ) -> NTSTATUS,
>;
pub type PIOMMU_RESERVE_LOGICAL_ADDRESS_RANGE = IOMMU_RESERVE_LOGICAL_ADDRESS_RANGE;
pub type IOMMU_FREE_RESERVED_LOGICAL_ADDRESS_RANGE = ::core::option::Option<
    unsafe extern "C" fn(LogicalAddressToken: PIOMMU_DMA_LOGICAL_ADDRESS_TOKEN) -> NTSTATUS,
>;
pub type PIOMMU_FREE_RESERVED_LOGICAL_ADDRESS_RANGE = IOMMU_FREE_RESERVED_LOGICAL_ADDRESS_RANGE;
pub type IOMMU_MAP_RESERVED_LOGICAL_RANGE = ::core::option::Option<
    unsafe extern "C" fn(
        LogicalAddressToken: PIOMMU_DMA_LOGICAL_ADDRESS_TOKEN,
        Offset: SIZE_T,
        Permissions: ULONG,
        PhysicalAddressToMap: PIOMMU_MAP_PHYSICAL_ADDRESS,
        MappedSegment: PIOMMU_DMA_LOGICAL_ADDRESS_TOKEN_MAPPED_SEGMENT,
    ) -> NTSTATUS,
>;
pub type PIOMMU_MAP_RESERVED_LOGICAL_RANGE = IOMMU_MAP_RESERVED_LOGICAL_RANGE;
pub type IOMMU_UNMAP_RESERVED_LOGICAL_RANGE = ::core::option::Option<
    unsafe extern "C" fn(
        MappedSegment: PIOMMU_DMA_LOGICAL_ADDRESS_TOKEN_MAPPED_SEGMENT,
    ) -> NTSTATUS,
>;
pub type PIOMMU_UNMAP_RESERVED_LOGICAL_RANGE = IOMMU_UNMAP_RESERVED_LOGICAL_RANGE;
pub type IOMMU_DEVICE_CREATE = ::core::option::Option<
    unsafe extern "C" fn(
        DeviceObject: PDEVICE_OBJECT,
        DeviceConfig: PIOMMU_DEVICE_CREATION_CONFIGURATION,
        DmaDeviceOut: *mut PIOMMU_DMA_DEVICE,
    ) -> NTSTATUS,
>;
pub type PIOMMU_DEVICE_CREATE = IOMMU_DEVICE_CREATE;
pub type IOMMU_DEVICE_DELETE =
::core::option::Option<unsafe extern "C" fn(DmaDevice: PIOMMU_DMA_DEVICE) -> NTSTATUS>;
pub type PIOMMU_DEVICE_DELETE = IOMMU_DEVICE_DELETE;
pub type IOMMU_SET_DEVICE_FAULT_REPORTING_EX = ::core::option::Option<
    unsafe extern "C" fn(
        DmaDevice: PIOMMU_DMA_DEVICE,
        InputMappingIdBase: ULONG,
        Enable: BOOLEAN,
        FaultConfig: PDEVICE_FAULT_CONFIGURATION,
    ) -> NTSTATUS,
>;
pub type PIOMMU_SET_DEVICE_FAULT_REPORTING_EX = IOMMU_SET_DEVICE_FAULT_REPORTING_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DMA_IOMMU_INTERFACE {
    pub Version: ULONG,
    pub CreateDomain: PIOMMU_DOMAIN_CREATE,
    pub DeleteDomain: PIOMMU_DOMAIN_DELETE,
    pub AttachDevice: PIOMMU_DOMAIN_ATTACH_DEVICE,
    pub DetachDevice: PIOMMU_DOMAIN_DETACH_DEVICE,
    pub FlushDomain: PIOMMU_FLUSH_DOMAIN,
    pub FlushDomainByVaList: PIOMMU_FLUSH_DOMAIN_VA_LIST,
    pub QueryInputMappings: PIOMMU_QUERY_INPUT_MAPPINGS,
    pub MapLogicalRange: PIOMMU_MAP_LOGICAL_RANGE,
    pub UnmapLogicalRange: PIOMMU_UNMAP_LOGICAL_RANGE,
    pub MapIdentityRange: PIOMMU_MAP_IDENTITY_RANGE,
    pub UnmapIdentityRange: PIOMMU_UNMAP_IDENTITY_RANGE,
    pub SetDeviceFaultReporting: PIOMMU_SET_DEVICE_FAULT_REPORTING,
    pub ConfigureDomain: PIOMMU_DOMAIN_CONFIGURE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DMA_IOMMU_INTERFACE_V1 {
    pub CreateDomain: PIOMMU_DOMAIN_CREATE,
    pub DeleteDomain: PIOMMU_DOMAIN_DELETE,
    pub AttachDevice: PIOMMU_DOMAIN_ATTACH_DEVICE,
    pub DetachDevice: PIOMMU_DOMAIN_DETACH_DEVICE,
    pub FlushDomain: PIOMMU_FLUSH_DOMAIN,
    pub FlushDomainByVaList: PIOMMU_FLUSH_DOMAIN_VA_LIST,
    pub QueryInputMappings: PIOMMU_QUERY_INPUT_MAPPINGS,
    pub MapLogicalRange: PIOMMU_MAP_LOGICAL_RANGE,
    pub UnmapLogicalRange: PIOMMU_UNMAP_LOGICAL_RANGE,
    pub MapIdentityRange: PIOMMU_MAP_IDENTITY_RANGE,
    pub UnmapIdentityRange: PIOMMU_UNMAP_IDENTITY_RANGE,
    pub SetDeviceFaultReporting: PIOMMU_SET_DEVICE_FAULT_REPORTING,
    pub ConfigureDomain: PIOMMU_DOMAIN_CONFIGURE,
}
pub type DMA_IOMMU_INTERFACE_V1 = _DMA_IOMMU_INTERFACE_V1;
pub type PDMA_IOMMU_INTERFACE_V1 = *mut _DMA_IOMMU_INTERFACE_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DMA_IOMMU_INTERFACE_V2 {
    pub CreateDomainEx: PIOMMU_DOMAIN_CREATE_EX,
    pub DeleteDomain: PIOMMU_DOMAIN_DELETE,
    pub AttachDeviceEx: PIOMMU_DOMAIN_ATTACH_DEVICE_EX,
    pub DetachDeviceEx: PIOMMU_DOMAIN_DETACH_DEVICE_EX,
    pub FlushDomain: PIOMMU_FLUSH_DOMAIN,
    pub FlushDomainByVaList: PIOMMU_FLUSH_DOMAIN_VA_LIST,
    pub QueryInputMappings: PIOMMU_QUERY_INPUT_MAPPINGS,
    pub MapLogicalRangeEx: PIOMMU_MAP_LOGICAL_RANGE_EX,
    pub UnmapLogicalRange: PIOMMU_UNMAP_LOGICAL_RANGE,
    pub MapIdentityRangeEx: PIOMMU_MAP_IDENTITY_RANGE_EX,
    pub UnmapIdentityRangeEx: PIOMMU_UNMAP_IDENTITY_RANGE_EX,
    pub SetDeviceFaultReportingEx: PIOMMU_SET_DEVICE_FAULT_REPORTING_EX,
    pub ConfigureDomain: PIOMMU_DOMAIN_CONFIGURE,
    pub QueryAvailableDomainTypes: PIOMMU_DEVICE_QUERY_DOMAIN_TYPES,
    pub RegisterInterfaceStateChangeCallback: PIOMMU_REGISTER_INTERFACE_STATE_CHANGE_CALLBACK,
    pub UnregisterInterfaceStateChangeCallback: PIOMMU_UNREGISTER_INTERFACE_STATE_CHANGE_CALLBACK,
    pub ReserveLogicalAddressRange: PIOMMU_RESERVE_LOGICAL_ADDRESS_RANGE,
    pub FreeReservedLogicalAddressRange: PIOMMU_FREE_RESERVED_LOGICAL_ADDRESS_RANGE,
    pub MapReservedLogicalRange: PIOMMU_MAP_RESERVED_LOGICAL_RANGE,
    pub UnmapReservedLogicalRange: PIOMMU_UNMAP_RESERVED_LOGICAL_RANGE,
    pub CreateDevice: PIOMMU_DEVICE_CREATE,
    pub DeleteDevice: PIOMMU_DEVICE_DELETE,
}
pub type DMA_IOMMU_INTERFACE_V2 = _DMA_IOMMU_INTERFACE_V2;
pub type PDMA_IOMMU_INTERFACE_V2 = *mut _DMA_IOMMU_INTERFACE_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DMA_IOMMU_INTERFACE_EX {
    pub Size: SIZE_T,
    pub Version: ULONG,
    pub __bindgen_anon_1: _DMA_IOMMU_INTERFACE_EX__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DMA_IOMMU_INTERFACE_EX__bindgen_ty_1 {
    pub V1: DMA_IOMMU_INTERFACE_V1,
    pub V2: DMA_IOMMU_INTERFACE_V2,
}
unsafe extern "C" {
    pub fn PoSetHiberRange(
        MemoryMap: PVOID,
        Flags: ULONG,
        Address: PVOID,
        Length: ULONG_PTR,
        Tag: ULONG,
    );
}
unsafe extern "C" {
    pub fn PoSetSystemState(Flags: EXECUTION_STATE);
}
unsafe extern "C" {
    pub fn PoRegisterSystemState(StateHandle: PVOID, Flags: EXECUTION_STATE) -> PVOID;
}
unsafe extern "C" {
    pub fn PoCreatePowerRequest(
        PowerRequest: *mut PVOID,
        DeviceObject: PDEVICE_OBJECT,
        Context: PCOUNTED_REASON_CONTEXT,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PoSetPowerRequest(PowerRequest: PVOID, Type: POWER_REQUEST_TYPE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PoClearPowerRequest(PowerRequest: PVOID, Type: POWER_REQUEST_TYPE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PoDeletePowerRequest(PowerRequest: PVOID);
}
pub type REQUEST_POWER_COMPLETE = ::core::option::Option<
    unsafe extern "C" fn(
        DeviceObject: PDEVICE_OBJECT,
        MinorFunction: UCHAR,
        PowerState: POWER_STATE,
        Context: PVOID,
        IoStatus: PIO_STATUS_BLOCK,
    ),
>;
pub type PREQUEST_POWER_COMPLETE = REQUEST_POWER_COMPLETE;
unsafe extern "C" {
    pub fn PoRequestPowerIrp(
        DeviceObject: PDEVICE_OBJECT,
        MinorFunction: UCHAR,
        PowerState: POWER_STATE,
        CompletionFunction: PREQUEST_POWER_COMPLETE,
        Context: PVOID,
        Irp: *mut PIRP,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PoSetSystemWake(Irp: PIRP);
}
unsafe extern "C" {
    pub fn PoSetSystemWakeDevice(DeviceObject: PDEVICE_OBJECT);
}
unsafe extern "C" {
    pub fn PoGetSystemWake(Irp: PIRP) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn PoUnregisterSystemState(StateHandle: PVOID);
}
unsafe extern "C" {
    pub fn PoSetPowerState(
        DeviceObject: PDEVICE_OBJECT,
        Type: POWER_STATE_TYPE,
        State: POWER_STATE,
    ) -> POWER_STATE;
}
unsafe extern "C" {
    pub fn PoCallDriver(DeviceObject: PDEVICE_OBJECT, Irp: PIRP) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PoStartNextPowerIrp(Irp: PIRP);
}
unsafe extern "C" {
    pub fn PoRegisterDeviceForIdleDetection(
        DeviceObject: PDEVICE_OBJECT,
        ConservationIdleTime: ULONG,
        PerformanceIdleTime: ULONG,
        State: DEVICE_POWER_STATE,
    ) -> PULONG;
}
unsafe extern "C" {
    pub fn PoSetDeviceBusyEx(IdlePointer: PULONG);
}
unsafe extern "C" {
    pub fn PoStartDeviceBusy(IdlePointer: PULONG);
}
unsafe extern "C" {
    pub fn PoEndDeviceBusy(IdlePointer: PULONG);
}
unsafe extern "C" {
    pub fn PoQueryWatchdogTime(Pdo: PDEVICE_OBJECT, SecondsRemaining: PULONG) -> BOOLEAN;
}
pub type POWER_SETTING_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        SettingGuid: LPCGUID,
        Value: PVOID,
        ValueLength: ULONG,
        Context: PVOID,
    ) -> NTSTATUS,
>;
pub type PPOWER_SETTING_CALLBACK = POWER_SETTING_CALLBACK;
unsafe extern "C" {
    pub fn PoRegisterPowerSettingCallback(
        DeviceObject: PDEVICE_OBJECT,
        SettingGuid: LPCGUID,
        Callback: PPOWER_SETTING_CALLBACK,
        Context: PVOID,
        Handle: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PoUnregisterPowerSettingCallback(Handle: PVOID) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct POHANDLE__ {
    pub unused: core::ffi::c_int,
}
pub type POHANDLE = *mut POHANDLE__;
pub type PO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, Component: ULONG)>;
pub type PPO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK = PO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK;
pub type PO_FX_COMPONENT_IDLE_CONDITION_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, Component: ULONG)>;
pub type PPO_FX_COMPONENT_IDLE_CONDITION_CALLBACK = PO_FX_COMPONENT_IDLE_CONDITION_CALLBACK;
pub type PO_FX_COMPONENT_IDLE_STATE_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, Component: ULONG, State: ULONG)>;
pub type PPO_FX_COMPONENT_IDLE_STATE_CALLBACK = PO_FX_COMPONENT_IDLE_STATE_CALLBACK;
pub type PO_FX_DEVICE_POWER_REQUIRED_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
pub type PPO_FX_DEVICE_POWER_REQUIRED_CALLBACK = PO_FX_DEVICE_POWER_REQUIRED_CALLBACK;
pub type PO_FX_DEVICE_POWER_NOT_REQUIRED_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
pub type PPO_FX_DEVICE_POWER_NOT_REQUIRED_CALLBACK = PO_FX_DEVICE_POWER_NOT_REQUIRED_CALLBACK;
pub type PO_FX_POWER_CONTROL_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        DeviceContext: PVOID,
        PowerControlCode: LPCGUID,
        InBuffer: PVOID,
        InBufferSize: SIZE_T,
        OutBuffer: PVOID,
        OutBufferSize: SIZE_T,
        BytesReturned: PSIZE_T,
    ) -> NTSTATUS,
>;
pub type PPO_FX_POWER_CONTROL_CALLBACK = PO_FX_POWER_CONTROL_CALLBACK;
pub type PO_FX_COMPONENT_CRITICAL_TRANSITION_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, Component: ULONG, Active: BOOLEAN)>;
pub type PPO_FX_COMPONENT_CRITICAL_TRANSITION_CALLBACK =
PO_FX_COMPONENT_CRITICAL_TRANSITION_CALLBACK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_FX_COMPONENT_IDLE_STATE {
    pub TransitionLatency: ULONGLONG,
    pub ResidencyRequirement: ULONGLONG,
    pub NominalPower: ULONG,
}
pub type PO_FX_COMPONENT_IDLE_STATE = _PO_FX_COMPONENT_IDLE_STATE;
pub type PPO_FX_COMPONENT_IDLE_STATE = *mut _PO_FX_COMPONENT_IDLE_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_FX_COMPONENT_V1 {
    pub Id: GUID,
    pub IdleStateCount: ULONG,
    pub DeepestWakeableIdleState: ULONG,
    pub IdleStates: PPO_FX_COMPONENT_IDLE_STATE,
}
pub type PO_FX_COMPONENT_V1 = _PO_FX_COMPONENT_V1;
pub type PPO_FX_COMPONENT_V1 = *mut _PO_FX_COMPONENT_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_FX_DEVICE_V1 {
    pub Version: ULONG,
    pub ComponentCount: ULONG,
    pub ComponentActiveConditionCallback: PPO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK,
    pub ComponentIdleConditionCallback: PPO_FX_COMPONENT_IDLE_CONDITION_CALLBACK,
    pub ComponentIdleStateCallback: PPO_FX_COMPONENT_IDLE_STATE_CALLBACK,
    pub DevicePowerRequiredCallback: PPO_FX_DEVICE_POWER_REQUIRED_CALLBACK,
    pub DevicePowerNotRequiredCallback: PPO_FX_DEVICE_POWER_NOT_REQUIRED_CALLBACK,
    pub PowerControlCallback: PPO_FX_POWER_CONTROL_CALLBACK,
    pub DeviceContext: PVOID,
    pub Components: [PO_FX_COMPONENT_V1; 1usize],
}
pub type PO_FX_DEVICE_V1 = _PO_FX_DEVICE_V1;
pub type PPO_FX_DEVICE_V1 = *mut _PO_FX_DEVICE_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_FX_COMPONENT_V2 {
    pub Id: GUID,
    pub Flags: ULONGLONG,
    pub DeepestWakeableIdleState: ULONG,
    pub IdleStateCount: ULONG,
    pub IdleStates: PPO_FX_COMPONENT_IDLE_STATE,
    pub ProviderCount: ULONG,
    pub Providers: PULONG,
}
pub type PO_FX_COMPONENT_V2 = _PO_FX_COMPONENT_V2;
pub type PPO_FX_COMPONENT_V2 = *mut _PO_FX_COMPONENT_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_FX_DEVICE_V2 {
    pub Version: ULONG,
    pub Flags: ULONGLONG,
    pub ComponentActiveConditionCallback: PPO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK,
    pub ComponentIdleConditionCallback: PPO_FX_COMPONENT_IDLE_CONDITION_CALLBACK,
    pub ComponentIdleStateCallback: PPO_FX_COMPONENT_IDLE_STATE_CALLBACK,
    pub DevicePowerRequiredCallback: PPO_FX_DEVICE_POWER_REQUIRED_CALLBACK,
    pub DevicePowerNotRequiredCallback: PPO_FX_DEVICE_POWER_NOT_REQUIRED_CALLBACK,
    pub PowerControlCallback: PPO_FX_POWER_CONTROL_CALLBACK,
    pub DeviceContext: PVOID,
    pub ComponentCount: ULONG,
    pub Components: [PO_FX_COMPONENT_V2; 1usize],
}
pub type PO_FX_DEVICE_V2 = _PO_FX_DEVICE_V2;
pub type PPO_FX_DEVICE_V2 = *mut _PO_FX_DEVICE_V2;
pub type PO_FX_DIRECTED_POWER_UP_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, Flags: ULONG)>;
pub type PPO_FX_DIRECTED_POWER_UP_CALLBACK = PO_FX_DIRECTED_POWER_UP_CALLBACK;
pub type PO_FX_DIRECTED_POWER_DOWN_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, Flags: ULONG)>;
pub type PPO_FX_DIRECTED_POWER_DOWN_CALLBACK = PO_FX_DIRECTED_POWER_DOWN_CALLBACK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_FX_DEVICE_V3 {
    pub Version: ULONG,
    pub Flags: ULONGLONG,
    pub ComponentActiveConditionCallback: PPO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK,
    pub ComponentIdleConditionCallback: PPO_FX_COMPONENT_IDLE_CONDITION_CALLBACK,
    pub ComponentIdleStateCallback: PPO_FX_COMPONENT_IDLE_STATE_CALLBACK,
    pub DevicePowerRequiredCallback: PPO_FX_DEVICE_POWER_REQUIRED_CALLBACK,
    pub DevicePowerNotRequiredCallback: PPO_FX_DEVICE_POWER_NOT_REQUIRED_CALLBACK,
    pub PowerControlCallback: PPO_FX_POWER_CONTROL_CALLBACK,
    pub DirectedPowerUpCallback: PPO_FX_DIRECTED_POWER_UP_CALLBACK,
    pub DirectedPowerDownCallback: PPO_FX_DIRECTED_POWER_DOWN_CALLBACK,
    pub DirectedFxTimeoutInSeconds: ULONG,
    pub DeviceContext: PVOID,
    pub ComponentCount: ULONG,
    pub Components: [PO_FX_COMPONENT_V2; 1usize],
}
pub type PO_FX_DEVICE_V3 = _PO_FX_DEVICE_V3;
pub type PPO_FX_DEVICE_V3 = *mut _PO_FX_DEVICE_V3;
pub type PO_FX_COMPONENT = PO_FX_COMPONENT_V1;
pub type PPO_FX_COMPONENT = *mut PO_FX_COMPONENT_V1;
pub type PO_FX_DEVICE = PO_FX_DEVICE_V1;
pub type PPO_FX_DEVICE = *mut PO_FX_DEVICE_V1;
pub const _PO_FX_PERF_STATE_UNIT_PoFxPerfStateUnitOther: _PO_FX_PERF_STATE_UNIT = 0;
pub const _PO_FX_PERF_STATE_UNIT_PoFxPerfStateUnitFrequency: _PO_FX_PERF_STATE_UNIT = 1;
pub const _PO_FX_PERF_STATE_UNIT_PoFxPerfStateUnitBandwidth: _PO_FX_PERF_STATE_UNIT = 2;
pub const _PO_FX_PERF_STATE_UNIT_PoFxPerfStateUnitMaximum: _PO_FX_PERF_STATE_UNIT = 3;
pub type _PO_FX_PERF_STATE_UNIT = core::ffi::c_int;
pub use self::_PO_FX_PERF_STATE_UNIT as PO_FX_PERF_STATE_UNIT;
pub type PPO_FX_PERF_STATE_UNIT = *mut _PO_FX_PERF_STATE_UNIT;
pub const _PO_FX_PERF_STATE_TYPE_PoFxPerfStateTypeDiscrete: _PO_FX_PERF_STATE_TYPE = 0;
pub const _PO_FX_PERF_STATE_TYPE_PoFxPerfStateTypeRange: _PO_FX_PERF_STATE_TYPE = 1;
pub const _PO_FX_PERF_STATE_TYPE_PoFxPerfStateTypeMaximum: _PO_FX_PERF_STATE_TYPE = 2;
pub type _PO_FX_PERF_STATE_TYPE = core::ffi::c_int;
pub use self::_PO_FX_PERF_STATE_TYPE as PO_FX_PERF_STATE_TYPE;
pub type PPO_FX_PERF_STATE_TYPE = *mut _PO_FX_PERF_STATE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_FX_PERF_STATE {
    pub Value: ULONGLONG,
    pub Context: PVOID,
}
pub type PO_FX_PERF_STATE = _PO_FX_PERF_STATE;
pub type PPO_FX_PERF_STATE = *mut _PO_FX_PERF_STATE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PO_FX_COMPONENT_PERF_SET {
    pub Name: UNICODE_STRING,
    pub Flags: ULONGLONG,
    pub Unit: PO_FX_PERF_STATE_UNIT,
    pub Type: PO_FX_PERF_STATE_TYPE,
    pub __bindgen_anon_1: _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1 {
    pub Discrete: _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1__bindgen_ty_1,
    pub Range: _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1__bindgen_ty_1 {
    pub Count: ULONG,
    pub States: PPO_FX_PERF_STATE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1__bindgen_ty_2 {
    pub Minimum: ULONGLONG,
    pub Maximum: ULONGLONG,
}
pub type PO_FX_COMPONENT_PERF_SET = _PO_FX_COMPONENT_PERF_SET;
pub type PPO_FX_COMPONENT_PERF_SET = *mut _PO_FX_COMPONENT_PERF_SET;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PO_FX_COMPONENT_PERF_INFO {
    pub PerfStateSetsCount: ULONG,
    pub PerfStateSets: [PO_FX_COMPONENT_PERF_SET; 1usize],
}
pub type PO_FX_COMPONENT_PERF_INFO = _PO_FX_COMPONENT_PERF_INFO;
pub type PPO_FX_COMPONENT_PERF_INFO = *mut _PO_FX_COMPONENT_PERF_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PO_FX_PERF_STATE_CHANGE {
    pub Set: ULONG,
    pub __bindgen_anon_1: _PO_FX_PERF_STATE_CHANGE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PO_FX_PERF_STATE_CHANGE__bindgen_ty_1 {
    pub StateIndex: ULONG,
    pub StateValue: ULONGLONG,
}
pub type PO_FX_PERF_STATE_CHANGE = _PO_FX_PERF_STATE_CHANGE;
pub type PPO_FX_PERF_STATE_CHANGE = *mut _PO_FX_PERF_STATE_CHANGE;
unsafe extern "C" {
    pub fn PoFxRegisterDevice(
        Pdo: PDEVICE_OBJECT,
        Device: PPO_FX_DEVICE,
        Handle: *mut POHANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PoFxStartDevicePowerManagement(Handle: POHANDLE);
}
unsafe extern "C" {
    pub fn PoFxUnregisterDevice(Handle: POHANDLE);
}
unsafe extern "C" {
    pub fn PoFxRegisterCrashdumpDevice(Handle: POHANDLE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PoFxPowerOnCrashdumpDevice(Handle: POHANDLE, Context: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PoFxActivateComponent(Handle: POHANDLE, Component: ULONG, Flags: ULONG);
}
unsafe extern "C" {
    pub fn PoFxCompleteDevicePowerNotRequired(Handle: POHANDLE);
}
unsafe extern "C" {
    pub fn PoFxCompleteIdleCondition(Handle: POHANDLE, Component: ULONG);
}
unsafe extern "C" {
    pub fn PoFxCompleteIdleState(Handle: POHANDLE, Component: ULONG);
}
unsafe extern "C" {
    pub fn PoFxIdleComponent(Handle: POHANDLE, Component: ULONG, Flags: ULONG);
}
unsafe extern "C" {
    pub fn PoFxSetComponentLatency(Handle: POHANDLE, Component: ULONG, Latency: ULONGLONG);
}
unsafe extern "C" {
    pub fn PoFxSetComponentResidency(Handle: POHANDLE, Component: ULONG, Residency: ULONGLONG);
}
unsafe extern "C" {
    pub fn PoFxSetComponentWake(Handle: POHANDLE, Component: ULONG, WakeHint: BOOLEAN);
}
unsafe extern "C" {
    pub fn PoFxSetDeviceIdleTimeout(Handle: POHANDLE, IdleTimeout: ULONGLONG);
}
unsafe extern "C" {
    pub fn PoFxReportDevicePoweredOn(Handle: POHANDLE);
}
unsafe extern "C" {
    pub fn PoFxPowerControl(
        Handle: POHANDLE,
        PowerControlCode: LPCGUID,
        InBuffer: PVOID,
        InBufferSize: SIZE_T,
        OutBuffer: PVOID,
        OutBufferSize: SIZE_T,
        BytesReturned: PSIZE_T,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PoFxNotifySurprisePowerOn(Pdo: PDEVICE_OBJECT);
}
pub type PO_FX_COMPONENT_PERF_STATE_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        Component: ULONG,
        Succeeded: BOOLEAN,
        RequestContext: PVOID,
    ),
>;
pub type PPO_FX_COMPONENT_PERF_STATE_CALLBACK = PO_FX_COMPONENT_PERF_STATE_CALLBACK;
unsafe extern "C" {
    pub fn PoFxRegisterComponentPerfStates(
        Handle: POHANDLE,
        Component: ULONG,
        Flags: ULONGLONG,
        ComponentPerfStateCallback: PPO_FX_COMPONENT_PERF_STATE_CALLBACK,
        InputStateInfo: PPO_FX_COMPONENT_PERF_INFO,
        OutputStateInfo: *mut PPO_FX_COMPONENT_PERF_INFO,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PoFxIssueComponentPerfStateChange(
        Handle: POHANDLE,
        Flags: ULONG,
        Component: ULONG,
        PerfChange: PPO_FX_PERF_STATE_CHANGE,
        Context: PVOID,
    );
}
unsafe extern "C" {
    pub fn PoFxIssueComponentPerfStateChangeMultiple(
        Handle: POHANDLE,
        Flags: ULONG,
        Component: ULONG,
        PerfChangesCount: ULONG,
        PerfChanges: *mut PO_FX_PERF_STATE_CHANGE,
        Context: PVOID,
    );
}
unsafe extern "C" {
    pub fn PoFxQueryCurrentComponentPerfState(
        Handle: POHANDLE,
        Flags: ULONG,
        Component: ULONG,
        SetIndex: ULONG,
        CurrentPerf: PULONGLONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PoFxSetTargetDripsDevicePowerState(
        Handle: POHANDLE,
        TargetState: DEVICE_POWER_STATE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PoFxCompleteDirectedPowerDown(Handle: POHANDLE);
}
unsafe extern "C" {
    pub fn PoCreateThermalRequest(
        ThermalRequest: *mut PVOID,
        TargetDeviceObject: PDEVICE_OBJECT,
        PolicyDeviceObject: PDEVICE_OBJECT,
        Context: PCOUNTED_REASON_CONTEXT,
        Flags: ULONG,
    ) -> NTSTATUS;
}
pub const _PO_THERMAL_REQUEST_TYPE_PoThermalRequestPassive: _PO_THERMAL_REQUEST_TYPE = 0;
pub const _PO_THERMAL_REQUEST_TYPE_PoThermalRequestActive: _PO_THERMAL_REQUEST_TYPE = 1;
pub type _PO_THERMAL_REQUEST_TYPE = core::ffi::c_int;
pub use self::_PO_THERMAL_REQUEST_TYPE as PO_THERMAL_REQUEST_TYPE;
pub type PPO_THERMAL_REQUEST_TYPE = *mut _PO_THERMAL_REQUEST_TYPE;
unsafe extern "C" {
    pub fn PoGetThermalRequestSupport(
        ThermalRequest: PVOID,
        Type: PO_THERMAL_REQUEST_TYPE,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn PoSetThermalPassiveCooling(ThermalRequest: PVOID, Throttle: UCHAR) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PoSetThermalActiveCooling(ThermalRequest: PVOID, Engaged: BOOLEAN) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PoDeleteThermalRequest(ThermalRequest: PVOID);
}
pub type PO_FX_DRIPS_WATCHDOG_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(Context: PVOID, PhysicalDeviceObject: PDEVICE_OBJECT, UniqueId: ULONG),
>;
pub type PPO_FX_DRIPS_WATCHDOG_CALLBACK = PO_FX_DRIPS_WATCHDOG_CALLBACK;
unsafe extern "C" {
    pub fn PoFxRegisterDripsWatchdogCallback(
        Handle: POHANDLE,
        Callback: PPO_FX_DRIPS_WATCHDOG_CALLBACK,
        IncludeChildDevices: BOOLEAN,
        MatchingDriverObject: PDRIVER_OBJECT,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_HANDLE_INFORMATION {
    pub HandleAttributes: ULONG,
    pub GrantedAccess: ACCESS_MASK,
}
pub type OBJECT_HANDLE_INFORMATION = _OBJECT_HANDLE_INFORMATION;
pub type POBJECT_HANDLE_INFORMATION = *mut _OBJECT_HANDLE_INFORMATION;
unsafe extern "C" {
    pub fn ObReferenceObjectByHandle(
        Handle: HANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectType: POBJECT_TYPE,
        AccessMode: KPROCESSOR_MODE,
        Object: *mut PVOID,
        HandleInformation: POBJECT_HANDLE_INFORMATION,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ObReferenceObjectByHandleWithTag(
        Handle: HANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectType: POBJECT_TYPE,
        AccessMode: KPROCESSOR_MODE,
        Tag: ULONG,
        Object: *mut PVOID,
        HandleInformation: POBJECT_HANDLE_INFORMATION,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ObReferenceObjectSafe(Object: PVOID) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ObReferenceObjectSafeWithTag(Object: PVOID, Tag: ULONG) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ObCloseHandle(Handle: HANDLE, PreviousMode: KPROCESSOR_MODE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ObfReferenceObject(Object: PVOID) -> LONG_PTR;
}
unsafe extern "C" {
    pub fn ObfReferenceObjectWithTag(Object: PVOID, Tag: ULONG) -> LONG_PTR;
}
unsafe extern "C" {
    pub fn ObReferenceObjectByPointer(
        Object: PVOID,
        DesiredAccess: ACCESS_MASK,
        ObjectType: POBJECT_TYPE,
        AccessMode: KPROCESSOR_MODE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ObReferenceObjectByPointerWithTag(
        Object: PVOID,
        DesiredAccess: ACCESS_MASK,
        ObjectType: POBJECT_TYPE,
        AccessMode: KPROCESSOR_MODE,
        Tag: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ObfDereferenceObject(Object: PVOID) -> LONG_PTR;
}
unsafe extern "C" {
    pub fn ObfDereferenceObjectWithTag(Object: PVOID, Tag: ULONG) -> LONG_PTR;
}
unsafe extern "C" {
    pub fn ObDereferenceObjectDeferDelete(Object: PVOID);
}
unsafe extern "C" {
    pub fn ObDereferenceObjectDeferDeleteWithTag(Object: PVOID, Tag: ULONG);
}
unsafe extern "C" {
    pub fn ObGetObjectSecurity(
        Object: PVOID,
        SecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
        MemoryAllocated: PBOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ObReleaseObjectSecurity(
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        MemoryAllocated: BOOLEAN,
    );
}
pub type OB_OPERATION = ULONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OB_PRE_CREATE_HANDLE_INFORMATION {
    pub DesiredAccess: ACCESS_MASK,
    pub OriginalDesiredAccess: ACCESS_MASK,
}
pub type OB_PRE_CREATE_HANDLE_INFORMATION = _OB_PRE_CREATE_HANDLE_INFORMATION;
pub type POB_PRE_CREATE_HANDLE_INFORMATION = *mut _OB_PRE_CREATE_HANDLE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OB_PRE_DUPLICATE_HANDLE_INFORMATION {
    pub DesiredAccess: ACCESS_MASK,
    pub OriginalDesiredAccess: ACCESS_MASK,
    pub SourceProcess: PVOID,
    pub TargetProcess: PVOID,
}
pub type OB_PRE_DUPLICATE_HANDLE_INFORMATION = _OB_PRE_DUPLICATE_HANDLE_INFORMATION;
pub type POB_PRE_DUPLICATE_HANDLE_INFORMATION = *mut _OB_PRE_DUPLICATE_HANDLE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OB_PRE_OPERATION_PARAMETERS {
    pub CreateHandleInformation: OB_PRE_CREATE_HANDLE_INFORMATION,
    pub DuplicateHandleInformation: OB_PRE_DUPLICATE_HANDLE_INFORMATION,
}
pub type OB_PRE_OPERATION_PARAMETERS = _OB_PRE_OPERATION_PARAMETERS;
pub type POB_PRE_OPERATION_PARAMETERS = *mut _OB_PRE_OPERATION_PARAMETERS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OB_PRE_OPERATION_INFORMATION {
    pub Operation: OB_OPERATION,
    pub __bindgen_anon_1: _OB_PRE_OPERATION_INFORMATION__bindgen_ty_1,
    pub Object: PVOID,
    pub ObjectType: POBJECT_TYPE,
    pub CallContext: PVOID,
    pub Parameters: POB_PRE_OPERATION_PARAMETERS,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OB_PRE_OPERATION_INFORMATION__bindgen_ty_1 {
    pub Flags: ULONG,
    pub __bindgen_anon_1: _OB_PRE_OPERATION_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OB_PRE_OPERATION_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _OB_PRE_OPERATION_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn KernelHandle(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_KernelHandle(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn KernelHandle_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_KernelHandle_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        KernelHandle: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let KernelHandle: u32 = unsafe { ::core::mem::transmute(KernelHandle) };
            KernelHandle as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type OB_PRE_OPERATION_INFORMATION = _OB_PRE_OPERATION_INFORMATION;
pub type POB_PRE_OPERATION_INFORMATION = *mut _OB_PRE_OPERATION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OB_POST_CREATE_HANDLE_INFORMATION {
    pub GrantedAccess: ACCESS_MASK,
}
pub type OB_POST_CREATE_HANDLE_INFORMATION = _OB_POST_CREATE_HANDLE_INFORMATION;
pub type POB_POST_CREATE_HANDLE_INFORMATION = *mut _OB_POST_CREATE_HANDLE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OB_POST_DUPLICATE_HANDLE_INFORMATION {
    pub GrantedAccess: ACCESS_MASK,
}
pub type OB_POST_DUPLICATE_HANDLE_INFORMATION = _OB_POST_DUPLICATE_HANDLE_INFORMATION;
pub type POB_POST_DUPLICATE_HANDLE_INFORMATION = *mut _OB_POST_DUPLICATE_HANDLE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OB_POST_OPERATION_PARAMETERS {
    pub CreateHandleInformation: OB_POST_CREATE_HANDLE_INFORMATION,
    pub DuplicateHandleInformation: OB_POST_DUPLICATE_HANDLE_INFORMATION,
}
pub type OB_POST_OPERATION_PARAMETERS = _OB_POST_OPERATION_PARAMETERS;
pub type POB_POST_OPERATION_PARAMETERS = *mut _OB_POST_OPERATION_PARAMETERS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OB_POST_OPERATION_INFORMATION {
    pub Operation: OB_OPERATION,
    pub __bindgen_anon_1: _OB_POST_OPERATION_INFORMATION__bindgen_ty_1,
    pub Object: PVOID,
    pub ObjectType: POBJECT_TYPE,
    pub CallContext: PVOID,
    pub ReturnStatus: NTSTATUS,
    pub Parameters: POB_POST_OPERATION_PARAMETERS,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OB_POST_OPERATION_INFORMATION__bindgen_ty_1 {
    pub Flags: ULONG,
    pub __bindgen_anon_1: _OB_POST_OPERATION_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OB_POST_OPERATION_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _OB_POST_OPERATION_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn KernelHandle(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_KernelHandle(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn KernelHandle_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_KernelHandle_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        KernelHandle: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let KernelHandle: u32 = unsafe { ::core::mem::transmute(KernelHandle) };
            KernelHandle as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type OB_POST_OPERATION_INFORMATION = _OB_POST_OPERATION_INFORMATION;
pub type POB_POST_OPERATION_INFORMATION = *mut _OB_POST_OPERATION_INFORMATION;
pub const _OB_PREOP_CALLBACK_STATUS_OB_PREOP_SUCCESS: _OB_PREOP_CALLBACK_STATUS = 0;
pub type _OB_PREOP_CALLBACK_STATUS = core::ffi::c_int;
pub use self::_OB_PREOP_CALLBACK_STATUS as OB_PREOP_CALLBACK_STATUS;
pub type POB_PREOP_CALLBACK_STATUS = *mut _OB_PREOP_CALLBACK_STATUS;
pub type POB_PRE_OPERATION_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        RegistrationContext: PVOID,
        OperationInformation: POB_PRE_OPERATION_INFORMATION,
    ) -> OB_PREOP_CALLBACK_STATUS,
>;
pub type POB_POST_OPERATION_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        RegistrationContext: PVOID,
        OperationInformation: POB_POST_OPERATION_INFORMATION,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OB_OPERATION_REGISTRATION {
    pub ObjectType: *mut POBJECT_TYPE,
    pub Operations: OB_OPERATION,
    pub PreOperation: POB_PRE_OPERATION_CALLBACK,
    pub PostOperation: POB_POST_OPERATION_CALLBACK,
}
pub type OB_OPERATION_REGISTRATION = _OB_OPERATION_REGISTRATION;
pub type POB_OPERATION_REGISTRATION = *mut _OB_OPERATION_REGISTRATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OB_CALLBACK_REGISTRATION {
    pub Version: USHORT,
    pub OperationRegistrationCount: USHORT,
    pub Altitude: UNICODE_STRING,
    pub RegistrationContext: PVOID,
    pub OperationRegistration: *mut OB_OPERATION_REGISTRATION,
}
pub type OB_CALLBACK_REGISTRATION = _OB_CALLBACK_REGISTRATION;
pub type POB_CALLBACK_REGISTRATION = *mut _OB_CALLBACK_REGISTRATION;
unsafe extern "C" {
    pub fn ObRegisterCallbacks(
        CallbackRegistration: POB_CALLBACK_REGISTRATION,
        RegistrationHandle: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ObUnRegisterCallbacks(RegistrationHandle: PVOID);
}
unsafe extern "C" {
    pub fn ObGetFilterVersion() -> USHORT;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_SEGMENT_BUS_NUMBER {
    pub u: _PCI_SEGMENT_BUS_NUMBER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_SEGMENT_BUS_NUMBER__bindgen_ty_1 {
    pub bits: _PCI_SEGMENT_BUS_NUMBER__bindgen_ty_1__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_SEGMENT_BUS_NUMBER__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_SEGMENT_BUS_NUMBER__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn BusNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BusNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn BusNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_BusNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SegmentNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_SegmentNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SegmentNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SegmentNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BusNumber: ULONG,
        SegmentNumber: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let BusNumber: u32 = unsafe { ::core::mem::transmute(BusNumber) };
            BusNumber as u64
        });
        __bindgen_bitfield_unit.set(8usize, 16u8, {
            let SegmentNumber: u32 = unsafe { ::core::mem::transmute(SegmentNumber) };
            SegmentNumber as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_SEGMENT_BUS_NUMBER = _PCI_SEGMENT_BUS_NUMBER;
pub type PPCI_SEGMENT_BUS_NUMBER = *mut _PCI_SEGMENT_BUS_NUMBER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_SLOT_NUMBER {
    pub u: _PCI_SLOT_NUMBER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_SLOT_NUMBER__bindgen_ty_1 {
    pub bits: _PCI_SLOT_NUMBER__bindgen_ty_1__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_SLOT_NUMBER__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_SLOT_NUMBER__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn DeviceNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_DeviceNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DeviceNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DeviceNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FunctionNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_FunctionNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FunctionNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FunctionNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DeviceNumber: ULONG,
        FunctionNumber: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let DeviceNumber: u32 = unsafe { ::core::mem::transmute(DeviceNumber) };
            DeviceNumber as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let FunctionNumber: u32 = unsafe { ::core::mem::transmute(FunctionNumber) };
            FunctionNumber as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_SLOT_NUMBER = _PCI_SLOT_NUMBER;
pub type PPCI_SLOT_NUMBER = *mut _PCI_SLOT_NUMBER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_COMMON_HEADER {
    pub VendorID: USHORT,
    pub DeviceID: USHORT,
    pub Command: USHORT,
    pub Status: USHORT,
    pub RevisionID: UCHAR,
    pub ProgIf: UCHAR,
    pub SubClass: UCHAR,
    pub BaseClass: UCHAR,
    pub CacheLineSize: UCHAR,
    pub LatencyTimer: UCHAR,
    pub HeaderType: UCHAR,
    pub BIST: UCHAR,
    pub u: _PCI_COMMON_HEADER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_COMMON_HEADER__bindgen_ty_1 {
    pub type0: _PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_0,
    pub type1: _PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_1,
    pub type2: _PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_0 {
    pub BaseAddresses: [ULONG; 6usize],
    pub CIS: ULONG,
    pub SubVendorID: USHORT,
    pub SubSystemID: USHORT,
    pub ROMBaseAddress: ULONG,
    pub CapabilitiesPtr: UCHAR,
    pub Reserved1: [UCHAR; 3usize],
    pub Reserved2: ULONG,
    pub InterruptLine: UCHAR,
    pub InterruptPin: UCHAR,
    pub MinimumGrant: UCHAR,
    pub MaximumLatency: UCHAR,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_1 {
    pub BaseAddresses: [ULONG; 2usize],
    pub PrimaryBus: UCHAR,
    pub SecondaryBus: UCHAR,
    pub SubordinateBus: UCHAR,
    pub SecondaryLatency: UCHAR,
    pub IOBase: UCHAR,
    pub IOLimit: UCHAR,
    pub SecondaryStatus: USHORT,
    pub MemoryBase: USHORT,
    pub MemoryLimit: USHORT,
    pub PrefetchBase: USHORT,
    pub PrefetchLimit: USHORT,
    pub PrefetchBaseUpper32: ULONG,
    pub PrefetchLimitUpper32: ULONG,
    pub IOBaseUpper16: USHORT,
    pub IOLimitUpper16: USHORT,
    pub CapabilitiesPtr: UCHAR,
    pub Reserved1: [UCHAR; 3usize],
    pub ROMBaseAddress: ULONG,
    pub InterruptLine: UCHAR,
    pub InterruptPin: UCHAR,
    pub BridgeControl: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_2 {
    pub SocketRegistersBaseAddress: ULONG,
    pub CapabilitiesPtr: UCHAR,
    pub Reserved: UCHAR,
    pub SecondaryStatus: USHORT,
    pub PrimaryBus: UCHAR,
    pub SecondaryBus: UCHAR,
    pub SubordinateBus: UCHAR,
    pub SecondaryLatency: UCHAR,
    pub Range: [_PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_2__bindgen_ty_1; 4usize],
    pub InterruptLine: UCHAR,
    pub InterruptPin: UCHAR,
    pub BridgeControl: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_2__bindgen_ty_1 {
    pub Base: ULONG,
    pub Limit: ULONG,
}
pub type PCI_COMMON_HEADER = _PCI_COMMON_HEADER;
pub type PPCI_COMMON_HEADER = *mut _PCI_COMMON_HEADER;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_COMMON_CONFIG {
    pub __bindgen_padding_0: [u8; 64usize],
    pub DeviceSpecific: [UCHAR; 192usize],
}
pub type PCI_COMMON_CONFIG = _PCI_COMMON_CONFIG;
pub type PPCI_COMMON_CONFIG = *mut _PCI_COMMON_CONFIG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_CAPABILITIES_HEADER {
    pub CapabilityID: UCHAR,
    pub Next: UCHAR,
}
pub type PCI_CAPABILITIES_HEADER = _PCI_CAPABILITIES_HEADER;
pub type PPCI_CAPABILITIES_HEADER = *mut _PCI_CAPABILITIES_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_PMC {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub Support: _PCI_PMC__PM_SUPPORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_PMC__PM_SUPPORT {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _PCI_PMC__PM_SUPPORT {
    #[inline]
    pub fn Rsvd2(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd2_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd2_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn D1(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_D1(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn D1_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_D1_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn D2(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_D2(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn D2_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_D2_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PMED0(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PMED0(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PMED0_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_PMED0_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PMED1(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PMED1(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PMED1_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_PMED1_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PMED2(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PMED2(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PMED2_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_PMED2_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PMED3Hot(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PMED3Hot(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PMED3Hot_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_PMED3Hot_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PMED3Cold(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PMED3Cold(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PMED3Cold_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_PMED3Cold_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Rsvd2: UCHAR,
        D1: UCHAR,
        D2: UCHAR,
        PMED0: UCHAR,
        PMED1: UCHAR,
        PMED2: UCHAR,
        PMED3Hot: UCHAR,
        PMED3Cold: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Rsvd2: u8 = unsafe { ::core::mem::transmute(Rsvd2) };
            Rsvd2 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let D1: u8 = unsafe { ::core::mem::transmute(D1) };
            D1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let D2: u8 = unsafe { ::core::mem::transmute(D2) };
            D2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PMED0: u8 = unsafe { ::core::mem::transmute(PMED0) };
            PMED0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PMED1: u8 = unsafe { ::core::mem::transmute(PMED1) };
            PMED1 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PMED2: u8 = unsafe { ::core::mem::transmute(PMED2) };
            PMED2 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PMED3Hot: u8 = unsafe { ::core::mem::transmute(PMED3Hot) };
            PMED3Hot as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PMED3Cold: u8 = unsafe { ::core::mem::transmute(PMED3Cold) };
            PMED3Cold as u64
        });
        __bindgen_bitfield_unit
    }
}
impl _PCI_PMC {
    #[inline]
    pub fn Version(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_Version(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Version_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Version_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PMEClock(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PMEClock(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PMEClock_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_PMEClock_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd1(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd1_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd1_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DeviceSpecificInitialization(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DeviceSpecificInitialization(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DeviceSpecificInitialization_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_DeviceSpecificInitialization_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd2(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd2_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd2_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Version: UCHAR,
        PMEClock: UCHAR,
        Rsvd1: UCHAR,
        DeviceSpecificInitialization: UCHAR,
        Rsvd2: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let Version: u8 = unsafe { ::core::mem::transmute(Version) };
            Version as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PMEClock: u8 = unsafe { ::core::mem::transmute(PMEClock) };
            PMEClock as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Rsvd1: u8 = unsafe { ::core::mem::transmute(Rsvd1) };
            Rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DeviceSpecificInitialization: u8 =
                unsafe { ::core::mem::transmute(DeviceSpecificInitialization) };
            DeviceSpecificInitialization as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let Rsvd2: u8 = unsafe { ::core::mem::transmute(Rsvd2) };
            Rsvd2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_PMC = _PCI_PMC;
pub type PPCI_PMC = *mut _PCI_PMC;
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_PMCSR {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_PMCSR {
    #[inline]
    pub fn PowerState(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_PowerState(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PowerState_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PowerState_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd1(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd1_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd1_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NoSoftReset(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_NoSoftReset(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NoSoftReset_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_NoSoftReset_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd2(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd2_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd2_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PMEEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PMEEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PMEEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PMEEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DataSelect(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_DataSelect(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DataSelect_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_DataSelect_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DataScale(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_DataScale(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DataScale_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_DataScale_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PMEStatus(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PMEStatus(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PMEStatus_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PMEStatus_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PowerState: USHORT,
        Rsvd1: USHORT,
        NoSoftReset: USHORT,
        Rsvd2: USHORT,
        PMEEnable: USHORT,
        DataSelect: USHORT,
        DataScale: USHORT,
        PMEStatus: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let PowerState: u16 = unsafe { ::core::mem::transmute(PowerState) };
            PowerState as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Rsvd1: u16 = unsafe { ::core::mem::transmute(Rsvd1) };
            Rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let NoSoftReset: u16 = unsafe { ::core::mem::transmute(NoSoftReset) };
            NoSoftReset as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let Rsvd2: u16 = unsafe { ::core::mem::transmute(Rsvd2) };
            Rsvd2 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let PMEEnable: u16 = unsafe { ::core::mem::transmute(PMEEnable) };
            PMEEnable as u64
        });
        __bindgen_bitfield_unit.set(9usize, 4u8, {
            let DataSelect: u16 = unsafe { ::core::mem::transmute(DataSelect) };
            DataSelect as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let DataScale: u16 = unsafe { ::core::mem::transmute(DataScale) };
            DataScale as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let PMEStatus: u16 = unsafe { ::core::mem::transmute(PMEStatus) };
            PMEStatus as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_PMCSR = _PCI_PMCSR;
pub type PPCI_PMCSR = *mut _PCI_PMCSR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_PMCSR_BSE {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _PCI_PMCSR_BSE {
    #[inline]
    pub fn Rsvd1(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd1_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                6u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd1_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn D3HotSupportsStopClock(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_D3HotSupportsStopClock(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn D3HotSupportsStopClock_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_D3HotSupportsStopClock_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn BusPowerClockControlEnabled(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BusPowerClockControlEnabled(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn BusPowerClockControlEnabled_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_BusPowerClockControlEnabled_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Rsvd1: UCHAR,
        D3HotSupportsStopClock: UCHAR,
        BusPowerClockControlEnabled: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let Rsvd1: u8 = unsafe { ::core::mem::transmute(Rsvd1) };
            Rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let D3HotSupportsStopClock: u8 =
                unsafe { ::core::mem::transmute(D3HotSupportsStopClock) };
            D3HotSupportsStopClock as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let BusPowerClockControlEnabled: u8 =
                unsafe { ::core::mem::transmute(BusPowerClockControlEnabled) };
            BusPowerClockControlEnabled as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_PMCSR_BSE = _PCI_PMCSR_BSE;
pub type PPCI_PMCSR_BSE = *mut _PCI_PMCSR_BSE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_PM_CAPABILITY {
    pub Header: PCI_CAPABILITIES_HEADER,
    pub PMC: _PCI_PM_CAPABILITY__bindgen_ty_1,
    pub PMCSR: _PCI_PM_CAPABILITY__bindgen_ty_2,
    pub PMCSR_BSE: _PCI_PM_CAPABILITY__bindgen_ty_3,
    pub Data: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_PM_CAPABILITY__bindgen_ty_1 {
    pub Capabilities: PCI_PMC,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_PM_CAPABILITY__bindgen_ty_2 {
    pub ControlStatus: PCI_PMCSR,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_PM_CAPABILITY__bindgen_ty_3 {
    pub BridgeSupport: PCI_PMCSR_BSE,
    pub AsUCHAR: UCHAR,
}
pub type PCI_PM_CAPABILITY = _PCI_PM_CAPABILITY;
pub type PPCI_PM_CAPABILITY = *mut _PCI_PM_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PCI_X_CAPABILITY {
    pub Header: PCI_CAPABILITIES_HEADER,
    pub Command: PCI_X_CAPABILITY__bindgen_ty_1,
    pub Status: PCI_X_CAPABILITY__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PCI_X_CAPABILITY__bindgen_ty_1 {
    pub bits: PCI_X_CAPABILITY__bindgen_ty_1__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PCI_X_CAPABILITY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl PCI_X_CAPABILITY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn DataParityErrorRecoveryEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DataParityErrorRecoveryEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DataParityErrorRecoveryEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_DataParityErrorRecoveryEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EnableRelaxedOrdering(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EnableRelaxedOrdering(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EnableRelaxedOrdering_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_EnableRelaxedOrdering_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MaxMemoryReadByteCount(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_MaxMemoryReadByteCount(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MaxMemoryReadByteCount_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_MaxMemoryReadByteCount_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MaxOutstandingSplitTransactions(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_MaxOutstandingSplitTransactions(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MaxOutstandingSplitTransactions_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_MaxOutstandingSplitTransactions_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                9u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                9u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DataParityErrorRecoveryEnable: USHORT,
        EnableRelaxedOrdering: USHORT,
        MaxMemoryReadByteCount: USHORT,
        MaxOutstandingSplitTransactions: USHORT,
        Reserved: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DataParityErrorRecoveryEnable: u16 =
                unsafe { ::core::mem::transmute(DataParityErrorRecoveryEnable) };
            DataParityErrorRecoveryEnable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let EnableRelaxedOrdering: u16 =
                unsafe { ::core::mem::transmute(EnableRelaxedOrdering) };
            EnableRelaxedOrdering as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let MaxMemoryReadByteCount: u16 =
                unsafe { ::core::mem::transmute(MaxMemoryReadByteCount) };
            MaxMemoryReadByteCount as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let MaxOutstandingSplitTransactions: u16 =
                unsafe { ::core::mem::transmute(MaxOutstandingSplitTransactions) };
            MaxOutstandingSplitTransactions as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let Reserved: u16 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PCI_X_CAPABILITY__bindgen_ty_2 {
    pub bits: PCI_X_CAPABILITY__bindgen_ty_2__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PCI_X_CAPABILITY__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl PCI_X_CAPABILITY__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn FunctionNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_FunctionNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FunctionNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FunctionNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DeviceNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_DeviceNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DeviceNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DeviceNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn BusNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BusNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn BusNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_BusNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Device64Bit(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Device64Bit(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Device64Bit_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Device64Bit_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Capable133MHz(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Capable133MHz(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Capable133MHz_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Capable133MHz_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SplitCompletionDiscarded(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SplitCompletionDiscarded(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SplitCompletionDiscarded_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SplitCompletionDiscarded_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UnexpectedSplitCompletion(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UnexpectedSplitCompletion(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UnexpectedSplitCompletion_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UnexpectedSplitCompletion_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DeviceComplexity(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeviceComplexity(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DeviceComplexity_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DeviceComplexity_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DesignedMaxMemoryReadByteCount(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_DesignedMaxMemoryReadByteCount(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DesignedMaxMemoryReadByteCount_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DesignedMaxMemoryReadByteCount_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DesignedMaxOutstandingSplitTransactions(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_DesignedMaxOutstandingSplitTransactions(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DesignedMaxOutstandingSplitTransactions_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DesignedMaxOutstandingSplitTransactions_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DesignedMaxCumulativeReadSize(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_DesignedMaxCumulativeReadSize(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DesignedMaxCumulativeReadSize_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DesignedMaxCumulativeReadSize_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReceivedSplitCompletionErrorMessage(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReceivedSplitCompletionErrorMessage(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReceivedSplitCompletionErrorMessage_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                29usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReceivedSplitCompletionErrorMessage_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                29usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CapablePCIX266(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CapablePCIX266(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CapablePCIX266_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CapablePCIX266_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CapablePCIX533(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CapablePCIX533(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CapablePCIX533_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CapablePCIX533_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FunctionNumber: ULONG,
        DeviceNumber: ULONG,
        BusNumber: ULONG,
        Device64Bit: ULONG,
        Capable133MHz: ULONG,
        SplitCompletionDiscarded: ULONG,
        UnexpectedSplitCompletion: ULONG,
        DeviceComplexity: ULONG,
        DesignedMaxMemoryReadByteCount: ULONG,
        DesignedMaxOutstandingSplitTransactions: ULONG,
        DesignedMaxCumulativeReadSize: ULONG,
        ReceivedSplitCompletionErrorMessage: ULONG,
        CapablePCIX266: ULONG,
        CapablePCIX533: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let FunctionNumber: u32 = unsafe { ::core::mem::transmute(FunctionNumber) };
            FunctionNumber as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let DeviceNumber: u32 = unsafe { ::core::mem::transmute(DeviceNumber) };
            DeviceNumber as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let BusNumber: u32 = unsafe { ::core::mem::transmute(BusNumber) };
            BusNumber as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let Device64Bit: u32 = unsafe { ::core::mem::transmute(Device64Bit) };
            Device64Bit as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let Capable133MHz: u32 = unsafe { ::core::mem::transmute(Capable133MHz) };
            Capable133MHz as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let SplitCompletionDiscarded: u32 =
                unsafe { ::core::mem::transmute(SplitCompletionDiscarded) };
            SplitCompletionDiscarded as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let UnexpectedSplitCompletion: u32 =
                unsafe { ::core::mem::transmute(UnexpectedSplitCompletion) };
            UnexpectedSplitCompletion as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let DeviceComplexity: u32 = unsafe { ::core::mem::transmute(DeviceComplexity) };
            DeviceComplexity as u64
        });
        __bindgen_bitfield_unit.set(21usize, 2u8, {
            let DesignedMaxMemoryReadByteCount: u32 =
                unsafe { ::core::mem::transmute(DesignedMaxMemoryReadByteCount) };
            DesignedMaxMemoryReadByteCount as u64
        });
        __bindgen_bitfield_unit.set(23usize, 3u8, {
            let DesignedMaxOutstandingSplitTransactions: u32 =
                unsafe { ::core::mem::transmute(DesignedMaxOutstandingSplitTransactions) };
            DesignedMaxOutstandingSplitTransactions as u64
        });
        __bindgen_bitfield_unit.set(26usize, 3u8, {
            let DesignedMaxCumulativeReadSize: u32 =
                unsafe { ::core::mem::transmute(DesignedMaxCumulativeReadSize) };
            DesignedMaxCumulativeReadSize as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let ReceivedSplitCompletionErrorMessage: u32 =
                unsafe { ::core::mem::transmute(ReceivedSplitCompletionErrorMessage) };
            ReceivedSplitCompletionErrorMessage as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let CapablePCIX266: u32 = unsafe { ::core::mem::transmute(CapablePCIX266) };
            CapablePCIX266 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let CapablePCIX533: u32 = unsafe { ::core::mem::transmute(CapablePCIX533) };
            CapablePCIX533 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PPCI_X_CAPABILITY = *mut PCI_X_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER {
    pub CapabilityID: USHORT,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER {
    #[inline]
    pub fn Version(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_Version(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Version_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Version_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Next(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_Next(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Next_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                12u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Next_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(Version: USHORT, Next: USHORT) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let Version: u16 = unsafe { ::core::mem::transmute(Version) };
            Version as u64
        });
        __bindgen_bitfield_unit.set(4usize, 12u8, {
            let Next: u16 = unsafe { ::core::mem::transmute(Next) };
            Next as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER = _PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER;
pub type PPCI_EXPRESS_ENHANCED_CAPABILITY_HEADER = *mut _PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_VENDOR_SPECIFIC_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub VsecId: USHORT,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_VENDOR_SPECIFIC_CAPABILITY {
    #[inline]
    pub fn VsecRev(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_VsecRev(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VsecRev_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_VsecRev_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VsecLength(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_VsecLength(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VsecLength_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                12u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_VsecLength_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        VsecRev: USHORT,
        VsecLength: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let VsecRev: u16 = unsafe { ::core::mem::transmute(VsecRev) };
            VsecRev as u64
        });
        __bindgen_bitfield_unit.set(4usize, 12u8, {
            let VsecLength: u16 = unsafe { ::core::mem::transmute(VsecLength) };
            VsecLength as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_VENDOR_SPECIFIC_CAPABILITY = _PCI_EXPRESS_VENDOR_SPECIFIC_CAPABILITY;
pub type PPCI_EXPRESS_VENDOR_SPECIFIC_CAPABILITY = *mut _PCI_EXPRESS_VENDOR_SPECIFIC_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_SERIAL_NUMBER_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub LowSerialNumber: ULONG,
    pub HighSerialNumber: ULONG,
}
pub type PCI_EXPRESS_SERIAL_NUMBER_CAPABILITY = _PCI_EXPRESS_SERIAL_NUMBER_CAPABILITY;
pub type PPCI_EXPRESS_SERIAL_NUMBER_CAPABILITY = *mut _PCI_EXPRESS_SERIAL_NUMBER_CAPABILITY;
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_ARI_CAPABILITY_REGISTER {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_ARI_CAPABILITY_REGISTER {
    #[inline]
    pub fn MfvcFunctionGroupsCapability(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_MfvcFunctionGroupsCapability(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MfvcFunctionGroupsCapability_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_MfvcFunctionGroupsCapability_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AcsFunctionGroupsCapability(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_AcsFunctionGroupsCapability(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AcsFunctionGroupsCapability_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_AcsFunctionGroupsCapability_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                6u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NextFunctionNumber(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_NextFunctionNumber(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NextFunctionNumber_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_NextFunctionNumber_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MfvcFunctionGroupsCapability: USHORT,
        AcsFunctionGroupsCapability: USHORT,
        Reserved: USHORT,
        NextFunctionNumber: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let MfvcFunctionGroupsCapability: u16 =
                unsafe { ::core::mem::transmute(MfvcFunctionGroupsCapability) };
            MfvcFunctionGroupsCapability as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AcsFunctionGroupsCapability: u16 =
                unsafe { ::core::mem::transmute(AcsFunctionGroupsCapability) };
            AcsFunctionGroupsCapability as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let Reserved: u16 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let NextFunctionNumber: u16 = unsafe { ::core::mem::transmute(NextFunctionNumber) };
            NextFunctionNumber as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_ARI_CAPABILITY_REGISTER = _PCI_EXPRESS_ARI_CAPABILITY_REGISTER;
pub type PPCI_EXPRESS_ARI_CAPABILITY_REGISTER = *mut _PCI_EXPRESS_ARI_CAPABILITY_REGISTER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_ARI_CONTROL_REGISTER {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_ARI_CONTROL_REGISTER {
    #[inline]
    pub fn MfvcFunctionGroupsEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_MfvcFunctionGroupsEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MfvcFunctionGroupsEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_MfvcFunctionGroupsEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AcsFunctionGroupsEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_AcsFunctionGroupsEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AcsFunctionGroupsEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_AcsFunctionGroupsEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FunctionGroup(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_FunctionGroup(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FunctionGroup_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_FunctionGroup_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved2_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                9u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved2_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                9u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MfvcFunctionGroupsEnable: USHORT,
        AcsFunctionGroupsEnable: USHORT,
        Reserved1: USHORT,
        FunctionGroup: USHORT,
        Reserved2: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let MfvcFunctionGroupsEnable: u16 =
                unsafe { ::core::mem::transmute(MfvcFunctionGroupsEnable) };
            MfvcFunctionGroupsEnable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AcsFunctionGroupsEnable: u16 =
                unsafe { ::core::mem::transmute(AcsFunctionGroupsEnable) };
            AcsFunctionGroupsEnable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let Reserved1: u16 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let FunctionGroup: u16 = unsafe { ::core::mem::transmute(FunctionGroup) };
            FunctionGroup as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let Reserved2: u16 = unsafe { ::core::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_ARI_CONTROL_REGISTER = _PCI_EXPRESS_ARI_CONTROL_REGISTER;
pub type PPCI_EXPRESS_ARI_CONTROL_REGISTER = *mut _PCI_EXPRESS_ARI_CONTROL_REGISTER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_ARI_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub Capability: PCI_EXPRESS_ARI_CAPABILITY_REGISTER,
    pub Control: PCI_EXPRESS_ARI_CONTROL_REGISTER,
}
pub type PCI_EXPRESS_ARI_CAPABILITY = _PCI_EXPRESS_ARI_CAPABILITY;
pub type PPCI_EXPRESS_ARI_CAPABILITY = *mut _PCI_EXPRESS_ARI_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VIRTUAL_CHANNEL_CAPABILITIES1 {
    pub __bindgen_anon_1: _VIRTUAL_CHANNEL_CAPABILITIES1__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VIRTUAL_CHANNEL_CAPABILITIES1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VIRTUAL_CHANNEL_CAPABILITIES1__bindgen_ty_1 {
    #[inline]
    pub fn ExtendedVCCount(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ExtendedVCCount(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ExtendedVCCount_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ExtendedVCCount_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RsvdP1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RsvdP1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RsvdP1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RsvdP1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LowPriorityExtendedVCCount(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_LowPriorityExtendedVCCount(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LowPriorityExtendedVCCount_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_LowPriorityExtendedVCCount_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RsvdP2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RsvdP2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RsvdP2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RsvdP2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReferenceClock(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ReferenceClock(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReferenceClock_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReferenceClock_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PortArbitrationTableEntrySize(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_PortArbitrationTableEntrySize(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PortArbitrationTableEntrySize_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PortArbitrationTableEntrySize_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RsvdP3(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_RsvdP3(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RsvdP3_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                20u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RsvdP3_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                20u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ExtendedVCCount: ULONG,
        RsvdP1: ULONG,
        LowPriorityExtendedVCCount: ULONG,
        RsvdP2: ULONG,
        ReferenceClock: ULONG,
        PortArbitrationTableEntrySize: ULONG,
        RsvdP3: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let ExtendedVCCount: u32 = unsafe { ::core::mem::transmute(ExtendedVCCount) };
            ExtendedVCCount as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let RsvdP1: u32 = unsafe { ::core::mem::transmute(RsvdP1) };
            RsvdP1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let LowPriorityExtendedVCCount: u32 =
                unsafe { ::core::mem::transmute(LowPriorityExtendedVCCount) };
            LowPriorityExtendedVCCount as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let RsvdP2: u32 = unsafe { ::core::mem::transmute(RsvdP2) };
            RsvdP2 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let ReferenceClock: u32 = unsafe { ::core::mem::transmute(ReferenceClock) };
            ReferenceClock as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let PortArbitrationTableEntrySize: u32 =
                unsafe { ::core::mem::transmute(PortArbitrationTableEntrySize) };
            PortArbitrationTableEntrySize as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let RsvdP3: u32 = unsafe { ::core::mem::transmute(RsvdP3) };
            RsvdP3 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type VIRTUAL_CHANNEL_CAPABILITIES1 = _VIRTUAL_CHANNEL_CAPABILITIES1;
pub type PVIRTUAL_CHANNEL_CAPABILITIES1 = *mut _VIRTUAL_CHANNEL_CAPABILITIES1;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VIRTUAL_CHANNEL_CAPABILITIES2 {
    pub __bindgen_anon_1: _VIRTUAL_CHANNEL_CAPABILITIES2__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _VIRTUAL_CHANNEL_CAPABILITIES2__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VIRTUAL_CHANNEL_CAPABILITIES2__bindgen_ty_1 {
    #[inline]
    pub fn VCArbitrationCapability(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_VCArbitrationCapability(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VCArbitrationCapability_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VCArbitrationCapability_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RsvdP(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_RsvdP(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RsvdP_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RsvdP_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VCArbitrationTableOffset(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_VCArbitrationTableOffset(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VCArbitrationTableOffset_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VCArbitrationTableOffset_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        VCArbitrationCapability: ULONG,
        RsvdP: ULONG,
        VCArbitrationTableOffset: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let VCArbitrationCapability: u32 =
                unsafe { ::core::mem::transmute(VCArbitrationCapability) };
            VCArbitrationCapability as u64
        });
        __bindgen_bitfield_unit.set(8usize, 16u8, {
            let RsvdP: u32 = unsafe { ::core::mem::transmute(RsvdP) };
            RsvdP as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let VCArbitrationTableOffset: u32 =
                unsafe { ::core::mem::transmute(VCArbitrationTableOffset) };
            VCArbitrationTableOffset as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type VIRTUAL_CHANNEL_CAPABILITIES2 = _VIRTUAL_CHANNEL_CAPABILITIES2;
pub type PVIRTUAL_CHANNEL_CAPABILITIES2 = *mut _VIRTUAL_CHANNEL_CAPABILITIES2;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VIRTUAL_CHANNEL_CONTROL {
    pub __bindgen_anon_1: _VIRTUAL_CHANNEL_CONTROL__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VIRTUAL_CHANNEL_CONTROL__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _VIRTUAL_CHANNEL_CONTROL__bindgen_ty_1 {
    #[inline]
    pub fn LoadVCArbitrationTable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LoadVCArbitrationTable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LoadVCArbitrationTable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_LoadVCArbitrationTable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VCArbitrationSelect(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_VCArbitrationSelect(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VCArbitrationSelect_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_VCArbitrationSelect_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RsvdP(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_RsvdP(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RsvdP_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                12u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_RsvdP_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        LoadVCArbitrationTable: USHORT,
        VCArbitrationSelect: USHORT,
        RsvdP: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let LoadVCArbitrationTable: u16 =
                unsafe { ::core::mem::transmute(LoadVCArbitrationTable) };
            LoadVCArbitrationTable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let VCArbitrationSelect: u16 = unsafe { ::core::mem::transmute(VCArbitrationSelect) };
            VCArbitrationSelect as u64
        });
        __bindgen_bitfield_unit.set(4usize, 12u8, {
            let RsvdP: u16 = unsafe { ::core::mem::transmute(RsvdP) };
            RsvdP as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type VIRTUAL_CHANNEL_CONTROL = _VIRTUAL_CHANNEL_CONTROL;
pub type PVIRTUAL_CHANNEL_CONTROL = *mut _VIRTUAL_CHANNEL_CONTROL;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VIRTUAL_CHANNEL_STATUS {
    pub __bindgen_anon_1: _VIRTUAL_CHANNEL_STATUS__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VIRTUAL_CHANNEL_STATUS__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _VIRTUAL_CHANNEL_STATUS__bindgen_ty_1 {
    #[inline]
    pub fn VCArbitrationTableStatus(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_VCArbitrationTableStatus(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VCArbitrationTableStatus_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_VCArbitrationTableStatus_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RsvdZ(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 15u8) as u16) }
    }
    #[inline]
    pub fn set_RsvdZ(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RsvdZ_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                15u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_RsvdZ_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                15u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        VCArbitrationTableStatus: USHORT,
        RsvdZ: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let VCArbitrationTableStatus: u16 =
                unsafe { ::core::mem::transmute(VCArbitrationTableStatus) };
            VCArbitrationTableStatus as u64
        });
        __bindgen_bitfield_unit.set(1usize, 15u8, {
            let RsvdZ: u16 = unsafe { ::core::mem::transmute(RsvdZ) };
            RsvdZ as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type VIRTUAL_CHANNEL_STATUS = _VIRTUAL_CHANNEL_STATUS;
pub type PVIRTUAL_CHANNEL_STATUS = *mut _VIRTUAL_CHANNEL_STATUS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VIRTUAL_RESOURCE_CAPABILITY {
    pub __bindgen_anon_1: _VIRTUAL_RESOURCE_CAPABILITY__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _VIRTUAL_RESOURCE_CAPABILITY__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VIRTUAL_RESOURCE_CAPABILITY__bindgen_ty_1 {
    #[inline]
    pub fn PortArbitrationCapability(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_PortArbitrationCapability(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PortArbitrationCapability_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PortArbitrationCapability_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RsvdP1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_RsvdP1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RsvdP1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RsvdP1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Undefined(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Undefined(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Undefined_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Undefined_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RejectSnoopTransactions(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RejectSnoopTransactions(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RejectSnoopTransactions_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RejectSnoopTransactions_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MaximumTimeSlots(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_MaximumTimeSlots(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MaximumTimeSlots_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                7u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MaximumTimeSlots_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RsvdP2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RsvdP2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RsvdP2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RsvdP2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PortArbitrationTableOffset(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_PortArbitrationTableOffset(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PortArbitrationTableOffset_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PortArbitrationTableOffset_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PortArbitrationCapability: ULONG,
        RsvdP1: ULONG,
        Undefined: ULONG,
        RejectSnoopTransactions: ULONG,
        MaximumTimeSlots: ULONG,
        RsvdP2: ULONG,
        PortArbitrationTableOffset: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PortArbitrationCapability: u32 =
                unsafe { ::core::mem::transmute(PortArbitrationCapability) };
            PortArbitrationCapability as u64
        });
        __bindgen_bitfield_unit.set(8usize, 6u8, {
            let RsvdP1: u32 = unsafe { ::core::mem::transmute(RsvdP1) };
            RsvdP1 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let Undefined: u32 = unsafe { ::core::mem::transmute(Undefined) };
            Undefined as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let RejectSnoopTransactions: u32 =
                unsafe { ::core::mem::transmute(RejectSnoopTransactions) };
            RejectSnoopTransactions as u64
        });
        __bindgen_bitfield_unit.set(16usize, 7u8, {
            let MaximumTimeSlots: u32 = unsafe { ::core::mem::transmute(MaximumTimeSlots) };
            MaximumTimeSlots as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let RsvdP2: u32 = unsafe { ::core::mem::transmute(RsvdP2) };
            RsvdP2 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let PortArbitrationTableOffset: u32 =
                unsafe { ::core::mem::transmute(PortArbitrationTableOffset) };
            PortArbitrationTableOffset as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type VIRTUAL_RESOURCE_CAPABILITY = _VIRTUAL_RESOURCE_CAPABILITY;
pub type PVIRTUAL_RESOURCE_CAPABILITY = *mut _VIRTUAL_RESOURCE_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VIRTUAL_RESOURCE_CONTROL {
    pub __bindgen_anon_1: _VIRTUAL_RESOURCE_CONTROL__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _VIRTUAL_RESOURCE_CONTROL__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VIRTUAL_RESOURCE_CONTROL__bindgen_ty_1 {
    #[inline]
    pub fn TcVcMap(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_TcVcMap(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TcVcMap_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_TcVcMap_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RsvdP1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_RsvdP1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RsvdP1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RsvdP1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LoadPortArbitrationTable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LoadPortArbitrationTable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LoadPortArbitrationTable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_LoadPortArbitrationTable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PortArbitrationSelect(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_PortArbitrationSelect(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PortArbitrationSelect_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PortArbitrationSelect_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RsvdP2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_RsvdP2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RsvdP2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RsvdP2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VcID(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_VcID(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VcID_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VcID_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RsvdP3(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_RsvdP3(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RsvdP3_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RsvdP3_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VcEnable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VcEnable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VcEnable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VcEnable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TcVcMap: ULONG,
        RsvdP1: ULONG,
        LoadPortArbitrationTable: ULONG,
        PortArbitrationSelect: ULONG,
        RsvdP2: ULONG,
        VcID: ULONG,
        RsvdP3: ULONG,
        VcEnable: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let TcVcMap: u32 = unsafe { ::core::mem::transmute(TcVcMap) };
            TcVcMap as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let RsvdP1: u32 = unsafe { ::core::mem::transmute(RsvdP1) };
            RsvdP1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let LoadPortArbitrationTable: u32 =
                unsafe { ::core::mem::transmute(LoadPortArbitrationTable) };
            LoadPortArbitrationTable as u64
        });
        __bindgen_bitfield_unit.set(17usize, 3u8, {
            let PortArbitrationSelect: u32 =
                unsafe { ::core::mem::transmute(PortArbitrationSelect) };
            PortArbitrationSelect as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let RsvdP2: u32 = unsafe { ::core::mem::transmute(RsvdP2) };
            RsvdP2 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 3u8, {
            let VcID: u32 = unsafe { ::core::mem::transmute(VcID) };
            VcID as u64
        });
        __bindgen_bitfield_unit.set(27usize, 4u8, {
            let RsvdP3: u32 = unsafe { ::core::mem::transmute(RsvdP3) };
            RsvdP3 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let VcEnable: u32 = unsafe { ::core::mem::transmute(VcEnable) };
            VcEnable as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type VIRTUAL_RESOURCE_CONTROL = _VIRTUAL_RESOURCE_CONTROL;
pub type PVIRTUAL_RESOURCE_CONTROL = *mut _VIRTUAL_RESOURCE_CONTROL;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VIRTUAL_RESOURCE_STATUS {
    pub __bindgen_anon_1: _VIRTUAL_RESOURCE_STATUS__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VIRTUAL_RESOURCE_STATUS__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _VIRTUAL_RESOURCE_STATUS__bindgen_ty_1 {
    #[inline]
    pub fn PortArbitrationTableStatus(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PortArbitrationTableStatus(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PortArbitrationTableStatus_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PortArbitrationTableStatus_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VcNegotiationPending(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_VcNegotiationPending(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VcNegotiationPending_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_VcNegotiationPending_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RsvdZ(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 14u8) as u16) }
    }
    #[inline]
    pub fn set_RsvdZ(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RsvdZ_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                14u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_RsvdZ_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                14u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PortArbitrationTableStatus: USHORT,
        VcNegotiationPending: USHORT,
        RsvdZ: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PortArbitrationTableStatus: u16 =
                unsafe { ::core::mem::transmute(PortArbitrationTableStatus) };
            PortArbitrationTableStatus as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let VcNegotiationPending: u16 = unsafe { ::core::mem::transmute(VcNegotiationPending) };
            VcNegotiationPending as u64
        });
        __bindgen_bitfield_unit.set(2usize, 14u8, {
            let RsvdZ: u16 = unsafe { ::core::mem::transmute(RsvdZ) };
            RsvdZ as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type VIRTUAL_RESOURCE_STATUS = _VIRTUAL_RESOURCE_STATUS;
pub type PVIRTUAL_RESOURCE_STATUS = *mut _VIRTUAL_RESOURCE_STATUS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VIRTUAL_RESOURCE {
    pub Capability: VIRTUAL_RESOURCE_CAPABILITY,
    pub Control: VIRTUAL_RESOURCE_CONTROL,
    pub RsvdP: USHORT,
    pub Status: VIRTUAL_RESOURCE_STATUS,
}
pub type VIRTUAL_RESOURCE = _VIRTUAL_RESOURCE;
pub type PVIRTUAL_RESOURCE = *mut _VIRTUAL_RESOURCE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_VIRTUAL_CHANNEL_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub Capabilities1: VIRTUAL_CHANNEL_CAPABILITIES1,
    pub Capabilities2: VIRTUAL_CHANNEL_CAPABILITIES2,
    pub Control: VIRTUAL_CHANNEL_CONTROL,
    pub Status: VIRTUAL_CHANNEL_STATUS,
    pub Resource: [VIRTUAL_RESOURCE; 8usize],
}
pub type PCI_EXPRESS_VIRTUAL_CHANNEL_CAPABILITY = _PCI_EXPRESS_VIRTUAL_CHANNEL_CAPABILITY;
pub type PPCI_EXPRESS_VIRTUAL_CHANNEL_CAPABILITY = *mut _PCI_EXPRESS_VIRTUAL_CHANNEL_CAPABILITY;
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_ATS_CAPABILITY_REGISTER {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_ATS_CAPABILITY_REGISTER {
    #[inline]
    pub fn InvalidateQueueDepth(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_InvalidateQueueDepth(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InvalidateQueueDepth_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_InvalidateQueueDepth_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PageAlignedRequest(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PageAlignedRequest(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PageAlignedRequest_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PageAlignedRequest_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn GlobalInvalidateSupported(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_GlobalInvalidateSupported(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn GlobalInvalidateSupported_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_GlobalInvalidateSupported_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RelaxedOrderingSupported(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RelaxedOrderingSupported(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RelaxedOrderingSupported_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_RelaxedOrderingSupported_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        InvalidateQueueDepth: USHORT,
        PageAlignedRequest: USHORT,
        GlobalInvalidateSupported: USHORT,
        RelaxedOrderingSupported: USHORT,
        Reserved: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let InvalidateQueueDepth: u16 = unsafe { ::core::mem::transmute(InvalidateQueueDepth) };
            InvalidateQueueDepth as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PageAlignedRequest: u16 = unsafe { ::core::mem::transmute(PageAlignedRequest) };
            PageAlignedRequest as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let GlobalInvalidateSupported: u16 =
                unsafe { ::core::mem::transmute(GlobalInvalidateSupported) };
            GlobalInvalidateSupported as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let RelaxedOrderingSupported: u16 =
                unsafe { ::core::mem::transmute(RelaxedOrderingSupported) };
            RelaxedOrderingSupported as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let Reserved: u16 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_ATS_CAPABILITY_REGISTER = _PCI_EXPRESS_ATS_CAPABILITY_REGISTER;
pub type PPCI_EXPRESS_ATS_CAPABILITY_REGISTER = *mut _PCI_EXPRESS_ATS_CAPABILITY_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_ATS_CONTROL_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_ATS_CONTROL_REGISTER__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_ATS_CONTROL_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_ATS_CONTROL_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn SmallestTransactionUnit(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_SmallestTransactionUnit(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SmallestTransactionUnit_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_SmallestTransactionUnit_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 10u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                10u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                10u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Enable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Enable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Enable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Enable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SmallestTransactionUnit: USHORT,
        Reserved: USHORT,
        Enable: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let SmallestTransactionUnit: u16 =
                unsafe { ::core::mem::transmute(SmallestTransactionUnit) };
            SmallestTransactionUnit as u64
        });
        __bindgen_bitfield_unit.set(5usize, 10u8, {
            let Reserved: u16 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let Enable: u16 = unsafe { ::core::mem::transmute(Enable) };
            Enable as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_ATS_CONTROL_REGISTER = _PCI_EXPRESS_ATS_CONTROL_REGISTER;
pub type PPCI_EXPRESS_ATS_CONTROL_REGISTER = *mut _PCI_EXPRESS_ATS_CONTROL_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_ATS_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub Capability: PCI_EXPRESS_ATS_CAPABILITY_REGISTER,
    pub Control: PCI_EXPRESS_ATS_CONTROL_REGISTER,
}
pub type PCI_EXPRESS_ATS_CAPABILITY = _PCI_EXPRESS_ATS_CAPABILITY;
pub type PPCI_EXPRESS_ATS_CAPABILITY = *mut _PCI_EXPRESS_ATS_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_PASID_CAPABILITY_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_PASID_CAPABILITY_REGISTER__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_PASID_CAPABILITY_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_PASID_CAPABILITY_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn Rsvd(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ExecutePermissionSupported(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ExecutePermissionSupported(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ExecutePermissionSupported_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ExecutePermissionSupported_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PrivilegedModeSupported(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PrivilegedModeSupported(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PrivilegedModeSupported_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PrivilegedModeSupported_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd2(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd2_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd2_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MaxPASIDWidth(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_MaxPASIDWidth(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MaxPASIDWidth_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_MaxPASIDWidth_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd3(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd3(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd3_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd3_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Rsvd: USHORT,
        ExecutePermissionSupported: USHORT,
        PrivilegedModeSupported: USHORT,
        Rsvd2: USHORT,
        MaxPASIDWidth: USHORT,
        Rsvd3: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Rsvd: u16 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ExecutePermissionSupported: u16 =
                unsafe { ::core::mem::transmute(ExecutePermissionSupported) };
            ExecutePermissionSupported as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PrivilegedModeSupported: u16 =
                unsafe { ::core::mem::transmute(PrivilegedModeSupported) };
            PrivilegedModeSupported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let Rsvd2: u16 = unsafe { ::core::mem::transmute(Rsvd2) };
            Rsvd2 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let MaxPASIDWidth: u16 = unsafe { ::core::mem::transmute(MaxPASIDWidth) };
            MaxPASIDWidth as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let Rsvd3: u16 = unsafe { ::core::mem::transmute(Rsvd3) };
            Rsvd3 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_PASID_CAPABILITY_REGISTER = _PCI_EXPRESS_PASID_CAPABILITY_REGISTER;
pub type PPCI_EXPRESS_PASID_CAPABILITY_REGISTER = *mut _PCI_EXPRESS_PASID_CAPABILITY_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_PASID_CONTROL_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_PASID_CONTROL_REGISTER__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_PASID_CONTROL_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_PASID_CONTROL_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn PASIDEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PASIDEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PASIDEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PASIDEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ExecutePermissionEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ExecutePermissionEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ExecutePermissionEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ExecutePermissionEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PrivilegedModeEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PrivilegedModeEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PrivilegedModeEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PrivilegedModeEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 13u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                13u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                13u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PASIDEnable: USHORT,
        ExecutePermissionEnable: USHORT,
        PrivilegedModeEnable: USHORT,
        Rsvd: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PASIDEnable: u16 = unsafe { ::core::mem::transmute(PASIDEnable) };
            PASIDEnable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ExecutePermissionEnable: u16 =
                unsafe { ::core::mem::transmute(ExecutePermissionEnable) };
            ExecutePermissionEnable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PrivilegedModeEnable: u16 = unsafe { ::core::mem::transmute(PrivilegedModeEnable) };
            PrivilegedModeEnable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 13u8, {
            let Rsvd: u16 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_PASID_CONTROL_REGISTER = _PCI_EXPRESS_PASID_CONTROL_REGISTER;
pub type PPCI_EXPRESS_PASID_CONTROL_REGISTER = *mut _PCI_EXPRESS_PASID_CONTROL_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_PASID_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub Capability: PCI_EXPRESS_PASID_CAPABILITY_REGISTER,
    pub Control: PCI_EXPRESS_PASID_CONTROL_REGISTER,
}
pub type PCI_EXPRESS_PASID_CAPABILITY = _PCI_EXPRESS_PASID_CAPABILITY;
pub type PPCI_EXPRESS_PASID_CAPABILITY = *mut _PCI_EXPRESS_PASID_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_PRI_STATUS_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_PRI_STATUS_REGISTER__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_PRI_STATUS_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_PRI_STATUS_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn ResponseFailure(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ResponseFailure(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ResponseFailure_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ResponseFailure_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UnexpectedPageRequestGroupIndex(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UnexpectedPageRequestGroupIndex(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UnexpectedPageRequestGroupIndex_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_UnexpectedPageRequestGroupIndex_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                6u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Stopped(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Stopped(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Stopped_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Stopped_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd2(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd2_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                6u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd2_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PrgResponsePasidRequired(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PrgResponsePasidRequired(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PrgResponsePasidRequired_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PrgResponsePasidRequired_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ResponseFailure: USHORT,
        UnexpectedPageRequestGroupIndex: USHORT,
        Rsvd: USHORT,
        Stopped: USHORT,
        Rsvd2: USHORT,
        PrgResponsePasidRequired: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ResponseFailure: u16 = unsafe { ::core::mem::transmute(ResponseFailure) };
            ResponseFailure as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let UnexpectedPageRequestGroupIndex: u16 =
                unsafe { ::core::mem::transmute(UnexpectedPageRequestGroupIndex) };
            UnexpectedPageRequestGroupIndex as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let Rsvd: u16 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Stopped: u16 = unsafe { ::core::mem::transmute(Stopped) };
            Stopped as u64
        });
        __bindgen_bitfield_unit.set(9usize, 6u8, {
            let Rsvd2: u16 = unsafe { ::core::mem::transmute(Rsvd2) };
            Rsvd2 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let PrgResponsePasidRequired: u16 =
                unsafe { ::core::mem::transmute(PrgResponsePasidRequired) };
            PrgResponsePasidRequired as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_PRI_STATUS_REGISTER = _PCI_EXPRESS_PRI_STATUS_REGISTER;
pub type PPCI_EXPRESS_PRI_STATUS_REGISTER = *mut _PCI_EXPRESS_PRI_STATUS_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_PRI_CONTROL_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_PRI_CONTROL_REGISTER__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_PRI_CONTROL_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_PRI_CONTROL_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn Enable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Enable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Enable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Enable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reset(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Reset(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reset_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reset_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 14u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                14u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                14u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Enable: USHORT,
        Reset: USHORT,
        Rsvd: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Enable: u16 = unsafe { ::core::mem::transmute(Enable) };
            Enable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Reset: u16 = unsafe { ::core::mem::transmute(Reset) };
            Reset as u64
        });
        __bindgen_bitfield_unit.set(2usize, 14u8, {
            let Rsvd: u16 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_PRI_CONTROL_REGISTER = _PCI_EXPRESS_PRI_CONTROL_REGISTER;
pub type PPCI_EXPRESS_PRI_CONTROL_REGISTER = *mut _PCI_EXPRESS_PRI_CONTROL_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_PRI_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub Control: PCI_EXPRESS_PRI_CONTROL_REGISTER,
    pub Status: PCI_EXPRESS_PRI_STATUS_REGISTER,
    pub PRCapacity: ULONG,
    pub PRAllocation: ULONG,
}
pub type PCI_EXPRESS_PRI_CAPABILITY = _PCI_EXPRESS_PRI_CAPABILITY;
pub type PPCI_EXPRESS_PRI_CAPABILITY = *mut _PCI_EXPRESS_PRI_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_PTM_CAPABILITY_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_PTM_CAPABILITY_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_PTM_CAPABILITY_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_PTM_CAPABILITY_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn RequesterCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RequesterCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RequesterCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RequesterCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ResponderCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ResponderCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ResponderCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ResponderCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RootCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RootCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RootCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RootCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LocalGranularity(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_LocalGranularity(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LocalGranularity_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_LocalGranularity_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RequesterCapable: ULONG,
        ResponderCapable: ULONG,
        RootCapable: ULONG,
        Rsvd: ULONG,
        LocalGranularity: ULONG,
        Rsvd2: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let RequesterCapable: u32 = unsafe { ::core::mem::transmute(RequesterCapable) };
            RequesterCapable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ResponderCapable: u32 = unsafe { ::core::mem::transmute(ResponderCapable) };
            ResponderCapable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RootCapable: u32 = unsafe { ::core::mem::transmute(RootCapable) };
            RootCapable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let Rsvd: u32 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let LocalGranularity: u32 = unsafe { ::core::mem::transmute(LocalGranularity) };
            LocalGranularity as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let Rsvd2: u32 = unsafe { ::core::mem::transmute(Rsvd2) };
            Rsvd2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_PTM_CAPABILITY_REGISTER = _PCI_EXPRESS_PTM_CAPABILITY_REGISTER;
pub type PPCI_EXPRESS_PTM_CAPABILITY_REGISTER = *mut _PCI_EXPRESS_PTM_CAPABILITY_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_PTM_CONTROL_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_PTM_CONTROL_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_PTM_CONTROL_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_PTM_CONTROL_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn Enable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Enable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Enable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Enable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RootSelect(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RootSelect(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RootSelect_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RootSelect_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EffectiveGranularity(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_EffectiveGranularity(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EffectiveGranularity_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_EffectiveGranularity_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Enable: ULONG,
        RootSelect: ULONG,
        Rsvd: ULONG,
        EffectiveGranularity: ULONG,
        Rsvd2: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Enable: u32 = unsafe { ::core::mem::transmute(Enable) };
            Enable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let RootSelect: u32 = unsafe { ::core::mem::transmute(RootSelect) };
            RootSelect as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let Rsvd: u32 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let EffectiveGranularity: u32 = unsafe { ::core::mem::transmute(EffectiveGranularity) };
            EffectiveGranularity as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let Rsvd2: u32 = unsafe { ::core::mem::transmute(Rsvd2) };
            Rsvd2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_PTM_CONTROL_REGISTER = _PCI_EXPRESS_PTM_CONTROL_REGISTER;
pub type PPCI_EXPRESS_PTM_CONTROL_REGISTER = *mut _PCI_EXPRESS_PTM_CONTROL_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_PTM_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub PtmCapability: PCI_EXPRESS_PTM_CAPABILITY_REGISTER,
    pub PtmControl: PCI_EXPRESS_PTM_CONTROL_REGISTER,
}
pub type PCI_EXPRESS_PTM_CAPABILITY = _PCI_EXPRESS_PTM_CAPABILITY;
pub type PPCI_EXPRESS_PTM_CAPABILITY = *mut _PCI_EXPRESS_PTM_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS {
    pub __bindgen_anon_1: _PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS__bindgen_ty_1 {
    #[inline]
    pub fn Undefined(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Undefined(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Undefined_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Undefined_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DataLinkProtocolError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DataLinkProtocolError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DataLinkProtocolError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DataLinkProtocolError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SurpriseDownError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SurpriseDownError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SurpriseDownError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SurpriseDownError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PoisonedTLP(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PoisonedTLP(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PoisonedTLP_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PoisonedTLP_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FlowControlProtocolError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FlowControlProtocolError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FlowControlProtocolError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FlowControlProtocolError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CompletionTimeout(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CompletionTimeout(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CompletionTimeout_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CompletionTimeout_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CompleterAbort(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CompleterAbort(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CompleterAbort_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CompleterAbort_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UnexpectedCompletion(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UnexpectedCompletion(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UnexpectedCompletion_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UnexpectedCompletion_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReceiverOverflow(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReceiverOverflow(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReceiverOverflow_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReceiverOverflow_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MalformedTLP(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MalformedTLP(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MalformedTLP_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MalformedTLP_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ECRCError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ECRCError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ECRCError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ECRCError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UnsupportedRequestError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UnsupportedRequestError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UnsupportedRequestError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UnsupportedRequestError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AcsViolation(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AcsViolation(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AcsViolation_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AcsViolation_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableInternalError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableInternalError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableInternalError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableInternalError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MCBlockedTlp(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MCBlockedTlp(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MCBlockedTlp_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MCBlockedTlp_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AtomicOpEgressBlocked(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AtomicOpEgressBlocked(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AtomicOpEgressBlocked_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AtomicOpEgressBlocked_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TlpPrefixBlocked(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TlpPrefixBlocked(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TlpPrefixBlocked_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_TlpPrefixBlocked_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved3(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved3(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved3_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved3_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Undefined: ULONG,
        Reserved1: ULONG,
        DataLinkProtocolError: ULONG,
        SurpriseDownError: ULONG,
        Reserved2: ULONG,
        PoisonedTLP: ULONG,
        FlowControlProtocolError: ULONG,
        CompletionTimeout: ULONG,
        CompleterAbort: ULONG,
        UnexpectedCompletion: ULONG,
        ReceiverOverflow: ULONG,
        MalformedTLP: ULONG,
        ECRCError: ULONG,
        UnsupportedRequestError: ULONG,
        AcsViolation: ULONG,
        UncorrectableInternalError: ULONG,
        MCBlockedTlp: ULONG,
        AtomicOpEgressBlocked: ULONG,
        TlpPrefixBlocked: ULONG,
        Reserved3: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Undefined: u32 = unsafe { ::core::mem::transmute(Undefined) };
            Undefined as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let DataLinkProtocolError: u32 =
                unsafe { ::core::mem::transmute(DataLinkProtocolError) };
            DataLinkProtocolError as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let SurpriseDownError: u32 = unsafe { ::core::mem::transmute(SurpriseDownError) };
            SurpriseDownError as u64
        });
        __bindgen_bitfield_unit.set(6usize, 6u8, {
            let Reserved2: u32 = unsafe { ::core::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let PoisonedTLP: u32 = unsafe { ::core::mem::transmute(PoisonedTLP) };
            PoisonedTLP as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let FlowControlProtocolError: u32 =
                unsafe { ::core::mem::transmute(FlowControlProtocolError) };
            FlowControlProtocolError as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let CompletionTimeout: u32 = unsafe { ::core::mem::transmute(CompletionTimeout) };
            CompletionTimeout as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let CompleterAbort: u32 = unsafe { ::core::mem::transmute(CompleterAbort) };
            CompleterAbort as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let UnexpectedCompletion: u32 = unsafe { ::core::mem::transmute(UnexpectedCompletion) };
            UnexpectedCompletion as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let ReceiverOverflow: u32 = unsafe { ::core::mem::transmute(ReceiverOverflow) };
            ReceiverOverflow as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let MalformedTLP: u32 = unsafe { ::core::mem::transmute(MalformedTLP) };
            MalformedTLP as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ECRCError: u32 = unsafe { ::core::mem::transmute(ECRCError) };
            ECRCError as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let UnsupportedRequestError: u32 =
                unsafe { ::core::mem::transmute(UnsupportedRequestError) };
            UnsupportedRequestError as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let AcsViolation: u32 = unsafe { ::core::mem::transmute(AcsViolation) };
            AcsViolation as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let UncorrectableInternalError: u32 =
                unsafe { ::core::mem::transmute(UncorrectableInternalError) };
            UncorrectableInternalError as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let MCBlockedTlp: u32 = unsafe { ::core::mem::transmute(MCBlockedTlp) };
            MCBlockedTlp as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let AtomicOpEgressBlocked: u32 =
                unsafe { ::core::mem::transmute(AtomicOpEgressBlocked) };
            AtomicOpEgressBlocked as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let TlpPrefixBlocked: u32 = unsafe { ::core::mem::transmute(TlpPrefixBlocked) };
            TlpPrefixBlocked as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let Reserved3: u32 = unsafe { ::core::mem::transmute(Reserved3) };
            Reserved3 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS = _PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS;
pub type PPCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS = *mut _PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK {
    pub __bindgen_anon_1: _PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK__bindgen_ty_1 {
    #[inline]
    pub fn Undefined(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Undefined(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Undefined_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Undefined_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DataLinkProtocolError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DataLinkProtocolError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DataLinkProtocolError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DataLinkProtocolError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SurpriseDownError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SurpriseDownError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SurpriseDownError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SurpriseDownError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PoisonedTLP(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PoisonedTLP(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PoisonedTLP_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PoisonedTLP_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FlowControlProtocolError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FlowControlProtocolError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FlowControlProtocolError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FlowControlProtocolError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CompletionTimeout(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CompletionTimeout(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CompletionTimeout_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CompletionTimeout_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CompleterAbort(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CompleterAbort(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CompleterAbort_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CompleterAbort_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UnexpectedCompletion(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UnexpectedCompletion(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UnexpectedCompletion_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UnexpectedCompletion_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReceiverOverflow(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReceiverOverflow(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReceiverOverflow_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReceiverOverflow_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MalformedTLP(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MalformedTLP(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MalformedTLP_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MalformedTLP_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ECRCError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ECRCError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ECRCError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ECRCError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UnsupportedRequestError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UnsupportedRequestError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UnsupportedRequestError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UnsupportedRequestError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AcsViolation(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AcsViolation(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AcsViolation_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AcsViolation_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableInternalError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableInternalError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableInternalError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableInternalError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MCBlockedTlp(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MCBlockedTlp(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MCBlockedTlp_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MCBlockedTlp_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AtomicOpEgressBlocked(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AtomicOpEgressBlocked(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AtomicOpEgressBlocked_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AtomicOpEgressBlocked_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TlpPrefixBlocked(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TlpPrefixBlocked(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TlpPrefixBlocked_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_TlpPrefixBlocked_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved3(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved3(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved3_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved3_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Undefined: ULONG,
        Reserved1: ULONG,
        DataLinkProtocolError: ULONG,
        SurpriseDownError: ULONG,
        Reserved2: ULONG,
        PoisonedTLP: ULONG,
        FlowControlProtocolError: ULONG,
        CompletionTimeout: ULONG,
        CompleterAbort: ULONG,
        UnexpectedCompletion: ULONG,
        ReceiverOverflow: ULONG,
        MalformedTLP: ULONG,
        ECRCError: ULONG,
        UnsupportedRequestError: ULONG,
        AcsViolation: ULONG,
        UncorrectableInternalError: ULONG,
        MCBlockedTlp: ULONG,
        AtomicOpEgressBlocked: ULONG,
        TlpPrefixBlocked: ULONG,
        Reserved3: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Undefined: u32 = unsafe { ::core::mem::transmute(Undefined) };
            Undefined as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let DataLinkProtocolError: u32 =
                unsafe { ::core::mem::transmute(DataLinkProtocolError) };
            DataLinkProtocolError as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let SurpriseDownError: u32 = unsafe { ::core::mem::transmute(SurpriseDownError) };
            SurpriseDownError as u64
        });
        __bindgen_bitfield_unit.set(6usize, 6u8, {
            let Reserved2: u32 = unsafe { ::core::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let PoisonedTLP: u32 = unsafe { ::core::mem::transmute(PoisonedTLP) };
            PoisonedTLP as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let FlowControlProtocolError: u32 =
                unsafe { ::core::mem::transmute(FlowControlProtocolError) };
            FlowControlProtocolError as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let CompletionTimeout: u32 = unsafe { ::core::mem::transmute(CompletionTimeout) };
            CompletionTimeout as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let CompleterAbort: u32 = unsafe { ::core::mem::transmute(CompleterAbort) };
            CompleterAbort as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let UnexpectedCompletion: u32 = unsafe { ::core::mem::transmute(UnexpectedCompletion) };
            UnexpectedCompletion as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let ReceiverOverflow: u32 = unsafe { ::core::mem::transmute(ReceiverOverflow) };
            ReceiverOverflow as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let MalformedTLP: u32 = unsafe { ::core::mem::transmute(MalformedTLP) };
            MalformedTLP as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ECRCError: u32 = unsafe { ::core::mem::transmute(ECRCError) };
            ECRCError as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let UnsupportedRequestError: u32 =
                unsafe { ::core::mem::transmute(UnsupportedRequestError) };
            UnsupportedRequestError as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let AcsViolation: u32 = unsafe { ::core::mem::transmute(AcsViolation) };
            AcsViolation as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let UncorrectableInternalError: u32 =
                unsafe { ::core::mem::transmute(UncorrectableInternalError) };
            UncorrectableInternalError as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let MCBlockedTlp: u32 = unsafe { ::core::mem::transmute(MCBlockedTlp) };
            MCBlockedTlp as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let AtomicOpEgressBlocked: u32 =
                unsafe { ::core::mem::transmute(AtomicOpEgressBlocked) };
            AtomicOpEgressBlocked as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let TlpPrefixBlocked: u32 = unsafe { ::core::mem::transmute(TlpPrefixBlocked) };
            TlpPrefixBlocked as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let Reserved3: u32 = unsafe { ::core::mem::transmute(Reserved3) };
            Reserved3 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK = _PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK;
pub type PPCI_EXPRESS_UNCORRECTABLE_ERROR_MASK = *mut _PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY {
    pub __bindgen_anon_1: _PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY__bindgen_ty_1 {
    #[inline]
    pub fn Undefined(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Undefined(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Undefined_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Undefined_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DataLinkProtocolError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DataLinkProtocolError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DataLinkProtocolError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DataLinkProtocolError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SurpriseDownError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SurpriseDownError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SurpriseDownError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SurpriseDownError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PoisonedTLP(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PoisonedTLP(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PoisonedTLP_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PoisonedTLP_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FlowControlProtocolError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FlowControlProtocolError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FlowControlProtocolError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FlowControlProtocolError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CompletionTimeout(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CompletionTimeout(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CompletionTimeout_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CompletionTimeout_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CompleterAbort(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CompleterAbort(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CompleterAbort_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CompleterAbort_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UnexpectedCompletion(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UnexpectedCompletion(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UnexpectedCompletion_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UnexpectedCompletion_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReceiverOverflow(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReceiverOverflow(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReceiverOverflow_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReceiverOverflow_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MalformedTLP(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MalformedTLP(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MalformedTLP_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MalformedTLP_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ECRCError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ECRCError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ECRCError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ECRCError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UnsupportedRequestError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UnsupportedRequestError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UnsupportedRequestError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UnsupportedRequestError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AcsViolation(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AcsViolation(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AcsViolation_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AcsViolation_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableInternalError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableInternalError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableInternalError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableInternalError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MCBlockedTlp(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MCBlockedTlp(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MCBlockedTlp_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MCBlockedTlp_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AtomicOpEgressBlocked(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AtomicOpEgressBlocked(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AtomicOpEgressBlocked_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AtomicOpEgressBlocked_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TlpPrefixBlocked(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TlpPrefixBlocked(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TlpPrefixBlocked_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_TlpPrefixBlocked_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved3(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved3(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved3_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved3_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Undefined: ULONG,
        Reserved1: ULONG,
        DataLinkProtocolError: ULONG,
        SurpriseDownError: ULONG,
        Reserved2: ULONG,
        PoisonedTLP: ULONG,
        FlowControlProtocolError: ULONG,
        CompletionTimeout: ULONG,
        CompleterAbort: ULONG,
        UnexpectedCompletion: ULONG,
        ReceiverOverflow: ULONG,
        MalformedTLP: ULONG,
        ECRCError: ULONG,
        UnsupportedRequestError: ULONG,
        AcsViolation: ULONG,
        UncorrectableInternalError: ULONG,
        MCBlockedTlp: ULONG,
        AtomicOpEgressBlocked: ULONG,
        TlpPrefixBlocked: ULONG,
        Reserved3: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Undefined: u32 = unsafe { ::core::mem::transmute(Undefined) };
            Undefined as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let DataLinkProtocolError: u32 =
                unsafe { ::core::mem::transmute(DataLinkProtocolError) };
            DataLinkProtocolError as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let SurpriseDownError: u32 = unsafe { ::core::mem::transmute(SurpriseDownError) };
            SurpriseDownError as u64
        });
        __bindgen_bitfield_unit.set(6usize, 6u8, {
            let Reserved2: u32 = unsafe { ::core::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let PoisonedTLP: u32 = unsafe { ::core::mem::transmute(PoisonedTLP) };
            PoisonedTLP as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let FlowControlProtocolError: u32 =
                unsafe { ::core::mem::transmute(FlowControlProtocolError) };
            FlowControlProtocolError as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let CompletionTimeout: u32 = unsafe { ::core::mem::transmute(CompletionTimeout) };
            CompletionTimeout as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let CompleterAbort: u32 = unsafe { ::core::mem::transmute(CompleterAbort) };
            CompleterAbort as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let UnexpectedCompletion: u32 = unsafe { ::core::mem::transmute(UnexpectedCompletion) };
            UnexpectedCompletion as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let ReceiverOverflow: u32 = unsafe { ::core::mem::transmute(ReceiverOverflow) };
            ReceiverOverflow as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let MalformedTLP: u32 = unsafe { ::core::mem::transmute(MalformedTLP) };
            MalformedTLP as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ECRCError: u32 = unsafe { ::core::mem::transmute(ECRCError) };
            ECRCError as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let UnsupportedRequestError: u32 =
                unsafe { ::core::mem::transmute(UnsupportedRequestError) };
            UnsupportedRequestError as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let AcsViolation: u32 = unsafe { ::core::mem::transmute(AcsViolation) };
            AcsViolation as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let UncorrectableInternalError: u32 =
                unsafe { ::core::mem::transmute(UncorrectableInternalError) };
            UncorrectableInternalError as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let MCBlockedTlp: u32 = unsafe { ::core::mem::transmute(MCBlockedTlp) };
            MCBlockedTlp as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let AtomicOpEgressBlocked: u32 =
                unsafe { ::core::mem::transmute(AtomicOpEgressBlocked) };
            AtomicOpEgressBlocked as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let TlpPrefixBlocked: u32 = unsafe { ::core::mem::transmute(TlpPrefixBlocked) };
            TlpPrefixBlocked as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let Reserved3: u32 = unsafe { ::core::mem::transmute(Reserved3) };
            Reserved3 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY = _PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY;
pub type PPCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY = *mut _PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_CORRECTABLE_ERROR_STATUS {
    pub __bindgen_anon_1: _PCI_EXPRESS_CORRECTABLE_ERROR_STATUS__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_CORRECTABLE_ERROR_STATUS__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_CORRECTABLE_ERROR_STATUS__bindgen_ty_1 {
    #[inline]
    pub fn ReceiverError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReceiverError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReceiverError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReceiverError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn BadTLP(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BadTLP(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn BadTLP_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_BadTLP_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn BadDLLP(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BadDLLP(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn BadDLLP_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_BadDLLP_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReplayNumRollover(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReplayNumRollover(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReplayNumRollover_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReplayNumRollover_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReplayTimerTimeout(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReplayTimerTimeout(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReplayTimerTimeout_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReplayTimerTimeout_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AdvisoryNonFatalError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AdvisoryNonFatalError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AdvisoryNonFatalError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AdvisoryNonFatalError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CorrectedInternalError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CorrectedInternalError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CorrectedInternalError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CorrectedInternalError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn HeaderLogOverflow(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HeaderLogOverflow(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn HeaderLogOverflow_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_HeaderLogOverflow_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved3(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved3(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved3_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved3_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ReceiverError: ULONG,
        Reserved1: ULONG,
        BadTLP: ULONG,
        BadDLLP: ULONG,
        ReplayNumRollover: ULONG,
        Reserved2: ULONG,
        ReplayTimerTimeout: ULONG,
        AdvisoryNonFatalError: ULONG,
        CorrectedInternalError: ULONG,
        HeaderLogOverflow: ULONG,
        Reserved3: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ReceiverError: u32 = unsafe { ::core::mem::transmute(ReceiverError) };
            ReceiverError as u64
        });
        __bindgen_bitfield_unit.set(1usize, 5u8, {
            let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let BadTLP: u32 = unsafe { ::core::mem::transmute(BadTLP) };
            BadTLP as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let BadDLLP: u32 = unsafe { ::core::mem::transmute(BadDLLP) };
            BadDLLP as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ReplayNumRollover: u32 = unsafe { ::core::mem::transmute(ReplayNumRollover) };
            ReplayNumRollover as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let Reserved2: u32 = unsafe { ::core::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ReplayTimerTimeout: u32 = unsafe { ::core::mem::transmute(ReplayTimerTimeout) };
            ReplayTimerTimeout as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let AdvisoryNonFatalError: u32 =
                unsafe { ::core::mem::transmute(AdvisoryNonFatalError) };
            AdvisoryNonFatalError as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let CorrectedInternalError: u32 =
                unsafe { ::core::mem::transmute(CorrectedInternalError) };
            CorrectedInternalError as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let HeaderLogOverflow: u32 = unsafe { ::core::mem::transmute(HeaderLogOverflow) };
            HeaderLogOverflow as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let Reserved3: u32 = unsafe { ::core::mem::transmute(Reserved3) };
            Reserved3 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_CORRECTABLE_ERROR_STATUS = _PCI_EXPRESS_CORRECTABLE_ERROR_STATUS;
pub type PPCI_CORRECTABLE_ERROR_STATUS = *mut _PCI_EXPRESS_CORRECTABLE_ERROR_STATUS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_CORRECTABLE_ERROR_MASK {
    pub __bindgen_anon_1: _PCI_EXPRESS_CORRECTABLE_ERROR_MASK__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_CORRECTABLE_ERROR_MASK__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_CORRECTABLE_ERROR_MASK__bindgen_ty_1 {
    #[inline]
    pub fn ReceiverError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReceiverError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReceiverError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReceiverError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn BadTLP(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BadTLP(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn BadTLP_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_BadTLP_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn BadDLLP(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BadDLLP(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn BadDLLP_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_BadDLLP_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReplayNumRollover(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReplayNumRollover(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReplayNumRollover_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReplayNumRollover_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReplayTimerTimeout(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReplayTimerTimeout(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReplayTimerTimeout_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReplayTimerTimeout_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AdvisoryNonFatalError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AdvisoryNonFatalError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AdvisoryNonFatalError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AdvisoryNonFatalError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CorrectedInternalError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CorrectedInternalError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CorrectedInternalError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CorrectedInternalError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn HeaderLogOverflow(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HeaderLogOverflow(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn HeaderLogOverflow_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_HeaderLogOverflow_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved3(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved3(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved3_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved3_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ReceiverError: ULONG,
        Reserved1: ULONG,
        BadTLP: ULONG,
        BadDLLP: ULONG,
        ReplayNumRollover: ULONG,
        Reserved2: ULONG,
        ReplayTimerTimeout: ULONG,
        AdvisoryNonFatalError: ULONG,
        CorrectedInternalError: ULONG,
        HeaderLogOverflow: ULONG,
        Reserved3: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ReceiverError: u32 = unsafe { ::core::mem::transmute(ReceiverError) };
            ReceiverError as u64
        });
        __bindgen_bitfield_unit.set(1usize, 5u8, {
            let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let BadTLP: u32 = unsafe { ::core::mem::transmute(BadTLP) };
            BadTLP as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let BadDLLP: u32 = unsafe { ::core::mem::transmute(BadDLLP) };
            BadDLLP as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ReplayNumRollover: u32 = unsafe { ::core::mem::transmute(ReplayNumRollover) };
            ReplayNumRollover as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let Reserved2: u32 = unsafe { ::core::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ReplayTimerTimeout: u32 = unsafe { ::core::mem::transmute(ReplayTimerTimeout) };
            ReplayTimerTimeout as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let AdvisoryNonFatalError: u32 =
                unsafe { ::core::mem::transmute(AdvisoryNonFatalError) };
            AdvisoryNonFatalError as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let CorrectedInternalError: u32 =
                unsafe { ::core::mem::transmute(CorrectedInternalError) };
            CorrectedInternalError as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let HeaderLogOverflow: u32 = unsafe { ::core::mem::transmute(HeaderLogOverflow) };
            HeaderLogOverflow as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let Reserved3: u32 = unsafe { ::core::mem::transmute(Reserved3) };
            Reserved3 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_CORRECTABLE_ERROR_MASK = _PCI_EXPRESS_CORRECTABLE_ERROR_MASK;
pub type PPCI_CORRECTABLE_ERROR_MASK = *mut _PCI_EXPRESS_CORRECTABLE_ERROR_MASK;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_AER_CAPABILITIES {
    pub __bindgen_anon_1: _PCI_EXPRESS_AER_CAPABILITIES__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_AER_CAPABILITIES__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_AER_CAPABILITIES__bindgen_ty_1 {
    #[inline]
    pub fn FirstErrorPointer(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_FirstErrorPointer(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FirstErrorPointer_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FirstErrorPointer_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ECRCGenerationCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ECRCGenerationCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ECRCGenerationCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ECRCGenerationCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ECRCGenerationEnable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ECRCGenerationEnable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ECRCGenerationEnable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ECRCGenerationEnable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ECRCCheckCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ECRCCheckCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ECRCCheckCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ECRCCheckCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ECRCCheckEnable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ECRCCheckEnable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ECRCCheckEnable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ECRCCheckEnable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MultipleHeaderRecordingCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MultipleHeaderRecordingCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MultipleHeaderRecordingCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MultipleHeaderRecordingCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MultipleHeaderRecordingEnable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MultipleHeaderRecordingEnable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MultipleHeaderRecordingEnable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MultipleHeaderRecordingEnable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TlpPrefixLogPresent(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TlpPrefixLogPresent(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TlpPrefixLogPresent_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_TlpPrefixLogPresent_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                20u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                20u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FirstErrorPointer: ULONG,
        ECRCGenerationCapable: ULONG,
        ECRCGenerationEnable: ULONG,
        ECRCCheckCapable: ULONG,
        ECRCCheckEnable: ULONG,
        MultipleHeaderRecordingCapable: ULONG,
        MultipleHeaderRecordingEnable: ULONG,
        TlpPrefixLogPresent: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let FirstErrorPointer: u32 = unsafe { ::core::mem::transmute(FirstErrorPointer) };
            FirstErrorPointer as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ECRCGenerationCapable: u32 =
                unsafe { ::core::mem::transmute(ECRCGenerationCapable) };
            ECRCGenerationCapable as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ECRCGenerationEnable: u32 = unsafe { ::core::mem::transmute(ECRCGenerationEnable) };
            ECRCGenerationEnable as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ECRCCheckCapable: u32 = unsafe { ::core::mem::transmute(ECRCCheckCapable) };
            ECRCCheckCapable as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ECRCCheckEnable: u32 = unsafe { ::core::mem::transmute(ECRCCheckEnable) };
            ECRCCheckEnable as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let MultipleHeaderRecordingCapable: u32 =
                unsafe { ::core::mem::transmute(MultipleHeaderRecordingCapable) };
            MultipleHeaderRecordingCapable as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let MultipleHeaderRecordingEnable: u32 =
                unsafe { ::core::mem::transmute(MultipleHeaderRecordingEnable) };
            MultipleHeaderRecordingEnable as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let TlpPrefixLogPresent: u32 = unsafe { ::core::mem::transmute(TlpPrefixLogPresent) };
            TlpPrefixLogPresent as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_AER_CAPABILITIES = _PCI_EXPRESS_AER_CAPABILITIES;
pub type PPCI_EXPRESS_AER_CAPABILITIES = *mut _PCI_EXPRESS_AER_CAPABILITIES;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_ROOT_ERROR_COMMAND {
    pub __bindgen_anon_1: _PCI_EXPRESS_ROOT_ERROR_COMMAND__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_ROOT_ERROR_COMMAND__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_ROOT_ERROR_COMMAND__bindgen_ty_1 {
    #[inline]
    pub fn CorrectableErrorReportingEnable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CorrectableErrorReportingEnable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CorrectableErrorReportingEnable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CorrectableErrorReportingEnable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NonFatalErrorReportingEnable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NonFatalErrorReportingEnable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NonFatalErrorReportingEnable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NonFatalErrorReportingEnable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FatalErrorReportingEnable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FatalErrorReportingEnable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FatalErrorReportingEnable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FatalErrorReportingEnable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                29u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                29u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CorrectableErrorReportingEnable: ULONG,
        NonFatalErrorReportingEnable: ULONG,
        FatalErrorReportingEnable: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CorrectableErrorReportingEnable: u32 =
                unsafe { ::core::mem::transmute(CorrectableErrorReportingEnable) };
            CorrectableErrorReportingEnable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let NonFatalErrorReportingEnable: u32 =
                unsafe { ::core::mem::transmute(NonFatalErrorReportingEnable) };
            NonFatalErrorReportingEnable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let FatalErrorReportingEnable: u32 =
                unsafe { ::core::mem::transmute(FatalErrorReportingEnable) };
            FatalErrorReportingEnable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_ROOT_ERROR_COMMAND = _PCI_EXPRESS_ROOT_ERROR_COMMAND;
pub type PPCI_EXPRESS_ROOT_ERROR_COMMAND = *mut _PCI_EXPRESS_ROOT_ERROR_COMMAND;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_ROOT_ERROR_STATUS {
    pub __bindgen_anon_1: _PCI_EXPRESS_ROOT_ERROR_STATUS__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_ROOT_ERROR_STATUS__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_ROOT_ERROR_STATUS__bindgen_ty_1 {
    #[inline]
    pub fn CorrectableErrorReceived(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CorrectableErrorReceived(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CorrectableErrorReceived_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CorrectableErrorReceived_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MultipleCorrectableErrorsReceived(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MultipleCorrectableErrorsReceived(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MultipleCorrectableErrorsReceived_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MultipleCorrectableErrorsReceived_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableErrorReceived(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableErrorReceived(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableErrorReceived_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableErrorReceived_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MultipleUncorrectableErrorsReceived(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MultipleUncorrectableErrorsReceived(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MultipleUncorrectableErrorsReceived_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MultipleUncorrectableErrorsReceived_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FirstUncorrectableFatal(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FirstUncorrectableFatal(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FirstUncorrectableFatal_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FirstUncorrectableFatal_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NonFatalErrorMessagesReceived(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NonFatalErrorMessagesReceived(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NonFatalErrorMessagesReceived_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NonFatalErrorMessagesReceived_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FatalErrorMessagesReceived(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FatalErrorMessagesReceived(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FatalErrorMessagesReceived_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FatalErrorMessagesReceived_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                20u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                20u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AdvancedErrorInterruptMessageNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_AdvancedErrorInterruptMessageNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AdvancedErrorInterruptMessageNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AdvancedErrorInterruptMessageNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CorrectableErrorReceived: ULONG,
        MultipleCorrectableErrorsReceived: ULONG,
        UncorrectableErrorReceived: ULONG,
        MultipleUncorrectableErrorsReceived: ULONG,
        FirstUncorrectableFatal: ULONG,
        NonFatalErrorMessagesReceived: ULONG,
        FatalErrorMessagesReceived: ULONG,
        Reserved: ULONG,
        AdvancedErrorInterruptMessageNumber: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CorrectableErrorReceived: u32 =
                unsafe { ::core::mem::transmute(CorrectableErrorReceived) };
            CorrectableErrorReceived as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let MultipleCorrectableErrorsReceived: u32 =
                unsafe { ::core::mem::transmute(MultipleCorrectableErrorsReceived) };
            MultipleCorrectableErrorsReceived as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let UncorrectableErrorReceived: u32 =
                unsafe { ::core::mem::transmute(UncorrectableErrorReceived) };
            UncorrectableErrorReceived as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let MultipleUncorrectableErrorsReceived: u32 =
                unsafe { ::core::mem::transmute(MultipleUncorrectableErrorsReceived) };
            MultipleUncorrectableErrorsReceived as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let FirstUncorrectableFatal: u32 =
                unsafe { ::core::mem::transmute(FirstUncorrectableFatal) };
            FirstUncorrectableFatal as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let NonFatalErrorMessagesReceived: u32 =
                unsafe { ::core::mem::transmute(NonFatalErrorMessagesReceived) };
            NonFatalErrorMessagesReceived as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let FatalErrorMessagesReceived: u32 =
                unsafe { ::core::mem::transmute(FatalErrorMessagesReceived) };
            FatalErrorMessagesReceived as u64
        });
        __bindgen_bitfield_unit.set(7usize, 20u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let AdvancedErrorInterruptMessageNumber: u32 =
                unsafe { ::core::mem::transmute(AdvancedErrorInterruptMessageNumber) };
            AdvancedErrorInterruptMessageNumber as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_ROOT_ERROR_STATUS = _PCI_EXPRESS_ROOT_ERROR_STATUS;
pub type PPCI_EXPRESS_ROOT_ERROR_STATUS = *mut _PCI_EXPRESS_ROOT_ERROR_STATUS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_ERROR_SOURCE_ID {
    pub __bindgen_anon_1: _PCI_EXPRESS_ERROR_SOURCE_ID__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_ERROR_SOURCE_ID__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_ERROR_SOURCE_ID__bindgen_ty_1 {
    #[inline]
    pub fn CorrectableSourceIdFun(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_CorrectableSourceIdFun(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CorrectableSourceIdFun_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_CorrectableSourceIdFun_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CorrectableSourceIdDev(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_CorrectableSourceIdDev(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CorrectableSourceIdDev_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_CorrectableSourceIdDev_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CorrectableSourceIdBus(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_CorrectableSourceIdBus(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CorrectableSourceIdBus_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_CorrectableSourceIdBus_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableSourceIdFun(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_UncorrectableSourceIdFun(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableSourceIdFun_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableSourceIdFun_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableSourceIdDev(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_UncorrectableSourceIdDev(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableSourceIdDev_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableSourceIdDev_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableSourceIdBus(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_UncorrectableSourceIdBus(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableSourceIdBus_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableSourceIdBus_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CorrectableSourceIdFun: USHORT,
        CorrectableSourceIdDev: USHORT,
        CorrectableSourceIdBus: USHORT,
        UncorrectableSourceIdFun: USHORT,
        UncorrectableSourceIdDev: USHORT,
        UncorrectableSourceIdBus: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let CorrectableSourceIdFun: u16 =
                unsafe { ::core::mem::transmute(CorrectableSourceIdFun) };
            CorrectableSourceIdFun as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let CorrectableSourceIdDev: u16 =
                unsafe { ::core::mem::transmute(CorrectableSourceIdDev) };
            CorrectableSourceIdDev as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let CorrectableSourceIdBus: u16 =
                unsafe { ::core::mem::transmute(CorrectableSourceIdBus) };
            CorrectableSourceIdBus as u64
        });
        __bindgen_bitfield_unit.set(16usize, 3u8, {
            let UncorrectableSourceIdFun: u16 =
                unsafe { ::core::mem::transmute(UncorrectableSourceIdFun) };
            UncorrectableSourceIdFun as u64
        });
        __bindgen_bitfield_unit.set(19usize, 5u8, {
            let UncorrectableSourceIdDev: u16 =
                unsafe { ::core::mem::transmute(UncorrectableSourceIdDev) };
            UncorrectableSourceIdDev as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let UncorrectableSourceIdBus: u16 =
                unsafe { ::core::mem::transmute(UncorrectableSourceIdBus) };
            UncorrectableSourceIdBus as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_ERROR_SOURCE_ID = _PCI_EXPRESS_ERROR_SOURCE_ID;
pub type PPCI_EXPRESS_ERROR_SOURCE_ID = *mut _PCI_EXPRESS_ERROR_SOURCE_ID;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS {
    pub __bindgen_anon_1: _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS__bindgen_ty_1 {
    #[inline]
    pub fn TargetAbortOnSplitCompletion(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TargetAbortOnSplitCompletion(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TargetAbortOnSplitCompletion_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_TargetAbortOnSplitCompletion_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MasterAbortOnSplitCompletion(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MasterAbortOnSplitCompletion(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MasterAbortOnSplitCompletion_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MasterAbortOnSplitCompletion_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReceivedTargetAbort(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReceivedTargetAbort(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReceivedTargetAbort_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReceivedTargetAbort_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReceivedMasterAbort(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReceivedMasterAbort(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReceivedMasterAbort_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReceivedMasterAbort_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RsvdZ(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RsvdZ(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RsvdZ_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RsvdZ_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UnexpectedSplitCompletionError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UnexpectedSplitCompletionError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UnexpectedSplitCompletionError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UnexpectedSplitCompletionError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableSplitCompletion(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableSplitCompletion(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableSplitCompletion_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableSplitCompletion_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableDataError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableDataError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableDataError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableDataError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableAttributeError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableAttributeError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableAttributeError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableAttributeError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableAddressError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableAddressError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableAddressError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableAddressError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DelayedTransactionDiscardTimerExpired(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DelayedTransactionDiscardTimerExpired(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DelayedTransactionDiscardTimerExpired_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DelayedTransactionDiscardTimerExpired_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PERRAsserted(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PERRAsserted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PERRAsserted_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PERRAsserted_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SERRAsserted(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SERRAsserted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SERRAsserted_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SERRAsserted_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn InternalBridgeError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InternalBridgeError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InternalBridgeError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_InternalBridgeError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                18u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                18u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TargetAbortOnSplitCompletion: ULONG,
        MasterAbortOnSplitCompletion: ULONG,
        ReceivedTargetAbort: ULONG,
        ReceivedMasterAbort: ULONG,
        RsvdZ: ULONG,
        UnexpectedSplitCompletionError: ULONG,
        UncorrectableSplitCompletion: ULONG,
        UncorrectableDataError: ULONG,
        UncorrectableAttributeError: ULONG,
        UncorrectableAddressError: ULONG,
        DelayedTransactionDiscardTimerExpired: ULONG,
        PERRAsserted: ULONG,
        SERRAsserted: ULONG,
        InternalBridgeError: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let TargetAbortOnSplitCompletion: u32 =
                unsafe { ::core::mem::transmute(TargetAbortOnSplitCompletion) };
            TargetAbortOnSplitCompletion as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let MasterAbortOnSplitCompletion: u32 =
                unsafe { ::core::mem::transmute(MasterAbortOnSplitCompletion) };
            MasterAbortOnSplitCompletion as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ReceivedTargetAbort: u32 = unsafe { ::core::mem::transmute(ReceivedTargetAbort) };
            ReceivedTargetAbort as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ReceivedMasterAbort: u32 = unsafe { ::core::mem::transmute(ReceivedMasterAbort) };
            ReceivedMasterAbort as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let RsvdZ: u32 = unsafe { ::core::mem::transmute(RsvdZ) };
            RsvdZ as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let UnexpectedSplitCompletionError: u32 =
                unsafe { ::core::mem::transmute(UnexpectedSplitCompletionError) };
            UnexpectedSplitCompletionError as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let UncorrectableSplitCompletion: u32 =
                unsafe { ::core::mem::transmute(UncorrectableSplitCompletion) };
            UncorrectableSplitCompletion as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let UncorrectableDataError: u32 =
                unsafe { ::core::mem::transmute(UncorrectableDataError) };
            UncorrectableDataError as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let UncorrectableAttributeError: u32 =
                unsafe { ::core::mem::transmute(UncorrectableAttributeError) };
            UncorrectableAttributeError as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let UncorrectableAddressError: u32 =
                unsafe { ::core::mem::transmute(UncorrectableAddressError) };
            UncorrectableAddressError as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let DelayedTransactionDiscardTimerExpired: u32 =
                unsafe { ::core::mem::transmute(DelayedTransactionDiscardTimerExpired) };
            DelayedTransactionDiscardTimerExpired as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let PERRAsserted: u32 = unsafe { ::core::mem::transmute(PERRAsserted) };
            PERRAsserted as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let SERRAsserted: u32 = unsafe { ::core::mem::transmute(SERRAsserted) };
            SERRAsserted as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let InternalBridgeError: u32 = unsafe { ::core::mem::transmute(InternalBridgeError) };
            InternalBridgeError as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS = _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS;
pub type PPCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS =
*mut _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK {
    pub __bindgen_anon_1: _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK__bindgen_ty_1 {
    #[inline]
    pub fn TargetAbortOnSplitCompletion(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TargetAbortOnSplitCompletion(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TargetAbortOnSplitCompletion_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_TargetAbortOnSplitCompletion_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MasterAbortOnSplitCompletion(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MasterAbortOnSplitCompletion(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MasterAbortOnSplitCompletion_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MasterAbortOnSplitCompletion_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReceivedTargetAbort(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReceivedTargetAbort(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReceivedTargetAbort_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReceivedTargetAbort_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReceivedMasterAbort(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReceivedMasterAbort(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReceivedMasterAbort_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReceivedMasterAbort_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RsvdZ(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RsvdZ(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RsvdZ_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RsvdZ_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UnexpectedSplitCompletionError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UnexpectedSplitCompletionError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UnexpectedSplitCompletionError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UnexpectedSplitCompletionError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableSplitCompletion(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableSplitCompletion(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableSplitCompletion_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableSplitCompletion_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableDataError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableDataError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableDataError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableDataError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableAttributeError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableAttributeError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableAttributeError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableAttributeError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableAddressError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableAddressError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableAddressError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableAddressError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DelayedTransactionDiscardTimerExpired(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DelayedTransactionDiscardTimerExpired(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DelayedTransactionDiscardTimerExpired_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DelayedTransactionDiscardTimerExpired_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PERRAsserted(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PERRAsserted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PERRAsserted_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PERRAsserted_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SERRAsserted(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SERRAsserted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SERRAsserted_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SERRAsserted_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn InternalBridgeError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InternalBridgeError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InternalBridgeError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_InternalBridgeError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                18u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                18u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TargetAbortOnSplitCompletion: ULONG,
        MasterAbortOnSplitCompletion: ULONG,
        ReceivedTargetAbort: ULONG,
        ReceivedMasterAbort: ULONG,
        RsvdZ: ULONG,
        UnexpectedSplitCompletionError: ULONG,
        UncorrectableSplitCompletion: ULONG,
        UncorrectableDataError: ULONG,
        UncorrectableAttributeError: ULONG,
        UncorrectableAddressError: ULONG,
        DelayedTransactionDiscardTimerExpired: ULONG,
        PERRAsserted: ULONG,
        SERRAsserted: ULONG,
        InternalBridgeError: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let TargetAbortOnSplitCompletion: u32 =
                unsafe { ::core::mem::transmute(TargetAbortOnSplitCompletion) };
            TargetAbortOnSplitCompletion as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let MasterAbortOnSplitCompletion: u32 =
                unsafe { ::core::mem::transmute(MasterAbortOnSplitCompletion) };
            MasterAbortOnSplitCompletion as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ReceivedTargetAbort: u32 = unsafe { ::core::mem::transmute(ReceivedTargetAbort) };
            ReceivedTargetAbort as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ReceivedMasterAbort: u32 = unsafe { ::core::mem::transmute(ReceivedMasterAbort) };
            ReceivedMasterAbort as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let RsvdZ: u32 = unsafe { ::core::mem::transmute(RsvdZ) };
            RsvdZ as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let UnexpectedSplitCompletionError: u32 =
                unsafe { ::core::mem::transmute(UnexpectedSplitCompletionError) };
            UnexpectedSplitCompletionError as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let UncorrectableSplitCompletion: u32 =
                unsafe { ::core::mem::transmute(UncorrectableSplitCompletion) };
            UncorrectableSplitCompletion as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let UncorrectableDataError: u32 =
                unsafe { ::core::mem::transmute(UncorrectableDataError) };
            UncorrectableDataError as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let UncorrectableAttributeError: u32 =
                unsafe { ::core::mem::transmute(UncorrectableAttributeError) };
            UncorrectableAttributeError as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let UncorrectableAddressError: u32 =
                unsafe { ::core::mem::transmute(UncorrectableAddressError) };
            UncorrectableAddressError as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let DelayedTransactionDiscardTimerExpired: u32 =
                unsafe { ::core::mem::transmute(DelayedTransactionDiscardTimerExpired) };
            DelayedTransactionDiscardTimerExpired as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let PERRAsserted: u32 = unsafe { ::core::mem::transmute(PERRAsserted) };
            PERRAsserted as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let SERRAsserted: u32 = unsafe { ::core::mem::transmute(SERRAsserted) };
            SERRAsserted as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let InternalBridgeError: u32 = unsafe { ::core::mem::transmute(InternalBridgeError) };
            InternalBridgeError as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK = _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK;
pub type PPCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK = *mut _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY {
    pub __bindgen_anon_1: _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY__bindgen_ty_1 {
    #[inline]
    pub fn TargetAbortOnSplitCompletion(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TargetAbortOnSplitCompletion(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TargetAbortOnSplitCompletion_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_TargetAbortOnSplitCompletion_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MasterAbortOnSplitCompletion(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MasterAbortOnSplitCompletion(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MasterAbortOnSplitCompletion_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MasterAbortOnSplitCompletion_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReceivedTargetAbort(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReceivedTargetAbort(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReceivedTargetAbort_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReceivedTargetAbort_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReceivedMasterAbort(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReceivedMasterAbort(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReceivedMasterAbort_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReceivedMasterAbort_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RsvdZ(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RsvdZ(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RsvdZ_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RsvdZ_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UnexpectedSplitCompletionError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UnexpectedSplitCompletionError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UnexpectedSplitCompletionError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UnexpectedSplitCompletionError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableSplitCompletion(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableSplitCompletion(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableSplitCompletion_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableSplitCompletion_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableDataError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableDataError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableDataError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableDataError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableAttributeError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableAttributeError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableAttributeError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableAttributeError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableAddressError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableAddressError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableAddressError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableAddressError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DelayedTransactionDiscardTimerExpired(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DelayedTransactionDiscardTimerExpired(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DelayedTransactionDiscardTimerExpired_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DelayedTransactionDiscardTimerExpired_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PERRAsserted(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PERRAsserted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PERRAsserted_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PERRAsserted_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SERRAsserted(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SERRAsserted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SERRAsserted_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SERRAsserted_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn InternalBridgeError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InternalBridgeError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InternalBridgeError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_InternalBridgeError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                18u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                18u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TargetAbortOnSplitCompletion: ULONG,
        MasterAbortOnSplitCompletion: ULONG,
        ReceivedTargetAbort: ULONG,
        ReceivedMasterAbort: ULONG,
        RsvdZ: ULONG,
        UnexpectedSplitCompletionError: ULONG,
        UncorrectableSplitCompletion: ULONG,
        UncorrectableDataError: ULONG,
        UncorrectableAttributeError: ULONG,
        UncorrectableAddressError: ULONG,
        DelayedTransactionDiscardTimerExpired: ULONG,
        PERRAsserted: ULONG,
        SERRAsserted: ULONG,
        InternalBridgeError: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let TargetAbortOnSplitCompletion: u32 =
                unsafe { ::core::mem::transmute(TargetAbortOnSplitCompletion) };
            TargetAbortOnSplitCompletion as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let MasterAbortOnSplitCompletion: u32 =
                unsafe { ::core::mem::transmute(MasterAbortOnSplitCompletion) };
            MasterAbortOnSplitCompletion as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ReceivedTargetAbort: u32 = unsafe { ::core::mem::transmute(ReceivedTargetAbort) };
            ReceivedTargetAbort as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ReceivedMasterAbort: u32 = unsafe { ::core::mem::transmute(ReceivedMasterAbort) };
            ReceivedMasterAbort as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let RsvdZ: u32 = unsafe { ::core::mem::transmute(RsvdZ) };
            RsvdZ as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let UnexpectedSplitCompletionError: u32 =
                unsafe { ::core::mem::transmute(UnexpectedSplitCompletionError) };
            UnexpectedSplitCompletionError as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let UncorrectableSplitCompletion: u32 =
                unsafe { ::core::mem::transmute(UncorrectableSplitCompletion) };
            UncorrectableSplitCompletion as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let UncorrectableDataError: u32 =
                unsafe { ::core::mem::transmute(UncorrectableDataError) };
            UncorrectableDataError as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let UncorrectableAttributeError: u32 =
                unsafe { ::core::mem::transmute(UncorrectableAttributeError) };
            UncorrectableAttributeError as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let UncorrectableAddressError: u32 =
                unsafe { ::core::mem::transmute(UncorrectableAddressError) };
            UncorrectableAddressError as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let DelayedTransactionDiscardTimerExpired: u32 =
                unsafe { ::core::mem::transmute(DelayedTransactionDiscardTimerExpired) };
            DelayedTransactionDiscardTimerExpired as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let PERRAsserted: u32 = unsafe { ::core::mem::transmute(PERRAsserted) };
            PERRAsserted as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let SERRAsserted: u32 = unsafe { ::core::mem::transmute(SERRAsserted) };
            SERRAsserted as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let InternalBridgeError: u32 = unsafe { ::core::mem::transmute(InternalBridgeError) };
            InternalBridgeError as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY =
_PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY;
pub type PPCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY =
*mut _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_SEC_AER_CAPABILITIES {
    pub __bindgen_anon_1: _PCI_EXPRESS_SEC_AER_CAPABILITIES__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_SEC_AER_CAPABILITIES__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_SEC_AER_CAPABILITIES__bindgen_ty_1 {
    #[inline]
    pub fn SecondaryUncorrectableFirstErrorPtr(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_SecondaryUncorrectableFirstErrorPtr(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SecondaryUncorrectableFirstErrorPtr_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SecondaryUncorrectableFirstErrorPtr_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                27u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                27u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SecondaryUncorrectableFirstErrorPtr: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let SecondaryUncorrectableFirstErrorPtr: u32 =
                unsafe { ::core::mem::transmute(SecondaryUncorrectableFirstErrorPtr) };
            SecondaryUncorrectableFirstErrorPtr as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_SEC_AER_CAPABILITIES = _PCI_EXPRESS_SEC_AER_CAPABILITIES;
pub type PPCI_EXPRESS_SEC_AER_CAPABILITIES = *mut _PCI_EXPRESS_SEC_AER_CAPABILITIES;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_AER_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub UncorrectableErrorStatus: PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS,
    pub UncorrectableErrorMask: PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK,
    pub UncorrectableErrorSeverity: PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY,
    pub CorrectableErrorStatus: PCI_EXPRESS_CORRECTABLE_ERROR_STATUS,
    pub CorrectableErrorMask: PCI_EXPRESS_CORRECTABLE_ERROR_MASK,
    pub CapabilitiesAndControl: PCI_EXPRESS_AER_CAPABILITIES,
    pub HeaderLog: [ULONG; 4usize],
    pub SecUncorrectableErrorStatus: PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS,
    pub SecUncorrectableErrorMask: PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK,
    pub SecUncorrectableErrorSeverity: PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY,
    pub SecCapabilitiesAndControl: PCI_EXPRESS_SEC_AER_CAPABILITIES,
    pub SecHeaderLog: [ULONG; 4usize],
}
pub type PCI_EXPRESS_AER_CAPABILITY = _PCI_EXPRESS_AER_CAPABILITY;
pub type PPCI_EXPRESS_AER_CAPABILITY = *mut _PCI_EXPRESS_AER_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_ROOTPORT_AER_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub UncorrectableErrorStatus: PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS,
    pub UncorrectableErrorMask: PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK,
    pub UncorrectableErrorSeverity: PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY,
    pub CorrectableErrorStatus: PCI_EXPRESS_CORRECTABLE_ERROR_STATUS,
    pub CorrectableErrorMask: PCI_EXPRESS_CORRECTABLE_ERROR_MASK,
    pub CapabilitiesAndControl: PCI_EXPRESS_AER_CAPABILITIES,
    pub HeaderLog: [ULONG; 4usize],
    pub RootErrorCommand: PCI_EXPRESS_ROOT_ERROR_COMMAND,
    pub RootErrorStatus: PCI_EXPRESS_ROOT_ERROR_STATUS,
    pub ErrorSourceId: PCI_EXPRESS_ERROR_SOURCE_ID,
}
pub type PCI_EXPRESS_ROOTPORT_AER_CAPABILITY = _PCI_EXPRESS_ROOTPORT_AER_CAPABILITY;
pub type PPCI_EXPRESS_ROOTPORT_AER_CAPABILITY = *mut _PCI_EXPRESS_ROOTPORT_AER_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_BRIDGE_AER_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub UncorrectableErrorStatus: PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS,
    pub UncorrectableErrorMask: PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK,
    pub UncorrectableErrorSeverity: PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY,
    pub CorrectableErrorStatus: PCI_EXPRESS_CORRECTABLE_ERROR_STATUS,
    pub CorrectableErrorMask: PCI_EXPRESS_CORRECTABLE_ERROR_MASK,
    pub CapabilitiesAndControl: PCI_EXPRESS_AER_CAPABILITIES,
    pub HeaderLog: [ULONG; 4usize],
    pub SecUncorrectableErrorStatus: PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS,
    pub SecUncorrectableErrorMask: PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK,
    pub SecUncorrectableErrorSeverity: PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY,
    pub SecCapabilitiesAndControl: PCI_EXPRESS_SEC_AER_CAPABILITIES,
    pub SecHeaderLog: [ULONG; 4usize],
}
pub type PCI_EXPRESS_BRIDGE_AER_CAPABILITY = _PCI_EXPRESS_BRIDGE_AER_CAPABILITY;
pub type PPCI_EXPRESS_BRIDGE_AER_CAPABILITY = *mut _PCI_EXPRESS_BRIDGE_AER_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_ACS_CAPABILITY_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_ACS_CAPABILITY_REGISTER__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_ACS_CAPABILITY_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_ACS_CAPABILITY_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn SourceValidation(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SourceValidation(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SourceValidation_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_SourceValidation_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TranslationBlocking(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TranslationBlocking(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TranslationBlocking_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_TranslationBlocking_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RequestRedirect(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RequestRedirect(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RequestRedirect_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_RequestRedirect_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CompletionRedirect(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CompletionRedirect(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CompletionRedirect_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_CompletionRedirect_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UpstreamForwarding(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UpstreamForwarding(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UpstreamForwarding_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_UpstreamForwarding_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EgressControl(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EgressControl(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EgressControl_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_EgressControl_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DirectTranslation(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DirectTranslation(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DirectTranslation_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_DirectTranslation_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EnhancedCapability(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EnhancedCapability(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EnhancedCapability_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_EnhancedCapability_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EgressControlVectorSize(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_EgressControlVectorSize(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EgressControlVectorSize_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_EgressControlVectorSize_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SourceValidation: USHORT,
        TranslationBlocking: USHORT,
        RequestRedirect: USHORT,
        CompletionRedirect: USHORT,
        UpstreamForwarding: USHORT,
        EgressControl: USHORT,
        DirectTranslation: USHORT,
        EnhancedCapability: USHORT,
        EgressControlVectorSize: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SourceValidation: u16 = unsafe { ::core::mem::transmute(SourceValidation) };
            SourceValidation as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TranslationBlocking: u16 = unsafe { ::core::mem::transmute(TranslationBlocking) };
            TranslationBlocking as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RequestRedirect: u16 = unsafe { ::core::mem::transmute(RequestRedirect) };
            RequestRedirect as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let CompletionRedirect: u16 = unsafe { ::core::mem::transmute(CompletionRedirect) };
            CompletionRedirect as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let UpstreamForwarding: u16 = unsafe { ::core::mem::transmute(UpstreamForwarding) };
            UpstreamForwarding as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let EgressControl: u16 = unsafe { ::core::mem::transmute(EgressControl) };
            EgressControl as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let DirectTranslation: u16 = unsafe { ::core::mem::transmute(DirectTranslation) };
            DirectTranslation as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let EnhancedCapability: u16 = unsafe { ::core::mem::transmute(EnhancedCapability) };
            EnhancedCapability as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let EgressControlVectorSize: u16 =
                unsafe { ::core::mem::transmute(EgressControlVectorSize) };
            EgressControlVectorSize as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_ACS_CAPABILITY_REGISTER = _PCI_EXPRESS_ACS_CAPABILITY_REGISTER;
pub type PPCI_EXPRESS_ACS_CAPABILITY_REGISTER = *mut _PCI_EXPRESS_ACS_CAPABILITY_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_ACS_CONTROL {
    pub __bindgen_anon_1: _PCI_EXPRESS_ACS_CONTROL__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_ACS_CONTROL__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_ACS_CONTROL__bindgen_ty_1 {
    #[inline]
    pub fn SourceValidation(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SourceValidation(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SourceValidation_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_SourceValidation_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TranslationBlocking(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TranslationBlocking(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TranslationBlocking_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_TranslationBlocking_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RequestRedirect(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RequestRedirect(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RequestRedirect_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_RequestRedirect_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CompletionRedirect(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CompletionRedirect(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CompletionRedirect_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_CompletionRedirect_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UpstreamForwarding(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UpstreamForwarding(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UpstreamForwarding_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_UpstreamForwarding_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EgressControl(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EgressControl(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EgressControl_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_EgressControl_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DirectTranslation(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DirectTranslation(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DirectTranslation_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_DirectTranslation_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IoBlocking(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_IoBlocking(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IoBlocking_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_IoBlocking_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DspMemoryControl(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_DspMemoryControl(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DspMemoryControl_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_DspMemoryControl_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UspMemoryControl(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_UspMemoryControl(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UspMemoryControl_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_UspMemoryControl_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UnclaimedRedirect(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UnclaimedRedirect(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UnclaimedRedirect_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_UnclaimedRedirect_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SourceValidation: USHORT,
        TranslationBlocking: USHORT,
        RequestRedirect: USHORT,
        CompletionRedirect: USHORT,
        UpstreamForwarding: USHORT,
        EgressControl: USHORT,
        DirectTranslation: USHORT,
        IoBlocking: USHORT,
        DspMemoryControl: USHORT,
        UspMemoryControl: USHORT,
        UnclaimedRedirect: USHORT,
        Reserved: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SourceValidation: u16 = unsafe { ::core::mem::transmute(SourceValidation) };
            SourceValidation as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TranslationBlocking: u16 = unsafe { ::core::mem::transmute(TranslationBlocking) };
            TranslationBlocking as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RequestRedirect: u16 = unsafe { ::core::mem::transmute(RequestRedirect) };
            RequestRedirect as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let CompletionRedirect: u16 = unsafe { ::core::mem::transmute(CompletionRedirect) };
            CompletionRedirect as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let UpstreamForwarding: u16 = unsafe { ::core::mem::transmute(UpstreamForwarding) };
            UpstreamForwarding as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let EgressControl: u16 = unsafe { ::core::mem::transmute(EgressControl) };
            EgressControl as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let DirectTranslation: u16 = unsafe { ::core::mem::transmute(DirectTranslation) };
            DirectTranslation as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let IoBlocking: u16 = unsafe { ::core::mem::transmute(IoBlocking) };
            IoBlocking as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let DspMemoryControl: u16 = unsafe { ::core::mem::transmute(DspMemoryControl) };
            DspMemoryControl as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let UspMemoryControl: u16 = unsafe { ::core::mem::transmute(UspMemoryControl) };
            UspMemoryControl as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let UnclaimedRedirect: u16 = unsafe { ::core::mem::transmute(UnclaimedRedirect) };
            UnclaimedRedirect as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let Reserved: u16 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_ACS_CONTROL = _PCI_EXPRESS_ACS_CONTROL;
pub type PPCI_EXPRESS_ACS_CONTROL = *mut _PCI_EXPRESS_ACS_CONTROL;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_ACS_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub Capability: PCI_EXPRESS_ACS_CAPABILITY_REGISTER,
    pub Control: PCI_EXPRESS_ACS_CONTROL,
    pub EgressControl: [ULONG; 1usize],
}
pub type PCI_EXPRESS_ACS_CAPABILITY = _PCI_EXPRESS_ACS_CAPABILITY;
pub type PPCI_EXPRESS_ACS_CAPABILITY = *mut _PCI_EXPRESS_ACS_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_SRIOV_CAPS {
    pub __bindgen_anon_1: _PCI_EXPRESS_SRIOV_CAPS__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_SRIOV_CAPS__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_SRIOV_CAPS__bindgen_ty_1 {
    #[inline]
    pub fn VFMigrationCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VFMigrationCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VFMigrationCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VFMigrationCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                20u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                20u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VFMigrationInterruptNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_VFMigrationInterruptNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VFMigrationInterruptNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                11u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VFMigrationInterruptNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                11u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        VFMigrationCapable: ULONG,
        Reserved1: ULONG,
        VFMigrationInterruptNumber: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let VFMigrationCapable: u32 = unsafe { ::core::mem::transmute(VFMigrationCapable) };
            VFMigrationCapable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 20u8, {
            let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 11u8, {
            let VFMigrationInterruptNumber: u32 =
                unsafe { ::core::mem::transmute(VFMigrationInterruptNumber) };
            VFMigrationInterruptNumber as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_SRIOV_CAPS = _PCI_EXPRESS_SRIOV_CAPS;
pub type PPCI_EXPRESS_SRIOV_CAPS = *mut _PCI_EXPRESS_SRIOV_CAPS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_SRIOV_CONTROL {
    pub __bindgen_anon_1: _PCI_EXPRESS_SRIOV_CONTROL__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_SRIOV_CONTROL__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_SRIOV_CONTROL__bindgen_ty_1 {
    #[inline]
    pub fn VFEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_VFEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VFEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_VFEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VFMigrationEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_VFMigrationEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VFMigrationEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_VFMigrationEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VFMigrationInterruptEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_VFMigrationInterruptEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VFMigrationInterruptEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_VFMigrationInterruptEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VFMemorySpaceEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_VFMemorySpaceEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VFMemorySpaceEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_VFMemorySpaceEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ARICapableHierarchy(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ARICapableHierarchy(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ARICapableHierarchy_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ARICapableHierarchy_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 11u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                11u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                11u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        VFEnable: USHORT,
        VFMigrationEnable: USHORT,
        VFMigrationInterruptEnable: USHORT,
        VFMemorySpaceEnable: USHORT,
        ARICapableHierarchy: USHORT,
        Reserved1: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let VFEnable: u16 = unsafe { ::core::mem::transmute(VFEnable) };
            VFEnable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let VFMigrationEnable: u16 = unsafe { ::core::mem::transmute(VFMigrationEnable) };
            VFMigrationEnable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let VFMigrationInterruptEnable: u16 =
                unsafe { ::core::mem::transmute(VFMigrationInterruptEnable) };
            VFMigrationInterruptEnable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let VFMemorySpaceEnable: u16 = unsafe { ::core::mem::transmute(VFMemorySpaceEnable) };
            VFMemorySpaceEnable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ARICapableHierarchy: u16 = unsafe { ::core::mem::transmute(ARICapableHierarchy) };
            ARICapableHierarchy as u64
        });
        __bindgen_bitfield_unit.set(5usize, 11u8, {
            let Reserved1: u16 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_SRIOV_CONTROL = _PCI_EXPRESS_SRIOV_CONTROL;
pub type PPCI_EXPRESS_SRIOV_CONTROL = *mut _PCI_EXPRESS_SRIOV_CONTROL;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_SRIOV_STATUS {
    pub __bindgen_anon_1: _PCI_EXPRESS_SRIOV_STATUS__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_SRIOV_STATUS__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_SRIOV_STATUS__bindgen_ty_1 {
    #[inline]
    pub fn VFMigrationStatus(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_VFMigrationStatus(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VFMigrationStatus_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_VFMigrationStatus_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 15u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                15u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                15u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        VFMigrationStatus: USHORT,
        Reserved1: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let VFMigrationStatus: u16 = unsafe { ::core::mem::transmute(VFMigrationStatus) };
            VFMigrationStatus as u64
        });
        __bindgen_bitfield_unit.set(1usize, 15u8, {
            let Reserved1: u16 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_SRIOV_STATUS = _PCI_EXPRESS_SRIOV_STATUS;
pub type PPCI_EXPRESS_SRIOV_STATUS = *mut _PCI_EXPRESS_SRIOV_STATUS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY {
    pub __bindgen_anon_1: _PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY__bindgen_ty_1 {
    #[inline]
    pub fn VFMigrationStateBIR(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_VFMigrationStateBIR(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VFMigrationStateBIR_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VFMigrationStateBIR_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VFMigrationStateOffset(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_VFMigrationStateOffset(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VFMigrationStateOffset_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                29u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VFMigrationStateOffset_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                29u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        VFMigrationStateBIR: ULONG,
        VFMigrationStateOffset: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let VFMigrationStateBIR: u32 = unsafe { ::core::mem::transmute(VFMigrationStateBIR) };
            VFMigrationStateBIR as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let VFMigrationStateOffset: u32 =
                unsafe { ::core::mem::transmute(VFMigrationStateOffset) };
            VFMigrationStateOffset as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY = _PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY;
pub type PPCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY = *mut _PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_SRIOV_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub SRIOVCapabilities: PCI_EXPRESS_SRIOV_CAPS,
    pub SRIOVControl: PCI_EXPRESS_SRIOV_CONTROL,
    pub SRIOVStatus: PCI_EXPRESS_SRIOV_STATUS,
    pub InitialVFs: USHORT,
    pub TotalVFs: USHORT,
    pub NumVFs: USHORT,
    pub FunctionDependencyLink: UCHAR,
    pub RsvdP1: UCHAR,
    pub FirstVFOffset: USHORT,
    pub VFStride: USHORT,
    pub RsvdP2: USHORT,
    pub VFDeviceId: USHORT,
    pub SupportedPageSizes: ULONG,
    pub SystemPageSize: ULONG,
    pub BaseAddresses: [ULONG; 6usize],
    pub VFMigrationStateArrayOffset: PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY,
}
pub type PCI_EXPRESS_SRIOV_CAPABILITY = _PCI_EXPRESS_SRIOV_CAPABILITY;
pub type PPCI_EXPRESS_SRIOV_CAPABILITY = *mut _PCI_EXPRESS_SRIOV_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_DEVICE_PRESENCE_PARAMETERS {
    pub Size: ULONG,
    pub Flags: ULONG,
    pub VendorID: USHORT,
    pub DeviceID: USHORT,
    pub RevisionID: UCHAR,
    pub SubVendorID: USHORT,
    pub SubSystemID: USHORT,
    pub BaseClass: UCHAR,
    pub SubClass: UCHAR,
    pub ProgIf: UCHAR,
}
pub type PCI_DEVICE_PRESENCE_PARAMETERS = _PCI_DEVICE_PRESENCE_PARAMETERS;
pub type PPCI_DEVICE_PRESENCE_PARAMETERS = *mut _PCI_DEVICE_PRESENCE_PARAMETERS;
pub type PCI_IS_DEVICE_PRESENT = ::core::option::Option<
    unsafe extern "C" fn(
        VendorID: USHORT,
        DeviceID: USHORT,
        RevisionID: UCHAR,
        SubVendorID: USHORT,
        SubSystemID: USHORT,
        Flags: ULONG,
    ) -> BOOLEAN,
>;
pub type PPCI_IS_DEVICE_PRESENT = PCI_IS_DEVICE_PRESENT;
pub type PCI_IS_DEVICE_PRESENT_EX = ::core::option::Option<
    unsafe extern "C" fn(Context: PVOID, Parameters: PPCI_DEVICE_PRESENCE_PARAMETERS) -> BOOLEAN,
>;
pub type PPCI_IS_DEVICE_PRESENT_EX = PCI_IS_DEVICE_PRESENT_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_DEVICE_PRESENT_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub IsDevicePresent: PPCI_IS_DEVICE_PRESENT,
    pub IsDevicePresentEx: PPCI_IS_DEVICE_PRESENT_EX,
}
pub type PCI_DEVICE_PRESENT_INTERFACE = _PCI_DEVICE_PRESENT_INTERFACE;
pub type PPCI_DEVICE_PRESENT_INTERFACE = *mut _PCI_DEVICE_PRESENT_INTERFACE;
pub type PCI_EXPRESS_ENTER_LINK_QUIESCENT_MODE =
::core::option::Option<unsafe extern "C" fn(Context: PVOID) -> NTSTATUS>;
pub type PPCI_EXPRESS_ENTER_LINK_QUIESCENT_MODE = PCI_EXPRESS_ENTER_LINK_QUIESCENT_MODE;
pub type PCI_EXPRESS_EXIT_LINK_QUIESCENT_MODE =
::core::option::Option<unsafe extern "C" fn(Context: PVOID) -> NTSTATUS>;
pub type PPCI_EXPRESS_EXIT_LINK_QUIESCENT_MODE = PCI_EXPRESS_EXIT_LINK_QUIESCENT_MODE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_LINK_QUIESCENT_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub PciExpressEnterLinkQuiescentMode: PPCI_EXPRESS_ENTER_LINK_QUIESCENT_MODE,
    pub PciExpressExitLinkQuiescentMode: PPCI_EXPRESS_EXIT_LINK_QUIESCENT_MODE,
}
pub type PCI_EXPRESS_LINK_QUIESCENT_INTERFACE = _PCI_EXPRESS_LINK_QUIESCENT_INTERFACE;
pub type PPCI_EXPRESS_LINK_QUIESCENT_INTERFACE = *mut _PCI_EXPRESS_LINK_QUIESCENT_INTERFACE;
pub type PPCI_EXPRESS_ROOT_PORT_READ_CONFIG_SPACE = ::core::option::Option<
    unsafe extern "C" fn(Context: PVOID, Buffer: PVOID, Offset: ULONG, Length: ULONG) -> ULONG,
>;
pub type PPCI_EXPRESS_ROOT_PORT_WRITE_CONFIG_SPACE = ::core::option::Option<
    unsafe extern "C" fn(Context: PVOID, Buffer: PVOID, Offset: ULONG, Length: ULONG) -> ULONG,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_ROOT_PORT_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub ReadConfigSpace: PPCI_EXPRESS_ROOT_PORT_READ_CONFIG_SPACE,
    pub WriteConfigSpace: PPCI_EXPRESS_ROOT_PORT_WRITE_CONFIG_SPACE,
}
pub type PCI_EXPRESS_ROOT_PORT_INTERFACE = _PCI_EXPRESS_ROOT_PORT_INTERFACE;
pub type PPCI_EXPRESS_ROOT_PORT_INTERFACE = *mut _PCI_EXPRESS_ROOT_PORT_INTERFACE;
pub type PCI_MSIX_SET_ENTRY = ::core::option::Option<
    unsafe extern "C" fn(Context: PVOID, TableEntry: ULONG, MessageNumber: ULONG) -> NTSTATUS,
>;
pub type PPCI_MSIX_SET_ENTRY = PCI_MSIX_SET_ENTRY;
pub type PCI_MSIX_MASKUNMASK_ENTRY =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, TableEntry: ULONG) -> NTSTATUS>;
pub type PPCI_MSIX_MASKUNMASK_ENTRY = PCI_MSIX_MASKUNMASK_ENTRY;
pub type PCI_MSIX_GET_ENTRY = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        TableEntry: ULONG,
        MessageNumber: PULONG,
        Masked: PBOOLEAN,
    ) -> NTSTATUS,
>;
pub type PPCI_MSIX_GET_ENTRY = PCI_MSIX_GET_ENTRY;
pub type PCI_MSIX_GET_TABLE_SIZE =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, TableSize: PULONG) -> NTSTATUS>;
pub type PPCI_MSIX_GET_TABLE_SIZE = PCI_MSIX_GET_TABLE_SIZE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_MSIX_TABLE_CONFIG_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub SetTableEntry: PPCI_MSIX_SET_ENTRY,
    pub MaskTableEntry: PPCI_MSIX_MASKUNMASK_ENTRY,
    pub UnmaskTableEntry: PPCI_MSIX_MASKUNMASK_ENTRY,
    pub GetTableEntry: PPCI_MSIX_GET_ENTRY,
    pub GetTableSize: PPCI_MSIX_GET_TABLE_SIZE,
}
pub type PCI_MSIX_TABLE_CONFIG_INTERFACE = _PCI_MSIX_TABLE_CONFIG_INTERFACE;
pub type PPCI_MSIX_TABLE_CONFIG_INTERFACE = *mut _PCI_MSIX_TABLE_CONFIG_INTERFACE;
unsafe extern "C" {
    pub fn ZwCreateFile(
        FileHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        AllocationSize: PLARGE_INTEGER,
        FileAttributes: ULONG,
        ShareAccess: ULONG,
        CreateDisposition: ULONG,
        CreateOptions: ULONG,
        EaBuffer: PVOID,
        EaLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwOpenFile(
        FileHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        ShareAccess: ULONG,
        OpenOptions: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwLoadDriver(DriverServiceName: PUNICODE_STRING) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwUnloadDriver(DriverServiceName: PUNICODE_STRING) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwQueryInformationFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FileInformation: PVOID,
        Length: ULONG,
        FileInformationClass: FILE_INFORMATION_CLASS,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwSetInformationFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FileInformation: PVOID,
        Length: ULONG,
        FileInformationClass: FILE_INFORMATION_CLASS,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwReadFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Buffer: PVOID,
        Length: ULONG,
        ByteOffset: PLARGE_INTEGER,
        Key: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwWriteFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Buffer: PVOID,
        Length: ULONG,
        ByteOffset: PLARGE_INTEGER,
        Key: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwClose(Handle: HANDLE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwCreateDirectoryObject(
        DirectoryHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwMakeTemporaryObject(Handle: HANDLE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwCreateSection(
        SectionHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        MaximumSize: PLARGE_INTEGER,
        SectionPageProtection: ULONG,
        AllocationAttributes: ULONG,
        FileHandle: HANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwOpenSection(
        SectionHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwMapViewOfSection(
        SectionHandle: HANDLE,
        ProcessHandle: HANDLE,
        BaseAddress: *mut PVOID,
        ZeroBits: ULONG_PTR,
        CommitSize: SIZE_T,
        SectionOffset: PLARGE_INTEGER,
        ViewSize: PSIZE_T,
        InheritDisposition: SECTION_INHERIT,
        AllocationType: ULONG,
        Win32Protect: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwUnmapViewOfSection(ProcessHandle: HANDLE, BaseAddress: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwCreateKey(
        KeyHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        TitleIndex: ULONG,
        Class: PUNICODE_STRING,
        CreateOptions: ULONG,
        Disposition: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwCreateKeyTransacted(
        KeyHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        TitleIndex: ULONG,
        Class: PUNICODE_STRING,
        CreateOptions: ULONG,
        TransactionHandle: HANDLE,
        Disposition: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwCreateRegistryTransaction(
        TransactionHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        CreateOptions: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtOpenRegistryTransaction(
        TransactionHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwCommitRegistryTransaction(TransactionHandle: HANDLE, Flags: ULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtRollbackRegistryTransaction(TransactionHandle: HANDLE, Flags: ULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwOpenKey(
        KeyHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwOpenKeyEx(
        KeyHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        OpenOptions: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwOpenKeyTransacted(
        KeyHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        TransactionHandle: HANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwOpenKeyTransactedEx(
        KeyHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        OpenOptions: ULONG,
        TransactionHandle: HANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwDeleteKey(KeyHandle: HANDLE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwDeleteValueKey(KeyHandle: HANDLE, ValueName: PUNICODE_STRING) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwEnumerateKey(
        KeyHandle: HANDLE,
        Index: ULONG,
        KeyInformationClass: KEY_INFORMATION_CLASS,
        KeyInformation: PVOID,
        Length: ULONG,
        ResultLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwEnumerateValueKey(
        KeyHandle: HANDLE,
        Index: ULONG,
        KeyValueInformationClass: KEY_VALUE_INFORMATION_CLASS,
        KeyValueInformation: PVOID,
        Length: ULONG,
        ResultLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwFlushKey(KeyHandle: HANDLE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwQueryKey(
        KeyHandle: HANDLE,
        KeyInformationClass: KEY_INFORMATION_CLASS,
        KeyInformation: PVOID,
        Length: ULONG,
        ResultLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwQueryValueKey(
        KeyHandle: HANDLE,
        ValueName: PUNICODE_STRING,
        KeyValueInformationClass: KEY_VALUE_INFORMATION_CLASS,
        KeyValueInformation: PVOID,
        Length: ULONG,
        ResultLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwRenameKey(KeyHandle: HANDLE, NewName: PUNICODE_STRING) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwSaveKey(KeyHandle: HANDLE, FileHandle: HANDLE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwSaveKeyEx(KeyHandle: HANDLE, FileHandle: HANDLE, Format: ULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwRestoreKey(KeyHandle: HANDLE, FileHandle: HANDLE, Flags: ULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwSetInformationKey(
        KeyHandle: HANDLE,
        KeySetInformationClass: KEY_SET_INFORMATION_CLASS,
        KeySetInformation: PVOID,
        KeySetInformationLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwSetValueKey(
        KeyHandle: HANDLE,
        ValueName: PUNICODE_STRING,
        TitleIndex: ULONG,
        Type: ULONG,
        Data: PVOID,
        DataSize: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwOpenSymbolicLinkObject(
        LinkHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwQuerySymbolicLinkObject(
        LinkHandle: HANDLE,
        LinkTarget: PUNICODE_STRING,
        ReturnedLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwCreateTransactionManager(
        TmHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        LogFileName: PUNICODE_STRING,
        CreateOptions: ULONG,
        CommitStrength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwOpenTransactionManager(
        TmHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        LogFileName: PUNICODE_STRING,
        TmIdentity: LPGUID,
        OpenOptions: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwRollforwardTransactionManager(
        TransactionManagerHandle: HANDLE,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwRecoverTransactionManager(TransactionManagerHandle: HANDLE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwQueryInformationTransactionManager(
        TransactionManagerHandle: HANDLE,
        TransactionManagerInformationClass: TRANSACTIONMANAGER_INFORMATION_CLASS,
        TransactionManagerInformation: PVOID,
        TransactionManagerInformationLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwSetInformationTransactionManager(
        TmHandle: HANDLE,
        TransactionManagerInformationClass: TRANSACTIONMANAGER_INFORMATION_CLASS,
        TransactionManagerInformation: PVOID,
        TransactionManagerInformationLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwEnumerateTransactionObject(
        RootObjectHandle: HANDLE,
        QueryType: KTMOBJECT_TYPE,
        ObjectCursor: PKTMOBJECT_CURSOR,
        ObjectCursorLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwCreateTransaction(
        TransactionHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        Uow: LPGUID,
        TmHandle: HANDLE,
        CreateOptions: ULONG,
        IsolationLevel: ULONG,
        IsolationFlags: ULONG,
        Timeout: PLARGE_INTEGER,
        Description: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwOpenTransaction(
        TransactionHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        Uow: LPGUID,
        TmHandle: HANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwQueryInformationTransaction(
        TransactionHandle: HANDLE,
        TransactionInformationClass: TRANSACTION_INFORMATION_CLASS,
        TransactionInformation: PVOID,
        TransactionInformationLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwSetInformationTransaction(
        TransactionHandle: HANDLE,
        TransactionInformationClass: TRANSACTION_INFORMATION_CLASS,
        TransactionInformation: PVOID,
        TransactionInformationLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwCommitTransaction(TransactionHandle: HANDLE, Wait: BOOLEAN) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwRollbackTransaction(TransactionHandle: HANDLE, Wait: BOOLEAN) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwCreateResourceManager(
        ResourceManagerHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        TmHandle: HANDLE,
        ResourceManagerGuid: LPGUID,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        CreateOptions: ULONG,
        Description: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwOpenResourceManager(
        ResourceManagerHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        TmHandle: HANDLE,
        ResourceManagerGuid: LPGUID,
        ObjectAttributes: POBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwRecoverResourceManager(ResourceManagerHandle: HANDLE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwGetNotificationResourceManager(
        ResourceManagerHandle: HANDLE,
        TransactionNotification: PTRANSACTION_NOTIFICATION,
        NotificationLength: ULONG,
        Timeout: PLARGE_INTEGER,
        ReturnLength: PULONG,
        Asynchronous: ULONG,
        AsynchronousContext: ULONG_PTR,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwQueryInformationResourceManager(
        ResourceManagerHandle: HANDLE,
        ResourceManagerInformationClass: RESOURCEMANAGER_INFORMATION_CLASS,
        ResourceManagerInformation: PVOID,
        ResourceManagerInformationLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwSetInformationResourceManager(
        ResourceManagerHandle: HANDLE,
        ResourceManagerInformationClass: RESOURCEMANAGER_INFORMATION_CLASS,
        ResourceManagerInformation: PVOID,
        ResourceManagerInformationLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwCreateEnlistment(
        EnlistmentHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ResourceManagerHandle: HANDLE,
        TransactionHandle: HANDLE,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        CreateOptions: ULONG,
        NotificationMask: NOTIFICATION_MASK,
        EnlistmentKey: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwOpenEnlistment(
        EnlistmentHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        RmHandle: HANDLE,
        EnlistmentGuid: LPGUID,
        ObjectAttributes: POBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwQueryInformationEnlistment(
        EnlistmentHandle: HANDLE,
        EnlistmentInformationClass: ENLISTMENT_INFORMATION_CLASS,
        EnlistmentInformation: PVOID,
        EnlistmentInformationLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwSetInformationEnlistment(
        EnlistmentHandle: HANDLE,
        EnlistmentInformationClass: ENLISTMENT_INFORMATION_CLASS,
        EnlistmentInformation: PVOID,
        EnlistmentInformationLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwRecoverEnlistment(EnlistmentHandle: HANDLE, EnlistmentKey: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwPrePrepareEnlistment(
        EnlistmentHandle: HANDLE,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwPrepareEnlistment(
        EnlistmentHandle: HANDLE,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwCommitEnlistment(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER)
                              -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwRollbackEnlistment(
        EnlistmentHandle: HANDLE,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwPrePrepareComplete(
        EnlistmentHandle: HANDLE,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwPrepareComplete(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwCommitComplete(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwReadOnlyEnlistment(
        EnlistmentHandle: HANDLE,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwRollbackComplete(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER)
                              -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwSinglePhaseReject(
        EnlistmentHandle: HANDLE,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwOpenEvent(
        EventHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwQueryInformationByName(
        ObjectAttributes: POBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FileInformation: PVOID,
        Length: ULONG,
        FileInformationClass: FILE_INFORMATION_CLASS,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwQueryFullAttributesFile(
        ObjectAttributes: POBJECT_ATTRIBUTES,
        FileInformation: PFILE_NETWORK_OPEN_INFORMATION,
    ) -> NTSTATUS;
}
pub type CLFS_CONTAINER_ID = ULONG;
pub type PCLFS_CONTAINER_ID = *mut CLFS_CONTAINER_ID;
pub type PPCLFS_CONTAINER_ID = *mut *mut CLFS_CONTAINER_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLS_LSN {
    pub Internal: ULONGLONG,
}
pub type CLS_LSN = _CLS_LSN;
pub type PCLS_LSN = *mut _CLS_LSN;
pub type PPCLS_LSN = *mut *mut _CLS_LSN;
pub type CLFS_LSN = CLS_LSN;
pub type PCLFS_LSN = *mut CLFS_LSN;
pub type PPCLFS_LSN = *mut *mut CLFS_LSN;
unsafe extern "C" {
    pub static CLFS_LSN_INVALID: CLFS_LSN;
}
unsafe extern "C" {
    pub static CLFS_LSN_NULL: CLFS_LSN;
}
pub type CLS_RECORD_TYPE = UCHAR;
pub type PCLS_RECORD_TYPE = *mut UCHAR;
pub type PPCLS_RECORD_TYPE = *mut *mut UCHAR;
pub type CLFS_RECORD_TYPE = CLS_RECORD_TYPE;
pub type PCLFS_RECORD_TYPE = *mut CLS_RECORD_TYPE;
pub type PPCLFS_RECORD_TYPE = *mut *mut CLS_RECORD_TYPE;
pub const _CLS_CONTEXT_MODE_ClsContextNone: _CLS_CONTEXT_MODE = 0;
pub const _CLS_CONTEXT_MODE_ClsContextUndoNext: _CLS_CONTEXT_MODE = 1;
pub const _CLS_CONTEXT_MODE_ClsContextPrevious: _CLS_CONTEXT_MODE = 2;
pub const _CLS_CONTEXT_MODE_ClsContextForward: _CLS_CONTEXT_MODE = 3;
pub type _CLS_CONTEXT_MODE = core::ffi::c_int;
pub use self::_CLS_CONTEXT_MODE as CLS_CONTEXT_MODE;
pub type PCLS_CONTEXT_MODE = *mut _CLS_CONTEXT_MODE;
pub type PPCLS_CONTEXT_MODE = *mut *mut _CLS_CONTEXT_MODE;
pub const _CLFS_CONTEXT_MODE_ClfsContextNone: _CLFS_CONTEXT_MODE = 0;
pub const _CLFS_CONTEXT_MODE_ClfsContextUndoNext: _CLFS_CONTEXT_MODE = 1;
pub const _CLFS_CONTEXT_MODE_ClfsContextPrevious: _CLFS_CONTEXT_MODE = 2;
pub const _CLFS_CONTEXT_MODE_ClfsContextForward: _CLFS_CONTEXT_MODE = 3;
pub type _CLFS_CONTEXT_MODE = core::ffi::c_int;
pub use self::_CLFS_CONTEXT_MODE as CLFS_CONTEXT_MODE;
pub type PCLFS_CONTEXT_MODE = *mut _CLFS_CONTEXT_MODE;
pub type PPCLFS_CONTEXT_MODE = *mut *mut _CLFS_CONTEXT_MODE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLFS_NODE_ID {
    pub cType: ULONG,
    pub cbNode: ULONG,
}
pub type CLFS_NODE_ID = _CLFS_NODE_ID;
pub type PCLFS_NODE_ID = *mut _CLFS_NODE_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLS_WRITE_ENTRY {
    pub Buffer: PVOID,
    pub ByteLength: ULONG,
}
pub type CLS_WRITE_ENTRY = _CLS_WRITE_ENTRY;
pub type PCLS_WRITE_ENTRY = *mut _CLS_WRITE_ENTRY;
pub type PPCLS_WRITE_ENTRY = *mut *mut _CLS_WRITE_ENTRY;
pub type CLFS_WRITE_ENTRY = CLS_WRITE_ENTRY;
pub type PCLFS_WRITE_ENTRY = *mut CLFS_WRITE_ENTRY;
pub type PPCLFS_WRITE_ENTRY = *mut *mut CLFS_WRITE_ENTRY;
pub type CLFS_LOG_ID = GUID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLS_INFORMATION {
    pub TotalAvailable: LONGLONG,
    pub CurrentAvailable: LONGLONG,
    pub TotalReservation: LONGLONG,
    pub BaseFileSize: ULONGLONG,
    pub ContainerSize: ULONGLONG,
    pub TotalContainers: ULONG,
    pub FreeContainers: ULONG,
    pub TotalClients: ULONG,
    pub Attributes: ULONG,
    pub FlushThreshold: ULONG,
    pub SectorSize: ULONG,
    pub MinArchiveTailLsn: CLS_LSN,
    pub BaseLsn: CLS_LSN,
    pub LastFlushedLsn: CLS_LSN,
    pub LastLsn: CLS_LSN,
    pub RestartLsn: CLS_LSN,
    pub Identity: GUID,
}
pub type CLS_INFORMATION = _CLS_INFORMATION;
pub type PCLS_INFORMATION = *mut _CLS_INFORMATION;
pub type PPCLS_INFORMATION = *mut _CLS_INFORMATION;
pub type CLFS_INFORMATION = CLS_INFORMATION;
pub type PCLFS_INFORMATION = *mut CLFS_INFORMATION;
pub type PPCLFS_INFORMATION = *mut CLFS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLFS_LOG_NAME_INFORMATION {
    pub NameLengthInBytes: USHORT,
    pub Name: [WCHAR; 1usize],
}
pub type CLFS_LOG_NAME_INFORMATION = _CLFS_LOG_NAME_INFORMATION;
pub type PCLFS_LOG_NAME_INFORMATION = *mut _CLFS_LOG_NAME_INFORMATION;
pub type PPCLFS_LOG_NAME_INFORMATION = *mut *mut _CLFS_LOG_NAME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLFS_STREAM_ID_INFORMATION {
    pub StreamIdentifier: UCHAR,
}
pub type CLFS_STREAM_ID_INFORMATION = _CLFS_STREAM_ID_INFORMATION;
pub type PCLFS_STREAM_ID_INFORMATION = *mut _CLFS_STREAM_ID_INFORMATION;
pub type PPCLFS_STREAM_ID_INFORMATION = *mut *mut _CLFS_STREAM_ID_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLFS_PHYSICAL_LSN_INFORMATION {
    pub StreamIdentifier: UCHAR,
    pub VirtualLsn: CLFS_LSN,
    pub PhysicalLsn: CLFS_LSN,
}
pub type CLFS_PHYSICAL_LSN_INFORMATION = _CLFS_PHYSICAL_LSN_INFORMATION;
pub type PCLFS_PHYSICAL_LSN_INFORMATION = *mut _CLFS_PHYSICAL_LSN_INFORMATION;
pub type CLS_CONTAINER_STATE = UINT32;
pub type PCLS_CONTAINER_STATE = *mut UINT32;
pub type PPCLS_CONTAINER_STATE = *mut UINT32;
pub type CLFS_CONTAINER_STATE = CLS_CONTAINER_STATE;
pub type PCLFS_CONTAINER_STATE = *mut CLS_CONTAINER_STATE;
pub type PPCLFS_CONTAINER_STATE = *mut CLS_CONTAINER_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLS_CONTAINER_INFORMATION {
    pub FileAttributes: ULONG,
    pub CreationTime: ULONGLONG,
    pub LastAccessTime: ULONGLONG,
    pub LastWriteTime: ULONGLONG,
    pub ContainerSize: LONGLONG,
    pub FileNameActualLength: ULONG,
    pub FileNameLength: ULONG,
    pub FileName: [WCHAR; 256usize],
    pub State: CLFS_CONTAINER_STATE,
    pub PhysicalContainerId: CLFS_CONTAINER_ID,
    pub LogicalContainerId: CLFS_CONTAINER_ID,
}
pub type CLS_CONTAINER_INFORMATION = _CLS_CONTAINER_INFORMATION;
pub type PCLS_CONTAINER_INFORMATION = *mut _CLS_CONTAINER_INFORMATION;
pub type PPCLS_CONTAINER_INFORMATION = *mut *mut _CLS_CONTAINER_INFORMATION;
pub type CLFS_CONTAINER_INFORMATION = CLS_CONTAINER_INFORMATION;
pub type PCLFS_CONTAINER_INFORMATION = *mut CLFS_CONTAINER_INFORMATION;
pub type PPCLFS_CONTAINER_INFORMATION = *mut *mut CLFS_CONTAINER_INFORMATION;
pub const _CLS_LOG_INFORMATION_CLASS_ClfsLogBasicInformation: _CLS_LOG_INFORMATION_CLASS = 0;
pub const _CLS_LOG_INFORMATION_CLASS_ClfsLogBasicInformationPhysical: _CLS_LOG_INFORMATION_CLASS =
    1;
pub const _CLS_LOG_INFORMATION_CLASS_ClfsLogPhysicalNameInformation: _CLS_LOG_INFORMATION_CLASS = 2;
pub const _CLS_LOG_INFORMATION_CLASS_ClfsLogStreamIdentifierInformation:
_CLS_LOG_INFORMATION_CLASS = 3;
pub const _CLS_LOG_INFORMATION_CLASS_ClfsLogSystemMarkingInformation: _CLS_LOG_INFORMATION_CLASS =
    4;
pub const _CLS_LOG_INFORMATION_CLASS_ClfsLogPhysicalLsnInformation: _CLS_LOG_INFORMATION_CLASS = 5;
pub type _CLS_LOG_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_CLS_LOG_INFORMATION_CLASS as CLS_LOG_INFORMATION_CLASS;
pub type PCLS_LOG_INFORMATION_CLASS = *mut _CLS_LOG_INFORMATION_CLASS;
pub type PPCLS_LOG_INFORMATION_CLASS = *mut *mut _CLS_LOG_INFORMATION_CLASS;
pub use self::CLS_LOG_INFORMATION_CLASS as CLFS_LOG_INFORMATION_CLASS;
pub type PCLFS_LOG_INFORMATION_CLASS = *mut CLFS_LOG_INFORMATION_CLASS;
pub type PPCLFS_LOG_INFORMATION_CLASS = *mut *mut CLFS_LOG_INFORMATION_CLASS;
pub const _CLS_IOSTATS_CLASS_ClsIoStatsDefault: _CLS_IOSTATS_CLASS = 0;
pub const _CLS_IOSTATS_CLASS_ClsIoStatsMax: _CLS_IOSTATS_CLASS = 65535;
pub type _CLS_IOSTATS_CLASS = core::ffi::c_int;
pub use self::_CLS_IOSTATS_CLASS as CLS_IOSTATS_CLASS;
pub type PCLS_IOSTATS_CLASS = *mut _CLS_IOSTATS_CLASS;
pub type PPCLS_IOSTATS_CLASS = *mut *mut _CLS_IOSTATS_CLASS;
pub const _CLFS_IOSTATS_CLASS_ClfsIoStatsDefault: _CLFS_IOSTATS_CLASS = 0;
pub const _CLFS_IOSTATS_CLASS_ClfsIoStatsMax: _CLFS_IOSTATS_CLASS = 65535;
pub type _CLFS_IOSTATS_CLASS = core::ffi::c_int;
pub use self::_CLFS_IOSTATS_CLASS as CLFS_IOSTATS_CLASS;
pub type PCLFS_IOSTATS_CLASS = *mut _CLFS_IOSTATS_CLASS;
pub type PPCLFS_IOSTATS_CLASS = *mut *mut _CLFS_IOSTATS_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLS_IO_STATISTICS_HEADER {
    pub ubMajorVersion: UCHAR,
    pub ubMinorVersion: UCHAR,
    pub eStatsClass: CLFS_IOSTATS_CLASS,
    pub cbLength: USHORT,
    pub coffData: ULONG,
}
pub type CLS_IO_STATISTICS_HEADER = _CLS_IO_STATISTICS_HEADER;
pub type PCLS_IO_STATISTICS_HEADER = *mut _CLS_IO_STATISTICS_HEADER;
pub type PPCLS_IO_STATISTICS_HEADER = *mut *mut _CLS_IO_STATISTICS_HEADER;
pub type CLFS_IO_STATISTICS_HEADER = CLS_IO_STATISTICS_HEADER;
pub type PCLFS_IO_STATISTICS_HEADER = *mut CLFS_IO_STATISTICS_HEADER;
pub type PPCLFS_IO_STATISTICS_HEADER = *mut *mut CLFS_IO_STATISTICS_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLS_IO_STATISTICS {
    pub hdrIoStats: CLS_IO_STATISTICS_HEADER,
    pub cFlush: ULONGLONG,
    pub cbFlush: ULONGLONG,
    pub cMetaFlush: ULONGLONG,
    pub cbMetaFlush: ULONGLONG,
}
pub type CLS_IO_STATISTICS = _CLS_IO_STATISTICS;
pub type PCLS_IO_STATISTICS = *mut _CLS_IO_STATISTICS;
pub type PPCLS_IO_STATISTICS = *mut *mut _CLS_IO_STATISTICS;
pub type CLFS_IO_STATISTICS = CLS_IO_STATISTICS;
pub type PCLFS_IO_STATISTICS = *mut CLFS_IO_STATISTICS;
pub type PPCLFS_IO_STATISTICS = *mut *mut CLFS_IO_STATISTICS;
pub type CLFS_SCAN_MODE = UCHAR;
pub type PCLFS_SCAN_MODE = *mut UCHAR;
pub type LOG_FILE_OBJECT = FILE_OBJECT;
pub type PLOG_FILE_OBJECT = *mut FILE_OBJECT;
pub type PPLOG_FILE_OBJECT = *mut *mut FILE_OBJECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLS_SCAN_CONTEXT {
    pub cidNode: CLFS_NODE_ID,
    pub plfoLog: PLOG_FILE_OBJECT,
    pub cIndex: ULONG,
    pub __bindgen_padding_0: u32,
    pub cContainers: ULONG,
    pub __bindgen_padding_1: u32,
    pub cContainersReturned: ULONG,
    pub __bindgen_padding_2: [u8; 4usize],
    pub eScanMode: CLFS_SCAN_MODE,
    pub pinfoContainer: PCLS_CONTAINER_INFORMATION,
}
pub type CLS_SCAN_CONTEXT = _CLS_SCAN_CONTEXT;
pub type PCLS_SCAN_CONTEXT = *mut _CLS_SCAN_CONTEXT;
pub type PPCLS_SCAN_CONTEXT = *mut *mut _CLS_SCAN_CONTEXT;
pub type CLFS_SCAN_CONTEXT = CLS_SCAN_CONTEXT;
pub type PCLFS_SCAN_CONTEXT = *mut CLFS_SCAN_CONTEXT;
pub type PPCLFS_SCAN_CONTEXT = *mut *mut CLFS_SCAN_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLS_ARCHIVE_DESCRIPTOR {
    pub coffLow: ULONGLONG,
    pub coffHigh: ULONGLONG,
    pub infoContainer: CLS_CONTAINER_INFORMATION,
}
pub type CLS_ARCHIVE_DESCRIPTOR = _CLS_ARCHIVE_DESCRIPTOR;
pub type PCLS_ARCHIVE_DESCRIPTOR = *mut _CLS_ARCHIVE_DESCRIPTOR;
pub type PPCLS_ARCHIVE_DESCRIPTOR = *mut *mut _CLS_ARCHIVE_DESCRIPTOR;
pub type CLFS_ARCHIVE_DESCRIPTOR = CLS_ARCHIVE_DESCRIPTOR;
pub type PCLFS_ARCHIVE_DESCRIPTOR = *mut CLFS_ARCHIVE_DESCRIPTOR;
pub type PPCLFS_ARCHIVE_DESCRIPTOR = *mut *mut CLFS_ARCHIVE_DESCRIPTOR;
pub type CLFS_BLOCK_ALLOCATION = ::core::option::Option<
    unsafe extern "C" fn(cbBufferLength: ULONG, pvUserContext: PVOID) -> PVOID,
>;
pub type CLFS_BLOCK_DEALLOCATION =
::core::option::Option<unsafe extern "C" fn(pvBuffer: PVOID, pvUserContext: PVOID)>;
pub const _CLFS_LOG_ARCHIVE_MODE_ClfsLogArchiveEnabled: _CLFS_LOG_ARCHIVE_MODE = 1;
pub const _CLFS_LOG_ARCHIVE_MODE_ClfsLogArchiveDisabled: _CLFS_LOG_ARCHIVE_MODE = 2;
pub type _CLFS_LOG_ARCHIVE_MODE = core::ffi::c_int;
pub use self::_CLFS_LOG_ARCHIVE_MODE as CLFS_LOG_ARCHIVE_MODE;
pub type PCLFS_LOG_ARCHIVE_MODE = *mut _CLFS_LOG_ARCHIVE_MODE;
unsafe extern "C" {
    pub fn ClfsLsnEqual(plsn1: *const CLFS_LSN, plsn2: *const CLFS_LSN) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ClfsLsnLess(plsn1: *const CLFS_LSN, plsn2: *const CLFS_LSN) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ClfsLsnGreater(plsn1: *const CLFS_LSN, plsn2: *const CLFS_LSN) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ClfsLsnNull(plsn: *const CLFS_LSN) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ClfsLsnContainer(plsn: *const CLFS_LSN) -> CLFS_CONTAINER_ID;
}
unsafe extern "C" {
    pub fn ClfsLsnCreate(
        cidContainer: CLFS_CONTAINER_ID,
        offBlock: ULONG,
        cRecord: ULONG,
    ) -> CLFS_LSN;
}
unsafe extern "C" {
    pub fn ClfsLsnBlockOffset(plsn: *const CLFS_LSN) -> ULONG;
}
unsafe extern "C" {
    pub fn ClfsLsnRecordSequence(plsn: *const CLFS_LSN) -> ULONG;
}
unsafe extern "C" {
    pub fn ClfsLsnInvalid(plsn: *const CLFS_LSN) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ClfsLsnIncrement(plsn: PCLFS_LSN) -> CLFS_LSN;
}
pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyMaximumSize: _CLFS_MGMT_POLICY_TYPE = 0;
pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyMinimumSize: _CLFS_MGMT_POLICY_TYPE = 1;
pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyNewContainerSize: _CLFS_MGMT_POLICY_TYPE = 2;
pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyGrowthRate: _CLFS_MGMT_POLICY_TYPE = 3;
pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyLogTail: _CLFS_MGMT_POLICY_TYPE = 4;
pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyAutoShrink: _CLFS_MGMT_POLICY_TYPE = 5;
pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyAutoGrow: _CLFS_MGMT_POLICY_TYPE = 6;
pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyNewContainerPrefix: _CLFS_MGMT_POLICY_TYPE = 7;
pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyNewContainerSuffix: _CLFS_MGMT_POLICY_TYPE = 8;
pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyNewContainerExtension: _CLFS_MGMT_POLICY_TYPE = 9;
pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyInvalid: _CLFS_MGMT_POLICY_TYPE = 10;
pub type _CLFS_MGMT_POLICY_TYPE = core::ffi::c_int;
pub use self::_CLFS_MGMT_POLICY_TYPE as CLFS_MGMT_POLICY_TYPE;
pub type PCLFS_MGMT_POLICY_TYPE = *mut _CLFS_MGMT_POLICY_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CLFS_MGMT_POLICY {
    pub Version: ULONG,
    pub LengthInBytes: ULONG,
    pub PolicyFlags: ULONG,
    pub PolicyType: CLFS_MGMT_POLICY_TYPE,
    pub PolicyParameters: _CLFS_MGMT_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CLFS_MGMT_POLICY__bindgen_ty_1 {
    pub MaximumSize: _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_1,
    pub MinimumSize: _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_2,
    pub NewContainerSize: _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_3,
    pub GrowthRate: _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_4,
    pub LogTail: _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_5,
    pub AutoShrink: _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_6,
    pub AutoGrow: _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_7,
    pub NewContainerPrefix: _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_8,
    pub NewContainerSuffix: _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_9,
    pub NewContainerExtension: _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_10,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub Containers: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_2 {
    pub Containers: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_3 {
    pub SizeInBytes: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_4 {
    pub AbsoluteGrowthInContainers: ULONG,
    pub RelativeGrowthPercentage: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_5 {
    pub MinimumAvailablePercentage: ULONG,
    pub MinimumAvailableContainers: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_6 {
    pub Percentage: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_7 {
    pub Enabled: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_8 {
    pub PrefixLengthInBytes: USHORT,
    pub PrefixString: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_9 {
    pub NextContainerSuffix: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_10 {
    pub ExtensionLengthInBytes: USHORT,
    pub ExtensionString: [WCHAR; 1usize],
}
pub type CLFS_MGMT_POLICY = _CLFS_MGMT_POLICY;
pub type PCLFS_MGMT_POLICY = *mut _CLFS_MGMT_POLICY;
pub const _CLFS_MGMT_NOTIFICATION_TYPE_ClfsMgmtAdvanceTailNotification:
_CLFS_MGMT_NOTIFICATION_TYPE = 0;
pub const _CLFS_MGMT_NOTIFICATION_TYPE_ClfsMgmtLogFullHandlerNotification:
_CLFS_MGMT_NOTIFICATION_TYPE = 1;
pub const _CLFS_MGMT_NOTIFICATION_TYPE_ClfsMgmtLogUnpinnedNotification:
_CLFS_MGMT_NOTIFICATION_TYPE = 2;
pub const _CLFS_MGMT_NOTIFICATION_TYPE_ClfsMgmtLogWriteNotification: _CLFS_MGMT_NOTIFICATION_TYPE =
    3;
pub type _CLFS_MGMT_NOTIFICATION_TYPE = core::ffi::c_int;
pub use self::_CLFS_MGMT_NOTIFICATION_TYPE as CLFS_MGMT_NOTIFICATION_TYPE;
pub type PCLFS_MGMT_NOTIFICATION_TYPE = *mut _CLFS_MGMT_NOTIFICATION_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLFS_MGMT_NOTIFICATION {
    pub Notification: CLFS_MGMT_NOTIFICATION_TYPE,
    pub Lsn: CLFS_LSN,
    pub LogIsPinned: USHORT,
}
pub type CLFS_MGMT_NOTIFICATION = _CLFS_MGMT_NOTIFICATION;
pub type PCLFS_MGMT_NOTIFICATION = *mut _CLFS_MGMT_NOTIFICATION;
pub type PCLFS_CLIENT_ADVANCE_TAIL_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        LogFile: PLOG_FILE_OBJECT,
        TargetLsn: PCLFS_LSN,
        ClientData: PVOID,
    ) -> NTSTATUS,
>;
pub type PCLFS_CLIENT_LFF_HANDLER_COMPLETE_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        LogFile: PLOG_FILE_OBJECT,
        OperationStatus: NTSTATUS,
        LogIsPinned: BOOLEAN,
        ClientData: PVOID,
    ),
>;
pub type PCLFS_CLIENT_LOG_UNPINNED_CALLBACK =
::core::option::Option<unsafe extern "C" fn(LogFile: PLOG_FILE_OBJECT, ClientData: PVOID)>;
pub type PCLFS_SET_LOG_SIZE_COMPLETE_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(LogFile: PLOG_FILE_OBJECT, OperationStatus: NTSTATUS, ClientData: PVOID),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLFS_MGMT_CLIENT_REGISTRATION {
    pub Version: ULONG,
    pub AdvanceTailCallback: PCLFS_CLIENT_ADVANCE_TAIL_CALLBACK,
    pub AdvanceTailCallbackData: PVOID,
    pub LogGrowthCompleteCallback: PCLFS_CLIENT_LFF_HANDLER_COMPLETE_CALLBACK,
    pub LogGrowthCompleteCallbackData: PVOID,
    pub LogUnpinnedCallback: PCLFS_CLIENT_LOG_UNPINNED_CALLBACK,
    pub LogUnpinnedCallbackData: PVOID,
}
pub type CLFS_MGMT_CLIENT_REGISTRATION = _CLFS_MGMT_CLIENT_REGISTRATION;
pub type PCLFS_MGMT_CLIENT_REGISTRATION = *mut _CLFS_MGMT_CLIENT_REGISTRATION;
pub type CLFS_MGMT_CLIENT = PVOID;
pub type PCLFS_MGMT_CLIENT = *mut PVOID;
unsafe extern "C" {
    pub fn ClfsMgmtRegisterManagedClient(
        LogFile: PLOG_FILE_OBJECT,
        RegistrationData: PCLFS_MGMT_CLIENT_REGISTRATION,
        ClientCookie: PCLFS_MGMT_CLIENT,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsMgmtDeregisterManagedClient(ClientCookie: CLFS_MGMT_CLIENT) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsMgmtTailAdvanceFailure(Client: CLFS_MGMT_CLIENT, Reason: NTSTATUS) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsMgmtHandleLogFileFull(Client: CLFS_MGMT_CLIENT) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsMgmtInstallPolicy(
        LogFile: PLOG_FILE_OBJECT,
        Policy: PCLFS_MGMT_POLICY,
        PolicyLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsMgmtQueryPolicy(
        LogFile: PLOG_FILE_OBJECT,
        PolicyType: CLFS_MGMT_POLICY_TYPE,
        Policy: PCLFS_MGMT_POLICY,
        PolicyLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsMgmtRemovePolicy(
        LogFile: PLOG_FILE_OBJECT,
        PolicyType: CLFS_MGMT_POLICY_TYPE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsMgmtSetLogFileSize(
        LogFile: PLOG_FILE_OBJECT,
        NewSizeInContainers: PULONGLONG,
        ResultingSizeInContainers: PULONGLONG,
        CompletionRoutine: PCLFS_SET_LOG_SIZE_COMPLETE_CALLBACK,
        CompletionRoutineData: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsMgmtSetLogFileSizeAsClient(
        LogFile: PLOG_FILE_OBJECT,
        ClientCookie: PCLFS_MGMT_CLIENT,
        NewSizeInContainers: PULONGLONG,
        ResultingSizeInContainers: PULONGLONG,
        CompletionRoutine: PCLFS_SET_LOG_SIZE_COMPLETE_CALLBACK,
        CompletionRoutineData: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsInitialize() -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsFinalize();
}
unsafe extern "C" {
    pub fn ClfsCreateLogFile(
        pplfoLog: PPLOG_FILE_OBJECT,
        puszLogFileName: PUNICODE_STRING,
        fDesiredAccess: ACCESS_MASK,
        dwShareMode: ULONG,
        psdLogFile: PSECURITY_DESCRIPTOR,
        fCreateDisposition: ULONG,
        fCreateOptions: ULONG,
        fFlagsAndAttributes: ULONG,
        fLogOptionFlag: ULONG,
        pvContext: PVOID,
        cbContext: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsDeleteLogByPointer(plfoLog: PLOG_FILE_OBJECT) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsDeleteLogFile(
        puszLogFileName: PUNICODE_STRING,
        pvReserved: PVOID,
        fLogOptionFlag: ULONG,
        pvContext: PVOID,
        cbContext: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsAddLogContainer(
        plfoLog: PLOG_FILE_OBJECT,
        pcbContainer: PULONGLONG,
        puszContainerPath: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsAddLogContainerSet(
        plfoLog: PLOG_FILE_OBJECT,
        cContainers: USHORT,
        pcbContainer: PULONGLONG,
        rguszContainerPath: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsRemoveLogContainer(
        plfoLog: PLOG_FILE_OBJECT,
        puszContainerPath: PUNICODE_STRING,
        fForce: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsRemoveLogContainerSet(
        plfoLog: PLOG_FILE_OBJECT,
        cContainers: USHORT,
        rgwszContainerPath: PUNICODE_STRING,
        fForce: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsSetArchiveTail(plfoLog: PLOG_FILE_OBJECT, plsnArchiveTail: PCLFS_LSN) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsSetEndOfLog(plfoLog: PLOG_FILE_OBJECT, plsnEnd: PCLFS_LSN) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsCreateScanContext(
        plfoLog: PLOG_FILE_OBJECT,
        cFromContainer: ULONG,
        cContainers: ULONG,
        eScanMode: CLFS_SCAN_MODE,
        pcxScan: PCLFS_SCAN_CONTEXT,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsScanLogContainers(
        pcxScan: PCLFS_SCAN_CONTEXT,
        eScanMode: CLFS_SCAN_MODE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsGetContainerName(
        plfoLog: PLOG_FILE_OBJECT,
        cidLogicalContainer: CLFS_CONTAINER_ID,
        puszContainerName: PUNICODE_STRING,
        pcActualLenContainerName: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsGetLogFileInformation(
        plfoLog: PLOG_FILE_OBJECT,
        pinfoBuffer: PCLFS_INFORMATION,
        pcbInfoBuffer: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsQueryLogFileInformation(
        plfoLog: PLOG_FILE_OBJECT,
        eInformationClass: CLFS_LOG_INFORMATION_CLASS,
        pinfoInputBuffer: PVOID,
        cbinfoInputBuffer: ULONG,
        pinfoBuffer: PVOID,
        pcbInfoBuffer: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsSetLogFileInformation(
        plfoLog: PLOG_FILE_OBJECT,
        eInformationClass: CLFS_LOG_INFORMATION_CLASS,
        pinfoBuffer: PVOID,
        cbBuffer: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsReadRestartArea(
        pvMarshalContext: PVOID,
        ppvRestartBuffer: *mut PVOID,
        pcbRestartBuffer: PULONG,
        plsn: PCLFS_LSN,
        ppvReadContext: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsReadPreviousRestartArea(
        pvReadContext: PVOID,
        ppvRestartBuffer: *mut PVOID,
        pcbRestartBuffer: PULONG,
        plsnRestart: PCLFS_LSN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsWriteRestartArea(
        pvMarshalContext: PVOID,
        pvRestartBuffer: PVOID,
        cbRestartBuffer: ULONG,
        plsnBase: PCLFS_LSN,
        fFlags: ULONG,
        pcbWritten: PULONG,
        plsnNext: PCLFS_LSN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsAdvanceLogBase(
        pvMarshalContext: PVOID,
        plsnBase: PCLFS_LSN,
        fFlags: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsCloseAndResetLogFile(plfoLog: PLOG_FILE_OBJECT) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsCloseLogFileObject(plfoLog: PLOG_FILE_OBJECT) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsCreateMarshallingArea(
        plfoLog: PLOG_FILE_OBJECT,
        ePoolType: POOL_TYPE,
        pfnAllocBuffer: PALLOCATE_FUNCTION,
        pfnFreeBuffer: PFREE_FUNCTION,
        cbMarshallingBuffer: ULONG,
        cMaxWriteBuffers: ULONG,
        cMaxReadBuffers: ULONG,
        ppvMarshalContext: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsCreateMarshallingAreaEx(
        plfoLog: PLOG_FILE_OBJECT,
        ePoolType: POOL_TYPE,
        pfnAllocBuffer: PALLOCATE_FUNCTION,
        pfnFreeBuffer: PFREE_FUNCTION,
        cbMarshallingBuffer: ULONG,
        cMaxWriteBuffers: ULONG,
        cMaxReadBuffers: ULONG,
        cAlignmentSize: ULONG,
        fFlags: ULONGLONG,
        ppvMarshalContext: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsDeleteMarshallingArea(pvMarshalContext: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsReserveAndAppendLog(
        pvMarshalContext: PVOID,
        rgWriteEntries: PCLFS_WRITE_ENTRY,
        cWriteEntries: ULONG,
        plsnUndoNext: PCLFS_LSN,
        plsnPrevious: PCLFS_LSN,
        cReserveRecords: ULONG,
        rgcbReservation: PLONGLONG,
        fFlags: ULONG,
        plsn: PCLFS_LSN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsReserveAndAppendLogAligned(
        pvMarshalContext: PVOID,
        rgWriteEntries: PCLFS_WRITE_ENTRY,
        cWriteEntries: ULONG,
        cbEntryAlignment: ULONG,
        plsnUndoNext: PCLFS_LSN,
        plsnPrevious: PCLFS_LSN,
        cReserveRecords: ULONG,
        rgcbReservation: PLONGLONG,
        fFlags: ULONG,
        plsn: PCLFS_LSN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsAlignReservedLog(
        pvMarshalContext: PVOID,
        cRecords: ULONG,
        rgcbReservation: *mut LONGLONG,
        pcbAlignReservation: PLONGLONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsAllocReservedLog(
        pvMarshalContext: PVOID,
        cRecords: ULONG,
        pcbAdjustment: PLONGLONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsFreeReservedLog(
        pvMarshalContext: PVOID,
        cRecords: ULONG,
        pcbAdjustment: PLONGLONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsFlushBuffers(pvMarshalContext: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsFlushToLsn(
        pvMarshalContext: PVOID,
        plsnFlush: PCLFS_LSN,
        plsnLastFlushed: PCLFS_LSN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsReadLogRecord(
        pvMarshalContext: PVOID,
        plsnFirst: PCLFS_LSN,
        peContextMode: CLFS_CONTEXT_MODE,
        ppvReadBuffer: *mut PVOID,
        pcbReadBuffer: PULONG,
        peRecordType: PCLFS_RECORD_TYPE,
        plsnUndoNext: PCLFS_LSN,
        plsnPrevious: PCLFS_LSN,
        ppvReadContext: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsReadNextLogRecord(
        pvReadContext: PVOID,
        ppvBuffer: *mut PVOID,
        pcbBuffer: PULONG,
        peRecordType: PCLFS_RECORD_TYPE,
        plsnUser: PCLFS_LSN,
        plsnUndoNext: PCLFS_LSN,
        plsnPrevious: PCLFS_LSN,
        plsnRecord: PCLFS_LSN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsTerminateReadLog(pvCursorContext: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsGetLastLsn(plfoLog: PLOG_FILE_OBJECT, plsnLast: PCLFS_LSN) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsGetIoStatistics(
        plfoLog: PLOG_FILE_OBJECT,
        pvStatsBuffer: PVOID,
        cbStatsBuffer: ULONG,
        eStatsClass: CLFS_IOSTATS_CLASS,
        pcbStatsWritten: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsLaterLsn(plsn: PCLFS_LSN) -> CLFS_LSN;
}
unsafe extern "C" {
    pub fn ClfsEarlierLsn(plsn: PCLFS_LSN) -> CLFS_LSN;
}
unsafe extern "C" {
    pub fn ClfsLsnDifference(
        plsnStart: PCLFS_LSN,
        plsnFinish: PCLFS_LSN,
        cbContainer: ULONG,
        cbMaxBlock: ULONG,
        pcbDifference: PLONGLONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsValidTopLevelContext(pirpTopLevelContext: PIRP) -> BOOLEAN;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTRANSACTION {
    _unused: [u8; 0],
}
pub type KTRANSACTION = _KTRANSACTION;
pub type PKTRANSACTION = *mut _KTRANSACTION;
pub type PRKTRANSACTION = *mut _KTRANSACTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KENLISTMENT {
    _unused: [u8; 0],
}
pub type KENLISTMENT = _KENLISTMENT;
pub type PKENLISTMENT = *mut _KENLISTMENT;
pub type PRKENLISTMENT = *mut _KENLISTMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KRESOURCEMANAGER {
    _unused: [u8; 0],
}
pub type KRESOURCEMANAGER = _KRESOURCEMANAGER;
pub type PKRESOURCEMANAGER = *mut _KRESOURCEMANAGER;
pub type PRKRESOURCEMANAGER = *mut _KRESOURCEMANAGER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTM {
    _unused: [u8; 0],
}
pub type KTM = _KTM;
pub type PKTM = *mut _KTM;
pub type PRKTM = *mut _KTM;
pub type PGUID = *mut GUID;
pub type PTM_RM_NOTIFICATION = ::core::option::Option<
    unsafe extern "C" fn(
        EnlistmentObject: PKENLISTMENT,
        RMContext: PVOID,
        TransactionContext: PVOID,
        TransactionNotification: ULONG,
        TmVirtualClock: PLARGE_INTEGER,
        ArgumentLength: ULONG,
        Argument: PVOID,
    ) -> NTSTATUS,
>;
pub type KCRM_PROTOCOL_ID = GUID;
pub type PKCRM_PROTOCOL_ID = *mut GUID;
pub type PTM_PROPAGATE_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(
        PropagationCookie: PVOID,
        CallbackData: PVOID,
        PropagationStatus: NTSTATUS,
        TransactionGuid: GUID,
    ) -> NTSTATUS,
>;
unsafe extern "C" {
    pub fn TmInitializeTransactionManager(
        TransactionManager: PRKTM,
        LogFileName: PCUNICODE_STRING,
        TmId: PGUID,
        CreateOptions: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmRenameTransactionManager(
        LogFileName: PUNICODE_STRING,
        ExistingTransactionManagerGuid: LPGUID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmRecoverTransactionManager(Tm: PKTM, TargetVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmCommitTransaction(Transaction: PKTRANSACTION, Wait: BOOLEAN) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmRollbackTransaction(Transaction: PKTRANSACTION, Wait: BOOLEAN) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmCreateEnlistment(
        EnlistmentHandle: PHANDLE,
        PreviousMode: KPROCESSOR_MODE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        ResourceManager: PRKRESOURCEMANAGER,
        Transaction: PKTRANSACTION,
        CreateOptions: ULONG,
        NotificationMask: NOTIFICATION_MASK,
        EnlistmentKey: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmRecoverEnlistment(Enlistment: PKENLISTMENT, EnlistmentKey: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmPrePrepareEnlistment(
        Enlistment: PKENLISTMENT,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmPrepareEnlistment(
        Enlistment: PKENLISTMENT,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmCommitEnlistment(Enlistment: PKENLISTMENT, TmVirtualClock: PLARGE_INTEGER)
                              -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmRollbackEnlistment(
        Enlistment: PKENLISTMENT,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmPrePrepareComplete(
        Enlistment: PKENLISTMENT,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmPrepareComplete(Enlistment: PKENLISTMENT, TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmReadOnlyEnlistment(
        Enlistment: PKENLISTMENT,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmCommitComplete(Enlistment: PKENLISTMENT, TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmRollbackComplete(Enlistment: PKENLISTMENT, TmVirtualClock: PLARGE_INTEGER)
                              -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmReferenceEnlistmentKey(Enlistment: PKENLISTMENT, Key: *mut PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmDereferenceEnlistmentKey(
        Enlistment: PKENLISTMENT,
        LastReference: PBOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmSinglePhaseReject(
        Enlistment: PKENLISTMENT,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmRequestOutcomeEnlistment(
        Enlistment: PKENLISTMENT,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmEnableCallbacks(
        ResourceManager: PKRESOURCEMANAGER,
        CallbackRoutine: PTM_RM_NOTIFICATION,
        RMKey: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmRecoverResourceManager(ResourceManager: PKRESOURCEMANAGER) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmPropagationComplete(
        ResourceManager: PKRESOURCEMANAGER,
        RequestCookie: ULONG,
        BufferLength: ULONG,
        Buffer: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmPropagationFailed(
        ResourceManager: PKRESOURCEMANAGER,
        RequestCookie: ULONG,
        Status: NTSTATUS,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmGetTransactionId(Transaction: PKTRANSACTION, TransactionId: PUOW);
}
unsafe extern "C" {
    pub fn TmIsTransactionActive(Transaction: PKTRANSACTION) -> BOOLEAN;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCW_INSTANCE {
    _unused: [u8; 0],
}
pub type PPCW_INSTANCE = *mut _PCW_INSTANCE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCW_REGISTRATION {
    _unused: [u8; 0],
}
pub type PPCW_REGISTRATION = *mut _PCW_REGISTRATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCW_BUFFER {
    _unused: [u8; 0],
}
pub type PPCW_BUFFER = *mut _PCW_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCW_COUNTER_DESCRIPTOR {
    pub Id: USHORT,
    pub StructIndex: USHORT,
    pub Offset: USHORT,
    pub Size: USHORT,
}
pub type PCW_COUNTER_DESCRIPTOR = _PCW_COUNTER_DESCRIPTOR;
pub type PPCW_COUNTER_DESCRIPTOR = *mut _PCW_COUNTER_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCW_DATA {
    pub Data: *const core::ffi::c_void,
    pub Size: ULONG,
}
pub type PCW_DATA = _PCW_DATA;
pub type PPCW_DATA = *mut _PCW_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCW_COUNTER_INFORMATION {
    pub CounterMask: ULONG64,
    pub InstanceMask: PCUNICODE_STRING,
}
pub type PCW_COUNTER_INFORMATION = _PCW_COUNTER_INFORMATION;
pub type PPCW_COUNTER_INFORMATION = *mut _PCW_COUNTER_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCW_MASK_INFORMATION {
    pub CounterMask: ULONG64,
    pub InstanceMask: PCUNICODE_STRING,
    pub InstanceId: ULONG,
    pub CollectMultiple: BOOLEAN,
    pub Buffer: PPCW_BUFFER,
    pub CancelEvent: PKEVENT,
}
pub type PCW_MASK_INFORMATION = _PCW_MASK_INFORMATION;
pub type PPCW_MASK_INFORMATION = *mut _PCW_MASK_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCW_CALLBACK_INFORMATION {
    pub AddCounter: PCW_COUNTER_INFORMATION,
    pub RemoveCounter: PCW_COUNTER_INFORMATION,
    pub EnumerateInstances: PCW_MASK_INFORMATION,
    pub CollectData: PCW_MASK_INFORMATION,
}
pub type PCW_CALLBACK_INFORMATION = _PCW_CALLBACK_INFORMATION;
pub type PPCW_CALLBACK_INFORMATION = *mut _PCW_CALLBACK_INFORMATION;
pub const _PCW_CALLBACK_TYPE_PcwCallbackAddCounter: _PCW_CALLBACK_TYPE = 0;
pub const _PCW_CALLBACK_TYPE_PcwCallbackRemoveCounter: _PCW_CALLBACK_TYPE = 1;
pub const _PCW_CALLBACK_TYPE_PcwCallbackEnumerateInstances: _PCW_CALLBACK_TYPE = 2;
pub const _PCW_CALLBACK_TYPE_PcwCallbackCollectData: _PCW_CALLBACK_TYPE = 3;
pub type _PCW_CALLBACK_TYPE = core::ffi::c_int;
pub use self::_PCW_CALLBACK_TYPE as PCW_CALLBACK_TYPE;
pub type PPCW_CALLBACK_TYPE = *mut _PCW_CALLBACK_TYPE;
pub type PPCW_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: PCW_CALLBACK_TYPE,
        arg2: PPCW_CALLBACK_INFORMATION,
        arg3: PVOID,
    ) -> NTSTATUS,
>;
pub const PCW_REGISTRATION_FLAGS_PcwRegistrationNone: PCW_REGISTRATION_FLAGS = 0;
pub const PCW_REGISTRATION_FLAGS_PcwRegistrationSiloNeutral: PCW_REGISTRATION_FLAGS = 1;
pub type PCW_REGISTRATION_FLAGS = core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCW_REGISTRATION_INFORMATION {
    pub Version: ULONG,
    pub Name: PCUNICODE_STRING,
    pub CounterCount: ULONG,
    pub Counters: PPCW_COUNTER_DESCRIPTOR,
    pub Callback: PPCW_CALLBACK,
    pub CallbackContext: PVOID,
    pub Flags: PCW_REGISTRATION_FLAGS,
}
pub type PCW_REGISTRATION_INFORMATION = _PCW_REGISTRATION_INFORMATION;
pub type PPCW_REGISTRATION_INFORMATION = *mut _PCW_REGISTRATION_INFORMATION;
unsafe extern "C" {
    pub fn PcwRegister(
        Registration: *mut PPCW_REGISTRATION,
        Info: PPCW_REGISTRATION_INFORMATION,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PcwUnregister(Registration: PPCW_REGISTRATION);
}
unsafe extern "C" {
    pub fn PcwCreateInstance(
        Instance: *mut PPCW_INSTANCE,
        Registration: PPCW_REGISTRATION,
        Name: PCUNICODE_STRING,
        Count: ULONG,
        Data: PPCW_DATA,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PcwCloseInstance(Instance: PPCW_INSTANCE);
}
unsafe extern "C" {
    pub fn PcwAddInstance(
        Buffer: PPCW_BUFFER,
        Name: PCUNICODE_STRING,
        Id: ULONG,
        Count: ULONG,
        Data: PPCW_DATA,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn VslCreateSecureSection(
        Handle: PHANDLE,
        TargetProcess: PEPROCESS,
        Mdl: PMDL,
        DevicePageProtection: ULONG,
        Attributes: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn VslDeleteSecureSection(GlobalHandle: HANDLE) -> NTSTATUS;
}
pub const _DRIVER_RUNTIME_INIT_FLAGS_DrvRtPoolNxOptIn: _DRIVER_RUNTIME_INIT_FLAGS = 1;
pub const _DRIVER_RUNTIME_INIT_FLAGS_LastDrvRtFlag: _DRIVER_RUNTIME_INIT_FLAGS = 2;
pub type _DRIVER_RUNTIME_INIT_FLAGS = core::ffi::c_int;
pub use self::_DRIVER_RUNTIME_INIT_FLAGS as DRIVER_RUNTIME_INIT_FLAGS;
pub type PDRIVER_RUNTIME_INIT_FLAGS = *mut _DRIVER_RUNTIME_INIT_FLAGS;
pub type PCDRIVER_RUNTIME_INIT_FLAGS = *const _DRIVER_RUNTIME_INIT_FLAGS;
unsafe extern "C" {
    pub static mut CmKeyObjectType: *mut POBJECT_TYPE;
}
unsafe extern "C" {
    pub static mut IoFileObjectType: *mut POBJECT_TYPE;
}
unsafe extern "C" {
    pub static mut ExEventObjectType: *mut POBJECT_TYPE;
}
unsafe extern "C" {
    pub static mut ExSemaphoreObjectType: *mut POBJECT_TYPE;
}
unsafe extern "C" {
    pub static mut TmTransactionManagerObjectType: *mut POBJECT_TYPE;
}
unsafe extern "C" {
    pub static mut TmResourceManagerObjectType: *mut POBJECT_TYPE;
}
unsafe extern "C" {
    pub static mut TmEnlistmentObjectType: *mut POBJECT_TYPE;
}
unsafe extern "C" {
    pub static mut TmTransactionObjectType: *mut POBJECT_TYPE;
}
unsafe extern "C" {
    pub static mut PsProcessType: *mut POBJECT_TYPE;
}
unsafe extern "C" {
    pub static mut PsThreadType: *mut POBJECT_TYPE;
}
unsafe extern "C" {
    pub static mut PsJobType: *mut POBJECT_TYPE;
}
unsafe extern "C" {
    pub static mut SeTokenObjectType: *mut POBJECT_TYPE;
}
unsafe extern "C" {
    pub static mut ExDesktopObjectType: *mut POBJECT_TYPE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KQUEUE {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IORING_OBJECT {
    pub _address: u8,
}
