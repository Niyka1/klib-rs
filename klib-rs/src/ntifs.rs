/* automatically generated by rust-bindgen 0.72.1 */
#![allow(warnings)]
use crate::PVOID;
#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize)
        };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val { byte | mask } else { byte & !mask }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize)
        };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
#[doc = r" If Bindgen could only determine the size and alignment of a"]
#[doc = r" type, it is represented like this."]
#[derive(PartialEq, Copy, Clone, Debug, Hash)]
#[repr(C)]
pub struct __BindgenOpaqueArray<T: Copy, const N: usize>(pub [T; N]);
impl<T: Copy + Default, const N: usize> Default for __BindgenOpaqueArray<T, N> {
    fn default() -> Self {
        Self([<T as Default>::default(); N])
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const _STRSAFE_USE_SECURE_CRT: u32 = 0;
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_CXX26: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const EXCEPTION_EXECUTE_HANDLER: u32 = 1;
pub const EXCEPTION_CONTINUE_SEARCH: u32 = 0;
pub const EXCEPTION_CONTINUE_EXECUTION: i32 = -1;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _CRT_HAS_C11: u32 = 1;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const _STATIC_INLINE_UCRT_FUNCTIONS: u32 = 1;
pub const _UPPER: u32 = 1;
pub const _LOWER: u32 = 2;
pub const _DIGIT: u32 = 4;
pub const _SPACE: u32 = 8;
pub const _PUNCT: u32 = 16;
pub const _CONTROL: u32 = 32;
pub const _BLANK: u32 = 64;
pub const _HEX: u32 = 128;
pub const _LEADBYTE: u32 = 32768;
pub const _ALPHA: u32 = 259;
pub const WINAPI_FAMILY_PC_APP: u32 = 2;
pub const WINAPI_FAMILY_PHONE_APP: u32 = 3;
pub const WINAPI_FAMILY_SYSTEM: u32 = 4;
pub const WINAPI_FAMILY_SERVER: u32 = 5;
pub const WINAPI_FAMILY_GAMES: u32 = 6;
pub const WINAPI_FAMILY_DESKTOP_APP: u32 = 100;
pub const WINAPI_FAMILY_APP: u32 = 2;
pub const WINAPI_FAMILY: u32 = 100;
pub const ANYSIZE_ARRAY: u32 = 1;
pub const __SAL_H_FULL_VER: u32 = 140050727;
pub const __SPECSTRINGS_STRICT_LEVEL: u32 = 1;
pub const __drv_typeConst: u32 = 0;
pub const __drv_typeCond: u32 = 1;
pub const __drv_typeBitset: u32 = 2;
pub const __drv_typeExpr: u32 = 3;
pub const DISPATCH_LEVEL: u32 = 2;
pub const APC_LEVEL: u32 = 1;
pub const PASSIVE_LEVEL: u32 = 0;
pub const HIGH_LEVEL: u32 = 15;
pub const MEMORY_ALLOCATION_ALIGNMENT: u32 = 16;
pub const X86_CACHE_ALIGNMENT_SIZE: u32 = 64;
pub const ARM_CACHE_ALIGNMENT_SIZE: u32 = 128;
pub const SYSTEM_CACHE_ALIGNMENT_SIZE: u32 = 64;
pub const PRAGMA_DEPRECATED_DDK: u32 = 0;
pub const UCSCHAR_INVALID_CHARACTER: u32 = 4294967295;
pub const MIN_UCSCHAR: u32 = 0;
pub const MAX_UCSCHAR: u32 = 1114111;
pub const STRICT: u32 = 1;
pub const ALL_PROCESSOR_GROUPS: u32 = 65535;
pub const MAXIMUM_PROC_PER_GROUP: u32 = 64;
pub const MAXIMUM_PROCESSORS: u32 = 64;
pub const OBJ_HANDLE_TAGBITS: u32 = 3;
pub const APPLICATION_ERROR_MASK: u32 = 536870912;
pub const ERROR_SEVERITY_SUCCESS: u32 = 0;
pub const ERROR_SEVERITY_INFORMATIONAL: u32 = 1073741824;
pub const ERROR_SEVERITY_WARNING: u32 = 2147483648;
pub const ERROR_SEVERITY_ERROR: u32 = 3221225472;
pub const MAXLONGLONG: u64 = 9223372036854775807;
pub const UNICODE_STRING_MAX_CHARS: u32 = 32767;
pub const RTL_BALANCED_NODE_RESERVED_PARENT_MASK: u32 = 3;
pub const OBJ_INHERIT: u32 = 2;
pub const OBJ_PERMANENT: u32 = 16;
pub const OBJ_EXCLUSIVE: u32 = 32;
pub const OBJ_CASE_INSENSITIVE: u32 = 64;
pub const OBJ_OPENIF: u32 = 128;
pub const OBJ_OPENLINK: u32 = 256;
pub const OBJ_KERNEL_HANDLE: u32 = 512;
pub const OBJ_FORCE_ACCESS_CHECK: u32 = 1024;
pub const OBJ_IGNORE_IMPERSONATED_DEVICEMAP: u32 = 2048;
pub const OBJ_DONT_REPARSE: u32 = 4096;
pub const OBJ_VALID_ATTRIBUTES: u32 = 8178;
pub const FALSE: u32 = 0;
pub const TRUE: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const EDEADLK: u32 = 36;
pub const ENAMETOOLONG: u32 = 38;
pub const ENOLCK: u32 = 39;
pub const ENOSYS: u32 = 40;
pub const ENOTEMPTY: u32 = 41;
pub const EINVAL: u32 = 22;
pub const ERANGE: u32 = 34;
pub const EILSEQ: u32 = 42;
pub const STRUNCATE: u32 = 80;
pub const EDEADLOCK: u32 = 36;
pub const EADDRINUSE: u32 = 100;
pub const EADDRNOTAVAIL: u32 = 101;
pub const EAFNOSUPPORT: u32 = 102;
pub const EALREADY: u32 = 103;
pub const EBADMSG: u32 = 104;
pub const ECANCELED: u32 = 105;
pub const ECONNABORTED: u32 = 106;
pub const ECONNREFUSED: u32 = 107;
pub const ECONNRESET: u32 = 108;
pub const EDESTADDRREQ: u32 = 109;
pub const EHOSTUNREACH: u32 = 110;
pub const EIDRM: u32 = 111;
pub const EINPROGRESS: u32 = 112;
pub const EISCONN: u32 = 113;
pub const ELOOP: u32 = 114;
pub const EMSGSIZE: u32 = 115;
pub const ENETDOWN: u32 = 116;
pub const ENETRESET: u32 = 117;
pub const ENETUNREACH: u32 = 118;
pub const ENOBUFS: u32 = 119;
pub const ENODATA: u32 = 120;
pub const ENOLINK: u32 = 121;
pub const ENOMSG: u32 = 122;
pub const ENOPROTOOPT: u32 = 123;
pub const ENOSR: u32 = 124;
pub const ENOSTR: u32 = 125;
pub const ENOTCONN: u32 = 126;
pub const ENOTRECOVERABLE: u32 = 127;
pub const ENOTSOCK: u32 = 128;
pub const ENOTSUP: u32 = 129;
pub const EOPNOTSUPP: u32 = 130;
pub const EOTHER: u32 = 131;
pub const EOVERFLOW: u32 = 132;
pub const EOWNERDEAD: u32 = 133;
pub const EPROTO: u32 = 134;
pub const EPROTONOSUPPORT: u32 = 135;
pub const EPROTOTYPE: u32 = 136;
pub const ETIME: u32 = 137;
pub const ETIMEDOUT: u32 = 138;
pub const ETXTBSY: u32 = 139;
pub const EWOULDBLOCK: u32 = 140;
pub const _NLSCMPERROR: u32 = 2147483647;
pub const MINCHAR: u32 = 128;
pub const MAXCHAR: u32 = 127;
pub const MINSHORT: u32 = 32768;
pub const MAXSHORT: u32 = 32767;
pub const MINLONG: u32 = 2147483648;
pub const MAXLONG: u32 = 2147483647;
pub const MAXUCHAR: u32 = 255;
pub const MAXUSHORT: u32 = 65535;
pub const MAXULONG: u32 = 4294967295;
pub const ENCLAVE_SHORT_ID_LENGTH: u32 = 16;
pub const ENCLAVE_LONG_ID_LENGTH: u32 = 32;
pub const VER_SERVER_NT: u32 = 2147483648;
pub const VER_WORKSTATION_NT: u32 = 1073741824;
pub const VER_SUITE_SMALLBUSINESS: u32 = 1;
pub const VER_SUITE_ENTERPRISE: u32 = 2;
pub const VER_SUITE_BACKOFFICE: u32 = 4;
pub const VER_SUITE_COMMUNICATIONS: u32 = 8;
pub const VER_SUITE_TERMINAL: u32 = 16;
pub const VER_SUITE_SMALLBUSINESS_RESTRICTED: u32 = 32;
pub const VER_SUITE_EMBEDDEDNT: u32 = 64;
pub const VER_SUITE_DATACENTER: u32 = 128;
pub const VER_SUITE_SINGLEUSERTS: u32 = 256;
pub const VER_SUITE_PERSONAL: u32 = 512;
pub const VER_SUITE_BLADE: u32 = 1024;
pub const VER_SUITE_EMBEDDED_RESTRICTED: u32 = 2048;
pub const VER_SUITE_SECURITY_APPLIANCE: u32 = 4096;
pub const VER_SUITE_STORAGE_SERVER: u32 = 8192;
pub const VER_SUITE_COMPUTE_SERVER: u32 = 16384;
pub const VER_SUITE_WH_SERVER: u32 = 32768;
pub const VER_SUITE_MULTIUSERTS: u32 = 131072;
pub const PRODUCT_UNDEFINED: u32 = 0;
pub const PRODUCT_ULTIMATE: u32 = 1;
pub const PRODUCT_HOME_BASIC: u32 = 2;
pub const PRODUCT_HOME_PREMIUM: u32 = 3;
pub const PRODUCT_ENTERPRISE: u32 = 4;
pub const PRODUCT_HOME_BASIC_N: u32 = 5;
pub const PRODUCT_BUSINESS: u32 = 6;
pub const PRODUCT_STANDARD_SERVER: u32 = 7;
pub const PRODUCT_DATACENTER_SERVER: u32 = 8;
pub const PRODUCT_SMALLBUSINESS_SERVER: u32 = 9;
pub const PRODUCT_ENTERPRISE_SERVER: u32 = 10;
pub const PRODUCT_STARTER: u32 = 11;
pub const PRODUCT_DATACENTER_SERVER_CORE: u32 = 12;
pub const PRODUCT_STANDARD_SERVER_CORE: u32 = 13;
pub const PRODUCT_ENTERPRISE_SERVER_CORE: u32 = 14;
pub const PRODUCT_ENTERPRISE_SERVER_IA64: u32 = 15;
pub const PRODUCT_BUSINESS_N: u32 = 16;
pub const PRODUCT_WEB_SERVER: u32 = 17;
pub const PRODUCT_CLUSTER_SERVER: u32 = 18;
pub const PRODUCT_HOME_SERVER: u32 = 19;
pub const PRODUCT_STORAGE_EXPRESS_SERVER: u32 = 20;
pub const PRODUCT_STORAGE_STANDARD_SERVER: u32 = 21;
pub const PRODUCT_STORAGE_WORKGROUP_SERVER: u32 = 22;
pub const PRODUCT_STORAGE_ENTERPRISE_SERVER: u32 = 23;
pub const PRODUCT_SERVER_FOR_SMALLBUSINESS: u32 = 24;
pub const PRODUCT_SMALLBUSINESS_SERVER_PREMIUM: u32 = 25;
pub const PRODUCT_HOME_PREMIUM_N: u32 = 26;
pub const PRODUCT_ENTERPRISE_N: u32 = 27;
pub const PRODUCT_ULTIMATE_N: u32 = 28;
pub const PRODUCT_WEB_SERVER_CORE: u32 = 29;
pub const PRODUCT_MEDIUMBUSINESS_SERVER_MANAGEMENT: u32 = 30;
pub const PRODUCT_MEDIUMBUSINESS_SERVER_SECURITY: u32 = 31;
pub const PRODUCT_MEDIUMBUSINESS_SERVER_MESSAGING: u32 = 32;
pub const PRODUCT_SERVER_FOUNDATION: u32 = 33;
pub const PRODUCT_HOME_PREMIUM_SERVER: u32 = 34;
pub const PRODUCT_SERVER_FOR_SMALLBUSINESS_V: u32 = 35;
pub const PRODUCT_STANDARD_SERVER_V: u32 = 36;
pub const PRODUCT_DATACENTER_SERVER_V: u32 = 37;
pub const PRODUCT_ENTERPRISE_SERVER_V: u32 = 38;
pub const PRODUCT_DATACENTER_SERVER_CORE_V: u32 = 39;
pub const PRODUCT_STANDARD_SERVER_CORE_V: u32 = 40;
pub const PRODUCT_ENTERPRISE_SERVER_CORE_V: u32 = 41;
pub const PRODUCT_HYPERV: u32 = 42;
pub const PRODUCT_STORAGE_EXPRESS_SERVER_CORE: u32 = 43;
pub const PRODUCT_STORAGE_STANDARD_SERVER_CORE: u32 = 44;
pub const PRODUCT_STORAGE_WORKGROUP_SERVER_CORE: u32 = 45;
pub const PRODUCT_STORAGE_ENTERPRISE_SERVER_CORE: u32 = 46;
pub const PRODUCT_STARTER_N: u32 = 47;
pub const PRODUCT_PROFESSIONAL: u32 = 48;
pub const PRODUCT_PROFESSIONAL_N: u32 = 49;
pub const PRODUCT_SB_SOLUTION_SERVER: u32 = 50;
pub const PRODUCT_SERVER_FOR_SB_SOLUTIONS: u32 = 51;
pub const PRODUCT_STANDARD_SERVER_SOLUTIONS: u32 = 52;
pub const PRODUCT_STANDARD_SERVER_SOLUTIONS_CORE: u32 = 53;
pub const PRODUCT_SB_SOLUTION_SERVER_EM: u32 = 54;
pub const PRODUCT_SERVER_FOR_SB_SOLUTIONS_EM: u32 = 55;
pub const PRODUCT_SOLUTION_EMBEDDEDSERVER: u32 = 56;
pub const PRODUCT_SOLUTION_EMBEDDEDSERVER_CORE: u32 = 57;
pub const PRODUCT_PROFESSIONAL_EMBEDDED: u32 = 58;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_MGMT: u32 = 59;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_ADDL: u32 = 60;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_MGMTSVC: u32 = 61;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_ADDLSVC: u32 = 62;
pub const PRODUCT_SMALLBUSINESS_SERVER_PREMIUM_CORE: u32 = 63;
pub const PRODUCT_CLUSTER_SERVER_V: u32 = 64;
pub const PRODUCT_EMBEDDED: u32 = 65;
pub const PRODUCT_STARTER_E: u32 = 66;
pub const PRODUCT_HOME_BASIC_E: u32 = 67;
pub const PRODUCT_HOME_PREMIUM_E: u32 = 68;
pub const PRODUCT_PROFESSIONAL_E: u32 = 69;
pub const PRODUCT_ENTERPRISE_E: u32 = 70;
pub const PRODUCT_ULTIMATE_E: u32 = 71;
pub const PRODUCT_ENTERPRISE_EVALUATION: u32 = 72;
pub const PRODUCT_MULTIPOINT_STANDARD_SERVER: u32 = 76;
pub const PRODUCT_MULTIPOINT_PREMIUM_SERVER: u32 = 77;
pub const PRODUCT_STANDARD_EVALUATION_SERVER: u32 = 79;
pub const PRODUCT_DATACENTER_EVALUATION_SERVER: u32 = 80;
pub const PRODUCT_ENTERPRISE_N_EVALUATION: u32 = 84;
pub const PRODUCT_EMBEDDED_AUTOMOTIVE: u32 = 85;
pub const PRODUCT_EMBEDDED_INDUSTRY_A: u32 = 86;
pub const PRODUCT_THINPC: u32 = 87;
pub const PRODUCT_EMBEDDED_A: u32 = 88;
pub const PRODUCT_EMBEDDED_INDUSTRY: u32 = 89;
pub const PRODUCT_EMBEDDED_E: u32 = 90;
pub const PRODUCT_EMBEDDED_INDUSTRY_E: u32 = 91;
pub const PRODUCT_EMBEDDED_INDUSTRY_A_E: u32 = 92;
pub const PRODUCT_STORAGE_WORKGROUP_EVALUATION_SERVER: u32 = 95;
pub const PRODUCT_STORAGE_STANDARD_EVALUATION_SERVER: u32 = 96;
pub const PRODUCT_CORE_ARM: u32 = 97;
pub const PRODUCT_CORE_N: u32 = 98;
pub const PRODUCT_CORE_COUNTRYSPECIFIC: u32 = 99;
pub const PRODUCT_CORE_SINGLELANGUAGE: u32 = 100;
pub const PRODUCT_CORE: u32 = 101;
pub const PRODUCT_PROFESSIONAL_WMC: u32 = 103;
pub const PRODUCT_EMBEDDED_INDUSTRY_EVAL: u32 = 105;
pub const PRODUCT_EMBEDDED_INDUSTRY_E_EVAL: u32 = 106;
pub const PRODUCT_EMBEDDED_EVAL: u32 = 107;
pub const PRODUCT_EMBEDDED_E_EVAL: u32 = 108;
pub const PRODUCT_NANO_SERVER: u32 = 109;
pub const PRODUCT_CLOUD_STORAGE_SERVER: u32 = 110;
pub const PRODUCT_CORE_CONNECTED: u32 = 111;
pub const PRODUCT_PROFESSIONAL_STUDENT: u32 = 112;
pub const PRODUCT_CORE_CONNECTED_N: u32 = 113;
pub const PRODUCT_PROFESSIONAL_STUDENT_N: u32 = 114;
pub const PRODUCT_CORE_CONNECTED_SINGLELANGUAGE: u32 = 115;
pub const PRODUCT_CORE_CONNECTED_COUNTRYSPECIFIC: u32 = 116;
pub const PRODUCT_CONNECTED_CAR: u32 = 117;
pub const PRODUCT_INDUSTRY_HANDHELD: u32 = 118;
pub const PRODUCT_PPI_PRO: u32 = 119;
pub const PRODUCT_ARM64_SERVER: u32 = 120;
pub const PRODUCT_EDUCATION: u32 = 121;
pub const PRODUCT_EDUCATION_N: u32 = 122;
pub const PRODUCT_IOTUAP: u32 = 123;
pub const PRODUCT_CLOUD_HOST_INFRASTRUCTURE_SERVER: u32 = 124;
pub const PRODUCT_ENTERPRISE_S: u32 = 125;
pub const PRODUCT_ENTERPRISE_S_N: u32 = 126;
pub const PRODUCT_PROFESSIONAL_S: u32 = 127;
pub const PRODUCT_PROFESSIONAL_S_N: u32 = 128;
pub const PRODUCT_ENTERPRISE_S_EVALUATION: u32 = 129;
pub const PRODUCT_ENTERPRISE_S_N_EVALUATION: u32 = 130;
pub const PRODUCT_HOLOGRAPHIC: u32 = 135;
pub const PRODUCT_HOLOGRAPHIC_BUSINESS: u32 = 136;
pub const PRODUCT_PRO_SINGLE_LANGUAGE: u32 = 138;
pub const PRODUCT_PRO_CHINA: u32 = 139;
pub const PRODUCT_ENTERPRISE_SUBSCRIPTION: u32 = 140;
pub const PRODUCT_ENTERPRISE_SUBSCRIPTION_N: u32 = 141;
pub const PRODUCT_DATACENTER_NANO_SERVER: u32 = 143;
pub const PRODUCT_STANDARD_NANO_SERVER: u32 = 144;
pub const PRODUCT_DATACENTER_A_SERVER_CORE: u32 = 145;
pub const PRODUCT_STANDARD_A_SERVER_CORE: u32 = 146;
pub const PRODUCT_DATACENTER_WS_SERVER_CORE: u32 = 147;
pub const PRODUCT_STANDARD_WS_SERVER_CORE: u32 = 148;
pub const PRODUCT_UTILITY_VM: u32 = 149;
pub const PRODUCT_DATACENTER_EVALUATION_SERVER_CORE: u32 = 159;
pub const PRODUCT_STANDARD_EVALUATION_SERVER_CORE: u32 = 160;
pub const PRODUCT_PRO_WORKSTATION: u32 = 161;
pub const PRODUCT_PRO_WORKSTATION_N: u32 = 162;
pub const PRODUCT_PRO_FOR_EDUCATION: u32 = 164;
pub const PRODUCT_PRO_FOR_EDUCATION_N: u32 = 165;
pub const PRODUCT_AZURE_SERVER_CORE: u32 = 168;
pub const PRODUCT_AZURE_NANO_SERVER: u32 = 169;
pub const PRODUCT_ENTERPRISEG: u32 = 171;
pub const PRODUCT_ENTERPRISEGN: u32 = 172;
pub const PRODUCT_SERVERRDSH: u32 = 175;
pub const PRODUCT_CLOUD: u32 = 178;
pub const PRODUCT_CLOUDN: u32 = 179;
pub const PRODUCT_HUBOS: u32 = 180;
pub const PRODUCT_ONECOREUPDATEOS: u32 = 182;
pub const PRODUCT_CLOUDE: u32 = 183;
pub const PRODUCT_IOTOS: u32 = 185;
pub const PRODUCT_CLOUDEN: u32 = 186;
pub const PRODUCT_IOTEDGEOS: u32 = 187;
pub const PRODUCT_IOTENTERPRISE: u32 = 188;
pub const PRODUCT_LITE: u32 = 189;
pub const PRODUCT_IOTENTERPRISES: u32 = 191;
pub const PRODUCT_XBOX_SYSTEMOS: u32 = 192;
pub const PRODUCT_XBOX_GAMEOS: u32 = 194;
pub const PRODUCT_XBOX_ERAOS: u32 = 195;
pub const PRODUCT_XBOX_DURANGOHOSTOS: u32 = 196;
pub const PRODUCT_XBOX_SCARLETTHOSTOS: u32 = 197;
pub const PRODUCT_XBOX_KEYSTONE: u32 = 198;
pub const PRODUCT_AZURE_SERVER_CLOUDHOST: u32 = 199;
pub const PRODUCT_AZURE_SERVER_CLOUDMOS: u32 = 200;
pub const PRODUCT_CLOUDEDITIONN: u32 = 202;
pub const PRODUCT_CLOUDEDITION: u32 = 203;
pub const PRODUCT_VALIDATION: u32 = 204;
pub const PRODUCT_IOTENTERPRISESK: u32 = 205;
pub const PRODUCT_IOTENTERPRISEK: u32 = 206;
pub const PRODUCT_IOTENTERPRISESEVAL: u32 = 207;
pub const PRODUCT_AZURE_SERVER_AGENTBRIDGE: u32 = 208;
pub const PRODUCT_AZURE_SERVER_NANOHOST: u32 = 209;
pub const PRODUCT_WNC: u32 = 210;
pub const PRODUCT_AZURESTACKHCI_SERVER_CORE: u32 = 406;
pub const PRODUCT_DATACENTER_SERVER_AZURE_EDITION: u32 = 407;
pub const PRODUCT_DATACENTER_SERVER_CORE_AZURE_EDITION: u32 = 408;
pub const PRODUCT_DATACENTER_WS_SERVER_CORE_AZURE_EDITION: u32 = 409;
pub const PRODUCT_UNLICENSED: u32 = 2882382797;
pub const _WIN32_WINNT_NT4: u32 = 1024;
pub const _WIN32_WINNT_WIN2K: u32 = 1280;
pub const _WIN32_WINNT_WINXP: u32 = 1281;
pub const _WIN32_WINNT_WS03: u32 = 1282;
pub const _WIN32_WINNT_WIN6: u32 = 1536;
pub const _WIN32_WINNT_VISTA: u32 = 1536;
pub const _WIN32_WINNT_WS08: u32 = 1536;
pub const _WIN32_WINNT_LONGHORN: u32 = 1536;
pub const _WIN32_WINNT_WIN7: u32 = 1537;
pub const _WIN32_WINNT_WIN8: u32 = 1538;
pub const _WIN32_WINNT_WINBLUE: u32 = 1539;
pub const _WIN32_WINNT_WINTHRESHOLD: u32 = 2560;
pub const _WIN32_WINNT_WIN10: u32 = 2560;
pub const _WIN32_IE_IE20: u32 = 512;
pub const _WIN32_IE_IE30: u32 = 768;
pub const _WIN32_IE_IE302: u32 = 770;
pub const _WIN32_IE_IE40: u32 = 1024;
pub const _WIN32_IE_IE401: u32 = 1025;
pub const _WIN32_IE_IE50: u32 = 1280;
pub const _WIN32_IE_IE501: u32 = 1281;
pub const _WIN32_IE_IE55: u32 = 1360;
pub const _WIN32_IE_IE60: u32 = 1536;
pub const _WIN32_IE_IE60SP1: u32 = 1537;
pub const _WIN32_IE_IE60SP2: u32 = 1539;
pub const _WIN32_IE_IE70: u32 = 1792;
pub const _WIN32_IE_IE80: u32 = 2048;
pub const _WIN32_IE_IE90: u32 = 2304;
pub const _WIN32_IE_IE100: u32 = 2560;
pub const _WIN32_IE_IE110: u32 = 2560;
pub const _WIN32_IE_NT4: u32 = 512;
pub const _WIN32_IE_NT4SP1: u32 = 512;
pub const _WIN32_IE_NT4SP2: u32 = 512;
pub const _WIN32_IE_NT4SP3: u32 = 770;
pub const _WIN32_IE_NT4SP4: u32 = 1025;
pub const _WIN32_IE_NT4SP5: u32 = 1025;
pub const _WIN32_IE_NT4SP6: u32 = 1280;
pub const _WIN32_IE_WIN98: u32 = 1025;
pub const _WIN32_IE_WIN98SE: u32 = 1280;
pub const _WIN32_IE_WINME: u32 = 1360;
pub const _WIN32_IE_WIN2K: u32 = 1281;
pub const _WIN32_IE_WIN2KSP1: u32 = 1281;
pub const _WIN32_IE_WIN2KSP2: u32 = 1281;
pub const _WIN32_IE_WIN2KSP3: u32 = 1281;
pub const _WIN32_IE_WIN2KSP4: u32 = 1281;
pub const _WIN32_IE_XP: u32 = 1536;
pub const _WIN32_IE_XPSP1: u32 = 1537;
pub const _WIN32_IE_XPSP2: u32 = 1539;
pub const _WIN32_IE_WS03: u32 = 1538;
pub const _WIN32_IE_WS03SP1: u32 = 1539;
pub const _WIN32_IE_WIN6: u32 = 1792;
pub const _WIN32_IE_LONGHORN: u32 = 1792;
pub const _WIN32_IE_WIN7: u32 = 2048;
pub const _WIN32_IE_WIN8: u32 = 2560;
pub const _WIN32_IE_WINBLUE: u32 = 2560;
pub const _WIN32_IE_WINTHRESHOLD: u32 = 2560;
pub const _WIN32_IE_WIN10: u32 = 2560;
pub const NTDDI_WIN4: u32 = 67108864;
pub const NTDDI_WIN2K: u32 = 83886080;
pub const NTDDI_WIN2KSP1: u32 = 83886336;
pub const NTDDI_WIN2KSP2: u32 = 83886592;
pub const NTDDI_WIN2KSP3: u32 = 83886848;
pub const NTDDI_WIN2KSP4: u32 = 83887104;
pub const NTDDI_WINXP: u32 = 83951616;
pub const NTDDI_WINXPSP1: u32 = 83951872;
pub const NTDDI_WINXPSP2: u32 = 83952128;
pub const NTDDI_WINXPSP3: u32 = 83952384;
pub const NTDDI_WINXPSP4: u32 = 83952640;
pub const NTDDI_WS03: u32 = 84017152;
pub const NTDDI_WS03SP1: u32 = 84017408;
pub const NTDDI_WS03SP2: u32 = 84017664;
pub const NTDDI_WS03SP3: u32 = 84017920;
pub const NTDDI_WS03SP4: u32 = 84018176;
pub const NTDDI_WIN6: u32 = 100663296;
pub const NTDDI_WIN6SP1: u32 = 100663552;
pub const NTDDI_WIN6SP2: u32 = 100663808;
pub const NTDDI_WIN6SP3: u32 = 100664064;
pub const NTDDI_WIN6SP4: u32 = 100664320;
pub const NTDDI_VISTA: u32 = 100663296;
pub const NTDDI_VISTASP1: u32 = 100663552;
pub const NTDDI_VISTASP2: u32 = 100663808;
pub const NTDDI_VISTASP3: u32 = 100664064;
pub const NTDDI_VISTASP4: u32 = 100664320;
pub const NTDDI_LONGHORN: u32 = 100663296;
pub const NTDDI_WS08: u32 = 100663552;
pub const NTDDI_WS08SP2: u32 = 100663808;
pub const NTDDI_WS08SP3: u32 = 100664064;
pub const NTDDI_WS08SP4: u32 = 100664320;
pub const NTDDI_WIN7: u32 = 100728832;
pub const NTDDI_WIN8: u32 = 100794368;
pub const NTDDI_WINBLUE: u32 = 100859904;
pub const NTDDI_WINTHRESHOLD: u32 = 167772160;
pub const NTDDI_WIN10: u32 = 167772160;
pub const NTDDI_WIN10_TH2: u32 = 167772161;
pub const NTDDI_WIN10_RS1: u32 = 167772162;
pub const NTDDI_WIN10_RS2: u32 = 167772163;
pub const NTDDI_WIN10_RS3: u32 = 167772164;
pub const NTDDI_WIN10_RS4: u32 = 167772165;
pub const NTDDI_WIN10_RS5: u32 = 167772166;
pub const NTDDI_WIN10_19H1: u32 = 167772167;
pub const NTDDI_WIN10_VB: u32 = 167772168;
pub const NTDDI_WIN10_MN: u32 = 167772169;
pub const NTDDI_WIN10_FE: u32 = 167772170;
pub const NTDDI_WIN10_CO: u32 = 167772171;
pub const NTDDI_WIN10_NI: u32 = 167772172;
pub const NTDDI_WIN10_CU: u32 = 167772173;
pub const NTDDI_WIN11_ZN: u32 = 167772174;
pub const NTDDI_WIN11_GA: u32 = 167772175;
pub const NTDDI_WIN11_GE: u32 = 167772176;
pub const WDK_NTDDI_VERSION: u32 = 167772176;
pub const OSVERSION_MASK: u32 = 4294901760;
pub const SPVERSION_MASK: u32 = 65280;
pub const SUBVERSION_MASK: u32 = 255;
pub const _WIN32_IE: u32 = 2560;
pub const LANG_NEUTRAL: u32 = 0;
pub const LANG_INVARIANT: u32 = 127;
pub const LANG_AFRIKAANS: u32 = 54;
pub const LANG_ALBANIAN: u32 = 28;
pub const LANG_ALSATIAN: u32 = 132;
pub const LANG_AMHARIC: u32 = 94;
pub const LANG_ARABIC: u32 = 1;
pub const LANG_ARMENIAN: u32 = 43;
pub const LANG_ASSAMESE: u32 = 77;
pub const LANG_AZERI: u32 = 44;
pub const LANG_AZERBAIJANI: u32 = 44;
pub const LANG_BANGLA: u32 = 69;
pub const LANG_BASHKIR: u32 = 109;
pub const LANG_BASQUE: u32 = 45;
pub const LANG_BELARUSIAN: u32 = 35;
pub const LANG_BENGALI: u32 = 69;
pub const LANG_BRETON: u32 = 126;
pub const LANG_BOSNIAN: u32 = 26;
pub const LANG_BOSNIAN_NEUTRAL: u32 = 30746;
pub const LANG_BULGARIAN: u32 = 2;
pub const LANG_CATALAN: u32 = 3;
pub const LANG_CENTRAL_KURDISH: u32 = 146;
pub const LANG_CHEROKEE: u32 = 92;
pub const LANG_CHINESE: u32 = 4;
pub const LANG_CHINESE_SIMPLIFIED: u32 = 4;
pub const LANG_CHINESE_TRADITIONAL: u32 = 31748;
pub const LANG_CORSICAN: u32 = 131;
pub const LANG_CROATIAN: u32 = 26;
pub const LANG_CZECH: u32 = 5;
pub const LANG_DANISH: u32 = 6;
pub const LANG_DARI: u32 = 140;
pub const LANG_DIVEHI: u32 = 101;
pub const LANG_DUTCH: u32 = 19;
pub const LANG_ENGLISH: u32 = 9;
pub const LANG_ESTONIAN: u32 = 37;
pub const LANG_FAEROESE: u32 = 56;
pub const LANG_FARSI: u32 = 41;
pub const LANG_FILIPINO: u32 = 100;
pub const LANG_FINNISH: u32 = 11;
pub const LANG_FRENCH: u32 = 12;
pub const LANG_FRISIAN: u32 = 98;
pub const LANG_FULAH: u32 = 103;
pub const LANG_GALICIAN: u32 = 86;
pub const LANG_GEORGIAN: u32 = 55;
pub const LANG_GERMAN: u32 = 7;
pub const LANG_GREEK: u32 = 8;
pub const LANG_GREENLANDIC: u32 = 111;
pub const LANG_GUJARATI: u32 = 71;
pub const LANG_HAUSA: u32 = 104;
pub const LANG_HAWAIIAN: u32 = 117;
pub const LANG_HEBREW: u32 = 13;
pub const LANG_HINDI: u32 = 57;
pub const LANG_HUNGARIAN: u32 = 14;
pub const LANG_ICELANDIC: u32 = 15;
pub const LANG_IGBO: u32 = 112;
pub const LANG_INDONESIAN: u32 = 33;
pub const LANG_INUKTITUT: u32 = 93;
pub const LANG_IRISH: u32 = 60;
pub const LANG_ITALIAN: u32 = 16;
pub const LANG_JAPANESE: u32 = 17;
pub const LANG_KANNADA: u32 = 75;
pub const LANG_KASHMIRI: u32 = 96;
pub const LANG_KAZAK: u32 = 63;
pub const LANG_KHMER: u32 = 83;
pub const LANG_KICHE: u32 = 134;
pub const LANG_KINYARWANDA: u32 = 135;
pub const LANG_KONKANI: u32 = 87;
pub const LANG_KOREAN: u32 = 18;
pub const LANG_KYRGYZ: u32 = 64;
pub const LANG_LAO: u32 = 84;
pub const LANG_LATVIAN: u32 = 38;
pub const LANG_LITHUANIAN: u32 = 39;
pub const LANG_LOWER_SORBIAN: u32 = 46;
pub const LANG_LUXEMBOURGISH: u32 = 110;
pub const LANG_MACEDONIAN: u32 = 47;
pub const LANG_MALAY: u32 = 62;
pub const LANG_MALAYALAM: u32 = 76;
pub const LANG_MALTESE: u32 = 58;
pub const LANG_MANIPURI: u32 = 88;
pub const LANG_MAORI: u32 = 129;
pub const LANG_MAPUDUNGUN: u32 = 122;
pub const LANG_MARATHI: u32 = 78;
pub const LANG_MOHAWK: u32 = 124;
pub const LANG_MONGOLIAN: u32 = 80;
pub const LANG_NEPALI: u32 = 97;
pub const LANG_NORWEGIAN: u32 = 20;
pub const LANG_OCCITAN: u32 = 130;
pub const LANG_ODIA: u32 = 72;
pub const LANG_ORIYA: u32 = 72;
pub const LANG_PASHTO: u32 = 99;
pub const LANG_PERSIAN: u32 = 41;
pub const LANG_POLISH: u32 = 21;
pub const LANG_PORTUGUESE: u32 = 22;
pub const LANG_PULAR: u32 = 103;
pub const LANG_PUNJABI: u32 = 70;
pub const LANG_QUECHUA: u32 = 107;
pub const LANG_ROMANIAN: u32 = 24;
pub const LANG_ROMANSH: u32 = 23;
pub const LANG_RUSSIAN: u32 = 25;
pub const LANG_SAKHA: u32 = 133;
pub const LANG_SAMI: u32 = 59;
pub const LANG_SANSKRIT: u32 = 79;
pub const LANG_SCOTTISH_GAELIC: u32 = 145;
pub const LANG_SERBIAN: u32 = 26;
pub const LANG_SERBIAN_NEUTRAL: u32 = 31770;
pub const LANG_SINDHI: u32 = 89;
pub const LANG_SINHALESE: u32 = 91;
pub const LANG_SLOVAK: u32 = 27;
pub const LANG_SLOVENIAN: u32 = 36;
pub const LANG_SOTHO: u32 = 108;
pub const LANG_SPANISH: u32 = 10;
pub const LANG_SWAHILI: u32 = 65;
pub const LANG_SWEDISH: u32 = 29;
pub const LANG_SYRIAC: u32 = 90;
pub const LANG_TAJIK: u32 = 40;
pub const LANG_TAMAZIGHT: u32 = 95;
pub const LANG_TAMIL: u32 = 73;
pub const LANG_TATAR: u32 = 68;
pub const LANG_TELUGU: u32 = 74;
pub const LANG_THAI: u32 = 30;
pub const LANG_TIBETAN: u32 = 81;
pub const LANG_TIGRIGNA: u32 = 115;
pub const LANG_TIGRINYA: u32 = 115;
pub const LANG_TSWANA: u32 = 50;
pub const LANG_TURKISH: u32 = 31;
pub const LANG_TURKMEN: u32 = 66;
pub const LANG_UIGHUR: u32 = 128;
pub const LANG_UKRAINIAN: u32 = 34;
pub const LANG_UPPER_SORBIAN: u32 = 46;
pub const LANG_URDU: u32 = 32;
pub const LANG_UZBEK: u32 = 67;
pub const LANG_VALENCIAN: u32 = 3;
pub const LANG_VIETNAMESE: u32 = 42;
pub const LANG_WELSH: u32 = 82;
pub const LANG_WOLOF: u32 = 136;
pub const LANG_XHOSA: u32 = 52;
pub const LANG_YAKUT: u32 = 133;
pub const LANG_YI: u32 = 120;
pub const LANG_YORUBA: u32 = 106;
pub const LANG_ZULU: u32 = 53;
pub const SUBLANG_NEUTRAL: u32 = 0;
pub const SUBLANG_DEFAULT: u32 = 1;
pub const SUBLANG_SYS_DEFAULT: u32 = 2;
pub const SUBLANG_CUSTOM_DEFAULT: u32 = 3;
pub const SUBLANG_CUSTOM_UNSPECIFIED: u32 = 4;
pub const SUBLANG_UI_CUSTOM_DEFAULT: u32 = 5;
pub const SUBLANG_AFRIKAANS_SOUTH_AFRICA: u32 = 1;
pub const SUBLANG_ALBANIAN_ALBANIA: u32 = 1;
pub const SUBLANG_ALSATIAN_FRANCE: u32 = 1;
pub const SUBLANG_AMHARIC_ETHIOPIA: u32 = 1;
pub const SUBLANG_ARABIC_SAUDI_ARABIA: u32 = 1;
pub const SUBLANG_ARABIC_IRAQ: u32 = 2;
pub const SUBLANG_ARABIC_EGYPT: u32 = 3;
pub const SUBLANG_ARABIC_LIBYA: u32 = 4;
pub const SUBLANG_ARABIC_ALGERIA: u32 = 5;
pub const SUBLANG_ARABIC_MOROCCO: u32 = 6;
pub const SUBLANG_ARABIC_TUNISIA: u32 = 7;
pub const SUBLANG_ARABIC_OMAN: u32 = 8;
pub const SUBLANG_ARABIC_YEMEN: u32 = 9;
pub const SUBLANG_ARABIC_SYRIA: u32 = 10;
pub const SUBLANG_ARABIC_JORDAN: u32 = 11;
pub const SUBLANG_ARABIC_LEBANON: u32 = 12;
pub const SUBLANG_ARABIC_KUWAIT: u32 = 13;
pub const SUBLANG_ARABIC_UAE: u32 = 14;
pub const SUBLANG_ARABIC_BAHRAIN: u32 = 15;
pub const SUBLANG_ARABIC_QATAR: u32 = 16;
pub const SUBLANG_ARMENIAN_ARMENIA: u32 = 1;
pub const SUBLANG_ASSAMESE_INDIA: u32 = 1;
pub const SUBLANG_AZERI_LATIN: u32 = 1;
pub const SUBLANG_AZERI_CYRILLIC: u32 = 2;
pub const SUBLANG_AZERBAIJANI_AZERBAIJAN_LATIN: u32 = 1;
pub const SUBLANG_AZERBAIJANI_AZERBAIJAN_CYRILLIC: u32 = 2;
pub const SUBLANG_BANGLA_INDIA: u32 = 1;
pub const SUBLANG_BANGLA_BANGLADESH: u32 = 2;
pub const SUBLANG_BASHKIR_RUSSIA: u32 = 1;
pub const SUBLANG_BASQUE_BASQUE: u32 = 1;
pub const SUBLANG_BELARUSIAN_BELARUS: u32 = 1;
pub const SUBLANG_BENGALI_INDIA: u32 = 1;
pub const SUBLANG_BENGALI_BANGLADESH: u32 = 2;
pub const SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN: u32 = 5;
pub const SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC: u32 = 8;
pub const SUBLANG_BRETON_FRANCE: u32 = 1;
pub const SUBLANG_BULGARIAN_BULGARIA: u32 = 1;
pub const SUBLANG_CATALAN_CATALAN: u32 = 1;
pub const SUBLANG_CENTRAL_KURDISH_IRAQ: u32 = 1;
pub const SUBLANG_CHEROKEE_CHEROKEE: u32 = 1;
pub const SUBLANG_CHINESE_TRADITIONAL: u32 = 1;
pub const SUBLANG_CHINESE_SIMPLIFIED: u32 = 2;
pub const SUBLANG_CHINESE_HONGKONG: u32 = 3;
pub const SUBLANG_CHINESE_SINGAPORE: u32 = 4;
pub const SUBLANG_CHINESE_MACAU: u32 = 5;
pub const SUBLANG_CORSICAN_FRANCE: u32 = 1;
pub const SUBLANG_CZECH_CZECH_REPUBLIC: u32 = 1;
pub const SUBLANG_CROATIAN_CROATIA: u32 = 1;
pub const SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN: u32 = 4;
pub const SUBLANG_DANISH_DENMARK: u32 = 1;
pub const SUBLANG_DARI_AFGHANISTAN: u32 = 1;
pub const SUBLANG_DIVEHI_MALDIVES: u32 = 1;
pub const SUBLANG_DUTCH: u32 = 1;
pub const SUBLANG_DUTCH_BELGIAN: u32 = 2;
pub const SUBLANG_ENGLISH_US: u32 = 1;
pub const SUBLANG_ENGLISH_UK: u32 = 2;
pub const SUBLANG_ENGLISH_AUS: u32 = 3;
pub const SUBLANG_ENGLISH_CAN: u32 = 4;
pub const SUBLANG_ENGLISH_NZ: u32 = 5;
pub const SUBLANG_ENGLISH_EIRE: u32 = 6;
pub const SUBLANG_ENGLISH_SOUTH_AFRICA: u32 = 7;
pub const SUBLANG_ENGLISH_JAMAICA: u32 = 8;
pub const SUBLANG_ENGLISH_CARIBBEAN: u32 = 9;
pub const SUBLANG_ENGLISH_BELIZE: u32 = 10;
pub const SUBLANG_ENGLISH_TRINIDAD: u32 = 11;
pub const SUBLANG_ENGLISH_ZIMBABWE: u32 = 12;
pub const SUBLANG_ENGLISH_PHILIPPINES: u32 = 13;
pub const SUBLANG_ENGLISH_INDIA: u32 = 16;
pub const SUBLANG_ENGLISH_MALAYSIA: u32 = 17;
pub const SUBLANG_ENGLISH_SINGAPORE: u32 = 18;
pub const SUBLANG_ESTONIAN_ESTONIA: u32 = 1;
pub const SUBLANG_FAEROESE_FAROE_ISLANDS: u32 = 1;
pub const SUBLANG_FILIPINO_PHILIPPINES: u32 = 1;
pub const SUBLANG_FINNISH_FINLAND: u32 = 1;
pub const SUBLANG_FRENCH: u32 = 1;
pub const SUBLANG_FRENCH_BELGIAN: u32 = 2;
pub const SUBLANG_FRENCH_CANADIAN: u32 = 3;
pub const SUBLANG_FRENCH_SWISS: u32 = 4;
pub const SUBLANG_FRENCH_LUXEMBOURG: u32 = 5;
pub const SUBLANG_FRENCH_MONACO: u32 = 6;
pub const SUBLANG_FRISIAN_NETHERLANDS: u32 = 1;
pub const SUBLANG_FULAH_SENEGAL: u32 = 2;
pub const SUBLANG_GALICIAN_GALICIAN: u32 = 1;
pub const SUBLANG_GEORGIAN_GEORGIA: u32 = 1;
pub const SUBLANG_GERMAN: u32 = 1;
pub const SUBLANG_GERMAN_SWISS: u32 = 2;
pub const SUBLANG_GERMAN_AUSTRIAN: u32 = 3;
pub const SUBLANG_GERMAN_LUXEMBOURG: u32 = 4;
pub const SUBLANG_GERMAN_LIECHTENSTEIN: u32 = 5;
pub const SUBLANG_GREEK_GREECE: u32 = 1;
pub const SUBLANG_GREENLANDIC_GREENLAND: u32 = 1;
pub const SUBLANG_GUJARATI_INDIA: u32 = 1;
pub const SUBLANG_HAUSA_NIGERIA_LATIN: u32 = 1;
pub const SUBLANG_HAWAIIAN_US: u32 = 1;
pub const SUBLANG_HEBREW_ISRAEL: u32 = 1;
pub const SUBLANG_HINDI_INDIA: u32 = 1;
pub const SUBLANG_HUNGARIAN_HUNGARY: u32 = 1;
pub const SUBLANG_ICELANDIC_ICELAND: u32 = 1;
pub const SUBLANG_IGBO_NIGERIA: u32 = 1;
pub const SUBLANG_INDONESIAN_INDONESIA: u32 = 1;
pub const SUBLANG_INUKTITUT_CANADA: u32 = 1;
pub const SUBLANG_INUKTITUT_CANADA_LATIN: u32 = 2;
pub const SUBLANG_IRISH_IRELAND: u32 = 2;
pub const SUBLANG_ITALIAN: u32 = 1;
pub const SUBLANG_ITALIAN_SWISS: u32 = 2;
pub const SUBLANG_JAPANESE_JAPAN: u32 = 1;
pub const SUBLANG_KANNADA_INDIA: u32 = 1;
pub const SUBLANG_KASHMIRI_SASIA: u32 = 2;
pub const SUBLANG_KASHMIRI_INDIA: u32 = 2;
pub const SUBLANG_KAZAK_KAZAKHSTAN: u32 = 1;
pub const SUBLANG_KHMER_CAMBODIA: u32 = 1;
pub const SUBLANG_KICHE_GUATEMALA: u32 = 1;
pub const SUBLANG_KINYARWANDA_RWANDA: u32 = 1;
pub const SUBLANG_KONKANI_INDIA: u32 = 1;
pub const SUBLANG_KOREAN: u32 = 1;
pub const SUBLANG_KYRGYZ_KYRGYZSTAN: u32 = 1;
pub const SUBLANG_LAO_LAO: u32 = 1;
pub const SUBLANG_LATVIAN_LATVIA: u32 = 1;
pub const SUBLANG_LITHUANIAN: u32 = 1;
pub const SUBLANG_LOWER_SORBIAN_GERMANY: u32 = 2;
pub const SUBLANG_LUXEMBOURGISH_LUXEMBOURG: u32 = 1;
pub const SUBLANG_MACEDONIAN_MACEDONIA: u32 = 1;
pub const SUBLANG_MALAY_MALAYSIA: u32 = 1;
pub const SUBLANG_MALAY_BRUNEI_DARUSSALAM: u32 = 2;
pub const SUBLANG_MALAYALAM_INDIA: u32 = 1;
pub const SUBLANG_MALTESE_MALTA: u32 = 1;
pub const SUBLANG_MAORI_NEW_ZEALAND: u32 = 1;
pub const SUBLANG_MAPUDUNGUN_CHILE: u32 = 1;
pub const SUBLANG_MARATHI_INDIA: u32 = 1;
pub const SUBLANG_MOHAWK_MOHAWK: u32 = 1;
pub const SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA: u32 = 1;
pub const SUBLANG_MONGOLIAN_PRC: u32 = 2;
pub const SUBLANG_NEPALI_INDIA: u32 = 2;
pub const SUBLANG_NEPALI_NEPAL: u32 = 1;
pub const SUBLANG_NORWEGIAN_BOKMAL: u32 = 1;
pub const SUBLANG_NORWEGIAN_NYNORSK: u32 = 2;
pub const SUBLANG_OCCITAN_FRANCE: u32 = 1;
pub const SUBLANG_ODIA_INDIA: u32 = 1;
pub const SUBLANG_ORIYA_INDIA: u32 = 1;
pub const SUBLANG_PASHTO_AFGHANISTAN: u32 = 1;
pub const SUBLANG_PERSIAN_IRAN: u32 = 1;
pub const SUBLANG_POLISH_POLAND: u32 = 1;
pub const SUBLANG_PORTUGUESE: u32 = 2;
pub const SUBLANG_PORTUGUESE_BRAZILIAN: u32 = 1;
pub const SUBLANG_PULAR_SENEGAL: u32 = 2;
pub const SUBLANG_PUNJABI_INDIA: u32 = 1;
pub const SUBLANG_PUNJABI_PAKISTAN: u32 = 2;
pub const SUBLANG_QUECHUA_BOLIVIA: u32 = 1;
pub const SUBLANG_QUECHUA_ECUADOR: u32 = 2;
pub const SUBLANG_QUECHUA_PERU: u32 = 3;
pub const SUBLANG_ROMANIAN_ROMANIA: u32 = 1;
pub const SUBLANG_ROMANSH_SWITZERLAND: u32 = 1;
pub const SUBLANG_RUSSIAN_RUSSIA: u32 = 1;
pub const SUBLANG_SAKHA_RUSSIA: u32 = 1;
pub const SUBLANG_SAMI_NORTHERN_NORWAY: u32 = 1;
pub const SUBLANG_SAMI_NORTHERN_SWEDEN: u32 = 2;
pub const SUBLANG_SAMI_NORTHERN_FINLAND: u32 = 3;
pub const SUBLANG_SAMI_LULE_NORWAY: u32 = 4;
pub const SUBLANG_SAMI_LULE_SWEDEN: u32 = 5;
pub const SUBLANG_SAMI_SOUTHERN_NORWAY: u32 = 6;
pub const SUBLANG_SAMI_SOUTHERN_SWEDEN: u32 = 7;
pub const SUBLANG_SAMI_SKOLT_FINLAND: u32 = 8;
pub const SUBLANG_SAMI_INARI_FINLAND: u32 = 9;
pub const SUBLANG_SANSKRIT_INDIA: u32 = 1;
pub const SUBLANG_SCOTTISH_GAELIC: u32 = 1;
pub const SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_LATIN: u32 = 6;
pub const SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_CYRILLIC: u32 = 7;
pub const SUBLANG_SERBIAN_MONTENEGRO_LATIN: u32 = 11;
pub const SUBLANG_SERBIAN_MONTENEGRO_CYRILLIC: u32 = 12;
pub const SUBLANG_SERBIAN_SERBIA_LATIN: u32 = 9;
pub const SUBLANG_SERBIAN_SERBIA_CYRILLIC: u32 = 10;
pub const SUBLANG_SERBIAN_CROATIA: u32 = 1;
pub const SUBLANG_SERBIAN_LATIN: u32 = 2;
pub const SUBLANG_SERBIAN_CYRILLIC: u32 = 3;
pub const SUBLANG_SINDHI_INDIA: u32 = 1;
pub const SUBLANG_SINDHI_PAKISTAN: u32 = 2;
pub const SUBLANG_SINDHI_AFGHANISTAN: u32 = 2;
pub const SUBLANG_SINHALESE_SRI_LANKA: u32 = 1;
pub const SUBLANG_SOTHO_NORTHERN_SOUTH_AFRICA: u32 = 1;
pub const SUBLANG_SLOVAK_SLOVAKIA: u32 = 1;
pub const SUBLANG_SLOVENIAN_SLOVENIA: u32 = 1;
pub const SUBLANG_SPANISH: u32 = 1;
pub const SUBLANG_SPANISH_MEXICAN: u32 = 2;
pub const SUBLANG_SPANISH_MODERN: u32 = 3;
pub const SUBLANG_SPANISH_GUATEMALA: u32 = 4;
pub const SUBLANG_SPANISH_COSTA_RICA: u32 = 5;
pub const SUBLANG_SPANISH_PANAMA: u32 = 6;
pub const SUBLANG_SPANISH_DOMINICAN_REPUBLIC: u32 = 7;
pub const SUBLANG_SPANISH_VENEZUELA: u32 = 8;
pub const SUBLANG_SPANISH_COLOMBIA: u32 = 9;
pub const SUBLANG_SPANISH_PERU: u32 = 10;
pub const SUBLANG_SPANISH_ARGENTINA: u32 = 11;
pub const SUBLANG_SPANISH_ECUADOR: u32 = 12;
pub const SUBLANG_SPANISH_CHILE: u32 = 13;
pub const SUBLANG_SPANISH_URUGUAY: u32 = 14;
pub const SUBLANG_SPANISH_PARAGUAY: u32 = 15;
pub const SUBLANG_SPANISH_BOLIVIA: u32 = 16;
pub const SUBLANG_SPANISH_EL_SALVADOR: u32 = 17;
pub const SUBLANG_SPANISH_HONDURAS: u32 = 18;
pub const SUBLANG_SPANISH_NICARAGUA: u32 = 19;
pub const SUBLANG_SPANISH_PUERTO_RICO: u32 = 20;
pub const SUBLANG_SPANISH_US: u32 = 21;
pub const SUBLANG_SWAHILI_KENYA: u32 = 1;
pub const SUBLANG_SWEDISH: u32 = 1;
pub const SUBLANG_SWEDISH_FINLAND: u32 = 2;
pub const SUBLANG_SYRIAC_SYRIA: u32 = 1;
pub const SUBLANG_TAJIK_TAJIKISTAN: u32 = 1;
pub const SUBLANG_TAMAZIGHT_ALGERIA_LATIN: u32 = 2;
pub const SUBLANG_TAMAZIGHT_MOROCCO_TIFINAGH: u32 = 4;
pub const SUBLANG_TAMIL_INDIA: u32 = 1;
pub const SUBLANG_TAMIL_SRI_LANKA: u32 = 2;
pub const SUBLANG_TATAR_RUSSIA: u32 = 1;
pub const SUBLANG_TELUGU_INDIA: u32 = 1;
pub const SUBLANG_THAI_THAILAND: u32 = 1;
pub const SUBLANG_TIBETAN_PRC: u32 = 1;
pub const SUBLANG_TIGRIGNA_ERITREA: u32 = 2;
pub const SUBLANG_TIGRINYA_ERITREA: u32 = 2;
pub const SUBLANG_TIGRINYA_ETHIOPIA: u32 = 1;
pub const SUBLANG_TSWANA_BOTSWANA: u32 = 2;
pub const SUBLANG_TSWANA_SOUTH_AFRICA: u32 = 1;
pub const SUBLANG_TURKISH_TURKEY: u32 = 1;
pub const SUBLANG_TURKMEN_TURKMENISTAN: u32 = 1;
pub const SUBLANG_UIGHUR_PRC: u32 = 1;
pub const SUBLANG_UKRAINIAN_UKRAINE: u32 = 1;
pub const SUBLANG_UPPER_SORBIAN_GERMANY: u32 = 1;
pub const SUBLANG_URDU_PAKISTAN: u32 = 1;
pub const SUBLANG_URDU_INDIA: u32 = 2;
pub const SUBLANG_UZBEK_LATIN: u32 = 1;
pub const SUBLANG_UZBEK_CYRILLIC: u32 = 2;
pub const SUBLANG_VALENCIAN_VALENCIA: u32 = 2;
pub const SUBLANG_VIETNAMESE_VIETNAM: u32 = 1;
pub const SUBLANG_WELSH_UNITED_KINGDOM: u32 = 1;
pub const SUBLANG_WOLOF_SENEGAL: u32 = 1;
pub const SUBLANG_XHOSA_SOUTH_AFRICA: u32 = 1;
pub const SUBLANG_YAKUT_RUSSIA: u32 = 1;
pub const SUBLANG_YI_PRC: u32 = 1;
pub const SUBLANG_YORUBA_NIGERIA: u32 = 1;
pub const SUBLANG_ZULU_SOUTH_AFRICA: u32 = 1;
pub const SORT_DEFAULT: u32 = 0;
pub const SORT_INVARIANT_MATH: u32 = 1;
pub const SORT_JAPANESE_XJIS: u32 = 0;
pub const SORT_JAPANESE_UNICODE: u32 = 1;
pub const SORT_JAPANESE_RADICALSTROKE: u32 = 4;
pub const SORT_CHINESE_BIG5: u32 = 0;
pub const SORT_CHINESE_PRCP: u32 = 0;
pub const SORT_CHINESE_UNICODE: u32 = 1;
pub const SORT_CHINESE_PRC: u32 = 2;
pub const SORT_CHINESE_BOPOMOFO: u32 = 3;
pub const SORT_CHINESE_RADICALSTROKE: u32 = 4;
pub const SORT_KOREAN_KSC: u32 = 0;
pub const SORT_KOREAN_UNICODE: u32 = 1;
pub const SORT_GERMAN_PHONE_BOOK: u32 = 1;
pub const SORT_HUNGARIAN_DEFAULT: u32 = 0;
pub const SORT_HUNGARIAN_TECHNICAL: u32 = 1;
pub const SORT_GEORGIAN_TRADITIONAL: u32 = 0;
pub const SORT_GEORGIAN_MODERN: u32 = 1;
pub const NLS_VALID_LOCALE_MASK: u32 = 1048575;
pub const LOCALE_NAME_MAX_LENGTH: u32 = 85;
pub const LOCALE_TRANSIENT_KEYBOARD1: u32 = 8192;
pub const LOCALE_TRANSIENT_KEYBOARD2: u32 = 9216;
pub const LOCALE_TRANSIENT_KEYBOARD3: u32 = 10240;
pub const LOCALE_TRANSIENT_KEYBOARD4: u32 = 11264;
pub const FACILITY_DEBUGGER: u32 = 1;
pub const FACILITY_RPC_RUNTIME: u32 = 2;
pub const FACILITY_RPC_STUBS: u32 = 3;
pub const FACILITY_IO_ERROR_CODE: u32 = 4;
pub const FACILITY_CODCLASS_ERROR_CODE: u32 = 6;
pub const FACILITY_NTWIN32: u32 = 7;
pub const FACILITY_NTCERT: u32 = 8;
pub const FACILITY_NTSSPI: u32 = 9;
pub const FACILITY_TERMINAL_SERVER: u32 = 10;
pub const FACILTIY_MUI_ERROR_CODE: u32 = 11;
pub const FACILITY_USB_ERROR_CODE: u32 = 16;
pub const FACILITY_HID_ERROR_CODE: u32 = 17;
pub const FACILITY_FIREWIRE_ERROR_CODE: u32 = 18;
pub const FACILITY_CLUSTER_ERROR_CODE: u32 = 19;
pub const FACILITY_ACPI_ERROR_CODE: u32 = 20;
pub const FACILITY_SXS_ERROR_CODE: u32 = 21;
pub const FACILITY_TRANSACTION: u32 = 25;
pub const FACILITY_COMMONLOG: u32 = 26;
pub const FACILITY_VIDEO: u32 = 27;
pub const FACILITY_FILTER_MANAGER: u32 = 28;
pub const FACILITY_MONITOR: u32 = 29;
pub const FACILITY_GRAPHICS_KERNEL: u32 = 30;
pub const FACILITY_CAMERA: u32 = 31;
pub const FACILITY_DRIVER_FRAMEWORK: u32 = 32;
pub const FACILITY_FVE_ERROR_CODE: u32 = 33;
pub const FACILITY_FWP_ERROR_CODE: u32 = 34;
pub const FACILITY_NDIS_ERROR_CODE: u32 = 35;
pub const FACILITY_QUIC_ERROR_CODE: u32 = 36;
pub const FACILITY_TPM: u32 = 41;
pub const FACILITY_RTPM: u32 = 42;
pub const FACILITY_HYPERVISOR: u32 = 53;
pub const FACILITY_IPSEC: u32 = 54;
pub const FACILITY_VIRTUALIZATION: u32 = 55;
pub const FACILITY_VOLMGR: u32 = 56;
pub const FACILITY_BCD_ERROR_CODE: u32 = 57;
pub const FACILITY_WIN32K_NTUSER: u32 = 62;
pub const FACILITY_WIN32K_NTGDI: u32 = 63;
pub const FACILITY_RESUME_KEY_FILTER: u32 = 64;
pub const FACILITY_RDBSS: u32 = 65;
pub const FACILITY_BTH_ATT: u32 = 66;
pub const FACILITY_SECUREBOOT: u32 = 67;
pub const FACILITY_AUDIO_KERNEL: u32 = 68;
pub const FACILITY_VSM: u32 = 69;
pub const FACILITY_NT_IORING: u32 = 70;
pub const FACILITY_VOLSNAP: u32 = 80;
pub const FACILITY_SDBUS: u32 = 81;
pub const FACILITY_SHARED_VHDX: u32 = 92;
pub const FACILITY_SMB: u32 = 93;
pub const FACILITY_XVS: u32 = 94;
pub const FACILITY_INTERIX: u32 = 153;
pub const FACILITY_SPACES: u32 = 231;
pub const FACILITY_SECURITY_CORE: u32 = 232;
pub const FACILITY_SYSTEM_INTEGRITY: u32 = 233;
pub const FACILITY_LICENSING: u32 = 234;
pub const FACILITY_PLATFORM_MANIFEST: u32 = 235;
pub const FACILITY_APP_EXEC: u32 = 236;
pub const FACILITY_UNIONFS: u32 = 237;
pub const FACILITY_PLATFORM_RUNTIME_MECHANISM: u32 = 238;
pub const FACILITY_WIN_ACCEL: u32 = 239;
pub const FACILITY_MAXIMUM_VALUE: u32 = 240;
pub const STATUS_SEVERITY_SUCCESS: u32 = 0;
pub const STATUS_SEVERITY_INFORMATIONAL: u32 = 1;
pub const STATUS_SEVERITY_WARNING: u32 = 2;
pub const STATUS_SEVERITY_ERROR: u32 = 3;
pub const BUGCHECK_CONTEXT_MODIFIER: u32 = 2147483648;
pub const FACILITY_MCA_ERROR_CODE: u32 = 5;
pub const MCA_EXTREG_V2MAX: u32 = 24;
pub const LOW_LEVEL: u32 = 0;
pub const CMCI_LEVEL: u32 = 5;
pub const CLOCK_LEVEL: u32 = 13;
pub const IPI_LEVEL: u32 = 14;
pub const DRS_LEVEL: u32 = 14;
pub const POWER_LEVEL: u32 = 14;
pub const PROFILE_LEVEL: u32 = 15;
pub const LOW_PRIORITY: u32 = 0;
pub const LOW_REALTIME_PRIORITY: u32 = 16;
pub const HIGH_PRIORITY: u32 = 31;
pub const MAXIMUM_PRIORITY: u32 = 32;
pub const MAXIMUM_WAIT_OBJECTS: u32 = 64;
pub const MAXIMUM_SUSPEND_COUNT: u32 = 127;
pub const LOCK_QUEUE_WAIT: u32 = 1;
pub const LOCK_QUEUE_WAIT_BIT: u32 = 0;
pub const LOCK_QUEUE_OWNER: u32 = 2;
pub const LOCK_QUEUE_OWNER_BIT: u32 = 1;
pub const LOCK_QUEUE_HALTED: u32 = 4;
pub const LOCK_QUEUE_HALTED_BIT: u32 = 2;
pub const LOCK_QUEUE_VALID_FLAGS: u32 = 7;
pub const LockQueueUnusedSpare0: u32 = 0;
pub const LockQueueUnusedSpare1: u32 = 1;
pub const LockQueueUnusedSpare2: u32 = 2;
pub const LockQueueUnusedSpare3: u32 = 3;
pub const LockQueueVacbLock: u32 = 4;
pub const LockQueueMasterLock: u32 = 5;
pub const LockQueueNonPagedPoolLock: u32 = 6;
pub const LockQueueIoCancelLock: u32 = 7;
pub const LockQueueUnusedSpare8: u32 = 8;
pub const LockQueueIoVpbLock: u32 = 9;
pub const LockQueueIoDatabaseLock: u32 = 10;
pub const LockQueueIoCompletionLock: u32 = 11;
pub const LockQueueNtfsStructLock: u32 = 12;
pub const LockQueueAfdWorkQueueLock: u32 = 13;
pub const LockQueueBcbLock: u32 = 14;
pub const LockQueueUnusedSpare15: u32 = 15;
pub const LockQueueUnusedSpare16: u32 = 16;
pub const LockQueueMaximumLock: u32 = 17;
pub const DPC_WATCHDOG_GLOBAL_TRIAGE_BLOCK_SIGNATURE: u32 = 2931740382;
pub const DPC_WATCHDOG_GLOBAL_TRIAGE_BLOCK_REVISION_1: u32 = 1;
pub const _MM_HINT_T0: u32 = 1;
pub const _MM_HINT_T1: u32 = 2;
pub const _MM_HINT_T2: u32 = 3;
pub const _MM_HINT_NTA: u32 = 0;
pub const PF_TEMPORAL_LEVEL_1: u32 = 1;
pub const PF_TEMPORAL_LEVEL_2: u32 = 2;
pub const PF_TEMPORAL_LEVEL_3: u32 = 3;
pub const PF_NON_TEMPORAL_LEVEL_ALL: u32 = 0;
pub const DELETE: u32 = 65536;
pub const READ_CONTROL: u32 = 131072;
pub const WRITE_DAC: u32 = 262144;
pub const WRITE_OWNER: u32 = 524288;
pub const SYNCHRONIZE: u32 = 1048576;
pub const STANDARD_RIGHTS_REQUIRED: u32 = 983040;
pub const STANDARD_RIGHTS_READ: u32 = 131072;
pub const STANDARD_RIGHTS_WRITE: u32 = 131072;
pub const STANDARD_RIGHTS_EXECUTE: u32 = 131072;
pub const STANDARD_RIGHTS_ALL: u32 = 2031616;
pub const SPECIFIC_RIGHTS_ALL: u32 = 65535;
pub const ACCESS_SYSTEM_SECURITY: u32 = 16777216;
pub const MAXIMUM_ALLOWED: u32 = 33554432;
pub const GENERIC_READ: u32 = 2147483648;
pub const GENERIC_WRITE: u32 = 1073741824;
pub const GENERIC_EXECUTE: u32 = 536870912;
pub const GENERIC_ALL: u32 = 268435456;
pub const ACL_REVISION: u32 = 2;
pub const ACL_REVISION_DS: u32 = 4;
pub const ACL_REVISION1: u32 = 1;
pub const ACL_REVISION2: u32 = 2;
pub const ACL_REVISION3: u32 = 3;
pub const ACL_REVISION4: u32 = 4;
pub const MAX_ACL_REVISION: u32 = 4;
pub const SECURITY_DESCRIPTOR_REVISION: u32 = 1;
pub const SECURITY_DESCRIPTOR_REVISION1: u32 = 1;
pub const SE_PRIVILEGE_ENABLED_BY_DEFAULT: u32 = 1;
pub const SE_PRIVILEGE_ENABLED: u32 = 2;
pub const SE_PRIVILEGE_REMOVED: u32 = 4;
pub const SE_PRIVILEGE_USED_FOR_ACCESS: u32 = 2147483648;
pub const SE_PRIVILEGE_VALID_ATTRIBUTES: u32 = 2147483655;
pub const PRIVILEGE_SET_ALL_NECESSARY: u32 = 1;
pub const SE_MIN_WELL_KNOWN_PRIVILEGE: u32 = 2;
pub const SE_CREATE_TOKEN_PRIVILEGE: u32 = 2;
pub const SE_ASSIGNPRIMARYTOKEN_PRIVILEGE: u32 = 3;
pub const SE_LOCK_MEMORY_PRIVILEGE: u32 = 4;
pub const SE_INCREASE_QUOTA_PRIVILEGE: u32 = 5;
pub const SE_MACHINE_ACCOUNT_PRIVILEGE: u32 = 6;
pub const SE_TCB_PRIVILEGE: u32 = 7;
pub const SE_SECURITY_PRIVILEGE: u32 = 8;
pub const SE_TAKE_OWNERSHIP_PRIVILEGE: u32 = 9;
pub const SE_LOAD_DRIVER_PRIVILEGE: u32 = 10;
pub const SE_SYSTEM_PROFILE_PRIVILEGE: u32 = 11;
pub const SE_SYSTEMTIME_PRIVILEGE: u32 = 12;
pub const SE_PROF_SINGLE_PROCESS_PRIVILEGE: u32 = 13;
pub const SE_INC_BASE_PRIORITY_PRIVILEGE: u32 = 14;
pub const SE_CREATE_PAGEFILE_PRIVILEGE: u32 = 15;
pub const SE_CREATE_PERMANENT_PRIVILEGE: u32 = 16;
pub const SE_BACKUP_PRIVILEGE: u32 = 17;
pub const SE_RESTORE_PRIVILEGE: u32 = 18;
pub const SE_SHUTDOWN_PRIVILEGE: u32 = 19;
pub const SE_DEBUG_PRIVILEGE: u32 = 20;
pub const SE_AUDIT_PRIVILEGE: u32 = 21;
pub const SE_SYSTEM_ENVIRONMENT_PRIVILEGE: u32 = 22;
pub const SE_CHANGE_NOTIFY_PRIVILEGE: u32 = 23;
pub const SE_REMOTE_SHUTDOWN_PRIVILEGE: u32 = 24;
pub const SE_UNDOCK_PRIVILEGE: u32 = 25;
pub const SE_SYNC_AGENT_PRIVILEGE: u32 = 26;
pub const SE_ENABLE_DELEGATION_PRIVILEGE: u32 = 27;
pub const SE_MANAGE_VOLUME_PRIVILEGE: u32 = 28;
pub const SE_IMPERSONATE_PRIVILEGE: u32 = 29;
pub const SE_CREATE_GLOBAL_PRIVILEGE: u32 = 30;
pub const SE_TRUSTED_CREDMAN_ACCESS_PRIVILEGE: u32 = 31;
pub const SE_RELABEL_PRIVILEGE: u32 = 32;
pub const SE_INC_WORKING_SET_PRIVILEGE: u32 = 33;
pub const SE_TIME_ZONE_PRIVILEGE: u32 = 34;
pub const SE_CREATE_SYMBOLIC_LINK_PRIVILEGE: u32 = 35;
pub const SE_DELEGATE_SESSION_USER_IMPERSONATE_PRIVILEGE: u32 = 36;
pub const SE_MAX_WELL_KNOWN_PRIVILEGE: u32 = 36;
pub const SECURITY_DYNAMIC_TRACKING: u32 = 1;
pub const SECURITY_STATIC_TRACKING: u32 = 0;
pub const OWNER_SECURITY_INFORMATION: u32 = 1;
pub const GROUP_SECURITY_INFORMATION: u32 = 2;
pub const DACL_SECURITY_INFORMATION: u32 = 4;
pub const SACL_SECURITY_INFORMATION: u32 = 8;
pub const LABEL_SECURITY_INFORMATION: u32 = 16;
pub const ATTRIBUTE_SECURITY_INFORMATION: u32 = 32;
pub const SCOPE_SECURITY_INFORMATION: u32 = 64;
pub const PROCESS_TRUST_LABEL_SECURITY_INFORMATION: u32 = 128;
pub const ACCESS_FILTER_SECURITY_INFORMATION: u32 = 256;
pub const BACKUP_SECURITY_INFORMATION: u32 = 65536;
pub const PROTECTED_DACL_SECURITY_INFORMATION: u32 = 2147483648;
pub const PROTECTED_SACL_SECURITY_INFORMATION: u32 = 1073741824;
pub const UNPROTECTED_DACL_SECURITY_INFORMATION: u32 = 536870912;
pub const UNPROTECTED_SACL_SECURITY_INFORMATION: u32 = 268435456;
pub const SE_ADT_OBJECT_ONLY: u32 = 1;
pub const SE_MAX_AUDIT_PARAMETERS: u32 = 32;
pub const SE_MAX_GENERIC_AUDIT_PARAMETERS: u32 = 28;
pub const SE_ADT_PARAMETERS_SELF_RELATIVE: u32 = 1;
pub const SE_ADT_PARAMETERS_SEND_TO_LSA: u32 = 2;
pub const SE_ADT_PARAMETER_EXTENSIBLE_AUDIT: u32 = 4;
pub const SE_ADT_PARAMETER_GENERIC_AUDIT: u32 = 8;
pub const SE_ADT_PARAMETER_WRITE_SYNCHRONOUS: u32 = 16;
pub const FILE_DEVICE_BEEP: u32 = 1;
pub const FILE_DEVICE_CD_ROM: u32 = 2;
pub const FILE_DEVICE_CD_ROM_FILE_SYSTEM: u32 = 3;
pub const FILE_DEVICE_CONTROLLER: u32 = 4;
pub const FILE_DEVICE_DATALINK: u32 = 5;
pub const FILE_DEVICE_DFS: u32 = 6;
pub const FILE_DEVICE_DISK: u32 = 7;
pub const FILE_DEVICE_DISK_FILE_SYSTEM: u32 = 8;
pub const FILE_DEVICE_FILE_SYSTEM: u32 = 9;
pub const FILE_DEVICE_INPORT_PORT: u32 = 10;
pub const FILE_DEVICE_KEYBOARD: u32 = 11;
pub const FILE_DEVICE_MAILSLOT: u32 = 12;
pub const FILE_DEVICE_MIDI_IN: u32 = 13;
pub const FILE_DEVICE_MIDI_OUT: u32 = 14;
pub const FILE_DEVICE_MOUSE: u32 = 15;
pub const FILE_DEVICE_MULTI_UNC_PROVIDER: u32 = 16;
pub const FILE_DEVICE_NAMED_PIPE: u32 = 17;
pub const FILE_DEVICE_NETWORK: u32 = 18;
pub const FILE_DEVICE_NETWORK_BROWSER: u32 = 19;
pub const FILE_DEVICE_NETWORK_FILE_SYSTEM: u32 = 20;
pub const FILE_DEVICE_NULL: u32 = 21;
pub const FILE_DEVICE_PARALLEL_PORT: u32 = 22;
pub const FILE_DEVICE_PHYSICAL_NETCARD: u32 = 23;
pub const FILE_DEVICE_PRINTER: u32 = 24;
pub const FILE_DEVICE_SCANNER: u32 = 25;
pub const FILE_DEVICE_SERIAL_MOUSE_PORT: u32 = 26;
pub const FILE_DEVICE_SERIAL_PORT: u32 = 27;
pub const FILE_DEVICE_SCREEN: u32 = 28;
pub const FILE_DEVICE_SOUND: u32 = 29;
pub const FILE_DEVICE_STREAMS: u32 = 30;
pub const FILE_DEVICE_TAPE: u32 = 31;
pub const FILE_DEVICE_TAPE_FILE_SYSTEM: u32 = 32;
pub const FILE_DEVICE_TRANSPORT: u32 = 33;
pub const FILE_DEVICE_UNKNOWN: u32 = 34;
pub const FILE_DEVICE_VIDEO: u32 = 35;
pub const FILE_DEVICE_VIRTUAL_DISK: u32 = 36;
pub const FILE_DEVICE_WAVE_IN: u32 = 37;
pub const FILE_DEVICE_WAVE_OUT: u32 = 38;
pub const FILE_DEVICE_8042_PORT: u32 = 39;
pub const FILE_DEVICE_NETWORK_REDIRECTOR: u32 = 40;
pub const FILE_DEVICE_BATTERY: u32 = 41;
pub const FILE_DEVICE_BUS_EXTENDER: u32 = 42;
pub const FILE_DEVICE_MODEM: u32 = 43;
pub const FILE_DEVICE_VDM: u32 = 44;
pub const FILE_DEVICE_MASS_STORAGE: u32 = 45;
pub const FILE_DEVICE_SMB: u32 = 46;
pub const FILE_DEVICE_KS: u32 = 47;
pub const FILE_DEVICE_CHANGER: u32 = 48;
pub const FILE_DEVICE_SMARTCARD: u32 = 49;
pub const FILE_DEVICE_ACPI: u32 = 50;
pub const FILE_DEVICE_DVD: u32 = 51;
pub const FILE_DEVICE_FULLSCREEN_VIDEO: u32 = 52;
pub const FILE_DEVICE_DFS_FILE_SYSTEM: u32 = 53;
pub const FILE_DEVICE_DFS_VOLUME: u32 = 54;
pub const FILE_DEVICE_SERENUM: u32 = 55;
pub const FILE_DEVICE_TERMSRV: u32 = 56;
pub const FILE_DEVICE_KSEC: u32 = 57;
pub const FILE_DEVICE_FIPS: u32 = 58;
pub const FILE_DEVICE_INFINIBAND: u32 = 59;
pub const FILE_DEVICE_VMBUS: u32 = 62;
pub const FILE_DEVICE_CRYPT_PROVIDER: u32 = 63;
pub const FILE_DEVICE_WPD: u32 = 64;
pub const FILE_DEVICE_BLUETOOTH: u32 = 65;
pub const FILE_DEVICE_MT_COMPOSITE: u32 = 66;
pub const FILE_DEVICE_MT_TRANSPORT: u32 = 67;
pub const FILE_DEVICE_BIOMETRIC: u32 = 68;
pub const FILE_DEVICE_PMI: u32 = 69;
pub const FILE_DEVICE_EHSTOR: u32 = 70;
pub const FILE_DEVICE_DEVAPI: u32 = 71;
pub const FILE_DEVICE_GPIO: u32 = 72;
pub const FILE_DEVICE_USBEX: u32 = 73;
pub const FILE_DEVICE_CONSOLE: u32 = 80;
pub const FILE_DEVICE_NFP: u32 = 81;
pub const FILE_DEVICE_SYSENV: u32 = 82;
pub const FILE_DEVICE_VIRTUAL_BLOCK: u32 = 83;
pub const FILE_DEVICE_POINT_OF_SERVICE: u32 = 84;
pub const FILE_DEVICE_STORAGE_REPLICATION: u32 = 85;
pub const FILE_DEVICE_TRUST_ENV: u32 = 86;
pub const FILE_DEVICE_UCM: u32 = 87;
pub const FILE_DEVICE_UCMTCPCI: u32 = 88;
pub const FILE_DEVICE_PERSISTENT_MEMORY: u32 = 89;
pub const FILE_DEVICE_NVDIMM: u32 = 90;
pub const FILE_DEVICE_HOLOGRAPHIC: u32 = 91;
pub const FILE_DEVICE_SDFXHCI: u32 = 92;
pub const FILE_DEVICE_UCMUCSI: u32 = 93;
pub const FILE_DEVICE_PRM: u32 = 94;
pub const FILE_DEVICE_EVENT_COLLECTOR: u32 = 95;
pub const FILE_DEVICE_USB4: u32 = 96;
pub const FILE_DEVICE_SOUNDWIRE: u32 = 97;
pub const METHOD_BUFFERED: u32 = 0;
pub const METHOD_IN_DIRECT: u32 = 1;
pub const METHOD_OUT_DIRECT: u32 = 2;
pub const METHOD_NEITHER: u32 = 3;
pub const METHOD_DIRECT_TO_HARDWARE: u32 = 1;
pub const METHOD_DIRECT_FROM_HARDWARE: u32 = 2;
pub const FILE_ANY_ACCESS: u32 = 0;
pub const FILE_SPECIAL_ACCESS: u32 = 0;
pub const FILE_READ_ACCESS: u32 = 1;
pub const FILE_WRITE_ACCESS: u32 = 2;
pub const FILE_READ_DATA: u32 = 1;
pub const FILE_LIST_DIRECTORY: u32 = 1;
pub const FILE_WRITE_DATA: u32 = 2;
pub const FILE_ADD_FILE: u32 = 2;
pub const FILE_APPEND_DATA: u32 = 4;
pub const FILE_ADD_SUBDIRECTORY: u32 = 4;
pub const FILE_CREATE_PIPE_INSTANCE: u32 = 4;
pub const FILE_READ_EA: u32 = 8;
pub const FILE_WRITE_EA: u32 = 16;
pub const FILE_EXECUTE: u32 = 32;
pub const FILE_TRAVERSE: u32 = 32;
pub const FILE_DELETE_CHILD: u32 = 64;
pub const FILE_READ_ATTRIBUTES: u32 = 128;
pub const FILE_WRITE_ATTRIBUTES: u32 = 256;
pub const FILE_ALL_ACCESS: u32 = 2032127;
pub const FILE_GENERIC_READ: u32 = 1179785;
pub const FILE_GENERIC_WRITE: u32 = 1179926;
pub const FILE_GENERIC_EXECUTE: u32 = 1179808;
pub const FILE_SHARE_READ: u32 = 1;
pub const FILE_SHARE_WRITE: u32 = 2;
pub const FILE_SHARE_DELETE: u32 = 4;
pub const FILE_SHARE_VALID_FLAGS: u32 = 7;
pub const FILE_ATTRIBUTE_READONLY: u32 = 1;
pub const FILE_ATTRIBUTE_HIDDEN: u32 = 2;
pub const FILE_ATTRIBUTE_SYSTEM: u32 = 4;
pub const FILE_ATTRIBUTE_DIRECTORY: u32 = 16;
pub const FILE_ATTRIBUTE_ARCHIVE: u32 = 32;
pub const FILE_ATTRIBUTE_DEVICE: u32 = 64;
pub const FILE_ATTRIBUTE_NORMAL: u32 = 128;
pub const FILE_ATTRIBUTE_TEMPORARY: u32 = 256;
pub const FILE_ATTRIBUTE_SPARSE_FILE: u32 = 512;
pub const FILE_ATTRIBUTE_REPARSE_POINT: u32 = 1024;
pub const FILE_ATTRIBUTE_COMPRESSED: u32 = 2048;
pub const FILE_ATTRIBUTE_OFFLINE: u32 = 4096;
pub const FILE_ATTRIBUTE_NOT_CONTENT_INDEXED: u32 = 8192;
pub const FILE_ATTRIBUTE_ENCRYPTED: u32 = 16384;
pub const FILE_ATTRIBUTE_INTEGRITY_STREAM: u32 = 32768;
pub const FILE_ATTRIBUTE_VIRTUAL: u32 = 65536;
pub const FILE_ATTRIBUTE_NO_SCRUB_DATA: u32 = 131072;
pub const FILE_ATTRIBUTE_EA: u32 = 262144;
pub const FILE_ATTRIBUTE_PINNED: u32 = 524288;
pub const FILE_ATTRIBUTE_UNPINNED: u32 = 1048576;
pub const FILE_ATTRIBUTE_RECALL_ON_OPEN: u32 = 262144;
pub const FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS: u32 = 4194304;
pub const TREE_CONNECT_ATTRIBUTE_PRIVACY: u32 = 16384;
pub const TREE_CONNECT_ATTRIBUTE_INTEGRITY: u32 = 32768;
pub const TREE_CONNECT_ATTRIBUTE_GLOBAL: u32 = 4;
pub const TREE_CONNECT_ATTRIBUTE_PINNED: u32 = 2;
pub const FILE_ATTRIBUTE_STRICTLY_SEQUENTIAL: u32 = 536870912;
pub const FILE_ATTRIBUTE_VALID_FLAGS: u32 = 5963703;
pub const FILE_ATTRIBUTE_VALID_SET_FLAGS: u32 = 1716647;
pub const FILE_ATTRIBUTE_VALID_KERNEL_SET_FLAGS: u32 = 5910951;
pub const FILE_SUPERSEDE: u32 = 0;
pub const FILE_OPEN: u32 = 1;
pub const FILE_CREATE: u32 = 2;
pub const FILE_OPEN_IF: u32 = 3;
pub const FILE_OVERWRITE: u32 = 4;
pub const FILE_OVERWRITE_IF: u32 = 5;
pub const FILE_MAXIMUM_DISPOSITION: u32 = 5;
pub const FILE_DIRECTORY_FILE: u32 = 1;
pub const FILE_WRITE_THROUGH: u32 = 2;
pub const FILE_SEQUENTIAL_ONLY: u32 = 4;
pub const FILE_NO_INTERMEDIATE_BUFFERING: u32 = 8;
pub const FILE_SYNCHRONOUS_IO_ALERT: u32 = 16;
pub const FILE_SYNCHRONOUS_IO_NONALERT: u32 = 32;
pub const FILE_NON_DIRECTORY_FILE: u32 = 64;
pub const FILE_CREATE_TREE_CONNECTION: u32 = 128;
pub const FILE_COMPLETE_IF_OPLOCKED: u32 = 256;
pub const FILE_NO_EA_KNOWLEDGE: u32 = 512;
pub const FILE_OPEN_REMOTE_INSTANCE: u32 = 1024;
pub const FILE_RANDOM_ACCESS: u32 = 2048;
pub const FILE_DELETE_ON_CLOSE: u32 = 4096;
pub const FILE_OPEN_BY_FILE_ID: u32 = 8192;
pub const FILE_OPEN_FOR_BACKUP_INTENT: u32 = 16384;
pub const FILE_NO_COMPRESSION: u32 = 32768;
pub const FILE_OPEN_REQUIRING_OPLOCK: u32 = 65536;
pub const FILE_DISALLOW_EXCLUSIVE: u32 = 131072;
pub const FILE_SESSION_AWARE: u32 = 262144;
pub const FILE_RESERVE_OPFILTER: u32 = 1048576;
pub const FILE_OPEN_REPARSE_POINT: u32 = 2097152;
pub const FILE_OPEN_NO_RECALL: u32 = 4194304;
pub const FILE_OPEN_FOR_FREE_SPACE_QUERY: u32 = 8388608;
pub const TREE_CONNECT_NO_CLIENT_BUFFERING: u32 = 8;
pub const TREE_CONNECT_WRITE_THROUGH: u32 = 2;
pub const FILE_VALID_OPTION_FLAGS: u32 = 16777215;
pub const FILE_VALID_PIPE_OPTION_FLAGS: u32 = 50;
pub const FILE_VALID_MAILSLOT_OPTION_FLAGS: u32 = 50;
pub const FILE_VALID_SET_FLAGS: u32 = 54;
pub const FILE_CONTAINS_EXTENDED_CREATE_INFORMATION: u32 = 268435456;
pub const FILE_VALID_EXTENDED_OPTION_FLAGS: u32 = 268435456;
pub const FILE_SUPERSEDED: u32 = 0;
pub const FILE_OPENED: u32 = 1;
pub const FILE_CREATED: u32 = 2;
pub const FILE_OVERWRITTEN: u32 = 3;
pub const FILE_EXISTS: u32 = 4;
pub const FILE_DOES_NOT_EXIST: u32 = 5;
pub const FILE_QUERY_RESTART_SCAN: u32 = 1;
pub const FILE_QUERY_RETURN_SINGLE_ENTRY: u32 = 2;
pub const FILE_QUERY_INDEX_SPECIFIED: u32 = 4;
pub const FILE_QUERY_RETURN_ON_DISK_ENTRIES_ONLY: u32 = 8;
pub const FILE_QUERY_NO_CURSOR_UPDATE: u32 = 16;
pub const FILE_WRITE_TO_END_OF_FILE: u32 = 4294967295;
pub const FILE_USE_FILE_POINTER_POSITION: u32 = 4294967294;
pub const FILE_BYTE_ALIGNMENT: u32 = 0;
pub const FILE_WORD_ALIGNMENT: u32 = 1;
pub const FILE_LONG_ALIGNMENT: u32 = 3;
pub const FILE_QUAD_ALIGNMENT: u32 = 7;
pub const FILE_OCTA_ALIGNMENT: u32 = 15;
pub const FILE_32_BYTE_ALIGNMENT: u32 = 31;
pub const FILE_64_BYTE_ALIGNMENT: u32 = 63;
pub const FILE_128_BYTE_ALIGNMENT: u32 = 127;
pub const FILE_256_BYTE_ALIGNMENT: u32 = 255;
pub const FILE_512_BYTE_ALIGNMENT: u32 = 511;
pub const MAXIMUM_FILENAME_LENGTH: u32 = 256;
pub const FILE_REMOVABLE_MEDIA: u32 = 1;
pub const FILE_READ_ONLY_DEVICE: u32 = 2;
pub const FILE_FLOPPY_DISKETTE: u32 = 4;
pub const FILE_WRITE_ONCE_MEDIA: u32 = 8;
pub const FILE_REMOTE_DEVICE: u32 = 16;
pub const FILE_DEVICE_IS_MOUNTED: u32 = 32;
pub const FILE_VIRTUAL_VOLUME: u32 = 64;
pub const FILE_AUTOGENERATED_DEVICE_NAME: u32 = 128;
pub const FILE_DEVICE_SECURE_OPEN: u32 = 256;
pub const FILE_CHARACTERISTIC_PNP_DEVICE: u32 = 2048;
pub const FILE_CHARACTERISTIC_TS_DEVICE: u32 = 4096;
pub const FILE_CHARACTERISTIC_WEBDAV_DEVICE: u32 = 8192;
pub const FILE_CHARACTERISTIC_CSV: u32 = 65536;
pub const FILE_DEVICE_ALLOW_APPCONTAINER_TRAVERSAL: u32 = 131072;
pub const FILE_PORTABLE_DEVICE: u32 = 262144;
pub const FILE_REMOTE_DEVICE_VSMB: u32 = 524288;
pub const FILE_DEVICE_REQUIRE_SECURITY_CHECK: u32 = 1048576;
pub const IO_SESSION_STATE_ALL_EVENTS: u32 = 4294967295;
pub const IO_SESSION_STATE_CREATION_EVENT: u32 = 1;
pub const IO_SESSION_STATE_TERMINATION_EVENT: u32 = 2;
pub const IO_SESSION_STATE_CONNECT_EVENT: u32 = 4;
pub const IO_SESSION_STATE_DISCONNECT_EVENT: u32 = 8;
pub const IO_SESSION_STATE_LOGON_EVENT: u32 = 16;
pub const IO_SESSION_STATE_LOGOFF_EVENT: u32 = 32;
pub const IO_SESSION_STATE_VALID_EVENT_MASK: u32 = 63;
pub const IO_SESSION_MAX_PAYLOAD_SIZE: u32 = 256;
pub const FILE_SKIP_COMPLETION_PORT_ON_SUCCESS: u32 = 1;
pub const FILE_SKIP_SET_EVENT_ON_HANDLE: u32 = 2;
pub const FILE_SKIP_SET_USER_EVENT_ON_FAST_IO: u32 = 4;
pub const FLUSH_FLAGS_FILE_DATA_ONLY: u32 = 1;
pub const FLUSH_FLAGS_NO_SYNC: u32 = 2;
pub const FLUSH_FLAGS_FILE_DATA_SYNC_ONLY: u32 = 4;
pub const ERROR_LOG_LIMIT_SIZE: u32 = 240;
pub const PORT_MAXIMUM_MESSAGE_LENGTH: u32 = 512;
pub const KEY_QUERY_VALUE: u32 = 1;
pub const KEY_SET_VALUE: u32 = 2;
pub const KEY_CREATE_SUB_KEY: u32 = 4;
pub const KEY_ENUMERATE_SUB_KEYS: u32 = 8;
pub const KEY_NOTIFY: u32 = 16;
pub const KEY_CREATE_LINK: u32 = 32;
pub const KEY_WOW64_32KEY: u32 = 512;
pub const KEY_WOW64_64KEY: u32 = 256;
pub const KEY_WOW64_RES: u32 = 768;
pub const KEY_READ: u32 = 131097;
pub const KEY_WRITE: u32 = 131078;
pub const KEY_EXECUTE: u32 = 131097;
pub const KEY_ALL_ACCESS: u32 = 983103;
pub const REG_OPTION_RESERVED: u32 = 0;
pub const REG_OPTION_NON_VOLATILE: u32 = 0;
pub const REG_OPTION_VOLATILE: u32 = 1;
pub const REG_OPTION_CREATE_LINK: u32 = 2;
pub const REG_OPTION_BACKUP_RESTORE: u32 = 4;
pub const REG_OPTION_OPEN_LINK: u32 = 8;
pub const REG_OPTION_DONT_VIRTUALIZE: u32 = 16;
pub const REG_LEGAL_OPTION: u32 = 31;
pub const REG_OPEN_LEGAL_OPTION: u32 = 28;
pub const REG_CREATED_NEW_KEY: u32 = 1;
pub const REG_OPENED_EXISTING_KEY: u32 = 2;
pub const REG_STANDARD_FORMAT: u32 = 1;
pub const REG_LATEST_FORMAT: u32 = 2;
pub const REG_NO_COMPRESSION: u32 = 4;
pub const REG_WHOLE_HIVE_VOLATILE: u32 = 1;
pub const REG_REFRESH_HIVE: u32 = 2;
pub const REG_NO_LAZY_FLUSH: u32 = 4;
pub const REG_FORCE_RESTORE: u32 = 8;
pub const REG_APP_HIVE: u32 = 16;
pub const REG_PROCESS_PRIVATE: u32 = 32;
pub const REG_START_JOURNAL: u32 = 64;
pub const REG_HIVE_EXACT_FILE_GROWTH: u32 = 128;
pub const REG_HIVE_NO_RM: u32 = 256;
pub const REG_HIVE_SINGLE_LOG: u32 = 512;
pub const REG_BOOT_HIVE: u32 = 1024;
pub const REG_LOAD_HIVE_OPEN_HANDLE: u32 = 2048;
pub const REG_FLUSH_HIVE_FILE_GROWTH: u32 = 4096;
pub const REG_OPEN_READ_ONLY: u32 = 8192;
pub const REG_IMMUTABLE: u32 = 16384;
pub const REG_NO_IMPERSONATION_FALLBACK: u32 = 32768;
pub const REG_APP_HIVE_OPEN_READ_ONLY: u32 = 8192;
pub const REG_FORCE_UNLOAD: u32 = 1;
pub const REG_UNLOAD_LEGAL_FLAGS: u32 = 1;
pub const REG_NOTIFY_CHANGE_NAME: u32 = 1;
pub const REG_NOTIFY_CHANGE_ATTRIBUTES: u32 = 2;
pub const REG_NOTIFY_CHANGE_LAST_SET: u32 = 4;
pub const REG_NOTIFY_CHANGE_SECURITY: u32 = 8;
pub const REG_NOTIFY_THREAD_AGNOSTIC: u32 = 268435456;
pub const REG_LEGAL_CHANGE_FILTER: u32 = 268435471;
pub const OBJECT_TYPE_CREATE: u32 = 1;
pub const OBJECT_TYPE_ALL_ACCESS: u32 = 983041;
pub const DIRECTORY_QUERY: u32 = 1;
pub const DIRECTORY_TRAVERSE: u32 = 2;
pub const DIRECTORY_CREATE_OBJECT: u32 = 4;
pub const DIRECTORY_CREATE_SUBDIRECTORY: u32 = 8;
pub const DIRECTORY_ALL_ACCESS: u32 = 983055;
pub const SYMBOLIC_LINK_QUERY: u32 = 1;
pub const SYMBOLIC_LINK_SET: u32 = 2;
pub const SYMBOLIC_LINK_ALL_ACCESS: u32 = 983041;
pub const SYMBOLIC_LINK_ALL_ACCESS_EX: u32 = 1048575;
pub const DUPLICATE_CLOSE_SOURCE: u32 = 1;
pub const DUPLICATE_SAME_ACCESS: u32 = 2;
pub const DUPLICATE_SAME_ATTRIBUTES: u32 = 4;
pub const SECTION_QUERY: u32 = 1;
pub const SECTION_MAP_WRITE: u32 = 2;
pub const SECTION_MAP_READ: u32 = 4;
pub const SECTION_MAP_EXECUTE: u32 = 8;
pub const SECTION_EXTEND_SIZE: u32 = 16;
pub const SECTION_MAP_EXECUTE_EXPLICIT: u32 = 32;
pub const SECTION_ALL_ACCESS: u32 = 983071;
pub const SESSION_QUERY_ACCESS: u32 = 1;
pub const SESSION_MODIFY_ACCESS: u32 = 2;
pub const SESSION_ALL_ACCESS: u32 = 983043;
pub const SEGMENT_ALL_ACCESS: u32 = 983071;
pub const PAGE_NOACCESS: u32 = 1;
pub const PAGE_READONLY: u32 = 2;
pub const PAGE_READWRITE: u32 = 4;
pub const PAGE_WRITECOPY: u32 = 8;
pub const PAGE_EXECUTE: u32 = 16;
pub const PAGE_EXECUTE_READ: u32 = 32;
pub const PAGE_EXECUTE_READWRITE: u32 = 64;
pub const PAGE_EXECUTE_WRITECOPY: u32 = 128;
pub const PAGE_GUARD: u32 = 256;
pub const PAGE_NOCACHE: u32 = 512;
pub const PAGE_WRITECOMBINE: u32 = 1024;
pub const PAGE_GRAPHICS_NOACCESS: u32 = 2048;
pub const PAGE_GRAPHICS_READONLY: u32 = 4096;
pub const PAGE_GRAPHICS_READWRITE: u32 = 8192;
pub const PAGE_GRAPHICS_EXECUTE: u32 = 16384;
pub const PAGE_GRAPHICS_EXECUTE_READ: u32 = 32768;
pub const PAGE_GRAPHICS_EXECUTE_READWRITE: u32 = 65536;
pub const PAGE_GRAPHICS_COHERENT: u32 = 131072;
pub const PAGE_GRAPHICS_NOCACHE: u32 = 262144;
pub const PAGE_ENCLAVE_THREAD_CONTROL: u32 = 2147483648;
pub const PAGE_REVERT_TO_FILE_MAP: u32 = 2147483648;
pub const PAGE_TARGETS_NO_UPDATE: u32 = 1073741824;
pub const PAGE_TARGETS_INVALID: u32 = 1073741824;
pub const PAGE_ENCLAVE_UNVALIDATED: u32 = 536870912;
pub const PAGE_ENCLAVE_NO_CHANGE: u32 = 536870912;
pub const PAGE_ENCLAVE_MASK: u32 = 268435456;
pub const PAGE_ENCLAVE_DECOMMIT: u32 = 268435456;
pub const PAGE_ENCLAVE_SS_FIRST: u32 = 268435457;
pub const PAGE_ENCLAVE_SS_REST: u32 = 268435458;
pub const MEM_COMMIT: u32 = 4096;
pub const MEM_RESERVE: u32 = 8192;
pub const MEM_RESET: u32 = 524288;
pub const MEM_TOP_DOWN: u32 = 1048576;
pub const MEM_RESET_UNDO: u32 = 16777216;
pub const MEM_LARGE_PAGES: u32 = 536870912;
pub const MEM_4MB_PAGES: u32 = 2147483648;
pub const MEM_DECOMMIT: u32 = 16384;
pub const MEM_RELEASE: u32 = 32768;
pub const MEM_FREE: u32 = 65536;
pub const MEM_EXTENDED_PARAMETER_GRAPHICS: u32 = 1;
pub const MEM_EXTENDED_PARAMETER_NONPAGED: u32 = 2;
pub const MEM_EXTENDED_PARAMETER_ZERO_PAGES_OPTIONAL: u32 = 4;
pub const MEM_EXTENDED_PARAMETER_NONPAGED_LARGE: u32 = 8;
pub const MEM_EXTENDED_PARAMETER_NONPAGED_HUGE: u32 = 16;
pub const MEM_EXTENDED_PARAMETER_SOFT_FAULT_PAGES: u32 = 32;
pub const MEM_EXTENDED_PARAMETER_EC_CODE: u32 = 64;
pub const MEM_EXTENDED_PARAMETER_IMAGE_NO_HPAT: u32 = 128;
pub const MEM_EXTENDED_PARAMETER_TYPE_BITS: u32 = 8;
pub const SEC_HUGE_PAGES: u32 = 131072;
pub const SEC_64K_PAGES: u32 = 524288;
pub const SEC_FILE: u32 = 8388608;
pub const SEC_IMAGE: u32 = 16777216;
pub const SEC_RESERVE: u32 = 67108864;
pub const SEC_COMMIT: u32 = 134217728;
pub const SEC_NOCACHE: u32 = 268435456;
pub const SEC_LARGE_PAGES: u32 = 2147483648;
pub const SEC_IMAGE_NO_EXECUTE: u32 = 285212672;
pub const MEM_PRIVATE: u32 = 131072;
pub const MEM_MAPPED: u32 = 262144;
pub const PROCESS_DUP_HANDLE: u32 = 64;
pub const PROCESS_ALL_ACCESS: u32 = 2097151;
pub const THREAD_TERMINATE: u32 = 1;
pub const THREAD_SUSPEND_RESUME: u32 = 2;
pub const THREAD_ALERT: u32 = 4;
pub const THREAD_GET_CONTEXT: u32 = 8;
pub const THREAD_SET_CONTEXT: u32 = 16;
pub const THREAD_SET_INFORMATION: u32 = 32;
pub const THREAD_SET_LIMITED_INFORMATION: u32 = 1024;
pub const THREAD_QUERY_LIMITED_INFORMATION: u32 = 2048;
pub const THREAD_RESUME: u32 = 4096;
pub const THREAD_ALL_ACCESS: u32 = 2097151;
pub const MEMORY_PARTITION_QUERY_ACCESS: u32 = 1;
pub const MEMORY_PARTITION_MODIFY_ACCESS: u32 = 2;
pub const MEMORY_PARTITION_ALL_ACCESS: u32 = 2031619;
pub const POWERBUTTON_ACTION_INDEX_NOTHING: u32 = 0;
pub const POWERBUTTON_ACTION_INDEX_SLEEP: u32 = 1;
pub const POWERBUTTON_ACTION_INDEX_HIBERNATE: u32 = 2;
pub const POWERBUTTON_ACTION_INDEX_SHUTDOWN: u32 = 3;
pub const POWERBUTTON_ACTION_INDEX_TURN_OFF_THE_DISPLAY: u32 = 4;
pub const POWERBUTTON_ACTION_VALUE_NOTHING: u32 = 0;
pub const POWERBUTTON_ACTION_VALUE_SLEEP: u32 = 2;
pub const POWERBUTTON_ACTION_VALUE_HIBERNATE: u32 = 3;
pub const POWERBUTTON_ACTION_VALUE_SHUTDOWN: u32 = 6;
pub const POWERBUTTON_ACTION_VALUE_TURN_OFF_THE_DISPLAY: u32 = 8;
pub const PERFSTATE_POLICY_CHANGE_IDEAL: u32 = 0;
pub const PERFSTATE_POLICY_CHANGE_SINGLE: u32 = 1;
pub const PERFSTATE_POLICY_CHANGE_ROCKET: u32 = 2;
pub const PERFSTATE_POLICY_CHANGE_IDEAL_AGGRESSIVE: u32 = 3;
pub const PERFSTATE_POLICY_CHANGE_DECREASE_MAX: u32 = 2;
pub const PERFSTATE_POLICY_CHANGE_INCREASE_MAX: u32 = 3;
pub const PROCESSOR_THROTTLE_DISABLED: u32 = 0;
pub const PROCESSOR_THROTTLE_ENABLED: u32 = 1;
pub const PROCESSOR_THROTTLE_AUTOMATIC: u32 = 2;
pub const PROCESSOR_PERF_BOOST_POLICY_DISABLED: u32 = 0;
pub const PROCESSOR_PERF_BOOST_POLICY_MAX: u32 = 100;
pub const PROCESSOR_PERF_BOOST_MODE_DISABLED: u32 = 0;
pub const PROCESSOR_PERF_BOOST_MODE_ENABLED: u32 = 1;
pub const PROCESSOR_PERF_BOOST_MODE_AGGRESSIVE: u32 = 2;
pub const PROCESSOR_PERF_BOOST_MODE_EFFICIENT_ENABLED: u32 = 3;
pub const PROCESSOR_PERF_BOOST_MODE_EFFICIENT_AGGRESSIVE: u32 = 4;
pub const PROCESSOR_PERF_BOOST_MODE_AGGRESSIVE_AT_GUARANTEED: u32 = 5;
pub const PROCESSOR_PERF_BOOST_MODE_EFFICIENT_AGGRESSIVE_AT_GUARANTEED: u32 = 6;
pub const PROCESSOR_PERF_BOOST_MODE_MAX: u32 = 6;
pub const PROCESSOR_PERF_AUTONOMOUS_MODE_DISABLED: u32 = 0;
pub const PROCESSOR_PERF_AUTONOMOUS_MODE_ENABLED: u32 = 1;
pub const PROCESSOR_PERF_PERFORMANCE_PREFERENCE: u32 = 255;
pub const PROCESSOR_PERF_ENERGY_PREFERENCE: u32 = 0;
pub const PROCESSOR_PERF_MINIMUM_ACTIVITY_WINDOW: u32 = 0;
pub const PROCESSOR_PERF_MAXIMUM_ACTIVITY_WINDOW: u32 = 1270000000;
pub const PROCESSOR_DUTY_CYCLING_DISABLED: u32 = 0;
pub const PROCESSOR_DUTY_CYCLING_ENABLED: u32 = 1;
pub const CORE_PARKING_POLICY_CHANGE_IDEAL: u32 = 0;
pub const CORE_PARKING_POLICY_CHANGE_SINGLE: u32 = 1;
pub const CORE_PARKING_POLICY_CHANGE_ROCKET: u32 = 2;
pub const CORE_PARKING_POLICY_CHANGE_MULTISTEP: u32 = 3;
pub const CORE_PARKING_POLICY_CHANGE_MAX: u32 = 3;
pub const PARKING_TOPOLOGY_POLICY_DISABLED: u32 = 0;
pub const PARKING_TOPOLOGY_POLICY_ROUNDROBIN: u32 = 1;
pub const PARKING_TOPOLOGY_POLICY_SEQUENTIAL: u32 = 2;
pub const SMT_UNPARKING_POLICY_CORE: u32 = 0;
pub const SMT_UNPARKING_POLICY_CORE_PER_THREAD: u32 = 1;
pub const SMT_UNPARKING_POLICY_LP_ROUNDROBIN: u32 = 2;
pub const SMT_UNPARKING_POLICY_LP_SEQUENTIAL: u32 = 3;
pub const POWER_DEVICE_IDLE_POLICY_PERFORMANCE: u32 = 0;
pub const POWER_DEVICE_IDLE_POLICY_CONSERVATIVE: u32 = 1;
pub const POWER_CONNECTIVITY_IN_STANDBY_DISABLED: u32 = 0;
pub const POWER_CONNECTIVITY_IN_STANDBY_ENABLED: u32 = 1;
pub const POWER_CONNECTIVITY_IN_STANDBY_SYSTEM_MANAGED: u32 = 2;
pub const POWER_DISCONNECTED_STANDBY_MODE_NORMAL: u32 = 0;
pub const POWER_DISCONNECTED_STANDBY_MODE_AGGRESSIVE: u32 = 1;
pub const POWER_SYSTEM_MAXIMUM: u32 = 7;
pub const DIAGNOSTIC_REASON_VERSION: u32 = 0;
pub const DIAGNOSTIC_REASON_SIMPLE_STRING: u32 = 1;
pub const DIAGNOSTIC_REASON_DETAILED_STRING: u32 = 2;
pub const DIAGNOSTIC_REASON_NOT_SPECIFIED: u32 = 2147483648;
pub const DIAGNOSTIC_REASON_INVALID_FLAGS: i64 = -2147483656;
pub const POWER_REQUEST_CONTEXT_VERSION: u32 = 0;
pub const POWER_REQUEST_CONTEXT_SIMPLE_STRING: u32 = 1;
pub const POWER_REQUEST_CONTEXT_DETAILED_STRING: u32 = 2;
pub const PDCAP_D0_SUPPORTED: u32 = 1;
pub const PDCAP_D1_SUPPORTED: u32 = 2;
pub const PDCAP_D2_SUPPORTED: u32 = 4;
pub const PDCAP_D3_SUPPORTED: u32 = 8;
pub const PDCAP_WAKE_FROM_D0_SUPPORTED: u32 = 16;
pub const PDCAP_WAKE_FROM_D1_SUPPORTED: u32 = 32;
pub const PDCAP_WAKE_FROM_D2_SUPPORTED: u32 = 64;
pub const PDCAP_WAKE_FROM_D3_SUPPORTED: u32 = 128;
pub const PDCAP_WARM_EJECT_SUPPORTED: u32 = 256;
pub const POWER_SETTING_VALUE_VERSION: u32 = 1;
pub const POWER_PLATFORM_ROLE_V1: u32 = 1;
pub const POWER_PLATFORM_ROLE_V2: u32 = 2;
pub const POWER_PLATFORM_ROLE_VERSION: u32 = 2;
pub const REG_NONE: u32 = 0;
pub const REG_SZ: u32 = 1;
pub const REG_EXPAND_SZ: u32 = 2;
pub const REG_BINARY: u32 = 3;
pub const REG_DWORD: u32 = 4;
pub const REG_DWORD_LITTLE_ENDIAN: u32 = 4;
pub const REG_DWORD_BIG_ENDIAN: u32 = 5;
pub const REG_LINK: u32 = 6;
pub const REG_MULTI_SZ: u32 = 7;
pub const REG_RESOURCE_LIST: u32 = 8;
pub const REG_FULL_RESOURCE_DESCRIPTOR: u32 = 9;
pub const REG_RESOURCE_REQUIREMENTS_LIST: u32 = 10;
pub const REG_QWORD: u32 = 11;
pub const REG_QWORD_LITTLE_ENDIAN: u32 = 11;
pub const SERVICE_KERNEL_DRIVER: u32 = 1;
pub const SERVICE_FILE_SYSTEM_DRIVER: u32 = 2;
pub const SERVICE_ADAPTER: u32 = 4;
pub const SERVICE_RECOGNIZER_DRIVER: u32 = 8;
pub const SERVICE_DRIVER: u32 = 11;
pub const SERVICE_WIN32_OWN_PROCESS: u32 = 16;
pub const SERVICE_WIN32_SHARE_PROCESS: u32 = 32;
pub const SERVICE_WIN32: u32 = 48;
pub const SERVICE_USER_SERVICE: u32 = 64;
pub const SERVICE_USERSERVICE_INSTANCE: u32 = 128;
pub const SERVICE_USER_SHARE_PROCESS: u32 = 96;
pub const SERVICE_USER_OWN_PROCESS: u32 = 80;
pub const SERVICE_INTERACTIVE_PROCESS: u32 = 256;
pub const SERVICE_PKG_SERVICE: u32 = 512;
pub const SERVICE_TYPE_ALL: u32 = 1023;
pub const SERVICE_BOOT_START: u32 = 0;
pub const SERVICE_SYSTEM_START: u32 = 1;
pub const SERVICE_AUTO_START: u32 = 2;
pub const SERVICE_DEMAND_START: u32 = 3;
pub const SERVICE_DISABLED: u32 = 4;
pub const SERVICE_ERROR_IGNORE: u32 = 0;
pub const SERVICE_ERROR_NORMAL: u32 = 1;
pub const SERVICE_ERROR_SEVERE: u32 = 2;
pub const SERVICE_ERROR_CRITICAL: u32 = 3;
pub const CM_SERVICE_NETWORK_BOOT_LOAD: u32 = 1;
pub const CM_SERVICE_VIRTUAL_DISK_BOOT_LOAD: u32 = 2;
pub const CM_SERVICE_USB_DISK_BOOT_LOAD: u32 = 4;
pub const CM_SERVICE_SD_DISK_BOOT_LOAD: u32 = 8;
pub const CM_SERVICE_USB3_DISK_BOOT_LOAD: u32 = 16;
pub const CM_SERVICE_MEASURED_BOOT_LOAD: u32 = 32;
pub const CM_SERVICE_VERIFIER_BOOT_LOAD: u32 = 64;
pub const CM_SERVICE_WINPE_BOOT_LOAD: u32 = 128;
pub const CM_SERVICE_RAM_DISK_BOOT_LOAD: u32 = 256;
pub const CM_SERVICE_VALID_PROMOTION_MASK: u32 = 511;
pub const CmResourceTypeNull: u32 = 0;
pub const CmResourceTypePort: u32 = 1;
pub const CmResourceTypeInterrupt: u32 = 2;
pub const CmResourceTypeMemory: u32 = 3;
pub const CmResourceTypeDma: u32 = 4;
pub const CmResourceTypeDeviceSpecific: u32 = 5;
pub const CmResourceTypeBusNumber: u32 = 6;
pub const CmResourceTypeMemoryLarge: u32 = 7;
pub const CmResourceTypeNonArbitrated: u32 = 128;
pub const CmResourceTypeConfigData: u32 = 128;
pub const CmResourceTypeDevicePrivate: u32 = 129;
pub const CmResourceTypePcCardConfig: u32 = 130;
pub const CmResourceTypeMfCardConfig: u32 = 131;
pub const CmResourceTypeConnection: u32 = 132;
pub const CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE: u32 = 0;
pub const CM_RESOURCE_INTERRUPT_LATCHED: u32 = 1;
pub const CM_RESOURCE_INTERRUPT_MESSAGE: u32 = 2;
pub const CM_RESOURCE_INTERRUPT_POLICY_INCLUDED: u32 = 4;
pub const CM_RESOURCE_INTERRUPT_SECONDARY_INTERRUPT: u32 = 16;
pub const CM_RESOURCE_INTERRUPT_WAKE_HINT: u32 = 32;
pub const CM_RESOURCE_INTERRUPT_LEVEL_LATCHED_BITS: u32 = 1;
pub const CM_RESOURCE_MEMORY_READ_WRITE: u32 = 0;
pub const CM_RESOURCE_MEMORY_READ_ONLY: u32 = 1;
pub const CM_RESOURCE_MEMORY_WRITE_ONLY: u32 = 2;
pub const CM_RESOURCE_MEMORY_WRITEABILITY_MASK: u32 = 3;
pub const CM_RESOURCE_MEMORY_PREFETCHABLE: u32 = 4;
pub const CM_RESOURCE_MEMORY_COMBINEDWRITE: u32 = 8;
pub const CM_RESOURCE_MEMORY_24: u32 = 16;
pub const CM_RESOURCE_MEMORY_CACHEABLE: u32 = 32;
pub const CM_RESOURCE_MEMORY_WINDOW_DECODE: u32 = 64;
pub const CM_RESOURCE_MEMORY_BAR: u32 = 128;
pub const CM_RESOURCE_MEMORY_COMPAT_FOR_INACCESSIBLE_RANGE: u32 = 256;
pub const CM_RESOURCE_MEMORY_LARGE: u32 = 3584;
pub const CM_RESOURCE_MEMORY_LARGE_40: u32 = 512;
pub const CM_RESOURCE_MEMORY_LARGE_48: u32 = 1024;
pub const CM_RESOURCE_MEMORY_LARGE_64: u32 = 2048;
pub const CM_RESOURCE_MEMORY_LARGE_40_MAXLEN: u64 = 1099511627520;
pub const CM_RESOURCE_MEMORY_LARGE_48_MAXLEN: u64 = 281474976645120;
pub const CM_RESOURCE_MEMORY_LARGE_64_MAXLEN: i64 = -4294967296;
pub const CM_RESOURCE_PORT_MEMORY: u32 = 0;
pub const CM_RESOURCE_PORT_IO: u32 = 1;
pub const CM_RESOURCE_PORT_10_BIT_DECODE: u32 = 4;
pub const CM_RESOURCE_PORT_12_BIT_DECODE: u32 = 8;
pub const CM_RESOURCE_PORT_16_BIT_DECODE: u32 = 16;
pub const CM_RESOURCE_PORT_POSITIVE_DECODE: u32 = 32;
pub const CM_RESOURCE_PORT_PASSIVE_DECODE: u32 = 64;
pub const CM_RESOURCE_PORT_WINDOW_DECODE: u32 = 128;
pub const CM_RESOURCE_PORT_BAR: u32 = 256;
pub const CM_RESOURCE_DMA_8: u32 = 0;
pub const CM_RESOURCE_DMA_16: u32 = 1;
pub const CM_RESOURCE_DMA_32: u32 = 2;
pub const CM_RESOURCE_DMA_8_AND_16: u32 = 4;
pub const CM_RESOURCE_DMA_BUS_MASTER: u32 = 8;
pub const CM_RESOURCE_DMA_TYPE_A: u32 = 16;
pub const CM_RESOURCE_DMA_TYPE_B: u32 = 32;
pub const CM_RESOURCE_DMA_TYPE_F: u32 = 64;
pub const CM_RESOURCE_DMA_V3: u32 = 128;
pub const DMAV3_TRANFER_WIDTH_8: u32 = 0;
pub const DMAV3_TRANFER_WIDTH_16: u32 = 1;
pub const DMAV3_TRANFER_WIDTH_32: u32 = 2;
pub const DMAV3_TRANFER_WIDTH_64: u32 = 3;
pub const DMAV3_TRANFER_WIDTH_128: u32 = 4;
pub const DMAV3_TRANFER_WIDTH_256: u32 = 5;
pub const CM_RESOURCE_CONNECTION_CLASS_GPIO: u32 = 1;
pub const CM_RESOURCE_CONNECTION_CLASS_SERIAL: u32 = 2;
pub const CM_RESOURCE_CONNECTION_CLASS_FUNCTION_CONFIG: u32 = 3;
pub const CM_RESOURCE_CONNECTION_TYPE_GPIO_IO: u32 = 2;
pub const CM_RESOURCE_CONNECTION_TYPE_SERIAL_I2C: u32 = 1;
pub const CM_RESOURCE_CONNECTION_TYPE_SERIAL_SPI: u32 = 2;
pub const CM_RESOURCE_CONNECTION_TYPE_SERIAL_UART: u32 = 3;
pub const CM_RESOURCE_CONNECTION_TYPE_FUNCTION_CONFIG: u32 = 1;
pub const EISA_FUNCTION_ENABLED: u32 = 128;
pub const EISA_FREE_FORM_DATA: u32 = 64;
pub const EISA_HAS_PORT_INIT_ENTRY: u32 = 32;
pub const EISA_HAS_PORT_RANGE: u32 = 16;
pub const EISA_HAS_DMA_ENTRY: u32 = 8;
pub const EISA_HAS_IRQ_ENTRY: u32 = 4;
pub const EISA_HAS_MEMORY_ENTRY: u32 = 2;
pub const EISA_HAS_TYPE_ENTRY: u32 = 1;
pub const EISA_HAS_INFORMATION: u32 = 31;
pub const EISA_MORE_ENTRIES: u32 = 128;
pub const EISA_SYSTEM_MEMORY: u32 = 0;
pub const EISA_MEMORY_TYPE_RAM: u32 = 1;
pub const EISA_INVALID_SLOT: u32 = 128;
pub const EISA_INVALID_FUNCTION: u32 = 129;
pub const EISA_INVALID_CONFIGURATION: u32 = 130;
pub const EISA_EMPTY_SLOT: u32 = 131;
pub const EISA_INVALID_BIOS_CALL: u32 = 134;
pub const IO_RESOURCE_PREFERRED: u32 = 1;
pub const IO_RESOURCE_DEFAULT: u32 = 2;
pub const IO_RESOURCE_ALTERNATIVE: u32 = 8;
pub const FAST_FAIL_LEGACY_GS_VIOLATION: u32 = 0;
pub const FAST_FAIL_VTGUARD_CHECK_FAILURE: u32 = 1;
pub const FAST_FAIL_STACK_COOKIE_CHECK_FAILURE: u32 = 2;
pub const FAST_FAIL_CORRUPT_LIST_ENTRY: u32 = 3;
pub const FAST_FAIL_INCORRECT_STACK: u32 = 4;
pub const FAST_FAIL_INVALID_ARG: u32 = 5;
pub const FAST_FAIL_GS_COOKIE_INIT: u32 = 6;
pub const FAST_FAIL_FATAL_APP_EXIT: u32 = 7;
pub const FAST_FAIL_RANGE_CHECK_FAILURE: u32 = 8;
pub const FAST_FAIL_UNSAFE_REGISTRY_ACCESS: u32 = 9;
pub const FAST_FAIL_GUARD_ICALL_CHECK_FAILURE: u32 = 10;
pub const FAST_FAIL_GUARD_WRITE_CHECK_FAILURE: u32 = 11;
pub const FAST_FAIL_INVALID_FIBER_SWITCH: u32 = 12;
pub const FAST_FAIL_INVALID_SET_OF_CONTEXT: u32 = 13;
pub const FAST_FAIL_INVALID_REFERENCE_COUNT: u32 = 14;
pub const FAST_FAIL_INVALID_JUMP_BUFFER: u32 = 18;
pub const FAST_FAIL_MRDATA_MODIFIED: u32 = 19;
pub const FAST_FAIL_CERTIFICATION_FAILURE: u32 = 20;
pub const FAST_FAIL_INVALID_EXCEPTION_CHAIN: u32 = 21;
pub const FAST_FAIL_CRYPTO_LIBRARY: u32 = 22;
pub const FAST_FAIL_INVALID_CALL_IN_DLL_CALLOUT: u32 = 23;
pub const FAST_FAIL_INVALID_IMAGE_BASE: u32 = 24;
pub const FAST_FAIL_DLOAD_PROTECTION_FAILURE: u32 = 25;
pub const FAST_FAIL_UNSAFE_EXTENSION_CALL: u32 = 26;
pub const FAST_FAIL_DEPRECATED_SERVICE_INVOKED: u32 = 27;
pub const FAST_FAIL_INVALID_BUFFER_ACCESS: u32 = 28;
pub const FAST_FAIL_INVALID_BALANCED_TREE: u32 = 29;
pub const FAST_FAIL_INVALID_NEXT_THREAD: u32 = 30;
pub const FAST_FAIL_GUARD_ICALL_CHECK_SUPPRESSED: u32 = 31;
pub const FAST_FAIL_APCS_DISABLED: u32 = 32;
pub const FAST_FAIL_INVALID_IDLE_STATE: u32 = 33;
pub const FAST_FAIL_MRDATA_PROTECTION_FAILURE: u32 = 34;
pub const FAST_FAIL_UNEXPECTED_HEAP_EXCEPTION: u32 = 35;
pub const FAST_FAIL_INVALID_LOCK_STATE: u32 = 36;
pub const FAST_FAIL_GUARD_JUMPTABLE: u32 = 37;
pub const FAST_FAIL_INVALID_LONGJUMP_TARGET: u32 = 38;
pub const FAST_FAIL_INVALID_DISPATCH_CONTEXT: u32 = 39;
pub const FAST_FAIL_INVALID_THREAD: u32 = 40;
pub const FAST_FAIL_INVALID_SYSCALL_NUMBER: u32 = 41;
pub const FAST_FAIL_INVALID_FILE_OPERATION: u32 = 42;
pub const FAST_FAIL_LPAC_ACCESS_DENIED: u32 = 43;
pub const FAST_FAIL_GUARD_SS_FAILURE: u32 = 44;
pub const FAST_FAIL_LOADER_CONTINUITY_FAILURE: u32 = 45;
pub const FAST_FAIL_GUARD_EXPORT_SUPPRESSION_FAILURE: u32 = 46;
pub const FAST_FAIL_INVALID_CONTROL_STACK: u32 = 47;
pub const FAST_FAIL_SET_CONTEXT_DENIED: u32 = 48;
pub const FAST_FAIL_INVALID_IAT: u32 = 49;
pub const FAST_FAIL_HEAP_METADATA_CORRUPTION: u32 = 50;
pub const FAST_FAIL_PAYLOAD_RESTRICTION_VIOLATION: u32 = 51;
pub const FAST_FAIL_LOW_LABEL_ACCESS_DENIED: u32 = 52;
pub const FAST_FAIL_ENCLAVE_CALL_FAILURE: u32 = 53;
pub const FAST_FAIL_UNHANDLED_LSS_EXCEPTON: u32 = 54;
pub const FAST_FAIL_ADMINLESS_ACCESS_DENIED: u32 = 55;
pub const FAST_FAIL_UNEXPECTED_CALL: u32 = 56;
pub const FAST_FAIL_CONTROL_INVALID_RETURN_ADDRESS: u32 = 57;
pub const FAST_FAIL_UNEXPECTED_HOST_BEHAVIOR: u32 = 58;
pub const FAST_FAIL_FLAGS_CORRUPTION: u32 = 59;
pub const FAST_FAIL_VEH_CORRUPTION: u32 = 60;
pub const FAST_FAIL_ETW_CORRUPTION: u32 = 61;
pub const FAST_FAIL_RIO_ABORT: u32 = 62;
pub const FAST_FAIL_INVALID_PFN: u32 = 63;
pub const FAST_FAIL_GUARD_ICALL_CHECK_FAILURE_XFG: u32 = 64;
pub const FAST_FAIL_CAST_GUARD: u32 = 65;
pub const FAST_FAIL_HOST_VISIBILITY_CHANGE: u32 = 66;
pub const FAST_FAIL_KERNEL_CET_SHADOW_STACK_ASSIST: u32 = 67;
pub const FAST_FAIL_PATCH_CALLBACK_FAILED: u32 = 68;
pub const FAST_FAIL_NTDLL_PATCH_FAILED: u32 = 69;
pub const FAST_FAIL_INVALID_FLS_DATA: u32 = 70;
pub const FAST_FAIL_INVALID_FAST_FAIL_CODE: u32 = 4294967295;
pub const RTL_QUERY_REGISTRY_SUBKEY: u32 = 1;
pub const RTL_QUERY_REGISTRY_TOPKEY: u32 = 2;
pub const RTL_QUERY_REGISTRY_REQUIRED: u32 = 4;
pub const RTL_QUERY_REGISTRY_NOVALUE: u32 = 8;
pub const RTL_QUERY_REGISTRY_NOEXPAND: u32 = 16;
pub const RTL_QUERY_REGISTRY_DIRECT: u32 = 32;
pub const RTL_QUERY_REGISTRY_DELETE: u32 = 64;
pub const RTL_QUERY_REGISTRY_NOSTRING: u32 = 128;
pub const RTL_QUERY_REGISTRY_TYPECHECK: u32 = 256;
pub const RTL_QUERY_REGISTRY_TYPECHECK_SHIFT: u32 = 24;
pub const RTL_QUERY_REGISTRY_TYPECHECK_MASK: u32 = 4278190080;
pub const RTL_REGISTRY_ABSOLUTE: u32 = 0;
pub const RTL_REGISTRY_SERVICES: u32 = 1;
pub const RTL_REGISTRY_CONTROL: u32 = 2;
pub const RTL_REGISTRY_WINDOWS_NT: u32 = 3;
pub const RTL_REGISTRY_DEVICEMAP: u32 = 4;
pub const RTL_REGISTRY_USER: u32 = 5;
pub const RTL_REGISTRY_MAXIMUM: u32 = 6;
pub const RTL_REGISTRY_HANDLE: u32 = 1073741824;
pub const RTL_REGISTRY_OPTIONAL: u32 = 2147483648;
pub const HASH_STRING_ALGORITHM_DEFAULT: u32 = 0;
pub const HASH_STRING_ALGORITHM_X65599: u32 = 1;
pub const HASH_STRING_ALGORITHM_INVALID: u32 = 4294967295;
pub const RTL_GUID_STRING_SIZE: u32 = 38;
pub const DBG_STATUS_CONTROL_C: u32 = 1;
pub const DBG_STATUS_SYSRQ: u32 = 2;
pub const DBG_STATUS_BUGCHECK_FIRST: u32 = 3;
pub const DBG_STATUS_BUGCHECK_SECOND: u32 = 4;
pub const DBG_STATUS_FATAL: u32 = 5;
pub const DBG_STATUS_DEBUG_CONTROL: u32 = 6;
pub const DBG_STATUS_WORKER: u32 = 7;
pub const LOWBYTE_MASK: u32 = 255;
pub const SHORT_LEAST_SIGNIFICANT_BIT: u32 = 0;
pub const SHORT_MOST_SIGNIFICANT_BIT: u32 = 1;
pub const LONG_LEAST_SIGNIFICANT_BIT: u32 = 0;
pub const LONG_3RD_MOST_SIGNIFICANT_BIT: u32 = 1;
pub const LONG_2ND_MOST_SIGNIFICANT_BIT: u32 = 2;
pub const LONG_MOST_SIGNIFICANT_BIT: u32 = 3;
pub const SEF_DACL_AUTO_INHERIT: u32 = 1;
pub const SEF_SACL_AUTO_INHERIT: u32 = 2;
pub const SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT: u32 = 4;
pub const SEF_AVOID_PRIVILEGE_CHECK: u32 = 8;
pub const SEF_AVOID_OWNER_CHECK: u32 = 16;
pub const SEF_DEFAULT_OWNER_FROM_PARENT: u32 = 32;
pub const SEF_DEFAULT_GROUP_FROM_PARENT: u32 = 64;
pub const SEF_MACL_NO_WRITE_UP: u32 = 256;
pub const SEF_MACL_NO_READ_UP: u32 = 512;
pub const SEF_MACL_NO_EXECUTE_UP: u32 = 1024;
pub const SEF_AI_USE_EXTRA_PARAMS: u32 = 2048;
pub const SEF_AVOID_OWNER_RESTRICTION: u32 = 4096;
pub const SEF_FORCE_USER_MODE: u32 = 8192;
pub const SEF_NORMALIZE_OUTPUT_DESCRIPTOR: u32 = 16384;
pub const SEF_MACL_VALID_FLAGS: u32 = 1792;
pub const VER_EQUAL: u32 = 1;
pub const VER_GREATER: u32 = 2;
pub const VER_GREATER_EQUAL: u32 = 3;
pub const VER_LESS: u32 = 4;
pub const VER_LESS_EQUAL: u32 = 5;
pub const VER_AND: u32 = 6;
pub const VER_OR: u32 = 7;
pub const VER_CONDITION_MASK: u32 = 7;
pub const VER_NUM_BITS_PER_CONDITION_MASK: u32 = 3;
pub const VER_MINORVERSION: u32 = 1;
pub const VER_MAJORVERSION: u32 = 2;
pub const VER_BUILDNUMBER: u32 = 4;
pub const VER_PLATFORMID: u32 = 8;
pub const VER_SERVICEPACKMINOR: u32 = 16;
pub const VER_SERVICEPACKMAJOR: u32 = 32;
pub const VER_SUITENAME: u32 = 64;
pub const VER_PRODUCT_TYPE: u32 = 128;
pub const VER_NT_WORKSTATION: u32 = 1;
pub const VER_NT_DOMAIN_CONTROLLER: u32 = 2;
pub const VER_NT_SERVER: u32 = 3;
pub const VER_PLATFORM_WIN32s: u32 = 0;
pub const VER_PLATFORM_WIN32_WINDOWS: u32 = 1;
pub const VER_PLATFORM_WIN32_NT: u32 = 2;
pub const DPFLTR_ERROR_LEVEL: u32 = 0;
pub const DPFLTR_WARNING_LEVEL: u32 = 1;
pub const DPFLTR_TRACE_LEVEL: u32 = 2;
pub const DPFLTR_INFO_LEVEL: u32 = 3;
pub const DPFLTR_MASK: u32 = 2147483648;
pub const VRL_PREDEFINED_CLASS_BEGIN: u32 = 1;
pub const VRL_CUSTOM_CLASS_BEGIN: u32 = 256;
pub const VRL_CLASS_CONSISTENCY: u32 = 1;
pub const VRL_ENABLE_KERNEL_BREAKS: u32 = 2147483648;
pub const CTMF_INCLUDE_APPCONTAINER: u32 = 1;
pub const CTMF_INCLUDE_LPAC: u32 = 2;
pub const CTMF_VALID_FLAGS: u32 = 3;
pub const IMAGE_POLICY_METADATA_VERSION: u32 = 1;
pub const IMAGE_POLICY_SECTION_NAME: &[u8; 9] = b".tPolicy\0";
pub const TRANSACTION_MANAGER_VOLATILE: u32 = 1;
pub const TRANSACTION_MANAGER_COMMIT_DEFAULT: u32 = 0;
pub const TRANSACTION_MANAGER_COMMIT_SYSTEM_VOLUME: u32 = 2;
pub const TRANSACTION_MANAGER_COMMIT_SYSTEM_HIVES: u32 = 4;
pub const TRANSACTION_MANAGER_COMMIT_LOWEST: u32 = 8;
pub const TRANSACTION_MANAGER_CORRUPT_FOR_RECOVERY: u32 = 16;
pub const TRANSACTION_MANAGER_CORRUPT_FOR_PROGRESS: u32 = 32;
pub const TRANSACTION_MANAGER_MAXIMUM_OPTION: u32 = 63;
pub const TRANSACTION_DO_NOT_PROMOTE: u32 = 1;
pub const TRANSACTION_MAXIMUM_OPTION: u32 = 1;
pub const RESOURCE_MANAGER_VOLATILE: u32 = 1;
pub const RESOURCE_MANAGER_COMMUNICATION: u32 = 2;
pub const RESOURCE_MANAGER_MAXIMUM_OPTION: u32 = 3;
pub const CRM_PROTOCOL_EXPLICIT_MARSHAL_ONLY: u32 = 1;
pub const CRM_PROTOCOL_DYNAMIC_MARSHAL_INFO: u32 = 2;
pub const CRM_PROTOCOL_MAXIMUM_OPTION: u32 = 3;
pub const ENLISTMENT_SUPERIOR: u32 = 1;
pub const ENLISTMENT_MAXIMUM_OPTION: u32 = 1;
pub const TRANSACTION_NOTIFY_MASK: u32 = 1073741823;
pub const TRANSACTION_NOTIFY_PREPREPARE: u32 = 1;
pub const TRANSACTION_NOTIFY_PREPARE: u32 = 2;
pub const TRANSACTION_NOTIFY_COMMIT: u32 = 4;
pub const TRANSACTION_NOTIFY_ROLLBACK: u32 = 8;
pub const TRANSACTION_NOTIFY_PREPREPARE_COMPLETE: u32 = 16;
pub const TRANSACTION_NOTIFY_PREPARE_COMPLETE: u32 = 32;
pub const TRANSACTION_NOTIFY_COMMIT_COMPLETE: u32 = 64;
pub const TRANSACTION_NOTIFY_ROLLBACK_COMPLETE: u32 = 128;
pub const TRANSACTION_NOTIFY_RECOVER: u32 = 256;
pub const TRANSACTION_NOTIFY_SINGLE_PHASE_COMMIT: u32 = 512;
pub const TRANSACTION_NOTIFY_DELEGATE_COMMIT: u32 = 1024;
pub const TRANSACTION_NOTIFY_RECOVER_QUERY: u32 = 2048;
pub const TRANSACTION_NOTIFY_ENLIST_PREPREPARE: u32 = 4096;
pub const TRANSACTION_NOTIFY_LAST_RECOVER: u32 = 8192;
pub const TRANSACTION_NOTIFY_INDOUBT: u32 = 16384;
pub const TRANSACTION_NOTIFY_PROPAGATE_PULL: u32 = 32768;
pub const TRANSACTION_NOTIFY_PROPAGATE_PUSH: u32 = 65536;
pub const TRANSACTION_NOTIFY_MARSHAL: u32 = 131072;
pub const TRANSACTION_NOTIFY_ENLIST_MASK: u32 = 262144;
pub const TRANSACTION_NOTIFY_RM_DISCONNECTED: u32 = 16777216;
pub const TRANSACTION_NOTIFY_TM_ONLINE: u32 = 33554432;
pub const TRANSACTION_NOTIFY_COMMIT_REQUEST: u32 = 67108864;
pub const TRANSACTION_NOTIFY_PROMOTE: u32 = 134217728;
pub const TRANSACTION_NOTIFY_PROMOTE_NEW: u32 = 268435456;
pub const TRANSACTION_NOTIFY_REQUEST_OUTCOME: u32 = 536870912;
pub const TRANSACTION_NOTIFY_COMMIT_FINALIZE: u32 = 1073741824;
pub const TRANSACTIONMANAGER_OBJECT_PATH: &[u8; 21] = b"\\TransactionManager\\\0";
pub const TRANSACTION_OBJECT_PATH: &[u8; 14] = b"\\Transaction\\\0";
pub const ENLISTMENT_OBJECT_PATH: &[u8; 13] = b"\\Enlistment\\\0";
pub const RESOURCE_MANAGER_OBJECT_PATH: &[u8; 18] = b"\\ResourceManager\\\0";
pub const TRANSACTION_NOTIFICATION_TM_ONLINE_FLAG_IS_CLUSTERED: u32 = 1;
pub const KTM_MARSHAL_BLOB_VERSION_MAJOR: u32 = 1;
pub const KTM_MARSHAL_BLOB_VERSION_MINOR: u32 = 1;
pub const MAX_TRANSACTION_DESCRIPTION_LENGTH: u32 = 64;
pub const MAX_RESOURCEMANAGER_DESCRIPTION_LENGTH: u32 = 64;
pub const TRANSACTIONMANAGER_QUERY_INFORMATION: u32 = 1;
pub const TRANSACTIONMANAGER_SET_INFORMATION: u32 = 2;
pub const TRANSACTIONMANAGER_RECOVER: u32 = 4;
pub const TRANSACTIONMANAGER_RENAME: u32 = 8;
pub const TRANSACTIONMANAGER_CREATE_RM: u32 = 16;
pub const TRANSACTIONMANAGER_BIND_TRANSACTION: u32 = 32;
pub const TRANSACTIONMANAGER_GENERIC_READ: u32 = 131073;
pub const TRANSACTIONMANAGER_GENERIC_WRITE: u32 = 131102;
pub const TRANSACTIONMANAGER_GENERIC_EXECUTE: u32 = 131072;
pub const TRANSACTIONMANAGER_ALL_ACCESS: u32 = 983103;
pub const TRANSACTION_QUERY_INFORMATION: u32 = 1;
pub const TRANSACTION_SET_INFORMATION: u32 = 2;
pub const TRANSACTION_ENLIST: u32 = 4;
pub const TRANSACTION_COMMIT: u32 = 8;
pub const TRANSACTION_ROLLBACK: u32 = 16;
pub const TRANSACTION_PROPAGATE: u32 = 32;
pub const TRANSACTION_RIGHT_RESERVED1: u32 = 64;
pub const TRANSACTION_GENERIC_READ: u32 = 1179649;
pub const TRANSACTION_GENERIC_WRITE: u32 = 1179710;
pub const TRANSACTION_GENERIC_EXECUTE: u32 = 1179672;
pub const TRANSACTION_ALL_ACCESS: u32 = 2031679;
pub const TRANSACTION_RESOURCE_MANAGER_RIGHTS: u32 = 1179703;
pub const RESOURCEMANAGER_QUERY_INFORMATION: u32 = 1;
pub const RESOURCEMANAGER_SET_INFORMATION: u32 = 2;
pub const RESOURCEMANAGER_RECOVER: u32 = 4;
pub const RESOURCEMANAGER_ENLIST: u32 = 8;
pub const RESOURCEMANAGER_GET_NOTIFICATION: u32 = 16;
pub const RESOURCEMANAGER_REGISTER_PROTOCOL: u32 = 32;
pub const RESOURCEMANAGER_COMPLETE_PROPAGATION: u32 = 64;
pub const RESOURCEMANAGER_GENERIC_READ: u32 = 1179649;
pub const RESOURCEMANAGER_GENERIC_WRITE: u32 = 1179774;
pub const RESOURCEMANAGER_GENERIC_EXECUTE: u32 = 1179740;
pub const RESOURCEMANAGER_ALL_ACCESS: u32 = 2031743;
pub const ENLISTMENT_QUERY_INFORMATION: u32 = 1;
pub const ENLISTMENT_SET_INFORMATION: u32 = 2;
pub const ENLISTMENT_RECOVER: u32 = 4;
pub const ENLISTMENT_SUBORDINATE_RIGHTS: u32 = 8;
pub const ENLISTMENT_SUPERIOR_RIGHTS: u32 = 16;
pub const ENLISTMENT_GENERIC_READ: u32 = 131073;
pub const ENLISTMENT_GENERIC_WRITE: u32 = 131102;
pub const ENLISTMENT_GENERIC_EXECUTE: u32 = 131100;
pub const ENLISTMENT_ALL_ACCESS: u32 = 983071;
pub const POOL_TAGGING: u32 = 1;
pub const DPC_NORMAL: u32 = 0;
pub const DPC_THREADED: u32 = 1;
pub const PAGE_SIZE: u32 = 4096;
pub const PAGE_SHIFT: u32 = 12;
pub const MDL_MAPPED_TO_SYSTEM_VA: u32 = 1;
pub const MDL_PAGES_LOCKED: u32 = 2;
pub const MDL_SOURCE_IS_NONPAGED_POOL: u32 = 4;
pub const MDL_ALLOCATED_FIXED_SIZE: u32 = 8;
pub const MDL_PARTIAL: u32 = 16;
pub const MDL_PARTIAL_HAS_BEEN_MAPPED: u32 = 32;
pub const MDL_IO_PAGE_READ: u32 = 64;
pub const MDL_WRITE_OPERATION: u32 = 128;
pub const MDL_LOCKED_PAGE_TABLES: u32 = 256;
pub const MDL_PARENT_MAPPED_SYSTEM_VA: u32 = 256;
pub const MDL_FREE_EXTRA_PTES: u32 = 512;
pub const MDL_DESCRIBES_AWE: u32 = 1024;
pub const MDL_IO_SPACE: u32 = 2048;
pub const MDL_NETWORK_HEADER: u32 = 4096;
pub const MDL_MAPPING_CAN_FAIL: u32 = 8192;
pub const MDL_PAGE_CONTENTS_INVARIANT: u32 = 16384;
pub const MDL_ALLOCATED_MUST_SUCCEED: u32 = 16384;
pub const MDL_INTERNAL: u32 = 32768;
pub const TIMER_TOLERABLE_DELAY_BITS: u32 = 6;
pub const TIMER_EXPIRED_INDEX_BITS: u32 = 6;
pub const TIMER_PROCESSOR_INDEX_BITS: u32 = 5;
pub const FLUSH_MULTIPLE_MAXIMUM: u32 = 19;
pub const ALLOC_PRAGMA: u32 = 1;
pub const ALLOC_DATA_PRAGMA: u32 = 1;
pub const EVENT_QUERY_STATE: u32 = 1;
pub const EVENT_MODIFY_STATE: u32 = 2;
pub const EVENT_ALL_ACCESS: u32 = 2031619;
pub const SEMAPHORE_QUERY_STATE: u32 = 1;
pub const SEMAPHORE_MODIFY_STATE: u32 = 2;
pub const SEMAPHORE_ALL_ACCESS: u32 = 2031619;
pub const LTP_PC_SMT: u32 = 1;
pub const CACHE_FULLY_ASSOCIATIVE: u32 = 255;
pub const SYSTEM_CPU_SET_INFORMATION_PARKED: u32 = 1;
pub const SYSTEM_CPU_SET_INFORMATION_ALLOCATED: u32 = 2;
pub const SYSTEM_CPU_SET_INFORMATION_ALLOCATED_TO_TARGET_PROCESS: u32 = 4;
pub const SYSTEM_CPU_SET_INFORMATION_REALTIME: u32 = 8;
pub const PF_FLOATING_POINT_PRECISION_ERRATA: u32 = 0;
pub const PF_FLOATING_POINT_EMULATED: u32 = 1;
pub const PF_COMPARE_EXCHANGE_DOUBLE: u32 = 2;
pub const PF_MMX_INSTRUCTIONS_AVAILABLE: u32 = 3;
pub const PF_PPC_MOVEMEM_64BIT_OK: u32 = 4;
pub const PF_ALPHA_BYTE_INSTRUCTIONS: u32 = 5;
pub const PF_XMMI_INSTRUCTIONS_AVAILABLE: u32 = 6;
pub const PF_3DNOW_INSTRUCTIONS_AVAILABLE: u32 = 7;
pub const PF_RDTSC_INSTRUCTION_AVAILABLE: u32 = 8;
pub const PF_PAE_ENABLED: u32 = 9;
pub const PF_XMMI64_INSTRUCTIONS_AVAILABLE: u32 = 10;
pub const PF_SSE_DAZ_MODE_AVAILABLE: u32 = 11;
pub const PF_NX_ENABLED: u32 = 12;
pub const PF_SSE3_INSTRUCTIONS_AVAILABLE: u32 = 13;
pub const PF_COMPARE_EXCHANGE128: u32 = 14;
pub const PF_COMPARE64_EXCHANGE128: u32 = 15;
pub const PF_CHANNELS_ENABLED: u32 = 16;
pub const PF_XSAVE_ENABLED: u32 = 17;
pub const PF_ARM_VFP_32_REGISTERS_AVAILABLE: u32 = 18;
pub const PF_ARM_NEON_INSTRUCTIONS_AVAILABLE: u32 = 19;
pub const PF_SECOND_LEVEL_ADDRESS_TRANSLATION: u32 = 20;
pub const PF_VIRT_FIRMWARE_ENABLED: u32 = 21;
pub const PF_RDWRFSGSBASE_AVAILABLE: u32 = 22;
pub const PF_FASTFAIL_AVAILABLE: u32 = 23;
pub const PF_ARM_DIVIDE_INSTRUCTION_AVAILABLE: u32 = 24;
pub const PF_ARM_64BIT_LOADSTORE_ATOMIC: u32 = 25;
pub const PF_ARM_EXTERNAL_CACHE_AVAILABLE: u32 = 26;
pub const PF_ARM_FMAC_INSTRUCTIONS_AVAILABLE: u32 = 27;
pub const PF_RDRAND_INSTRUCTION_AVAILABLE: u32 = 28;
pub const PF_ARM_V8_INSTRUCTIONS_AVAILABLE: u32 = 29;
pub const PF_ARM_V8_CRYPTO_INSTRUCTIONS_AVAILABLE: u32 = 30;
pub const PF_ARM_V8_CRC32_INSTRUCTIONS_AVAILABLE: u32 = 31;
pub const PF_RDTSCP_INSTRUCTION_AVAILABLE: u32 = 32;
pub const PF_RDPID_INSTRUCTION_AVAILABLE: u32 = 33;
pub const PF_ARM_V81_ATOMIC_INSTRUCTIONS_AVAILABLE: u32 = 34;
pub const PF_MONITORX_INSTRUCTION_AVAILABLE: u32 = 35;
pub const PF_SSSE3_INSTRUCTIONS_AVAILABLE: u32 = 36;
pub const PF_SSE4_1_INSTRUCTIONS_AVAILABLE: u32 = 37;
pub const PF_SSE4_2_INSTRUCTIONS_AVAILABLE: u32 = 38;
pub const PF_AVX_INSTRUCTIONS_AVAILABLE: u32 = 39;
pub const PF_AVX2_INSTRUCTIONS_AVAILABLE: u32 = 40;
pub const PF_AVX512F_INSTRUCTIONS_AVAILABLE: u32 = 41;
pub const PF_ERMS_AVAILABLE: u32 = 42;
pub const PF_ARM_V82_DP_INSTRUCTIONS_AVAILABLE: u32 = 43;
pub const PF_ARM_V83_JSCVT_INSTRUCTIONS_AVAILABLE: u32 = 44;
pub const PF_ARM_V83_LRCPC_INSTRUCTIONS_AVAILABLE: u32 = 45;
pub const IsNEC_98: u32 = 0;
pub const IsNotNEC_98: u32 = 1;
pub const PROCESSOR_FEATURE_MAX: u32 = 64;
pub const EXCEPTION_NONCONTINUABLE: u32 = 1;
pub const EXCEPTION_UNWINDING: u32 = 2;
pub const EXCEPTION_EXIT_UNWIND: u32 = 4;
pub const EXCEPTION_STACK_INVALID: u32 = 8;
pub const EXCEPTION_NESTED_CALL: u32 = 16;
pub const EXCEPTION_TARGET_UNWIND: u32 = 32;
pub const EXCEPTION_COLLIDED_UNWIND: u32 = 64;
pub const EXCEPTION_SOFTWARE_ORIGINATE: u32 = 128;
pub const EXCEPTION_UNWIND: u32 = 102;
pub const EXCEPTION_MAXIMUM_PARAMETERS: u32 = 15;
pub const THREAD_WAIT_OBJECTS: u32 = 3;
pub const SINGLE_GROUP_LEGACY_API: u32 = 1;
pub const KB_SECONDARY_DATA_FLAG_ADDITIONAL_DATA: u32 = 1;
pub const KB_SECONDARY_DATA_FLAG_NO_DEVICE_ACCESS: u32 = 2;
pub const KB_ADD_PAGES_FLAG_VIRTUAL_ADDRESS: u32 = 1;
pub const KB_ADD_PAGES_FLAG_PHYSICAL_ADDRESS: u32 = 2;
pub const KB_ADD_PAGES_FLAG_ADDITIONAL_RANGES_EXIST: u32 = 2147483648;
pub const KB_REMOVE_PAGES_FLAG_VIRTUAL_ADDRESS: u32 = 1;
pub const KB_REMOVE_PAGES_FLAG_PHYSICAL_ADDRESS: u32 = 2;
pub const KB_REMOVE_PAGES_FLAG_ADDITIONAL_RANGES_EXIST: u32 = 2147483648;
pub const KE_MAX_TRIAGE_DUMP_DATA_MEMORY_SIZE: u32 = 33554432;
pub const KB_TRIAGE_DUMP_DATA_FLAG_BUGCHECK_ACTIVE: u32 = 1;
pub const EXCEPTION_DIVIDED_BY_ZERO: u32 = 0;
pub const EXCEPTION_DEBUG: u32 = 1;
pub const EXCEPTION_NMI: u32 = 2;
pub const EXCEPTION_INT3: u32 = 3;
pub const EXCEPTION_BOUND_CHECK: u32 = 5;
pub const EXCEPTION_INVALID_OPCODE: u32 = 6;
pub const EXCEPTION_NPX_NOT_AVAILABLE: u32 = 7;
pub const EXCEPTION_DOUBLE_FAULT: u32 = 8;
pub const EXCEPTION_NPX_OVERRUN: u32 = 9;
pub const EXCEPTION_INVALID_TSS: u32 = 10;
pub const EXCEPTION_SEGMENT_NOT_PRESENT: u32 = 11;
pub const EXCEPTION_STACK_FAULT: u32 = 12;
pub const EXCEPTION_GP_FAULT: u32 = 13;
pub const EXCEPTION_RESERVED_TRAP: u32 = 15;
pub const EXCEPTION_NPX_ERROR: u32 = 16;
pub const EXCEPTION_ALIGNMENT_CHECK: u32 = 17;
pub const EXCEPTION_CP_FAULT: u32 = 21;
pub const EXCEPTION_SE_FAULT: u32 = 23;
pub const EXCEPTION_VIRTUALIZATION_FAULT: u32 = 32;
pub const KE_PROCESSOR_CHANGE_ADD_EXISTING: u32 = 1;
pub const INVALID_PROCESSOR_INDEX: u32 = 4294967295;
pub const POOL_COLD_ALLOCATION: u32 = 256;
pub const POOL_NX_ALLOCATION: u32 = 512;
pub const POOL_ZERO_ALLOCATION: u32 = 1024;
pub const POOL_QUOTA_FAIL_INSTEAD_OF_RAISE: u32 = 8;
pub const POOL_RAISE_IF_ALLOCATION_FAILURE: u32 = 16;
pub const POOL_EXTENDED_PARAMETER_TYPE_BITS: u32 = 8;
pub const POOL_EXTENDED_PARAMETER_REQUIRED_FIELD_BITS: u32 = 1;
pub const POOL_EXTENDED_PARAMETER_RESERVED_BITS: u32 = 55;
pub const SECURE_POOL_FLAGS_NONE: u32 = 0;
pub const SECURE_POOL_FLAGS_FREEABLE: u32 = 1;
pub const SECURE_POOL_FLAGS_MODIFIABLE: u32 = 2;
pub const POOL_CREATE_FLG_SECURE_POOL: u32 = 1;
pub const POOL_CREATE_FLG_USE_GLOBAL_POOL: u32 = 2;
pub const POOL_CREATE_FLG_VALID_FLAGS: u32 = 3;
pub const POOL_CREATE_PARAMS_VERSION: u32 = 1;
pub const FM_LOCK_BIT: u32 = 1;
pub const FM_LOCK_BIT_V: u32 = 0;
pub const EX_LOOKASIDE_LIST_EX_FLAGS_RAISE_ON_FAIL: u32 = 1;
pub const EX_LOOKASIDE_LIST_EX_FLAGS_FAIL_NO_RAISE: u32 = 2;
pub const EX_MAXIMUM_LOOKASIDE_DEPTH_BASE: u32 = 256;
pub const EX_MAXIMUM_LOOKASIDE_DEPTH_LIMIT: u32 = 1024;
pub const ResourceNeverExclusive: u32 = 16;
pub const ResourceReleaseByOtherThread: u32 = 32;
pub const ResourceOwnedExclusive: u32 = 128;
pub const RESOURCE_HASH_TABLE_SIZE: u32 = 64;
pub const FLAG_OWNER_POINTER_IS_THREAD: u32 = 1;
pub const EX_RUNDOWN_ACTIVE: u32 = 1;
pub const EX_RUNDOWN_COUNT_SHIFT: u32 = 1;
pub const EX_RUNDOWN_COUNT_INC: u32 = 2;
pub const EX_TIMER_HIGH_RESOLUTION: u32 = 4;
pub const EX_TIMER_NO_WAKE: u32 = 8;
pub const EX_TIMER_NOTIFICATION: u32 = 2147483648;
pub const EX_CARR_ALLOCATE_PAGED_POOL: u32 = 0;
pub const EX_CARR_ALLOCATE_NONPAGED_POOL: u32 = 1;
pub const EX_CARR_DISABLE_EXPANSION: u32 = 2;
pub const EX_CARR_VALID_FLAGS: u32 = 3;
pub const EX_DEFAULT_PUSH_LOCK_FLAGS: u32 = 0;
pub const ATS_DEVICE_SVM_OPTOUT: u32 = 1;
pub const EVENT_INCREMENT: u32 = 1;
pub const IO_NO_INCREMENT: u32 = 0;
pub const IO_CD_ROM_INCREMENT: u32 = 1;
pub const IO_DISK_INCREMENT: u32 = 1;
pub const IO_KEYBOARD_INCREMENT: u32 = 6;
pub const IO_MAILSLOT_INCREMENT: u32 = 2;
pub const IO_MOUSE_INCREMENT: u32 = 6;
pub const IO_NAMED_PIPE_INCREMENT: u32 = 2;
pub const IO_NETWORK_INCREMENT: u32 = 2;
pub const IO_PARALLEL_INCREMENT: u32 = 1;
pub const IO_SERIAL_INCREMENT: u32 = 2;
pub const IO_SOUND_INCREMENT: u32 = 8;
pub const IO_VIDEO_INCREMENT: u32 = 1;
pub const SEMAPHORE_INCREMENT: u32 = 1;
pub const MM_MAXIMUM_DISK_IO_SIZE: u32 = 65536;
pub const MM_PERMANENT_ADDRESS_IS_IO_SPACE: u32 = 1;
pub const MM_DUMP_MAP_CACHED: u32 = 1;
pub const MM_DUMP_MAP_INVALIDATE: u32 = 2;
pub const MdlMappingNoWrite: u32 = 2147483648;
pub const MdlMappingNoExecute: u32 = 1073741824;
pub const MdlMappingWithGuardPtes: u32 = 536870912;
pub const MM_MAPPING_ADDRESS_DIVISIBLE: u32 = 1;
pub const MM_DONT_ZERO_ALLOCATION: u32 = 1;
pub const MM_ALLOCATE_FROM_LOCAL_NODE_ONLY: u32 = 2;
pub const MM_ALLOCATE_FULLY_REQUIRED: u32 = 4;
pub const MM_ALLOCATE_NO_WAIT: u32 = 8;
pub const MM_ALLOCATE_PREFER_CONTIGUOUS: u32 = 16;
pub const MM_ALLOCATE_REQUIRE_CONTIGUOUS_CHUNKS: u32 = 32;
pub const MM_ALLOCATE_FAST_LARGE_PAGES: u32 = 64;
pub const MM_ALLOCATE_TRIM_IF_NECESSARY: u32 = 128;
pub const MM_ALLOCATE_AND_HOT_REMOVE: u32 = 256;
pub const MM_FREE_MDL_PAGES_ZERO: u32 = 1;
pub const MM_ANY_NODE_OK: u32 = 2147483648;
pub const MM_ALLOCATE_CONTIGUOUS_MEMORY_FAST_ONLY: u32 = 1;
pub const MM_PROTECT_DRIVER_SECTION_ALLOW_UNLOAD: u32 = 1;
pub const MM_PROTECT_DRIVER_SECTION_VALID_FLAGS: u32 = 1;
pub const INITIAL_PRIVILEGE_COUNT: u32 = 3;
pub const IO_TYPE_ADAPTER: u32 = 1;
pub const IO_TYPE_CONTROLLER: u32 = 2;
pub const IO_TYPE_DEVICE: u32 = 3;
pub const IO_TYPE_DRIVER: u32 = 4;
pub const IO_TYPE_FILE: u32 = 5;
pub const IO_TYPE_IRP: u32 = 6;
pub const IO_TYPE_MASTER_ADAPTER: u32 = 7;
pub const IO_TYPE_OPEN_PACKET: u32 = 8;
pub const IO_TYPE_TIMER: u32 = 9;
pub const IO_TYPE_VPB: u32 = 10;
pub const IO_TYPE_ERROR_LOG: u32 = 11;
pub const IO_TYPE_ERROR_MESSAGE: u32 = 12;
pub const IO_TYPE_DEVICE_OBJECT_EXTENSION: u32 = 13;
pub const IO_TYPE_IORING: u32 = 14;
pub const IRP_MJ_CREATE: u32 = 0;
pub const IRP_MJ_CREATE_NAMED_PIPE: u32 = 1;
pub const IRP_MJ_CLOSE: u32 = 2;
pub const IRP_MJ_READ: u32 = 3;
pub const IRP_MJ_WRITE: u32 = 4;
pub const IRP_MJ_QUERY_INFORMATION: u32 = 5;
pub const IRP_MJ_SET_INFORMATION: u32 = 6;
pub const IRP_MJ_QUERY_EA: u32 = 7;
pub const IRP_MJ_SET_EA: u32 = 8;
pub const IRP_MJ_FLUSH_BUFFERS: u32 = 9;
pub const IRP_MJ_QUERY_VOLUME_INFORMATION: u32 = 10;
pub const IRP_MJ_SET_VOLUME_INFORMATION: u32 = 11;
pub const IRP_MJ_DIRECTORY_CONTROL: u32 = 12;
pub const IRP_MJ_FILE_SYSTEM_CONTROL: u32 = 13;
pub const IRP_MJ_DEVICE_CONTROL: u32 = 14;
pub const IRP_MJ_INTERNAL_DEVICE_CONTROL: u32 = 15;
pub const IRP_MJ_SHUTDOWN: u32 = 16;
pub const IRP_MJ_LOCK_CONTROL: u32 = 17;
pub const IRP_MJ_CLEANUP: u32 = 18;
pub const IRP_MJ_CREATE_MAILSLOT: u32 = 19;
pub const IRP_MJ_QUERY_SECURITY: u32 = 20;
pub const IRP_MJ_SET_SECURITY: u32 = 21;
pub const IRP_MJ_POWER: u32 = 22;
pub const IRP_MJ_SYSTEM_CONTROL: u32 = 23;
pub const IRP_MJ_DEVICE_CHANGE: u32 = 24;
pub const IRP_MJ_QUERY_QUOTA: u32 = 25;
pub const IRP_MJ_SET_QUOTA: u32 = 26;
pub const IRP_MJ_PNP: u32 = 27;
pub const IRP_MJ_PNP_POWER: u32 = 27;
pub const IRP_MJ_MAXIMUM_FUNCTION: u32 = 27;
pub const IRP_MJ_SCSI: u32 = 15;
pub const IRP_MN_SCSI_CLASS: u32 = 1;
pub const IRP_MN_START_DEVICE: u32 = 0;
pub const IRP_MN_QUERY_REMOVE_DEVICE: u32 = 1;
pub const IRP_MN_REMOVE_DEVICE: u32 = 2;
pub const IRP_MN_CANCEL_REMOVE_DEVICE: u32 = 3;
pub const IRP_MN_STOP_DEVICE: u32 = 4;
pub const IRP_MN_QUERY_STOP_DEVICE: u32 = 5;
pub const IRP_MN_CANCEL_STOP_DEVICE: u32 = 6;
pub const IRP_MN_QUERY_DEVICE_RELATIONS: u32 = 7;
pub const IRP_MN_QUERY_INTERFACE: u32 = 8;
pub const IRP_MN_QUERY_CAPABILITIES: u32 = 9;
pub const IRP_MN_QUERY_RESOURCES: u32 = 10;
pub const IRP_MN_QUERY_RESOURCE_REQUIREMENTS: u32 = 11;
pub const IRP_MN_QUERY_DEVICE_TEXT: u32 = 12;
pub const IRP_MN_FILTER_RESOURCE_REQUIREMENTS: u32 = 13;
pub const IRP_MN_READ_CONFIG: u32 = 15;
pub const IRP_MN_WRITE_CONFIG: u32 = 16;
pub const IRP_MN_EJECT: u32 = 17;
pub const IRP_MN_SET_LOCK: u32 = 18;
pub const IRP_MN_QUERY_ID: u32 = 19;
pub const IRP_MN_QUERY_PNP_DEVICE_STATE: u32 = 20;
pub const IRP_MN_QUERY_BUS_INFORMATION: u32 = 21;
pub const IRP_MN_DEVICE_USAGE_NOTIFICATION: u32 = 22;
pub const IRP_MN_SURPRISE_REMOVAL: u32 = 23;
pub const IRP_MN_DEVICE_ENUMERATED: u32 = 25;
pub const IRP_MN_WAIT_WAKE: u32 = 0;
pub const IRP_MN_POWER_SEQUENCE: u32 = 1;
pub const IRP_MN_SET_POWER: u32 = 2;
pub const IRP_MN_QUERY_POWER: u32 = 3;
pub const IRP_MN_QUERY_ALL_DATA: u32 = 0;
pub const IRP_MN_QUERY_SINGLE_INSTANCE: u32 = 1;
pub const IRP_MN_CHANGE_SINGLE_INSTANCE: u32 = 2;
pub const IRP_MN_CHANGE_SINGLE_ITEM: u32 = 3;
pub const IRP_MN_ENABLE_EVENTS: u32 = 4;
pub const IRP_MN_DISABLE_EVENTS: u32 = 5;
pub const IRP_MN_ENABLE_COLLECTION: u32 = 6;
pub const IRP_MN_DISABLE_COLLECTION: u32 = 7;
pub const IRP_MN_REGINFO: u32 = 8;
pub const IRP_MN_EXECUTE_METHOD: u32 = 9;
pub const IRP_MN_REGINFO_EX: u32 = 11;
pub const IO_FORCE_ACCESS_CHECK: u32 = 1;
pub const IO_NO_PARAMETER_CHECKING: u32 = 256;
pub const IO_REPARSE: u32 = 0;
pub const IO_REMOUNT: u32 = 1;
pub const IO_REPARSE_GLOBAL: u32 = 2;
pub const VPB_MOUNTED: u32 = 1;
pub const VPB_LOCKED: u32 = 2;
pub const VPB_PERSISTENT: u32 = 4;
pub const VPB_REMOVE_PENDING: u32 = 8;
pub const VPB_RAW_MOUNT: u32 = 16;
pub const VPB_DIRECT_WRITES_ALLOWED: u32 = 32;
pub const VPB_FLAGS_BYPASSIO_BLOCKED: u32 = 64;
pub const VPB_DISMOUNTING: u32 = 128;
pub const DO_VERIFY_VOLUME: u32 = 2;
pub const DO_BUFFERED_IO: u32 = 4;
pub const DO_EXCLUSIVE: u32 = 8;
pub const DO_DIRECT_IO: u32 = 16;
pub const DO_MAP_IO_BUFFER: u32 = 32;
pub const DO_DEVICE_INITIALIZING: u32 = 128;
pub const DO_SHUTDOWN_REGISTERED: u32 = 2048;
pub const DO_BUS_ENUMERATED_DEVICE: u32 = 4096;
pub const DO_POWER_PAGABLE: u32 = 8192;
pub const DO_POWER_INRUSH: u32 = 16384;
pub const DO_DEVICE_TO_BE_RESET: u32 = 67108864;
pub const DO_DAX_VOLUME: u32 = 268435456;
pub const DRVO_UNLOAD_INVOKED: u32 = 1;
pub const DRVO_LEGACY_DRIVER: u32 = 2;
pub const DRVO_BUILTIN_DRIVER: u32 = 4;
pub const FO_FILE_OPEN: u32 = 1;
pub const FO_SYNCHRONOUS_IO: u32 = 2;
pub const FO_ALERTABLE_IO: u32 = 4;
pub const FO_NO_INTERMEDIATE_BUFFERING: u32 = 8;
pub const FO_WRITE_THROUGH: u32 = 16;
pub const FO_SEQUENTIAL_ONLY: u32 = 32;
pub const FO_CACHE_SUPPORTED: u32 = 64;
pub const FO_NAMED_PIPE: u32 = 128;
pub const FO_STREAM_FILE: u32 = 256;
pub const FO_MAILSLOT: u32 = 512;
pub const FO_GENERATE_AUDIT_ON_CLOSE: u32 = 1024;
pub const FO_QUEUE_IRP_TO_THREAD: u32 = 1024;
pub const FO_DIRECT_DEVICE_OPEN: u32 = 2048;
pub const FO_FILE_MODIFIED: u32 = 4096;
pub const FO_FILE_SIZE_CHANGED: u32 = 8192;
pub const FO_CLEANUP_COMPLETE: u32 = 16384;
pub const FO_TEMPORARY_FILE: u32 = 32768;
pub const FO_DELETE_ON_CLOSE: u32 = 65536;
pub const FO_OPENED_CASE_SENSITIVE: u32 = 131072;
pub const FO_HANDLE_CREATED: u32 = 262144;
pub const FO_FILE_FAST_IO_READ: u32 = 524288;
pub const FO_RANDOM_ACCESS: u32 = 1048576;
pub const FO_FILE_OPEN_CANCELLED: u32 = 2097152;
pub const FO_VOLUME_OPEN: u32 = 4194304;
pub const FO_BYPASS_IO_ENABLED: u32 = 8388608;
pub const FO_REMOTE_ORIGIN: u32 = 16777216;
pub const FO_DISALLOW_EXCLUSIVE: u32 = 33554432;
pub const FO_SKIP_COMPLETION_PORT: u32 = 33554432;
pub const FO_SKIP_SET_EVENT: u32 = 67108864;
pub const FO_SKIP_SET_FAST_IO: u32 = 134217728;
pub const FO_INDIRECT_WAIT_OBJECT: u32 = 268435456;
pub const FO_SECTION_MINSTORE_TREATMENT: u32 = 536870912;
pub const FO_FLAGS_VALID_ONLY_DURING_CREATE: u32 = 33554432;
pub const IRP_NOCACHE: u32 = 1;
pub const IRP_PAGING_IO: u32 = 2;
pub const IRP_MOUNT_COMPLETION: u32 = 2;
pub const IRP_SYNCHRONOUS_API: u32 = 4;
pub const IRP_ASSOCIATED_IRP: u32 = 8;
pub const IRP_BUFFERED_IO: u32 = 16;
pub const IRP_DEALLOCATE_BUFFER: u32 = 32;
pub const IRP_INPUT_OPERATION: u32 = 64;
pub const IRP_SYNCHRONOUS_PAGING_IO: u32 = 64;
pub const IRP_CREATE_OPERATION: u32 = 128;
pub const IRP_READ_OPERATION: u32 = 256;
pub const IRP_WRITE_OPERATION: u32 = 512;
pub const IRP_CLOSE_OPERATION: u32 = 1024;
pub const IRP_DEFER_IO_COMPLETION: u32 = 2048;
pub const IRP_OB_QUERY_NAME: u32 = 4096;
pub const IRP_HOLD_DEVICE_QUEUE: u32 = 8192;
pub const IRP_UM_DRIVER_INITIATED_IO: u32 = 4194304;
pub const IRP_QUOTA_CHARGED: u32 = 1;
pub const IRP_ALLOCATED_MUST_SUCCEED: u32 = 2;
pub const IRP_ALLOCATED_FIXED_SIZE: u32 = 4;
pub const IRP_LOOKASIDE_ALLOCATION: u32 = 8;
pub const SL_PENDING_RETURNED: u32 = 1;
pub const SL_ERROR_RETURNED: u32 = 2;
pub const SL_INVOKE_ON_CANCEL: u32 = 32;
pub const SL_INVOKE_ON_SUCCESS: u32 = 64;
pub const SL_INVOKE_ON_ERROR: u32 = 128;
pub const SL_FORCE_ACCESS_CHECK: u32 = 1;
pub const SL_OPEN_PAGING_FILE: u32 = 2;
pub const SL_OPEN_TARGET_DIRECTORY: u32 = 4;
pub const SL_STOP_ON_SYMLINK: u32 = 8;
pub const SL_IGNORE_READONLY_ATTRIBUTE: u32 = 64;
pub const SL_CASE_SENSITIVE: u32 = 128;
pub const SL_KEY_SPECIFIED: u32 = 1;
pub const SL_OVERRIDE_VERIFY_VOLUME: u32 = 2;
pub const SL_WRITE_THROUGH: u32 = 4;
pub const SL_FT_SEQUENTIAL_WRITE: u32 = 8;
pub const SL_FORCE_DIRECT_WRITE: u32 = 16;
pub const SL_REALTIME_STREAM: u32 = 32;
pub const SL_PERSISTENT_MEMORY_FIXED_MAPPING: u32 = 32;
pub const SL_BYPASS_IO: u32 = 64;
pub const SL_FORCE_ASYNCHRONOUS: u32 = 1;
pub const SL_READ_ACCESS_GRANTED: u32 = 1;
pub const SL_WRITE_ACCESS_GRANTED: u32 = 4;
pub const SL_FAIL_IMMEDIATELY: u32 = 1;
pub const SL_EXCLUSIVE_LOCK: u32 = 2;
pub const SL_RESTART_SCAN: u32 = 1;
pub const SL_RETURN_SINGLE_ENTRY: u32 = 2;
pub const SL_INDEX_SPECIFIED: u32 = 4;
pub const SL_RETURN_ON_DISK_ENTRIES_ONLY: u32 = 8;
pub const SL_NO_CURSOR_UPDATE: u32 = 16;
pub const SL_QUERY_DIRECTORY_MASK: u32 = 27;
pub const SL_WATCH_TREE: u32 = 1;
pub const SL_ALLOW_RAW_MOUNT: u32 = 1;
pub const SL_BYPASS_ACCESS_CHECK: u32 = 1;
pub const SL_INFO_FORCE_ACCESS_CHECK: u32 = 1;
pub const SL_INFO_IGNORE_READONLY_ATTRIBUTE: u32 = 64;
pub const PNP_DEVICE_DISABLED: u32 = 1;
pub const PNP_DEVICE_DONT_DISPLAY_IN_UI: u32 = 2;
pub const PNP_DEVICE_FAILED: u32 = 4;
pub const PNP_DEVICE_REMOVED: u32 = 8;
pub const PNP_DEVICE_RESOURCE_REQUIREMENTS_CHANGED: u32 = 16;
pub const PNP_DEVICE_NOT_DISABLEABLE: u32 = 32;
pub const PNP_DEVICE_DISCONNECTED: u32 = 64;
pub const PNP_DEVICE_RESOURCE_UPDATED: u32 = 128;
pub const PNP_DEVICE_ASSIGNED_TO_GUEST: u32 = 256;
pub const IO_SHARE_ACCESS_NO_WRITE_PERMISSION: u32 = 2147483648;
pub const IO_SHARE_ACCESS_NON_PRIMARY_STREAM: u32 = 128;
pub const IO_CHECK_SHARE_ACCESS_UPDATE_SHARE_ACCESS: u32 = 1;
pub const IO_CHECK_SHARE_ACCESS_DONT_UPDATE_FILE_OBJECT: u32 = 2;
pub const IO_CHECK_SHARE_ACCESS_DONT_CHECK_READ: u32 = 4;
pub const IO_CHECK_SHARE_ACCESS_DONT_CHECK_WRITE: u32 = 8;
pub const IO_CHECK_SHARE_ACCESS_DONT_CHECK_DELETE: u32 = 16;
pub const IO_CHECK_SHARE_ACCESS_FORCE_CHECK: u32 = 32;
pub const IO_CHECK_SHARE_ACCESS_FORCE_USING_SCB: u32 = 64;
pub const CONNECT_FULLY_SPECIFIED: u32 = 1;
pub const CONNECT_LINE_BASED: u32 = 2;
pub const CONNECT_MESSAGE_BASED: u32 = 3;
pub const CONNECT_FULLY_SPECIFIED_GROUP: u32 = 4;
pub const CONNECT_MESSAGE_BASED_PASSIVE: u32 = 5;
pub const CONNECT_CURRENT_VERSION: u32 = 5;
pub const WDM_MAJORVERSION: u32 = 6;
pub const WDM_MINORVERSION: u32 = 0;
pub const WMIREG_ACTION_REGISTER: u32 = 1;
pub const WMIREG_ACTION_DEREGISTER: u32 = 2;
pub const WMIREG_ACTION_REREGISTER: u32 = 3;
pub const WMIREG_ACTION_UPDATE_GUIDS: u32 = 4;
pub const WMIREG_ACTION_BLOCK_IRPS: u32 = 5;
pub const WMIREGISTER: u32 = 0;
pub const WMIUPDATE: u32 = 1;
pub const IO_TYPE_CSQ_IRP_CONTEXT: u32 = 1;
pub const IO_TYPE_CSQ: u32 = 2;
pub const IO_TYPE_CSQ_EX: u32 = 3;
pub const IO_ATTRIBUTION_INFO_V1: u32 = 1;
pub const IO_SET_IRP_IO_ATTRIBUTION_FROM_THREAD: u32 = 1;
pub const IO_SET_IRP_IO_ATTRIBUTION_FROM_PROCESS: u32 = 2;
pub const IO_SET_IRP_IO_ATTRIBUTION_FLAGS_MASK: u32 = 3;
pub const EVENT_MIN_LEVEL: u32 = 0;
pub const EVENT_MAX_LEVEL: u32 = 255;
pub const EVENT_ACTIVITY_CTRL_GET_ID: u32 = 1;
pub const EVENT_ACTIVITY_CTRL_SET_ID: u32 = 2;
pub const EVENT_ACTIVITY_CTRL_CREATE_ID: u32 = 3;
pub const EVENT_ACTIVITY_CTRL_GET_SET_ID: u32 = 4;
pub const EVENT_ACTIVITY_CTRL_CREATE_SET_ID: u32 = 5;
pub const MAX_EVENT_DATA_DESCRIPTORS: u32 = 128;
pub const MAX_EVENT_FILTER_DATA_SIZE: u32 = 1024;
pub const MAX_EVENT_FILTER_PAYLOAD_SIZE: u32 = 4096;
pub const MAX_EVENT_FILTER_EVENT_NAME_SIZE: u32 = 4096;
pub const MAX_EVENT_FILTERS_COUNT: u32 = 13;
pub const MAX_EVENT_FILTER_PID_COUNT: u32 = 8;
pub const MAX_EVENT_FILTER_EVENT_ID_COUNT: u32 = 64;
pub const EVENT_FILTER_TYPE_NONE: u32 = 0;
pub const EVENT_FILTER_TYPE_SCHEMATIZED: u32 = 2147483648;
pub const EVENT_FILTER_TYPE_SYSTEM_FLAGS: u32 = 2147483649;
pub const EVENT_FILTER_TYPE_TRACEHANDLE: u32 = 2147483650;
pub const EVENT_FILTER_TYPE_PID: u32 = 2147483652;
pub const EVENT_FILTER_TYPE_EXECUTABLE_NAME: u32 = 2147483656;
pub const EVENT_FILTER_TYPE_PACKAGE_ID: u32 = 2147483664;
pub const EVENT_FILTER_TYPE_PACKAGE_APP_ID: u32 = 2147483680;
pub const EVENT_FILTER_TYPE_PAYLOAD: u32 = 2147483904;
pub const EVENT_FILTER_TYPE_EVENT_ID: u32 = 2147484160;
pub const EVENT_FILTER_TYPE_EVENT_NAME: u32 = 2147484672;
pub const EVENT_FILTER_TYPE_STACKWALK: u32 = 2147487744;
pub const EVENT_FILTER_TYPE_STACKWALK_NAME: u32 = 2147491840;
pub const EVENT_FILTER_TYPE_STACKWALK_LEVEL_KW: u32 = 2147500032;
pub const EVENT_FILTER_TYPE_CONTAINER: u32 = 2147516416;
pub const EVENT_DATA_DESCRIPTOR_TYPE_NONE: u32 = 0;
pub const EVENT_DATA_DESCRIPTOR_TYPE_EVENT_METADATA: u32 = 1;
pub const EVENT_DATA_DESCRIPTOR_TYPE_PROVIDER_METADATA: u32 = 2;
pub const EVENT_DATA_DESCRIPTOR_TYPE_TIMESTAMP_OVERRIDE: u32 = 3;
pub const EVENT_WRITE_FLAG_NO_FAULTING: u32 = 1;
pub const EVENT_WRITE_FLAG_INPRIVATE: u32 = 2;
pub const __string_type: u32 = 0;
pub const __guid_type: u32 = 0;
pub const __multiString_type: u32 = 0;
pub const PCI_SECURITY_INTERFACE_VERSION: u32 = 1;
pub const PCI_SECURITY_INTERFACE_VERSION2: u32 = 2;
pub const PCI_SECURITY_FULLY_SUPPORTED: u32 = 1;
pub const PCI_SECURITY_ENHANCED: u32 = 2;
pub const PCI_SECURITY_GUEST_ASSIGNED: u32 = 1;
pub const PCI_SECURITY_DIRECT_TRANSLATED_P2P: u32 = 4;
pub const PCI_SECURITY_SRIOV_DIRECT_TRANSLATED_P2P: u32 = 262144;
pub const PCI_ATS_INTERFACE_VERSION: u32 = 1;
pub const PNP_EXTENDED_ADDRESS_INTERFACE_VERSION: u32 = 1;
pub const D3COLD_SUPPORT_INTERFACE_VERSION: u32 = 1;
pub const PCI_PTM_TIME_SOURCE_AUX: u32 = 4294967295;
pub const NPEM_CONTROL_INTERFACE_VERSION1: u32 = 1;
pub const NPEM_CONTROL_INTERFACE_VERSION2: u32 = 2;
pub const NPEM_CONTROL_INTERFACE_CURRENT_VERSION: u32 = 2;
pub const PLUGPLAY_REGKEY_DEVICE: u32 = 1;
pub const PLUGPLAY_REGKEY_DRIVER: u32 = 2;
pub const PLUGPLAY_REGKEY_CURRENT_HWPROFILE: u32 = 4;
pub const DEVICE_INTERFACE_INCLUDE_NONACTIVE: u32 = 1;
pub const PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES: u32 = 1;
pub const KERNEL_SOFT_RESTART_NOTIFICATION_VERSION: u32 = 1;
pub const DEVPROP_TYPEMOD_ARRAY: u32 = 4096;
pub const DEVPROP_TYPEMOD_LIST: u32 = 8192;
pub const DEVPROP_TYPE_EMPTY: u32 = 0;
pub const DEVPROP_TYPE_NULL: u32 = 1;
pub const DEVPROP_TYPE_SBYTE: u32 = 2;
pub const DEVPROP_TYPE_BYTE: u32 = 3;
pub const DEVPROP_TYPE_INT16: u32 = 4;
pub const DEVPROP_TYPE_UINT16: u32 = 5;
pub const DEVPROP_TYPE_INT32: u32 = 6;
pub const DEVPROP_TYPE_UINT32: u32 = 7;
pub const DEVPROP_TYPE_INT64: u32 = 8;
pub const DEVPROP_TYPE_UINT64: u32 = 9;
pub const DEVPROP_TYPE_FLOAT: u32 = 10;
pub const DEVPROP_TYPE_DOUBLE: u32 = 11;
pub const DEVPROP_TYPE_DECIMAL: u32 = 12;
pub const DEVPROP_TYPE_GUID: u32 = 13;
pub const DEVPROP_TYPE_CURRENCY: u32 = 14;
pub const DEVPROP_TYPE_DATE: u32 = 15;
pub const DEVPROP_TYPE_FILETIME: u32 = 16;
pub const DEVPROP_TYPE_BOOLEAN: u32 = 17;
pub const DEVPROP_TYPE_STRING: u32 = 18;
pub const DEVPROP_TYPE_STRING_LIST: u32 = 8210;
pub const DEVPROP_TYPE_SECURITY_DESCRIPTOR: u32 = 19;
pub const DEVPROP_TYPE_SECURITY_DESCRIPTOR_STRING: u32 = 20;
pub const DEVPROP_TYPE_DEVPROPKEY: u32 = 21;
pub const DEVPROP_TYPE_DEVPROPTYPE: u32 = 22;
pub const DEVPROP_TYPE_BINARY: u32 = 4099;
pub const DEVPROP_TYPE_ERROR: u32 = 23;
pub const DEVPROP_TYPE_NTSTATUS: u32 = 24;
pub const DEVPROP_TYPE_STRING_INDIRECT: u32 = 25;
pub const MAX_DEVPROP_TYPE: u32 = 25;
pub const MAX_DEVPROP_TYPEMOD: u32 = 8192;
pub const DEVPROP_MASK_TYPE: u32 = 4095;
pub const DEVPROP_MASK_TYPEMOD: u32 = 61440;
pub const DEVPROPID_FIRST_USABLE: u32 = 2;
pub const PLUGPLAY_PROPERTY_PERSISTENT: u32 = 1;
pub const PNP_REPLACE_NO_MAP: u64 = 9223372036854775807;
pub const PNP_REPLACE_PARAMETERS_VERSION: u32 = 2;
pub const PNP_REPLACE_DRIVER_INTERFACE_VERSION: u32 = 1;
pub const PNP_REPLACE_MEMORY_SUPPORTED: u32 = 1;
pub const PNP_REPLACE_PROCESSOR_SUPPORTED: u32 = 2;
pub const PNP_REPLACE_HARDWARE_MEMORY_MIRRORING: u32 = 4;
pub const PNP_REPLACE_HARDWARE_PAGE_COPY: u32 = 8;
pub const PNP_REPLACE_HARDWARE_QUIESCE: u32 = 16;
pub const DEVICE_RESET_INTERFACE_VERSION_1: u32 = 1;
pub const DEVICE_RESET_INTERFACE_VERSION_2: u32 = 2;
pub const DEVICE_RESET_INTERFACE_VERSION_3: u32 = 3;
pub const DEVICE_RESET_INTERFACE_VERSION: u32 = 1;
pub const SECURE_DRIVER_INTERFACE_VERSION: u32 = 1;
pub const SDEV_IDENTIFIER_INTERFACE_VERSION: u32 = 1;
pub const DEVICE_DESCRIPTION_VERSION: u32 = 0;
pub const DEVICE_DESCRIPTION_VERSION1: u32 = 1;
pub const DEVICE_DESCRIPTION_VERSION2: u32 = 2;
pub const DEVICE_DESCRIPTION_VERSION3: u32 = 3;
pub const DMA_ADAPTER_INFO_VERSION1: u32 = 1;
pub const DMA_ADAPTER_INFO_VERSION_CRASHDUMP: u32 = 4294967295;
pub const ADAPTER_INFO_SYNCHRONOUS_CALLBACK: u32 = 1;
pub const ADAPTER_INFO_API_BYPASS: u32 = 2;
pub const DMA_TRANSFER_INFO_VERSION1: u32 = 1;
pub const DMA_TRANSFER_INFO_VERSION2: u32 = 2;
pub const DMA_TRANSFER_CONTEXT_VERSION1: u32 = 1;
pub const DMA_TRANSFER_CONTEXT_SIZE_V1: u32 = 128;
pub const DMA_SYNCHRONOUS_CALLBACK: u32 = 1;
pub const DMA_ZERO_BUFFERS: u32 = 2;
pub const DMA_FAIL_ON_BOUNCE: u32 = 4;
pub const HAL_MASK_UNMASK_FLAGS_NONE: u32 = 0;
pub const HAL_MASK_UNMASK_FLAGS_SERVICING_DEFERRED: u32 = 1;
pub const HAL_MASK_UNMASK_FLAGS_SERVICING_COMPLETE: u32 = 2;
pub const HAL_DMA_ADAPTER_VERSION_1: u32 = 1;
pub const DOMAIN_COMMON_BUFFER_LARGE_PAGE: u32 = 1;
pub const IOMMU_ACCESS_NONE: u32 = 0;
pub const IOMMU_ACCESS_READ: u32 = 1;
pub const IOMMU_ACCESS_WRITE: u32 = 2;
pub const DMA_IOMMU_INTERFACE_VERSION_1: u32 = 1;
pub const DMA_IOMMU_INTERFACE_VERSION: u32 = 1;
pub const DMA_IOMMU_INTERFACE_EX_VERSION_1: u32 = 1;
pub const DMA_IOMMU_INTERFACE_EX_VERSION_2: u32 = 2;
pub const DMA_IOMMU_INTERFACE_EX_VERSION_MIN: u32 = 1;
pub const DMA_IOMMU_INTERFACE_EX_VERSION_MAX: u32 = 2;
pub const DMA_IOMMU_INTERFACE_EX_VERSION: u32 = 1;
pub const PO_MEM_PRESERVE: u32 = 1;
pub const PO_MEM_CLONE: u32 = 2;
pub const PO_MEM_CL_OR_NCHK: u32 = 4;
pub const PO_MEM_DISCARD: u32 = 32768;
pub const PO_MEM_PAGE_ADDRESS: u32 = 16384;
pub const PO_MEM_BOOT_PHASE: u32 = 65536;
pub const PO_CB_SYSTEM_POWER_POLICY: u32 = 0;
pub const PO_CB_AC_STATUS: u32 = 1;
pub const PO_CB_BUTTON_COLLISION: u32 = 2;
pub const PO_CB_SYSTEM_STATE_LOCK: u32 = 3;
pub const PO_CB_LID_SWITCH_STATE: u32 = 4;
pub const PO_CB_PROCESSOR_POWER_POLICY: u32 = 5;
pub const PO_FX_VERSION_V1: u32 = 1;
pub const PO_FX_VERSION_V2: u32 = 2;
pub const PO_FX_VERSION_V3: u32 = 3;
pub const PO_FX_VERSION: u32 = 1;
pub const PO_FX_COMPONENT_FLAG_F0_ON_DX: u32 = 1;
pub const PO_FX_COMPONENT_FLAG_NO_DEBOUNCE: u32 = 2;
pub const PO_FX_DEVICE_FLAG_RESERVED_1: u32 = 1;
pub const PO_FX_DEVICE_FLAG_DFX_DIRECT_CHILDREN_OPTIONAL: u32 = 2;
pub const PO_FX_DEVICE_FLAG_DFX_POWER_CHILDREN_OPTIONAL: u32 = 4;
pub const PO_FX_DEVICE_FLAG_DFX_CHILDREN_OPTIONAL: u32 = 6;
pub const PO_FX_DEVICE_FLAG_DISABLE_FAST_RESUME: u32 = 8;
pub const PO_FX_DEVICE_FLAG_ENABLE_FAST_RESUME: u32 = 16;
pub const PO_FX_DEVICE_FLAG_NO_FAULT_CALLBACKS: u32 = 32;
pub const PO_FX_DIRECTED_FX_DEFAULT_IDLE_TIMEOUT: u32 = 0;
pub const PO_FX_DIRECTED_FX_MAX_IDLE_TIMEOUT: u32 = 600;
pub const PO_FX_UNKNOWN_POWER: u32 = 4294967295;
pub const PO_FX_UNKNOWN_TIME: i32 = -1;
pub const PO_FX_FLAG_BLOCKING: u32 = 1;
pub const PO_FX_FLAG_ASYNC_ONLY: u32 = 2;
pub const PO_FX_FLAG_PERF_PEP_OPTIONAL: u32 = 1;
pub const PO_FX_FLAG_PERF_QUERY_ON_F0: u32 = 2;
pub const PO_FX_FLAG_PERF_QUERY_ON_ALL_IDLE_STATES: u32 = 4;
pub const OB_FLT_REGISTRATION_VERSION_0100: u32 = 256;
pub const OB_FLT_REGISTRATION_VERSION: u32 = 256;
pub const OB_OPERATION_HANDLE_CREATE: u32 = 1;
pub const OB_OPERATION_HANDLE_DUPLICATE: u32 = 2;
pub const PCI_TYPE0_ADDRESSES: u32 = 6;
pub const PCI_TYPE1_ADDRESSES: u32 = 2;
pub const PCI_TYPE2_ADDRESSES: u32 = 5;
pub const PCI_EXTENDED_CONFIG_LENGTH: u32 = 4096;
pub const PCI_MAX_DEVICES: u32 = 32;
pub const PCI_MAX_FUNCTION: u32 = 8;
pub const PCI_MAX_BRIDGE_NUMBER: u32 = 255;
pub const PCI_MAX_SEGMENT_NUMBER: u32 = 65535;
pub const PCI_INVALID_VENDORID: u32 = 65535;
pub const PCI_MULTIFUNCTION: u32 = 128;
pub const PCI_DEVICE_TYPE: u32 = 0;
pub const PCI_BRIDGE_TYPE: u32 = 1;
pub const PCI_CARDBUS_BRIDGE_TYPE: u32 = 2;
pub const PCI_ENABLE_IO_SPACE: u32 = 1;
pub const PCI_ENABLE_MEMORY_SPACE: u32 = 2;
pub const PCI_ENABLE_BUS_MASTER: u32 = 4;
pub const PCI_ENABLE_SPECIAL_CYCLES: u32 = 8;
pub const PCI_ENABLE_WRITE_AND_INVALIDATE: u32 = 16;
pub const PCI_ENABLE_VGA_COMPATIBLE_PALETTE: u32 = 32;
pub const PCI_ENABLE_PARITY: u32 = 64;
pub const PCI_ENABLE_WAIT_CYCLE: u32 = 128;
pub const PCI_ENABLE_SERR: u32 = 256;
pub const PCI_ENABLE_FAST_BACK_TO_BACK: u32 = 512;
pub const PCI_DISABLE_LEVEL_INTERRUPT: u32 = 1024;
pub const PCI_STATUS_IMMEDIATE_READINESS: u32 = 1;
pub const PCI_STATUS_INTERRUPT_PENDING: u32 = 8;
pub const PCI_STATUS_CAPABILITIES_LIST: u32 = 16;
pub const PCI_STATUS_66MHZ_CAPABLE: u32 = 32;
pub const PCI_STATUS_UDF_SUPPORTED: u32 = 64;
pub const PCI_STATUS_FAST_BACK_TO_BACK: u32 = 128;
pub const PCI_STATUS_DATA_PARITY_DETECTED: u32 = 256;
pub const PCI_STATUS_DEVSEL: u32 = 1536;
pub const PCI_STATUS_SIGNALED_TARGET_ABORT: u32 = 2048;
pub const PCI_STATUS_RECEIVED_TARGET_ABORT: u32 = 4096;
pub const PCI_STATUS_RECEIVED_MASTER_ABORT: u32 = 8192;
pub const PCI_STATUS_SIGNALED_SYSTEM_ERROR: u32 = 16384;
pub const PCI_STATUS_DETECTED_PARITY_ERROR: u32 = 32768;
pub const PCI_WHICHSPACE_CONFIG: u32 = 0;
pub const PCI_WHICHSPACE_ROM: u32 = 1382638416;
pub const PCI_CAPABILITY_ID_POWER_MANAGEMENT: u32 = 1;
pub const PCI_CAPABILITY_ID_AGP: u32 = 2;
pub const PCI_CAPABILITY_ID_VPD: u32 = 3;
pub const PCI_CAPABILITY_ID_SLOT_ID: u32 = 4;
pub const PCI_CAPABILITY_ID_MSI: u32 = 5;
pub const PCI_CAPABILITY_ID_CPCI_HOTSWAP: u32 = 6;
pub const PCI_CAPABILITY_ID_PCIX: u32 = 7;
pub const PCI_CAPABILITY_ID_HYPERTRANSPORT: u32 = 8;
pub const PCI_CAPABILITY_ID_VENDOR_SPECIFIC: u32 = 9;
pub const PCI_CAPABILITY_ID_DEBUG_PORT: u32 = 10;
pub const PCI_CAPABILITY_ID_CPCI_RES_CTRL: u32 = 11;
pub const PCI_CAPABILITY_ID_SHPC: u32 = 12;
pub const PCI_CAPABILITY_ID_P2P_SSID: u32 = 13;
pub const PCI_CAPABILITY_ID_AGP_TARGET: u32 = 14;
pub const PCI_CAPABILITY_ID_SECURE: u32 = 15;
pub const PCI_CAPABILITY_ID_PCI_EXPRESS: u32 = 16;
pub const PCI_CAPABILITY_ID_MSIX: u32 = 17;
pub const PCI_CAPABILITY_ID_SATA_CONFIG: u32 = 18;
pub const PCI_CAPABILITY_ID_ADVANCED_FEATURES: u32 = 19;
pub const PCI_CAPABILITY_ID_FPB: u32 = 21;
pub const PCI_EXPRESS_ADVANCED_ERROR_REPORTING_CAP_ID: u32 = 1;
pub const PCI_EXPRESS_VIRTUAL_CHANNEL_CAP_ID: u32 = 2;
pub const PCI_EXPRESS_DEVICE_SERIAL_NUMBER_CAP_ID: u32 = 3;
pub const PCI_EXPRESS_POWER_BUDGETING_CAP_ID: u32 = 4;
pub const PCI_EXPRESS_RC_LINK_DECLARATION_CAP_ID: u32 = 5;
pub const PCI_EXPRESS_RC_INTERNAL_LINK_CONTROL_CAP_ID: u32 = 6;
pub const PCI_EXPRESS_RC_EVENT_COLLECTOR_ENDPOINT_ASSOCIATION_CAP_ID: u32 = 7;
pub const PCI_EXPRESS_MFVC_CAP_ID: u32 = 8;
pub const PCI_EXPRESS_VC_AND_MFVC_CAP_ID: u32 = 9;
pub const PCI_EXPRESS_RCRB_HEADER_CAP_ID: u32 = 10;
pub const PCI_EXPRESS_VENDOR_SPECIFIC_CAP_ID: u32 = 11;
pub const PCI_EXPRESS_CONFIGURATION_ACCESS_CORRELATION_CAP_ID: u32 = 12;
pub const PCI_EXPRESS_ACCESS_CONTROL_SERVICES_CAP_ID: u32 = 13;
pub const PCI_EXPRESS_ARI_CAP_ID: u32 = 14;
pub const PCI_EXPRESS_ATS_CAP_ID: u32 = 15;
pub const PCI_EXPRESS_SINGLE_ROOT_IO_VIRTUALIZATION_CAP_ID: u32 = 16;
pub const PCI_EXPRESS_MULTI_ROOT_IO_VIRTUALIZATION_CAP_ID: u32 = 17;
pub const PCI_EXPRESS_MULTICAST_CAP_ID: u32 = 18;
pub const PCI_EXPRESS_PAGE_REQUEST_CAP_ID: u32 = 19;
pub const PCI_EXPRESS_RESERVED_FOR_AMD_CAP_ID: u32 = 20;
pub const PCI_EXPRESS_RESIZABLE_BAR_CAP_ID: u32 = 21;
pub const PCI_EXPRESS_DPA_CAP_ID: u32 = 22;
pub const PCI_EXPRESS_TPH_REQUESTER_CAP_ID: u32 = 23;
pub const PCI_EXPRESS_LTR_CAP_ID: u32 = 24;
pub const PCI_EXPRESS_SECONDARY_PCI_EXPRESS_CAP_ID: u32 = 25;
pub const PCI_EXPRESS_PMUX_CAP_ID: u32 = 26;
pub const PCI_EXPRESS_PASID_CAP_ID: u32 = 27;
pub const PCI_EXPRESS_LN_REQUESTER_CAP_ID: u32 = 28;
pub const PCI_EXPRESS_DPC_CAP_ID: u32 = 29;
pub const PCI_EXPRESS_L1_PM_SS_CAP_ID: u32 = 30;
pub const PCI_EXPRESS_PTM_CAP_ID: u32 = 31;
pub const PCI_EXPRESS_MPCIE_CAP_ID: u32 = 32;
pub const PCI_EXPRESS_FRS_QUEUEING_CAP_ID: u32 = 33;
pub const PCI_EXPRESS_READINESS_TIME_REPORTING_CAP_ID: u32 = 34;
pub const PCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_CAP_ID: u32 = 35;
pub const PCI_EXPRESS_NPEM_CAP_ID: u32 = 41;
pub const ROOT_CMD_ENABLE_CORRECTABLE_ERROR_REPORTING: u32 = 1;
pub const ROOT_CMD_ENABLE_NONFATAL_ERROR_REPORTING: u32 = 2;
pub const ROOT_CMD_ENABLE_FATAL_ERROR_REPORTING: u32 = 4;
pub const ROOT_CMD_ERROR_REPORTING_ENABLE_MASK: u32 = 7;
pub const PCI_ACS_ALLOWED: u32 = 0;
pub const PCI_ACS_BLOCKED: u32 = 1;
pub const PCI_ACS_REDIRECTED: u32 = 2;
pub const PCI_CLASS_PRE_20: u32 = 0;
pub const PCI_CLASS_MASS_STORAGE_CTLR: u32 = 1;
pub const PCI_CLASS_NETWORK_CTLR: u32 = 2;
pub const PCI_CLASS_DISPLAY_CTLR: u32 = 3;
pub const PCI_CLASS_MULTIMEDIA_DEV: u32 = 4;
pub const PCI_CLASS_MEMORY_CTLR: u32 = 5;
pub const PCI_CLASS_BRIDGE_DEV: u32 = 6;
pub const PCI_CLASS_SIMPLE_COMMS_CTLR: u32 = 7;
pub const PCI_CLASS_BASE_SYSTEM_DEV: u32 = 8;
pub const PCI_CLASS_INPUT_DEV: u32 = 9;
pub const PCI_CLASS_DOCKING_STATION: u32 = 10;
pub const PCI_CLASS_PROCESSOR: u32 = 11;
pub const PCI_CLASS_SERIAL_BUS_CTLR: u32 = 12;
pub const PCI_CLASS_WIRELESS_CTLR: u32 = 13;
pub const PCI_CLASS_INTELLIGENT_IO_CTLR: u32 = 14;
pub const PCI_CLASS_SATELLITE_COMMS_CTLR: u32 = 15;
pub const PCI_CLASS_ENCRYPTION_DECRYPTION: u32 = 16;
pub const PCI_CLASS_DATA_ACQ_SIGNAL_PROC: u32 = 17;
pub const PCI_CLASS_NOT_DEFINED: u32 = 255;
pub const PCI_SUBCLASS_PRE_20_NON_VGA: u32 = 0;
pub const PCI_SUBCLASS_PRE_20_VGA: u32 = 1;
pub const PCI_SUBCLASS_MSC_SCSI_BUS_CTLR: u32 = 0;
pub const PCI_SUBCLASS_MSC_IDE_CTLR: u32 = 1;
pub const PCI_SUBCLASS_MSC_FLOPPY_CTLR: u32 = 2;
pub const PCI_SUBCLASS_MSC_IPI_CTLR: u32 = 3;
pub const PCI_SUBCLASS_MSC_RAID_CTLR: u32 = 4;
pub const PCI_SUBCLASS_MSC_AHCI_CTLR: u32 = 6;
pub const PCI_SUBCLASS_MSC_NVM_CTLR: u32 = 8;
pub const PCI_SUBCLASS_MSC_OTHER: u32 = 128;
pub const PCI_PROGRAMMING_INTERFACE_MSC_NVM_EXPRESS: u32 = 2;
pub const PCI_SUBCLASS_NET_ETHERNET_CTLR: u32 = 0;
pub const PCI_SUBCLASS_NET_TOKEN_RING_CTLR: u32 = 1;
pub const PCI_SUBCLASS_NET_FDDI_CTLR: u32 = 2;
pub const PCI_SUBCLASS_NET_ATM_CTLR: u32 = 3;
pub const PCI_SUBCLASS_NET_ISDN_CTLR: u32 = 4;
pub const PCI_SUBCLASS_NET_OTHER: u32 = 128;
pub const PCI_SUBCLASS_VID_VGA_CTLR: u32 = 0;
pub const PCI_SUBCLASS_VID_XGA_CTLR: u32 = 1;
pub const PCI_SUBLCASS_VID_3D_CTLR: u32 = 2;
pub const PCI_SUBCLASS_VID_OTHER: u32 = 128;
pub const PCI_SUBCLASS_MM_VIDEO_DEV: u32 = 0;
pub const PCI_SUBCLASS_MM_AUDIO_DEV: u32 = 1;
pub const PCI_SUBCLASS_MM_TELEPHONY_DEV: u32 = 2;
pub const PCI_SUBCLASS_MM_OTHER: u32 = 128;
pub const PCI_SUBCLASS_MEM_RAM: u32 = 0;
pub const PCI_SUBCLASS_MEM_FLASH: u32 = 1;
pub const PCI_SUBCLASS_MEM_OTHER: u32 = 128;
pub const PCI_SUBCLASS_BR_HOST: u32 = 0;
pub const PCI_SUBCLASS_BR_ISA: u32 = 1;
pub const PCI_SUBCLASS_BR_EISA: u32 = 2;
pub const PCI_SUBCLASS_BR_MCA: u32 = 3;
pub const PCI_SUBCLASS_BR_PCI_TO_PCI: u32 = 4;
pub const PCI_SUBCLASS_BR_PCMCIA: u32 = 5;
pub const PCI_SUBCLASS_BR_NUBUS: u32 = 6;
pub const PCI_SUBCLASS_BR_CARDBUS: u32 = 7;
pub const PCI_SUBCLASS_BR_RACEWAY: u32 = 8;
pub const PCI_SUBCLASS_BR_OTHER: u32 = 128;
pub const PCI_SUBCLASS_COM_SERIAL: u32 = 0;
pub const PCI_SUBCLASS_COM_PARALLEL: u32 = 1;
pub const PCI_SUBCLASS_COM_MULTIPORT: u32 = 2;
pub const PCI_SUBCLASS_COM_MODEM: u32 = 3;
pub const PCI_SUBCLASS_COM_OTHER: u32 = 128;
pub const PCI_SUBCLASS_SYS_INTERRUPT_CTLR: u32 = 0;
pub const PCI_SUBCLASS_SYS_DMA_CTLR: u32 = 1;
pub const PCI_SUBCLASS_SYS_SYSTEM_TIMER: u32 = 2;
pub const PCI_SUBCLASS_SYS_REAL_TIME_CLOCK: u32 = 3;
pub const PCI_SUBCLASS_SYS_GEN_HOTPLUG_CTLR: u32 = 4;
pub const PCI_SUBCLASS_SYS_SDIO_CTRL: u32 = 5;
pub const PCI_SUBCLASS_SYS_RCEC: u32 = 7;
pub const PCI_SUBCLASS_SYS_OTHER: u32 = 128;
pub const PCI_SUBCLASS_INP_KEYBOARD: u32 = 0;
pub const PCI_SUBCLASS_INP_DIGITIZER: u32 = 1;
pub const PCI_SUBCLASS_INP_MOUSE: u32 = 2;
pub const PCI_SUBCLASS_INP_SCANNER: u32 = 3;
pub const PCI_SUBCLASS_INP_GAMEPORT: u32 = 4;
pub const PCI_SUBCLASS_INP_OTHER: u32 = 128;
pub const PCI_SUBCLASS_DOC_GENERIC: u32 = 0;
pub const PCI_SUBCLASS_DOC_OTHER: u32 = 128;
pub const PCI_SUBCLASS_PROC_386: u32 = 0;
pub const PCI_SUBCLASS_PROC_486: u32 = 1;
pub const PCI_SUBCLASS_PROC_PENTIUM: u32 = 2;
pub const PCI_SUBCLASS_PROC_ALPHA: u32 = 16;
pub const PCI_SUBCLASS_PROC_POWERPC: u32 = 32;
pub const PCI_SUBCLASS_PROC_COPROCESSOR: u32 = 64;
pub const PCI_SUBCLASS_SB_IEEE1394: u32 = 0;
pub const PCI_SUBCLASS_SB_ACCESS: u32 = 1;
pub const PCI_SUBCLASS_SB_SSA: u32 = 2;
pub const PCI_SUBCLASS_SB_USB: u32 = 3;
pub const PCI_SUBCLASS_SB_FIBRE_CHANNEL: u32 = 4;
pub const PCI_SUBCLASS_SB_SMBUS: u32 = 5;
pub const PCI_SUBCLASS_SB_THUNDERBOLT: u32 = 10;
pub const PCI_SUBCLASS_WIRELESS_IRDA: u32 = 0;
pub const PCI_SUBCLASS_WIRELESS_CON_IR: u32 = 1;
pub const PCI_SUBCLASS_WIRELESS_RF: u32 = 16;
pub const PCI_SUBCLASS_WIRELESS_OTHER: u32 = 128;
pub const PCI_SUBCLASS_INTIO_I2O: u32 = 0;
pub const PCI_SUBCLASS_SAT_TV: u32 = 1;
pub const PCI_SUBCLASS_SAT_AUDIO: u32 = 2;
pub const PCI_SUBCLASS_SAT_VOICE: u32 = 3;
pub const PCI_SUBCLASS_SAT_DATA: u32 = 4;
pub const PCI_SUBCLASS_CRYPTO_NET_COMP: u32 = 0;
pub const PCI_SUBCLASS_CRYPTO_ENTERTAINMENT: u32 = 16;
pub const PCI_SUBCLASS_CRYPTO_OTHER: u32 = 128;
pub const PCI_SUBCLASS_DASP_DPIO: u32 = 0;
pub const PCI_SUBCLASS_DASP_OTHER: u32 = 128;
pub const PCI_ADDRESS_IO_SPACE: u32 = 1;
pub const PCI_ADDRESS_MEMORY_TYPE_MASK: u32 = 6;
pub const PCI_ADDRESS_MEMORY_PREFETCHABLE: u32 = 8;
pub const PCI_ADDRESS_IO_ADDRESS_MASK: u32 = 4294967292;
pub const PCI_ADDRESS_MEMORY_ADDRESS_MASK: u32 = 4294967280;
pub const PCI_ADDRESS_ROM_ADDRESS_MASK: u32 = 4294965248;
pub const PCI_TYPE_32BIT: u32 = 0;
pub const PCI_TYPE_20BIT: u32 = 2;
pub const PCI_TYPE_64BIT: u32 = 4;
pub const PCI_ROMADDRESS_ENABLED: u32 = 1;
pub const PCI_DEVICE_PRESENT_INTERFACE_VERSION: u32 = 1;
pub const PCI_USE_SUBSYSTEM_IDS: u32 = 1;
pub const PCI_USE_REVISION: u32 = 2;
pub const PCI_USE_VENDEV_IDS: u32 = 4;
pub const PCI_USE_CLASS_SUBCLASS: u32 = 8;
pub const PCI_USE_PROGIF: u32 = 16;
pub const PCI_USE_LOCAL_BUS: u32 = 32;
pub const PCI_USE_LOCAL_DEVICE: u32 = 64;
pub const PCI_EXPRESS_LINK_QUIESCENT_INTERFACE_VERSION: u32 = 1;
pub const PCI_EXPRESS_ROOT_PORT_INTERFACE_VERSION: u32 = 1;
pub const PCI_MSIX_TABLE_CONFIG_INTERFACE_VERSION: u32 = 1;
pub const FILE_ATTRIBUTE_DEDICATED: u32 = 256;
pub const EA_CONTAINER_NAME: &[u8; 14] = b"ContainerName\0";
pub const EA_CONTAINER_SIZE: &[u8; 14] = b"ContainerSize\0";
pub const CLFS_BASELOG_EXTENSION: &[u8; 5] = b".blf\0";
pub const CLFS_FLAG_NO_FLAGS: u32 = 0;
pub const CLFS_FLAG_FORCE_APPEND: u32 = 1;
pub const CLFS_FLAG_FORCE_FLUSH: u32 = 2;
pub const CLFS_FLAG_USE_RESERVATION: u32 = 4;
pub const CLFS_FLAG_REENTRANT_FILE_SYSTEM: u32 = 8;
pub const CLFS_FLAG_NON_REENTRANT_FILTER: u32 = 16;
pub const CLFS_FLAG_REENTRANT_FILTER: u32 = 32;
pub const CLFS_FLAG_IGNORE_SHARE_ACCESS: u32 = 64;
pub const CLFS_FLAG_READ_IN_PROGRESS: u32 = 128;
pub const CLFS_FLAG_MINIFILTER_LEVEL: u32 = 256;
pub const CLFS_FLAG_HIDDEN_SYSTEM_LOG: u32 = 512;
pub const CLFS_MARSHALLING_FLAG_NONE: u32 = 0;
pub const CLFS_MARSHALLING_FLAG_DISABLE_BUFF_INIT: u32 = 1;
pub const CLFS_FLAG_FILTER_INTERMEDIATE_LEVEL: u32 = 16;
pub const CLFS_FLAG_FILTER_TOP_LEVEL: u32 = 32;
pub const ClfsNullRecord: u32 = 0;
pub const ClfsDataRecord: u32 = 1;
pub const ClfsRestartRecord: u32 = 2;
pub const ClfsClientRecord: u32 = 3;
pub const CLFS_CONTAINER_STREAM_PREFIX: &[u8; 7] = b"%BLF%:\0";
pub const CLFS_CONTAINER_RELATIVE_PREFIX: &[u8; 7] = b"%BLF%\\\0";
pub const ClsContainerInitializing: u32 = 1;
pub const ClsContainerInactive: u32 = 2;
pub const ClsContainerActive: u32 = 4;
pub const ClsContainerActivePendingDelete: u32 = 8;
pub const ClsContainerPendingArchive: u32 = 16;
pub const ClsContainerPendingArchiveAndDelete: u32 = 32;
pub const ClfsContainerInitializing: u32 = 1;
pub const ClfsContainerInactive: u32 = 2;
pub const ClfsContainerActive: u32 = 4;
pub const ClfsContainerActivePendingDelete: u32 = 8;
pub const ClfsContainerPendingArchive: u32 = 16;
pub const ClfsContainerPendingArchiveAndDelete: u32 = 32;
pub const CLFS_MAX_CONTAINER_INFO: u32 = 256;
pub const CLFS_SCAN_INIT: u32 = 1;
pub const CLFS_SCAN_FORWARD: u32 = 2;
pub const CLFS_SCAN_BACKWARD: u32 = 4;
pub const CLFS_SCAN_CLOSE: u32 = 8;
pub const CLFS_SCAN_INITIALIZED: u32 = 16;
pub const CLFS_SCAN_BUFFERED: u32 = 32;
pub const CLFS_MGMT_POLICY_VERSION: u32 = 1;
pub const LOG_POLICY_OVERWRITE: u32 = 1;
pub const LOG_POLICY_PERSIST: u32 = 2;
pub const CLFS_MGMT_CLIENT_REGISTRATION_VERSION: u32 = 1;
pub const PCW_VERSION_1: u32 = 256;
pub const PCW_VERSION_2: u32 = 512;
pub const PCW_CURRENT_VERSION: u32 = 512;
pub const SECURE_SECTION_ALLOW_PARTIAL_MDL: u32 = 1;
pub const KERNEL_STACK_SIZE: u32 = 24576;
pub const KERNEL_LARGE_STACK_SIZE: u32 = 73728;
pub const KERNEL_LARGE_STACK_COMMIT: u32 = 24576;
pub const KERNEL_MCA_EXCEPTION_STACK_SIZE: u32 = 8192;
pub const KERNEL_SHADOW_STACK_SIZE: u32 = 4096;
pub const EXCEPTION_READ_FAULT: u32 = 0;
pub const EXCEPTION_WRITE_FAULT: u32 = 1;
pub const EXCEPTION_EXECUTE_FAULT: u32 = 8;
pub const CONTEXT_AMD64: u32 = 1048576;
pub const CONTEXT_CONTROL: u32 = 1048577;
pub const CONTEXT_INTEGER: u32 = 1048578;
pub const CONTEXT_SEGMENTS: u32 = 1048580;
pub const CONTEXT_FLOATING_POINT: u32 = 1048584;
pub const CONTEXT_DEBUG_REGISTERS: u32 = 1048592;
pub const CONTEXT_FULL: u32 = 1048587;
pub const CONTEXT_ALL: u32 = 1048607;
pub const CONTEXT_XSTATE: u32 = 1048640;
pub const CONTEXT_KERNEL_CET: u32 = 1048704;
pub const CONTEXT_EXCEPTION_ACTIVE: u32 = 134217728;
pub const CONTEXT_SERVICE_ACTIVE: u32 = 268435456;
pub const CONTEXT_EXCEPTION_REQUEST: u32 = 1073741824;
pub const CONTEXT_EXCEPTION_REPORTING: u32 = 2147483648;
pub const CONTEXT_UNWOUND_TO_CALL: u32 = 536870912;
pub const INITIAL_MXCSR: u32 = 8064;
pub const INITIAL_FPCSR: u32 = 639;
pub const CONTEXT_ARM64: u32 = 4194304;
pub const CONTEXT_ARM64_CONTROL: u32 = 4194305;
pub const CONTEXT_ARM64_INTEGER: u32 = 4194306;
pub const CONTEXT_ARM64_FLOATING_POINT: u32 = 4194308;
pub const CONTEXT_ARM64_DEBUG_REGISTERS: u32 = 4194312;
pub const CONTEXT_ARM64_X18: u32 = 4194320;
pub const CONTEXT_ARM64_FULL: u32 = 4194311;
pub const CONTEXT_ARM64_ALL: u32 = 4194335;
pub const CONTEXT_ARM64_UNWOUND_TO_CALL: u32 = 536870912;
pub const CONTEXT_ARM64_RET_TO_GUEST: u32 = 67108864;
pub const ARM64_MAX_BREAKPOINTS: u32 = 8;
pub const ARM64_MAX_WATCHPOINTS: u32 = 2;
pub const SE_UNSOLICITED_INPUT_PRIVILEGE: u32 = 6;
pub const SE_SIGNING_LEVEL_UNCHECKED: u32 = 0;
pub const SE_SIGNING_LEVEL_UNSIGNED: u32 = 1;
pub const SE_SIGNING_LEVEL_ENTERPRISE: u32 = 2;
pub const SE_SIGNING_LEVEL_CUSTOM_1: u32 = 3;
pub const SE_SIGNING_LEVEL_DEVELOPER: u32 = 3;
pub const SE_SIGNING_LEVEL_AUTHENTICODE: u32 = 4;
pub const SE_SIGNING_LEVEL_CUSTOM_2: u32 = 5;
pub const SE_SIGNING_LEVEL_STORE: u32 = 6;
pub const SE_SIGNING_LEVEL_CUSTOM_3: u32 = 7;
pub const SE_SIGNING_LEVEL_ANTIMALWARE: u32 = 7;
pub const SE_SIGNING_LEVEL_MICROSOFT: u32 = 8;
pub const SE_SIGNING_LEVEL_CUSTOM_4: u32 = 9;
pub const SE_SIGNING_LEVEL_CUSTOM_5: u32 = 10;
pub const SE_SIGNING_LEVEL_DYNAMIC_CODEGEN: u32 = 11;
pub const SE_SIGNING_LEVEL_WINDOWS: u32 = 12;
pub const SE_SIGNING_LEVEL_CUSTOM_7: u32 = 13;
pub const SE_SIGNING_LEVEL_WINDOWS_TCB: u32 = 14;
pub const SE_SIGNING_LEVEL_CUSTOM_6: u32 = 15;
pub const RTL_RUN_ONCE_CHECK_ONLY: u32 = 1;
pub const RTL_RUN_ONCE_ASYNC: u32 = 2;
pub const RTL_RUN_ONCE_INIT_FAILED: u32 = 4;
pub const RTL_RUN_ONCE_CTX_RESERVED_BITS: u32 = 2;
pub const RTL_HASH_ALLOCATED_HEADER: u32 = 1;
pub const RTL_HASH_RESERVED_SIGNATURE: u32 = 0;
pub const RTL_STACK_WALKING_MODE_FRAMES_TO_SKIP_SHIFT: u32 = 8;
pub const FLUSH_NV_MEMORY_IN_FLAG_NO_DRAIN: u32 = 1;
pub const WRITE_NV_MEMORY_FLAG_FLUSH: u32 = 1;
pub const WRITE_NV_MEMORY_FLAG_NON_TEMPORAL: u32 = 2;
pub const WRITE_NV_MEMORY_FLAG_PERSIST: u32 = 3;
pub const WRITE_NV_MEMORY_FLAG_NO_DRAIN: u32 = 256;
pub const FILL_NV_MEMORY_FLAG_FLUSH: u32 = 1;
pub const FILL_NV_MEMORY_FLAG_NON_TEMPORAL: u32 = 2;
pub const FILL_NV_MEMORY_FLAG_PERSIST: u32 = 3;
pub const FILL_NV_MEMORY_FLAG_NO_DRAIN: u32 = 256;
pub const RTL_CORRELATION_VECTOR_STRING_LENGTH: u32 = 129;
pub const RTL_CORRELATION_VECTOR_V1_PREFIX_LENGTH: u32 = 16;
pub const RTL_CORRELATION_VECTOR_V1_LENGTH: u32 = 64;
pub const RTL_CORRELATION_VECTOR_V2_PREFIX_LENGTH: u32 = 22;
pub const RTL_CORRELATION_VECTOR_V2_LENGTH: u32 = 128;
pub const RTL_VIRTUAL_UNWIND2_VALIDATE_PAC: u32 = 1;
pub const FILE_CHARACTERISTICS_EXPECT_ORDERLY_REMOVAL_EX: u32 = 16384;
pub const FILE_CHARACTERISTICS_EXPECT_SURPRISE_REMOVAL_EX: u32 = 32768;
pub const FILE_CHARACTERISTICS_REMOVAL_POLICY_MASK_EX: u32 = 49152;
pub const FILE_CHARACTERISTICS_EXPECT_ORDERLY_REMOVAL_DEPRECATED: u32 = 512;
pub const FILE_CHARACTERISTICS_EXPECT_SURPRISE_REMOVAL_DEPRECATED: u32 = 768;
pub const FILE_CHARACTERISTICS_REMOVAL_POLICY_MASK_DEPRECATED: u32 = 768;
pub const FILE_CHARACTERISTICS_PROPAGATED: u32 = 327951;
pub const FILE_DISPOSITION_DO_NOT_DELETE: u32 = 0;
pub const FILE_DISPOSITION_DELETE: u32 = 1;
pub const FILE_DISPOSITION_POSIX_SEMANTICS: u32 = 2;
pub const FILE_DISPOSITION_FORCE_IMAGE_SECTION_CHECK: u32 = 4;
pub const FILE_DISPOSITION_ON_CLOSE: u32 = 8;
pub const FILE_DISPOSITION_IGNORE_READONLY_ATTRIBUTE: u32 = 16;
pub const SSINFO_FLAGS_ALIGNED_DEVICE: u32 = 1;
pub const SSINFO_FLAGS_PARTITION_ALIGNED_ON_DEVICE: u32 = 2;
pub const SSINFO_FLAGS_NO_SEEK_PENALTY: u32 = 4;
pub const SSINFO_FLAGS_TRIM_ENABLED: u32 = 8;
pub const SSINFO_FLAGS_BYTE_ADDRESSABLE: u32 = 16;
pub const SSINFO_OFFSET_UNKNOWN: u32 = 4294967295;
pub const THREAD_CSWITCH_PMU_DISABLE: u32 = 0;
pub const THREAD_CSWITCH_PMU_ENABLE: u32 = 1;
pub const MEMORY_PRIORITY_LOWEST: u32 = 0;
pub const MEMORY_PRIORITY_VERY_LOW: u32 = 1;
pub const MEMORY_PRIORITY_LOW: u32 = 2;
pub const MEMORY_PRIORITY_MEDIUM: u32 = 3;
pub const MEMORY_PRIORITY_BELOW_NORMAL: u32 = 4;
pub const MEMORY_PRIORITY_NORMAL: u32 = 5;
pub const PROCESS_LUID_DOSDEVICES_ONLY: u32 = 1;
pub const PROCESS_HANDLE_EXCEPTIONS_ENABLED: u32 = 1;
pub const PROCESS_HANDLE_RAISE_UM_EXCEPTION_ON_INVALID_HANDLE_CLOSE_DISABLED: u32 = 0;
pub const PROCESS_HANDLE_RAISE_UM_EXCEPTION_ON_INVALID_HANDLE_CLOSE_ENABLED: u32 = 1;
pub const PROCESS_HANDLE_TRACING_MAX_STACKS: u32 = 16;
pub const DYNAMIC_EH_CONTINUATION_TARGET_ADD: u32 = 1;
pub const DYNAMIC_EH_CONTINUATION_TARGET_PROCESSED: u32 = 2;
pub const DYNAMIC_ENFORCED_ADDRESS_RANGE_ADD: u32 = 1;
pub const DYNAMIC_ENFORCED_ADDRESS_RANGE_PROCESSED: u32 = 2;
pub const QUOTA_LIMITS_HARDWS_MIN_ENABLE: u32 = 1;
pub const QUOTA_LIMITS_HARDWS_MIN_DISABLE: u32 = 2;
pub const QUOTA_LIMITS_HARDWS_MAX_ENABLE: u32 = 4;
pub const QUOTA_LIMITS_HARDWS_MAX_DISABLE: u32 = 8;
pub const QUOTA_LIMITS_USE_DEFAULT_LIMITS: u32 = 16;
pub const MAX_HW_COUNTERS: u32 = 16;
pub const THREAD_PROFILING_FLAG_DISPATCH: u32 = 1;
pub const PROCESS_EXCEPTION_PORT_ALL_STATE_BITS: u32 = 3;
pub const POWER_THROTTLING_PROCESS_CURRENT_VERSION: u32 = 1;
pub const POWER_THROTTLING_PROCESS_EXECUTION_SPEED: u32 = 1;
pub const POWER_THROTTLING_PROCESS_DELAYTIMERS: u32 = 2;
pub const POWER_THROTTLING_PROCESS_IGNORE_TIMER_RESOLUTION: u32 = 4;
pub const POWER_THROTTLING_PROCESS_VALID_FLAGS: u32 = 7;
pub const POWER_THROTTLING_THREAD_CURRENT_VERSION: u32 = 1;
pub const POWER_THROTTLING_THREAD_EXECUTION_SPEED: u32 = 1;
pub const POWER_THROTTLING_THREAD_VALID_FLAGS: u32 = 1;
pub const PCR_MINOR_VERSION: u32 = 1;
pub const PCR_MAJOR_VERSION: u32 = 1;
pub const KUMS_UCH_VOLATILE_BIT: u32 = 0;
pub const KUMS_UCH_VOLATILE_MASK: u32 = 1;
pub const RESULT_ZERO: u32 = 0;
pub const RESULT_NEGATIVE: u32 = 1;
pub const RESULT_POSITIVE: u32 = 2;
pub const DRIVER_VERIFIER_SPECIAL_POOLING: u32 = 1;
pub const DRIVER_VERIFIER_FORCE_IRQL_CHECKING: u32 = 2;
pub const DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES: u32 = 4;
pub const DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS: u32 = 8;
pub const DRIVER_VERIFIER_IO_CHECKING: u32 = 16;
pub const XSTATE_LEGACY_FLOATING_POINT: u32 = 0;
pub const XSTATE_LEGACY_SSE: u32 = 1;
pub const XSTATE_GSSE: u32 = 2;
pub const XSTATE_AVX: u32 = 2;
pub const XSTATE_MPX_BNDREGS: u32 = 3;
pub const XSTATE_MPX_BNDCSR: u32 = 4;
pub const XSTATE_AVX512_KMASK: u32 = 5;
pub const XSTATE_AVX512_ZMM_H: u32 = 6;
pub const XSTATE_AVX512_ZMM: u32 = 7;
pub const XSTATE_IPT: u32 = 8;
pub const XSTATE_PASID: u32 = 10;
pub const XSTATE_CET_U: u32 = 11;
pub const XSTATE_CET_S: u32 = 12;
pub const XSTATE_AMX_TILE_CONFIG: u32 = 17;
pub const XSTATE_AMX_TILE_DATA: u32 = 18;
pub const XSTATE_LWP: u32 = 62;
pub const MAXIMUM_XSTATE_FEATURES: u32 = 64;
pub const XSTATE_COMPACTION_ENABLE: u32 = 63;
pub const XSTATE_ALIGN_BIT: u32 = 1;
pub const XSTATE_XFD_BIT: u32 = 2;
pub const XSTATE_CONTROLFLAG_XSAVEOPT_MASK: u32 = 1;
pub const XSTATE_CONTROLFLAG_XSAVEC_MASK: u32 = 2;
pub const XSTATE_CONTROLFLAG_XFD_MASK: u32 = 4;
pub const XSTATE_CONTROLFLAG_VALID_MASK: u32 = 7;
pub const NX_SUPPORT_POLICY_ALWAYSOFF: u32 = 0;
pub const NX_SUPPORT_POLICY_ALWAYSON: u32 = 1;
pub const NX_SUPPORT_POLICY_OPTIN: u32 = 2;
pub const NX_SUPPORT_POLICY_OPTOUT: u32 = 3;
pub const SEH_VALIDATION_POLICY_ON: u32 = 0;
pub const SEH_VALIDATION_POLICY_OFF: u32 = 1;
pub const SEH_VALIDATION_POLICY_TELEMETRY: u32 = 2;
pub const SEH_VALIDATION_POLICY_DEFER: u32 = 3;
pub const SHARED_GLOBAL_FLAGS_ERROR_PORT_V: u32 = 0;
pub const SHARED_GLOBAL_FLAGS_ERROR_PORT: u32 = 1;
pub const SHARED_GLOBAL_FLAGS_ELEVATION_ENABLED_V: u32 = 1;
pub const SHARED_GLOBAL_FLAGS_ELEVATION_ENABLED: u32 = 2;
pub const SHARED_GLOBAL_FLAGS_VIRT_ENABLED_V: u32 = 2;
pub const SHARED_GLOBAL_FLAGS_VIRT_ENABLED: u32 = 4;
pub const SHARED_GLOBAL_FLAGS_INSTALLER_DETECT_ENABLED_V: u32 = 3;
pub const SHARED_GLOBAL_FLAGS_INSTALLER_DETECT_ENABLED: u32 = 8;
pub const SHARED_GLOBAL_FLAGS_LKG_ENABLED_V: u32 = 4;
pub const SHARED_GLOBAL_FLAGS_LKG_ENABLED: u32 = 16;
pub const SHARED_GLOBAL_FLAGS_DYNAMIC_PROC_ENABLED_V: u32 = 5;
pub const SHARED_GLOBAL_FLAGS_DYNAMIC_PROC_ENABLED: u32 = 32;
pub const SHARED_GLOBAL_FLAGS_CONSOLE_BROKER_ENABLED_V: u32 = 6;
pub const SHARED_GLOBAL_FLAGS_CONSOLE_BROKER_ENABLED: u32 = 64;
pub const SHARED_GLOBAL_FLAGS_SECURE_BOOT_ENABLED_V: u32 = 7;
pub const SHARED_GLOBAL_FLAGS_SECURE_BOOT_ENABLED: u32 = 128;
pub const SHARED_GLOBAL_FLAGS_MULTI_SESSION_SKU_V: u32 = 8;
pub const SHARED_GLOBAL_FLAGS_MULTI_SESSION_SKU: u32 = 256;
pub const SHARED_GLOBAL_FLAGS_MULTIUSERS_IN_SESSION_SKU_V: u32 = 9;
pub const SHARED_GLOBAL_FLAGS_MULTIUSERS_IN_SESSION_SKU: u32 = 512;
pub const SHARED_GLOBAL_FLAGS_STATE_SEPARATION_ENABLED_V: u32 = 10;
pub const SHARED_GLOBAL_FLAGS_STATE_SEPARATION_ENABLED: u32 = 1024;
pub const SHARED_GLOBAL_FLAGS_SET_GLOBAL_DATA_FLAG: u32 = 1073741824;
pub const SHARED_GLOBAL_FLAGS_CLEAR_GLOBAL_DATA_FLAG: u32 = 2147483648;
pub const SYSTEM_CALL_SYSCALL: u32 = 0;
pub const SYSTEM_CALL_INT_2E: u32 = 1;
pub const SHARED_GLOBAL_FLAGS_QPC_BYPASS_ENABLED: u32 = 1;
pub const SHARED_GLOBAL_FLAGS_QPC_BYPASS_USE_HV_PAGE: u32 = 2;
pub const SHARED_GLOBAL_FLAGS_QPC_BYPASS_DISABLE_32BIT: u32 = 4;
pub const SHARED_GLOBAL_FLAGS_QPC_BYPASS_USE_MFENCE: u32 = 16;
pub const SHARED_GLOBAL_FLAGS_QPC_BYPASS_USE_LFENCE: u32 = 32;
pub const SHARED_GLOBAL_FLAGS_QPC_BYPASS_A73_ERRATA: u32 = 64;
pub const SHARED_GLOBAL_FLAGS_QPC_BYPASS_USE_RDTSCP: u32 = 128;
pub const CmResourceTypeMaximum: u32 = 8;
pub const PCCARD_MAP_ERROR: u32 = 1;
pub const PCCARD_DEVICE_PCI: u32 = 16;
pub const PCCARD_SCAN_DISABLED: u32 = 1;
pub const PCCARD_MAP_ZERO: u32 = 2;
pub const PCCARD_NO_TIMER: u32 = 3;
pub const PCCARD_NO_PIC: u32 = 4;
pub const PCCARD_NO_LEGACY_BASE: u32 = 5;
pub const PCCARD_DUP_LEGACY_BASE: u32 = 6;
pub const PCCARD_NO_CONTROLLERS: u32 = 7;
pub const MAXIMUM_EXPANSION_SIZE: u32 = 71680;
pub const CP_GET_SUCCESS: u32 = 0;
pub const CP_GET_NODATA: u32 = 1;
pub const CP_GET_ERROR: u32 = 2;
pub const PROTECTED_POOL: u32 = 0;
pub const MM_ADD_PHYSICAL_MEMORY_ALREADY_ZEROED: u32 = 1;
pub const MM_REMOVE_PHYSICAL_MEMORY_BAD_ONLY: u32 = 1;
pub const MM_GET_PHYSICAL_MEMORY_RANGES_INCLUDE_FILE_ONLY: u32 = 1;
pub const MM_GET_PHYSICAL_MEMORY_RANGES_INCLUDE_ALL_PARTITIONS: u32 = 2;
pub const MM_COPY_MEMORY_PHYSICAL: u32 = 1;
pub const MM_COPY_MEMORY_VIRTUAL: u32 = 2;
pub const MM_GET_CACHE_ATTRIBUTE_IO_SPACE: u32 = 1;
pub const MM_SECURE_EXCLUSIVE: u32 = 1;
pub const MM_SECURE_NO_CHANGE: u32 = 2;
pub const MM_SECURE_USER_MODE_ONLY: u32 = 4;
pub const MM_SECURE_NO_INHERIT: u32 = 8;
pub const MM_SYSTEM_VIEW_EXCEPTIONS_FOR_INPAGE_ERRORS: u32 = 1;
pub const IMAGE_ADDRESSING_MODE_32BIT: u32 = 3;
pub const PS_IMAGE_NOTIFY_CONFLICTING_ARCHITECTURE: u32 = 1;
pub const SILO_MONITOR_REGISTRATION_VERSION: u32 = 1;
pub const PS_INVALID_SILO_CONTEXT_SLOT: u32 = 4294967295;
pub const IRP_MN_QUERY_DIRECTORY: u32 = 1;
pub const IRP_MN_NOTIFY_CHANGE_DIRECTORY: u32 = 2;
pub const IRP_MN_NOTIFY_CHANGE_DIRECTORY_EX: u32 = 3;
pub const IRP_MN_USER_FS_REQUEST: u32 = 0;
pub const IRP_MN_MOUNT_VOLUME: u32 = 1;
pub const IRP_MN_VERIFY_VOLUME: u32 = 2;
pub const IRP_MN_LOAD_FILE_SYSTEM: u32 = 3;
pub const IRP_MN_TRACK_LINK: u32 = 4;
pub const IRP_MN_KERNEL_CALL: u32 = 4;
pub const IRP_MN_LOCK: u32 = 1;
pub const IRP_MN_UNLOCK_SINGLE: u32 = 2;
pub const IRP_MN_UNLOCK_ALL: u32 = 3;
pub const IRP_MN_UNLOCK_ALL_BY_KEY: u32 = 4;
pub const IRP_MN_FLUSH_AND_PURGE: u32 = 1;
pub const IRP_MN_FLUSH_DATA_ONLY: u32 = 2;
pub const IRP_MN_FLUSH_NO_SYNC: u32 = 3;
pub const IRP_MN_FLUSH_DATA_SYNC_ONLY: u32 = 4;
pub const IRP_MN_NORMAL: u32 = 0;
pub const IRP_MN_DPC: u32 = 1;
pub const IRP_MN_MDL: u32 = 2;
pub const IRP_MN_COMPLETE: u32 = 4;
pub const IRP_MN_COMPRESSED: u32 = 8;
pub const IRP_MN_MDL_DPC: u32 = 3;
pub const IRP_MN_COMPLETE_MDL: u32 = 6;
pub const IRP_MN_COMPLETE_MDL_DPC: u32 = 7;
pub const IRP_MN_QUERY_LEGACY_BUS_INFORMATION: u32 = 24;
pub const IO_CHECK_CREATE_PARAMETERS: u32 = 512;
pub const IO_ATTACH_DEVICE: u32 = 1024;
pub const IO_IGNORE_SHARE_ACCESS_CHECK: u32 = 2048;
pub const DO_DEVICE_HAS_NAME: u32 = 64;
pub const DO_SYSTEM_BOOT_PARTITION: u32 = 256;
pub const DO_LONG_TERM_REQUESTS: u32 = 512;
pub const DO_NEVER_LAST_DEVICE: u32 = 1024;
pub const DO_LOW_PRIORITY_FILESYSTEM: u32 = 65536;
pub const DO_SUPPORTS_TRANSACTIONS: u32 = 262144;
pub const DO_FORCE_NEITHER_IO: u32 = 524288;
pub const DO_VOLUME_DEVICE_OBJECT: u32 = 1048576;
pub const DO_SYSTEM_SYSTEM_PARTITION: u32 = 2097152;
pub const DO_SYSTEM_CRITICAL_PARTITION: u32 = 4194304;
pub const DO_DISALLOW_EXECUTE: u32 = 8388608;
pub const DO_DEVICE_IRP_REQUIRES_EXTENSION: u32 = 134217728;
pub const DO_BOOT_CRITICAL: u32 = 536870912;
pub const DRVO_REINIT_REGISTERED: u32 = 8;
pub const DRVO_INITIALIZED: u32 = 16;
pub const DRVO_BOOTREINIT_REGISTERED: u32 = 32;
pub const DRVO_LEGACY_RESOURCES: u32 = 64;
pub const TXF_MINIVERSION_DEFAULT_VIEW: u32 = 65534;
pub const OPLOCK_KEY_VERSION_WIN7: u32 = 1;
pub const OPLOCK_KEY_VERSION_WIN8: u32 = 2;
pub const OPLOCK_KEY_FLAG_PARENT_KEY: u32 = 1;
pub const OPLOCK_KEY_FLAG_TARGET_KEY: u32 = 2;
pub const BDCB_IMAGEFLAGS_FAILED_CODE_INTEGRITY: u32 = 1;
pub const ARBITER_FLAG_BOOT_CONFIG: u32 = 1;
pub const ARBITER_FLAG_ROOT_ENUM: u32 = 2;
pub const ARBITER_FLAG_OTHER_ENUM: u32 = 4;
pub const ARBITER_PARTIAL: u32 = 1;
pub const MAXIMUM_DEBUG_BARS: u32 = 6;
pub const DBG_DEVICE_FLAG_HAL_SCRATCH_ALLOCATED: u32 = 1;
pub const DBG_DEVICE_FLAG_BARS_MAPPED: u32 = 2;
pub const DBG_DEVICE_FLAG_SCRATCH_ALLOCATED: u32 = 4;
pub const DBG_DEVICE_FLAG_UNCACHED_MEMORY: u32 = 8;
pub const DBG_DEVICE_FLAG_SYNTHETIC: u32 = 16;
pub const DBG_DEVICE_FLAG_HOST_VISIBLE_ALLOCATED: u32 = 32;
pub const HAL_DISPATCH_VERSION: u32 = 5;
pub const HAL_PLATFORM_DISABLE_WRITE_COMBINING: u32 = 1;
pub const HAL_PLATFORM_DISABLE_PTCG: u32 = 4;
pub const HAL_PLATFORM_DISABLE_UC_MAIN_MEMORY: u32 = 8;
pub const HAL_PLATFORM_ENABLE_WRITE_COMBINING_MMIO: u32 = 16;
pub const HAL_PLATFORM_ACPI_TABLES_CACHED: u32 = 32;
pub const PCI_AGP_RATE_1X: u32 = 1;
pub const PCI_AGP_RATE_2X: u32 = 2;
pub const PCI_AGP_RATE_4X: u32 = 4;
pub const PCIX_MODE_CONVENTIONAL_PCI: u32 = 0;
pub const PCIX_MODE1_66MHZ: u32 = 1;
pub const PCIX_MODE1_100MHZ: u32 = 2;
pub const PCIX_MODE1_133MHZ: u32 = 3;
pub const PCIX_MODE2_266_66MHZ: u32 = 9;
pub const PCIX_MODE2_266_100MHZ: u32 = 10;
pub const PCIX_MODE2_266_133MHZ: u32 = 11;
pub const PCIX_MODE2_533_66MHZ: u32 = 13;
pub const PCIX_MODE2_533_100MHZ: u32 = 14;
pub const PCIX_MODE2_533_133MHZ: u32 = 15;
pub const PCIX_VERSION_MODE1_ONLY: u32 = 0;
pub const PCIX_VERSION_MODE2_ECC: u32 = 1;
pub const PCIX_VERSION_DUAL_MODE_ECC: u32 = 2;
pub const OSC_FIRMWARE_FAILURE: u32 = 2;
pub const OSC_UNRECOGNIZED_UUID: u32 = 4;
pub const OSC_UNRECOGNIZED_REVISION: u32 = 8;
pub const OSC_CAPABILITIES_MASKED: u32 = 16;
pub const PCI_ROOT_BUS_OSC_METHOD_CAPABILITY_REVISION: u32 = 1;
pub const FPB_VECTOR_SIZE_SUPPORTED_256BITS: u32 = 0;
pub const FPB_VECTOR_SIZE_SUPPORTED_512BITS: u32 = 1;
pub const FPB_VECTOR_SIZE_SUPPORTED_1KBITS: u32 = 2;
pub const FPB_VECTOR_SIZE_SUPPORTED_2KBITS: u32 = 3;
pub const FPB_VECTOR_SIZE_SUPPORTED_4KBITS: u32 = 4;
pub const FPB_VECTOR_SIZE_SUPPORTED_8KBITS: u32 = 5;
pub const FPB_RID_VECTOR_GRANULARITY_8RIDS: u32 = 0;
pub const FPB_RID_VECTOR_GRANULARITY_64RIDS: u32 = 3;
pub const FPB_RID_VECTOR_GRANULARITY_256RIDS: u32 = 5;
pub const FPB_MEM_LOW_VECTOR_GRANULARITY_1MB: u32 = 0;
pub const FPB_MEM_LOW_VECTOR_GRANULARITY_2MB: u32 = 1;
pub const FPB_MEM_LOW_VECTOR_GRANULARITY_4MB: u32 = 2;
pub const FPB_MEM_LOW_VECTOR_GRANULARITY_8MB: u32 = 3;
pub const FPB_MEM_LOW_VECTOR_GRANULARITY_16MB: u32 = 4;
pub const FPB_MEM_HIGH_VECTOR_GRANULARITY_256MB: u32 = 0;
pub const FPB_MEM_HIGH_VECTOR_GRANULARITY_512MB: u32 = 1;
pub const FPB_MEM_HIGH_VECTOR_GRANULARITY_1GB: u32 = 2;
pub const FPB_MEM_HIGH_VECTOR_GRANULARITY_2GB: u32 = 3;
pub const FPB_MEM_HIGH_VECTOR_GRANULARITY_4GB: u32 = 4;
pub const FPB_MEM_HIGH_VECTOR_GRANULARITY_8GB: u32 = 5;
pub const FPB_MEM_HIGH_VECTOR_GRANULARITY_16GB: u32 = 6;
pub const FPB_MEM_HIGH_VECTOR_GRANULARITY_32GB: u32 = 7;
pub const FPB_MEM_VECTOR_GRANULARITY_1B: u32 = 8;
pub const FPB_MEM_HIGH_VECTOR_GRANULARITY_1MB: u32 = 9;
pub const FPB_VECTOR_SELECT_RID: u32 = 0;
pub const FPB_VECTOR_SELECT_MEM_LOW: u32 = 1;
pub const FPB_VECTOR_SELECT_MEM_HIGH: u32 = 2;
pub const PCI_DATA_VERSION: u32 = 1;
pub const PCI_EXPRESS_TPH_ST_LOCATION_NONE: u32 = 0;
pub const PCI_EXPRESS_TPH_ST_LOCATION_TPH_CAPABILITY: u32 = 1;
pub const PCI_EXPRESS_TPH_ST_LOCATION_MSIX_TABLE: u32 = 2;
pub const PCI_EXPRESS_TPH_ST_LOCATION_RESERVED: u32 = 3;
pub const PCI_INVALID_ALTERNATE_FUNCTION_NUMBER: u32 = 255;
pub const PCI_BUS_INTERFACE_STANDARD_VERSION: u32 = 2;
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_VERSION_10: u32 = 10;
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_VERSION_11: u32 = 11;
pub const WHEA_MAX_MC_BANKS: u32 = 32;
pub const WHEA_ERROR_SOURCE_FLAG_FIRMWAREFIRST: u32 = 1;
pub const WHEA_ERROR_SOURCE_FLAG_GLOBAL: u32 = 2;
pub const WHEA_ERROR_SOURCE_FLAG_GHES_ASSIST: u32 = 4;
pub const WHEA_ERROR_SOURCE_FLAG_DEFAULTSOURCE: u32 = 2147483648;
pub const WHEA_ERROR_SOURCE_INVALID_RELATED_SOURCE: u32 = 65535;
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_XPFMCE: u32 = 0;
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_XPFCMC: u32 = 1;
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_XPFNMI: u32 = 2;
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_IPFMCA: u32 = 3;
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_IPFCMC: u32 = 4;
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_IPFCPE: u32 = 5;
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_AERROOTPORT: u32 = 6;
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_AERENDPOINT: u32 = 7;
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_AERBRIDGE: u32 = 8;
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_GENERIC: u32 = 9;
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_GENERIC_V2: u32 = 10;
pub const WHEA_XPF_MC_BANK_STATUSFORMAT_IA32MCA: u32 = 0;
pub const WHEA_XPF_MC_BANK_STATUSFORMAT_Intel64MCA: u32 = 1;
pub const WHEA_XPF_MC_BANK_STATUSFORMAT_AMD64MCA: u32 = 2;
pub const WHEA_NOTIFICATION_TYPE_POLLED: u32 = 0;
pub const WHEA_NOTIFICATION_TYPE_EXTERNALINTERRUPT: u32 = 1;
pub const WHEA_NOTIFICATION_TYPE_LOCALINTERRUPT: u32 = 2;
pub const WHEA_NOTIFICATION_TYPE_SCI: u32 = 3;
pub const WHEA_NOTIFICATION_TYPE_NMI: u32 = 4;
pub const WHEA_NOTIFICATION_TYPE_CMCI: u32 = 5;
pub const WHEA_NOTIFICATION_TYPE_MCE: u32 = 6;
pub const WHEA_NOTIFICATION_TYPE_GPIO_SIGNAL: u32 = 7;
pub const WHEA_NOTIFICATION_TYPE_ARMV8_SEA: u32 = 8;
pub const WHEA_NOTIFICATION_TYPE_ARMV8_SEI: u32 = 9;
pub const WHEA_NOTIFICATION_TYPE_EXTERNALINTERRUPT_GSIV: u32 = 10;
pub const WHEA_NOTIFICATION_TYPE_SDEI: u32 = 11;
pub const WHEA_DEVICE_DRIVER_CONFIG_V1: u32 = 1;
pub const WHEA_DEVICE_DRIVER_CONFIG_V2: u32 = 2;
pub const WHEA_DEVICE_DRIVER_CONFIG_MIN: u32 = 1;
pub const WHEA_DEVICE_DRIVER_CONFIG_MAX: u32 = 2;
pub const WHEA_DEVICE_DRIVER_BUFFER_SET_V1: u32 = 1;
pub const WHEA_DEVICE_DRIVER_BUFFER_SET_MIN: u32 = 1;
pub const WHEA_DEVICE_DRIVER_BUFFER_SET_MAX: u32 = 1;
pub const WHEA_DISABLE_OFFLINE: u32 = 0;
pub const WHEA_MEM_PERSISTOFFLINE: u32 = 1;
pub const WHEA_MEM_PFA_DISABLE: u32 = 2;
pub const WHEA_MEM_PFA_PAGECOUNT: u32 = 3;
pub const WHEA_MEM_PFA_THRESHOLD: u32 = 4;
pub const WHEA_MEM_PFA_TIMEOUT: u32 = 5;
pub const WHEA_DISABLE_DUMMY_WRITE: u32 = 6;
pub const WHEA_RESTORE_CMCI_ENABLED: u32 = 7;
pub const WHEA_RESTORE_CMCI_ATTEMPTS: u32 = 8;
pub const WHEA_RESTORE_CMCI_ERR_LIMIT: u32 = 9;
pub const WHEA_CMCI_THRESHOLD_COUNT: u32 = 10;
pub const WHEA_CMCI_THRESHOLD_TIME: u32 = 11;
pub const WHEA_CMCI_THRESHOLD_POLL_COUNT: u32 = 12;
pub const WHEA_PENDING_PAGE_LIST_SZ: u32 = 13;
pub const WHEA_BAD_PAGE_LIST_MAX_SIZE: u32 = 14;
pub const WHEA_BAD_PAGE_LIST_LOCATION: u32 = 15;
pub const WHEA_NOTIFY_ALL_OFFLINES: u32 = 16;
pub const WHEA_ROW_FAIL_CHECK_EXTENT: u32 = 17;
pub const WHEA_ROW_FAIL_CHECK_ENABLE: u32 = 18;
pub const WHEA_ROW_FAIL_CHECK_THRESHOLD: u32 = 19;
pub const IPMI_OS_SEL_RECORD_VERSION_1: u32 = 1;
pub const IPMI_OS_SEL_RECORD_VERSION: u32 = 1;
pub const IPMI_IOCTL_INDEX: u32 = 1024;
pub const IPMI_OS_SEL_RECORD_MASK: u32 = 65535;
pub const ERRTYP_INTERNAL: u32 = 1;
pub const ERRTYP_BUS: u32 = 16;
pub const ERRTYP_MEM: u32 = 4;
pub const ERRTYP_TLB: u32 = 5;
pub const ERRTYP_CACHE: u32 = 6;
pub const ERRTYP_FUNCTION: u32 = 7;
pub const ERRTYP_SELFTEST: u32 = 8;
pub const ERRTYP_FLOW: u32 = 9;
pub const ERRTYP_MAP: u32 = 17;
pub const ERRTYP_IMPROPER: u32 = 18;
pub const ERRTYP_UNIMPL: u32 = 19;
pub const ERRTYP_LOSSOFLOCKSTEP: u32 = 20;
pub const ERRTYP_RESPONSE: u32 = 21;
pub const ERRTYP_PARITY: u32 = 22;
pub const ERRTYP_PROTOCOL: u32 = 23;
pub const ERRTYP_PATHERROR: u32 = 24;
pub const ERRTYP_TIMEOUT: u32 = 25;
pub const ERRTYP_POISONED: u32 = 26;
pub const WHEA_ERROR_RECORD_VALID_PLATFORMID: u32 = 1;
pub const WHEA_ERROR_RECORD_VALID_TIMESTAMP: u32 = 2;
pub const WHEA_ERROR_RECORD_VALID_PARTITIONID: u32 = 4;
pub const WHEA_ERROR_RECORD_FLAGS_RECOVERED: u32 = 1;
pub const WHEA_ERROR_RECORD_FLAGS_PREVIOUSERROR: u32 = 2;
pub const WHEA_ERROR_RECORD_FLAGS_SIMULATED: u32 = 4;
pub const WHEA_ERROR_RECORD_FLAGS_DEVICE_DRIVER: u32 = 8;
pub const WHEA_ERROR_RECORD_REVISION: u32 = 528;
pub const WHEA_ERROR_RECORD_SIGNATURE_END: u32 = 4294967295;
pub const WHEA_SECTION_DESCRIPTOR_FLAGS_PRIMARY: u32 = 1;
pub const WHEA_SECTION_DESCRIPTOR_FLAGS_CONTAINMENTWRN: u32 = 2;
pub const WHEA_SECTION_DESCRIPTOR_FLAGS_RESET: u32 = 4;
pub const WHEA_SECTION_DESCRIPTOR_FLAGS_THRESHOLDEXCEEDED: u32 = 8;
pub const WHEA_SECTION_DESCRIPTOR_FLAGS_RESOURCENA: u32 = 16;
pub const WHEA_SECTION_DESCRIPTOR_FLAGS_LATENTERROR: u32 = 32;
pub const WHEA_SECTION_DESCRIPTOR_FLAGS_PROPAGATED: u32 = 64;
pub const WHEA_SECTION_DESCRIPTOR_FLAGS_FRU_TEXT_BY_PLUGIN: u32 = 128;
pub const WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_REVISION: u32 = 768;
pub const GENPROC_PROCTYPE_XPF: u32 = 0;
pub const GENPROC_PROCTYPE_IPF: u32 = 1;
pub const GENPROC_PROCTYPE_ARM: u32 = 2;
pub const GENPROC_PROCISA_X86: u32 = 0;
pub const GENPROC_PROCISA_IPF: u32 = 1;
pub const GENPROC_PROCISA_X64: u32 = 2;
pub const GENPROC_PROCISA_ARM32: u32 = 4;
pub const GENPROC_PROCISA_ARM64: u32 = 8;
pub const GENPROC_PROCERRTYPE_UNKNOWN: u32 = 0;
pub const GENPROC_PROCERRTYPE_CACHE: u32 = 1;
pub const GENPROC_PROCERRTYPE_TLB: u32 = 2;
pub const GENPROC_PROCERRTYPE_BUS: u32 = 4;
pub const GENPROC_PROCERRTYPE_MAE: u32 = 8;
pub const GENPROC_OP_GENERIC: u32 = 0;
pub const GENPROC_OP_DATAREAD: u32 = 1;
pub const GENPROC_OP_DATAWRITE: u32 = 2;
pub const GENPROC_OP_INSTRUCTIONEXE: u32 = 3;
pub const GENPROC_FLAGS_RESTARTABLE: u32 = 1;
pub const GENPROC_FLAGS_PRECISEIP: u32 = 2;
pub const GENPROC_FLAGS_OVERFLOW: u32 = 4;
pub const GENPROC_FLAGS_CORRECTED: u32 = 8;
pub const XPF_CACHE_CHECK_TRANSACTIONTYPE_INSTRUCTION: u32 = 0;
pub const XPF_CACHE_CHECK_TRANSACTIONTYPE_DATAACCESS: u32 = 1;
pub const XPF_CACHE_CHECK_TRANSACTIONTYPE_GENERIC: u32 = 2;
pub const XPF_CACHE_CHECK_OPERATION_GENERIC: u32 = 0;
pub const XPF_CACHE_CHECK_OPERATION_GENREAD: u32 = 1;
pub const XPF_CACHE_CHECK_OPERATION_GENWRITE: u32 = 2;
pub const XPF_CACHE_CHECK_OPERATION_DATAREAD: u32 = 3;
pub const XPF_CACHE_CHECK_OPERATION_DATAWRITE: u32 = 4;
pub const XPF_CACHE_CHECK_OPERATION_INSTRUCTIONFETCH: u32 = 5;
pub const XPF_CACHE_CHECK_OPERATION_PREFETCH: u32 = 6;
pub const XPF_CACHE_CHECK_OPERATION_EVICTION: u32 = 7;
pub const XPF_CACHE_CHECK_OPERATION_SNOOP: u32 = 8;
pub const XPF_TLB_CHECK_TRANSACTIONTYPE_INSTRUCTION: u32 = 0;
pub const XPF_TLB_CHECK_TRANSACTIONTYPE_DATAACCESS: u32 = 1;
pub const XPF_TLB_CHECK_TRANSACTIONTYPE_GENERIC: u32 = 2;
pub const XPF_TLB_CHECK_OPERATION_GENERIC: u32 = 0;
pub const XPF_TLB_CHECK_OPERATION_GENREAD: u32 = 1;
pub const XPF_TLB_CHECK_OPERATION_GENWRITE: u32 = 2;
pub const XPF_TLB_CHECK_OPERATION_DATAREAD: u32 = 3;
pub const XPF_TLB_CHECK_OPERATION_DATAWRITE: u32 = 4;
pub const XPF_TLB_CHECK_OPERATION_INSTRUCTIONFETCH: u32 = 5;
pub const XPF_TLB_CHECK_OPERATION_PREFETCH: u32 = 6;
pub const XPF_BUS_CHECK_TRANSACTIONTYPE_INSTRUCTION: u32 = 0;
pub const XPF_BUS_CHECK_TRANSACTIONTYPE_DATAACCESS: u32 = 1;
pub const XPF_BUS_CHECK_TRANSACTIONTYPE_GENERIC: u32 = 2;
pub const XPF_BUS_CHECK_OPERATION_GENERIC: u32 = 0;
pub const XPF_BUS_CHECK_OPERATION_GENREAD: u32 = 1;
pub const XPF_BUS_CHECK_OPERATION_GENWRITE: u32 = 2;
pub const XPF_BUS_CHECK_OPERATION_DATAREAD: u32 = 3;
pub const XPF_BUS_CHECK_OPERATION_DATAWRITE: u32 = 4;
pub const XPF_BUS_CHECK_OPERATION_INSTRUCTIONFETCH: u32 = 5;
pub const XPF_BUS_CHECK_OPERATION_PREFETCH: u32 = 6;
pub const XPF_BUS_CHECK_PARTICIPATION_PROCORIGINATED: u32 = 0;
pub const XPF_BUS_CHECK_PARTICIPATION_PROCRESPONDED: u32 = 1;
pub const XPF_BUS_CHECK_PARTICIPATION_PROCOBSERVED: u32 = 2;
pub const XPF_BUS_CHECK_PARTICIPATION_GENERIC: u32 = 3;
pub const XPF_BUS_CHECK_ADDRESS_MEMORY: u32 = 0;
pub const XPF_BUS_CHECK_ADDRESS_RESERVED: u32 = 1;
pub const XPF_BUS_CHECK_ADDRESS_IO: u32 = 2;
pub const XPF_BUS_CHECK_ADDRESS_OTHER: u32 = 3;
pub const XPF_MS_CHECK_ERRORTYPE_NOERROR: u32 = 0;
pub const XPF_MS_CHECK_ERRORTYPE_UNCLASSIFIED: u32 = 1;
pub const XPF_MS_CHECK_ERRORTYPE_MCROMPARITY: u32 = 2;
pub const XPF_MS_CHECK_ERRORTYPE_EXTERNAL: u32 = 3;
pub const XPF_MS_CHECK_ERRORTYPE_FRC: u32 = 4;
pub const XPF_MS_CHECK_ERRORTYPE_INTERNALUNCLASSIFIED: u32 = 5;
pub const XPF_CONTEXT_INFO_UNCLASSIFIEDDATA: u32 = 0;
pub const XPF_CONTEXT_INFO_MSRREGISTERS: u32 = 1;
pub const XPF_CONTEXT_INFO_32BITCONTEXT: u32 = 2;
pub const XPF_CONTEXT_INFO_64BITCONTEXT: u32 = 3;
pub const XPF_CONTEXT_INFO_FXSAVE: u32 = 4;
pub const XPF_CONTEXT_INFO_32BITDEBUGREGS: u32 = 5;
pub const XPF_CONTEXT_INFO_64BITDEBUGREGS: u32 = 6;
pub const XPF_CONTEXT_INFO_MMREGISTERS: u32 = 7;
pub const WHEA_MEMERRTYPE_UNKNOWN: u32 = 0;
pub const WHEA_MEMERRTYPE_NOERROR: u32 = 1;
pub const WHEA_MEMERRTYPE_SINGLEBITECC: u32 = 2;
pub const WHEA_MEMERRTYPE_MULTIBITECC: u32 = 3;
pub const WHEA_MEMERRTYPE_SINGLESYMCHIPKILL: u32 = 4;
pub const WHEA_MEMERRTYPE_MULTISYMCHIPKILL: u32 = 5;
pub const WHEA_MEMERRTYPE_MASTERABORT: u32 = 6;
pub const WHEA_MEMERRTYPE_TARGETABORT: u32 = 7;
pub const WHEA_MEMERRTYPE_PARITYERROR: u32 = 8;
pub const WHEA_MEMERRTYPE_WATCHDOGTIMEOUT: u32 = 9;
pub const WHEA_MEMERRTYPE_INVALIDADDRESS: u32 = 10;
pub const WHEA_MEMERRTYPE_MIRRORBROKEN: u32 = 11;
pub const WHEA_MEMERRTYPE_MEMORYSPARING: u32 = 12;
pub const WHEA_PMEM_ERROR_SECTION_LOCATION_INFO_SIZE: u32 = 64;
pub const WHEA_PMEM_ERROR_SECTION_MAX_PAGES: u32 = 50;
pub const WHEA_PCIE_CORRECTABLE_ERROR_SECTION_COUNT_SIZE: u32 = 32;
pub const PCIXBUS_ERRTYPE_UNKNOWN: u32 = 0;
pub const PCIXBUS_ERRTYPE_DATAPARITY: u32 = 1;
pub const PCIXBUS_ERRTYPE_SYSTEM: u32 = 2;
pub const PCIXBUS_ERRTYPE_MASTERABORT: u32 = 3;
pub const PCIXBUS_ERRTYPE_BUSTIMEOUT: u32 = 4;
pub const PCIXBUS_ERRTYPE_MASTERDATAPARITY: u32 = 5;
pub const PCIXBUS_ERRTYPE_ADDRESSPARITY: u32 = 6;
pub const PCIXBUS_ERRTYPE_COMMANDPARITY: u32 = 7;
pub const WHEA_FIRMWARE_RECORD_TYPE_IPFSAL: u32 = 0;
pub const WHEA_XPF_MCA_EXTREG_MAX_COUNT: u32 = 24;
pub const WHEA_XPF_MCA_SECTION_VERSION_2: u32 = 2;
pub const WHEA_XPF_MCA_SECTION_VERSION_3: u32 = 3;
pub const WHEA_XPF_MCA_SECTION_VERSION: u32 = 3;
pub const WHEA_AMD_EXT_REG_NUM: u32 = 10;
pub const ANY_SIZE: u32 = 1;
pub const WHEA_ERROR_PACKET_V1_VERSION: u32 = 2;
pub const WHEA_ERROR_PACKET_V2_VERSION: u32 = 3;
pub const WHEA_ERROR_PACKET_VERSION: u32 = 3;
pub const WHEA_ERROR_LOG_ENTRY_VERSION: u32 = 1;
pub const WHEA_ERROR_TEXT_LEN: u32 = 32;
pub const WHEA_SEL_BUGCHECK_RECOVERY_STATUS_PHASE1_VERSION: u32 = 1;
pub const WCS_RAS_REGISTER_NAME_MAX_LENGTH: u32 = 32;
pub const WHEA_GENERIC_ENTRY_TEXT_LEN: u32 = 20;
pub const WHEA_GENERIC_ENTRY_V2_VERSION: u32 = 768;
pub const WHEA_GENERIC_ENTRY_VERSION: u32 = 768;
pub const WHEA_MAX_LOG_DATA_LEN: u32 = 36;
pub const WHEA_INVALID_ERR_SRC_ID: u32 = 0;
pub const WHEA_ERR_SRC_OVERRIDE_FLAG: u32 = 1;
pub const INJECT_ERRTYPE_PROCESSOR_CORRECTABLE: u32 = 1;
pub const INJECT_ERRTYPE_PROCESSOR_UNCORRECTABLENONFATAL: u32 = 2;
pub const INJECT_ERRTYPE_PROCESSOR_UNCORRECTABLEFATAL: u32 = 4;
pub const INJECT_ERRTYPE_MEMORY_CORRECTABLE: u32 = 8;
pub const INJECT_ERRTYPE_MEMORY_UNCORRECTABLENONFATAL: u32 = 16;
pub const INJECT_ERRTYPE_MEMORY_UNCORRECTABLEFATAL: u32 = 32;
pub const INJECT_ERRTYPE_PCIEXPRESS_CORRECTABLE: u32 = 64;
pub const INJECT_ERRTYPE_PCIEXPRESS_UNCORRECTABLENONFATAL: u32 = 128;
pub const INJECT_ERRTYPE_PCIEXPRESS_UNCORRECTABLEFATAL: u32 = 256;
pub const INJECT_ERRTYPE_PLATFORM_CORRECTABLE: u32 = 512;
pub const INJECT_ERRTYPE_PLATFORM_UNCORRECTABLENONFATAL: u32 = 1024;
pub const INJECT_ERRTYPE_PLATFORM_UNCORRECTABLEFATAL: u32 = 2048;
pub const WHEA_IN_USE_PAGE_NOTIFY_FLAG_PLATFORMDIRECTED: u32 = 1;
pub const WHEA_IN_USE_PAGE_NOTIFY_FLAG_NOTIFYALL: u32 = 64;
pub const WHEA_IN_USE_PAGE_NOTIFY_FLAG_PAGEOFFLINED: u32 = 128;
pub const WHEA_PLUGIN_REGISTRATION_PACKET_V1: u32 = 65536;
pub const WHEA_PLUGIN_REGISTRATION_PACKET_V2: u32 = 131072;
pub const WHEA_PLUGIN_REGISTRATION_PACKET_VERSION: u32 = 131072;
pub const PshedFADiscovery: u32 = 1;
pub const PshedFAErrorSourceControl: u32 = 2;
pub const PshedFAErrorRecordPersistence: u32 = 4;
pub const PshedFAErrorInfoRetrieval: u32 = 8;
pub const PshedFAErrorRecovery: u32 = 16;
pub const PshedFAErrorInjection: u32 = 32;
pub const WHEA_WRITE_FLAG_DUMMY: u32 = 1;
pub const MAXIMUM_LEADBYTES: u32 = 12;
pub const SID_REVISION: u32 = 1;
pub const SID_MAX_SUB_AUTHORITIES: u32 = 15;
pub const SID_RECOMMENDED_SUB_AUTHORITIES: u32 = 1;
pub const SECURITY_MAX_SID_STRING_CHARACTERS: u32 = 187;
pub const SID_HASH_SIZE: u32 = 32;
pub const SECURITY_NULL_RID: u32 = 0;
pub const SECURITY_WORLD_RID: u32 = 0;
pub const SECURITY_LOCAL_RID: u32 = 0;
pub const SECURITY_LOCAL_LOGON_RID: u32 = 1;
pub const SECURITY_CREATOR_OWNER_RID: u32 = 0;
pub const SECURITY_CREATOR_GROUP_RID: u32 = 1;
pub const SECURITY_CREATOR_OWNER_SERVER_RID: u32 = 2;
pub const SECURITY_CREATOR_GROUP_SERVER_RID: u32 = 3;
pub const SECURITY_CREATOR_OWNER_RIGHTS_RID: u32 = 4;
pub const SECURITY_DIALUP_RID: u32 = 1;
pub const SECURITY_NETWORK_RID: u32 = 2;
pub const SECURITY_BATCH_RID: u32 = 3;
pub const SECURITY_INTERACTIVE_RID: u32 = 4;
pub const SECURITY_LOGON_IDS_RID: u32 = 5;
pub const SECURITY_LOGON_IDS_RID_COUNT: u32 = 3;
pub const SECURITY_SERVICE_RID: u32 = 6;
pub const SECURITY_ANONYMOUS_LOGON_RID: u32 = 7;
pub const SECURITY_PROXY_RID: u32 = 8;
pub const SECURITY_ENTERPRISE_CONTROLLERS_RID: u32 = 9;
pub const SECURITY_SERVER_LOGON_RID: u32 = 9;
pub const SECURITY_PRINCIPAL_SELF_RID: u32 = 10;
pub const SECURITY_AUTHENTICATED_USER_RID: u32 = 11;
pub const SECURITY_RESTRICTED_CODE_RID: u32 = 12;
pub const SECURITY_TERMINAL_SERVER_RID: u32 = 13;
pub const SECURITY_REMOTE_LOGON_RID: u32 = 14;
pub const SECURITY_THIS_ORGANIZATION_RID: u32 = 15;
pub const SECURITY_IUSER_RID: u32 = 17;
pub const SECURITY_LOCAL_SYSTEM_RID: u32 = 18;
pub const SECURITY_LOCAL_SERVICE_RID: u32 = 19;
pub const SECURITY_NETWORK_SERVICE_RID: u32 = 20;
pub const SECURITY_NT_NON_UNIQUE: u32 = 21;
pub const SECURITY_NT_NON_UNIQUE_SUB_AUTH_COUNT: u32 = 3;
pub const SECURITY_ENTERPRISE_READONLY_CONTROLLERS_RID: u32 = 22;
pub const SECURITY_BUILTIN_DOMAIN_RID: u32 = 32;
pub const SECURITY_WRITE_RESTRICTED_CODE_RID: u32 = 33;
pub const SECURITY_PACKAGE_BASE_RID: u32 = 64;
pub const SECURITY_PACKAGE_RID_COUNT: u32 = 2;
pub const SECURITY_PACKAGE_NTLM_RID: u32 = 10;
pub const SECURITY_PACKAGE_SCHANNEL_RID: u32 = 14;
pub const SECURITY_PACKAGE_DIGEST_RID: u32 = 21;
pub const SECURITY_CRED_TYPE_BASE_RID: u32 = 65;
pub const SECURITY_CRED_TYPE_RID_COUNT: u32 = 2;
pub const SECURITY_CRED_TYPE_THIS_ORG_CERT_RID: u32 = 1;
pub const SECURITY_MIN_BASE_RID: u32 = 80;
pub const SECURITY_SERVICE_ID_BASE_RID: u32 = 80;
pub const SECURITY_SERVICE_ID_RID_COUNT: u32 = 6;
pub const SECURITY_RESERVED_ID_BASE_RID: u32 = 81;
pub const SECURITY_APPPOOL_ID_BASE_RID: u32 = 82;
pub const SECURITY_APPPOOL_ID_RID_COUNT: u32 = 6;
pub const SECURITY_VIRTUALSERVER_ID_BASE_RID: u32 = 83;
pub const SECURITY_VIRTUALSERVER_ID_RID_COUNT: u32 = 6;
pub const SECURITY_USERMODEDRIVERHOST_ID_BASE_RID: u32 = 84;
pub const SECURITY_USERMODEDRIVERHOST_ID_RID_COUNT: u32 = 6;
pub const SECURITY_CLOUD_INFRASTRUCTURE_SERVICES_ID_BASE_RID: u32 = 85;
pub const SECURITY_CLOUD_INFRASTRUCTURE_SERVICES_ID_RID_COUNT: u32 = 6;
pub const SECURITY_WMIHOST_ID_BASE_RID: u32 = 86;
pub const SECURITY_WMIHOST_ID_RID_COUNT: u32 = 6;
pub const SECURITY_TASK_ID_BASE_RID: u32 = 87;
pub const SECURITY_NFS_ID_BASE_RID: u32 = 88;
pub const SECURITY_COM_ID_BASE_RID: u32 = 89;
pub const SECURITY_WINDOW_MANAGER_BASE_RID: u32 = 90;
pub const SECURITY_RDV_GFX_BASE_RID: u32 = 91;
pub const SECURITY_DASHOST_ID_BASE_RID: u32 = 92;
pub const SECURITY_DASHOST_ID_RID_COUNT: u32 = 6;
pub const SECURITY_USERMANAGER_ID_BASE_RID: u32 = 93;
pub const SECURITY_USERMANAGER_ID_RID_COUNT: u32 = 6;
pub const SECURITY_WINRM_ID_BASE_RID: u32 = 94;
pub const SECURITY_WINRM_ID_RID_COUNT: u32 = 6;
pub const SECURITY_CCG_ID_BASE_RID: u32 = 95;
pub const SECURITY_UMFD_BASE_RID: u32 = 96;
pub const SECURITY_VIRTUALACCOUNT_ID_RID_COUNT: u32 = 6;
pub const SECURITY_MAX_BASE_RID: u32 = 111;
pub const SECURITY_MAX_ALWAYS_FILTERED: u32 = 999;
pub const SECURITY_MIN_NEVER_FILTERED: u32 = 1000;
pub const SECURITY_OTHER_ORGANIZATION_RID: u32 = 1000;
pub const SECURITY_WINDOWSMOBILE_ID_BASE_RID: u32 = 112;
pub const SECURITY_INSTALLER_GROUP_CAPABILITY_BASE: u32 = 32;
pub const SECURITY_INSTALLER_GROUP_CAPABILITY_RID_COUNT: u32 = 9;
pub const SECURITY_INSTALLER_CAPABILITY_RID_COUNT: u32 = 10;
pub const SECURITY_LOCAL_ACCOUNT_RID: u32 = 113;
pub const SECURITY_LOCAL_ACCOUNT_AND_ADMIN_RID: u32 = 114;
pub const DOMAIN_GROUP_RID_AUTHORIZATION_DATA_IS_COMPOUNDED: u32 = 496;
pub const DOMAIN_GROUP_RID_AUTHORIZATION_DATA_CONTAINS_CLAIMS: u32 = 497;
pub const DOMAIN_GROUP_RID_ENTERPRISE_READONLY_DOMAIN_CONTROLLERS: u32 = 498;
pub const FOREST_USER_RID_MAX: u32 = 499;
pub const DOMAIN_USER_RID_ADMIN: u32 = 500;
pub const DOMAIN_USER_RID_GUEST: u32 = 501;
pub const DOMAIN_USER_RID_KRBTGT: u32 = 502;
pub const DOMAIN_USER_RID_DEFAULT_ACCOUNT: u32 = 503;
pub const DOMAIN_USER_RID_WDAG_ACCOUNT: u32 = 504;
pub const DOMAIN_USER_RID_MAX: u32 = 999;
pub const DOMAIN_GROUP_RID_ADMINS: u32 = 512;
pub const DOMAIN_GROUP_RID_USERS: u32 = 513;
pub const DOMAIN_GROUP_RID_GUESTS: u32 = 514;
pub const DOMAIN_GROUP_RID_COMPUTERS: u32 = 515;
pub const DOMAIN_GROUP_RID_CONTROLLERS: u32 = 516;
pub const DOMAIN_GROUP_RID_CERT_ADMINS: u32 = 517;
pub const DOMAIN_GROUP_RID_SCHEMA_ADMINS: u32 = 518;
pub const DOMAIN_GROUP_RID_ENTERPRISE_ADMINS: u32 = 519;
pub const DOMAIN_GROUP_RID_POLICY_ADMINS: u32 = 520;
pub const DOMAIN_GROUP_RID_READONLY_CONTROLLERS: u32 = 521;
pub const DOMAIN_GROUP_RID_CLONEABLE_CONTROLLERS: u32 = 522;
pub const DOMAIN_GROUP_RID_CDC_RESERVED: u32 = 524;
pub const DOMAIN_GROUP_RID_PROTECTED_USERS: u32 = 525;
pub const DOMAIN_GROUP_RID_KEY_ADMINS: u32 = 526;
pub const DOMAIN_GROUP_RID_ENTERPRISE_KEY_ADMINS: u32 = 527;
pub const DOMAIN_ALIAS_RID_ADMINS: u32 = 544;
pub const DOMAIN_ALIAS_RID_USERS: u32 = 545;
pub const DOMAIN_ALIAS_RID_GUESTS: u32 = 546;
pub const DOMAIN_ALIAS_RID_POWER_USERS: u32 = 547;
pub const DOMAIN_ALIAS_RID_ACCOUNT_OPS: u32 = 548;
pub const DOMAIN_ALIAS_RID_SYSTEM_OPS: u32 = 549;
pub const DOMAIN_ALIAS_RID_PRINT_OPS: u32 = 550;
pub const DOMAIN_ALIAS_RID_BACKUP_OPS: u32 = 551;
pub const DOMAIN_ALIAS_RID_REPLICATOR: u32 = 552;
pub const DOMAIN_ALIAS_RID_RAS_SERVERS: u32 = 553;
pub const DOMAIN_ALIAS_RID_PREW2KCOMPACCESS: u32 = 554;
pub const DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS: u32 = 555;
pub const DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS: u32 = 556;
pub const DOMAIN_ALIAS_RID_INCOMING_FOREST_TRUST_BUILDERS: u32 = 557;
pub const DOMAIN_ALIAS_RID_MONITORING_USERS: u32 = 558;
pub const DOMAIN_ALIAS_RID_LOGGING_USERS: u32 = 559;
pub const DOMAIN_ALIAS_RID_AUTHORIZATIONACCESS: u32 = 560;
pub const DOMAIN_ALIAS_RID_TS_LICENSE_SERVERS: u32 = 561;
pub const DOMAIN_ALIAS_RID_DCOM_USERS: u32 = 562;
pub const DOMAIN_ALIAS_RID_IUSERS: u32 = 568;
pub const DOMAIN_ALIAS_RID_CRYPTO_OPERATORS: u32 = 569;
pub const DOMAIN_ALIAS_RID_CACHEABLE_PRINCIPALS_GROUP: u32 = 571;
pub const DOMAIN_ALIAS_RID_NON_CACHEABLE_PRINCIPALS_GROUP: u32 = 572;
pub const DOMAIN_ALIAS_RID_EVENT_LOG_READERS_GROUP: u32 = 573;
pub const DOMAIN_ALIAS_RID_CERTSVC_DCOM_ACCESS_GROUP: u32 = 574;
pub const DOMAIN_ALIAS_RID_RDS_REMOTE_ACCESS_SERVERS: u32 = 575;
pub const DOMAIN_ALIAS_RID_RDS_ENDPOINT_SERVERS: u32 = 576;
pub const DOMAIN_ALIAS_RID_RDS_MANAGEMENT_SERVERS: u32 = 577;
pub const DOMAIN_ALIAS_RID_HYPER_V_ADMINS: u32 = 578;
pub const DOMAIN_ALIAS_RID_ACCESS_CONTROL_ASSISTANCE_OPS: u32 = 579;
pub const DOMAIN_ALIAS_RID_REMOTE_MANAGEMENT_USERS: u32 = 580;
pub const DOMAIN_ALIAS_RID_DEFAULT_ACCOUNT: u32 = 581;
pub const DOMAIN_ALIAS_RID_STORAGE_REPLICA_ADMINS: u32 = 582;
pub const DOMAIN_ALIAS_RID_DEVICE_OWNERS: u32 = 583;
pub const SECURITY_APP_PACKAGE_BASE_RID: u32 = 2;
pub const SECURITY_BUILTIN_APP_PACKAGE_RID_COUNT: u32 = 2;
pub const SECURITY_APP_PACKAGE_RID_COUNT: u32 = 8;
pub const SECURITY_CAPABILITY_BASE_RID: u32 = 3;
pub const SECURITY_CAPABILITY_APP_RID: u32 = 1024;
pub const SECURITY_CAPABILITY_APP_SILO_RID: u32 = 65536;
pub const SECURITY_BUILTIN_CAPABILITY_RID_COUNT: u32 = 2;
pub const SECURITY_CAPABILITY_RID_COUNT: u32 = 5;
pub const SECURITY_PARENT_PACKAGE_RID_COUNT: u32 = 8;
pub const SECURITY_CHILD_PACKAGE_RID_COUNT: u32 = 12;
pub const SECURITY_BUILTIN_PACKAGE_ANY_PACKAGE: u32 = 1;
pub const SECURITY_BUILTIN_PACKAGE_ANY_RESTRICTED_PACKAGE: u32 = 2;
pub const SECURITY_CAPABILITY_INTERNET_CLIENT: u32 = 1;
pub const SECURITY_CAPABILITY_INTERNET_CLIENT_SERVER: u32 = 2;
pub const SECURITY_CAPABILITY_PRIVATE_NETWORK_CLIENT_SERVER: u32 = 3;
pub const SECURITY_CAPABILITY_PICTURES_LIBRARY: u32 = 4;
pub const SECURITY_CAPABILITY_VIDEOS_LIBRARY: u32 = 5;
pub const SECURITY_CAPABILITY_MUSIC_LIBRARY: u32 = 6;
pub const SECURITY_CAPABILITY_DOCUMENTS_LIBRARY: u32 = 7;
pub const SECURITY_CAPABILITY_ENTERPRISE_AUTHENTICATION: u32 = 8;
pub const SECURITY_CAPABILITY_SHARED_USER_CERTIFICATES: u32 = 9;
pub const SECURITY_CAPABILITY_REMOVABLE_STORAGE: u32 = 10;
pub const SECURITY_CAPABILITY_APPOINTMENTS: u32 = 11;
pub const SECURITY_CAPABILITY_CONTACTS: u32 = 12;
pub const SECURITY_CAPABILITY_INTERNET_EXPLORER: u32 = 4096;
pub const SECURITY_MANDATORY_UNTRUSTED_RID: u32 = 0;
pub const SECURITY_MANDATORY_LOW_RID: u32 = 4096;
pub const SECURITY_MANDATORY_MEDIUM_RID: u32 = 8192;
pub const SECURITY_MANDATORY_MEDIUM_PLUS_RID: u32 = 8448;
pub const SECURITY_MANDATORY_HIGH_RID: u32 = 12288;
pub const SECURITY_MANDATORY_SYSTEM_RID: u32 = 16384;
pub const SECURITY_MANDATORY_PROTECTED_PROCESS_RID: u32 = 20480;
pub const SECURITY_MANDATORY_MAXIMUM_USER_RID: u32 = 16384;
pub const SECURITY_AUTHENTICATION_AUTHORITY_RID_COUNT: u32 = 1;
pub const SECURITY_AUTHENTICATION_AUTHORITY_ASSERTED_RID: u32 = 1;
pub const SECURITY_AUTHENTICATION_SERVICE_ASSERTED_RID: u32 = 2;
pub const SECURITY_AUTHENTICATION_FRESH_KEY_AUTH_RID: u32 = 3;
pub const SECURITY_AUTHENTICATION_KEY_TRUST_RID: u32 = 4;
pub const SECURITY_AUTHENTICATION_KEY_PROPERTY_MFA_RID: u32 = 5;
pub const SECURITY_AUTHENTICATION_KEY_PROPERTY_ATTESTATION_RID: u32 = 6;
pub const SECURITY_PROCESS_TRUST_AUTHORITY_RID_COUNT: u32 = 2;
pub const SECURITY_PROCESS_PROTECTION_TYPE_FULL_RID: u32 = 1024;
pub const SECURITY_PROCESS_PROTECTION_TYPE_LITE_RID: u32 = 512;
pub const SECURITY_PROCESS_PROTECTION_TYPE_NONE_RID: u32 = 0;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_WINTCB_RID: u32 = 8192;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_WINDOWS_RID: u32 = 4096;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_APP_RID: u32 = 2048;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_ANTIMALWARE_RID: u32 = 1536;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_AUTHENTICODE_RID: u32 = 1024;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_NONE_RID: u32 = 0;
pub const SECURITY_TRUSTED_INSTALLER_RID1: u32 = 956008885;
pub const SECURITY_TRUSTED_INSTALLER_RID2: u32 = 3418522649;
pub const SECURITY_TRUSTED_INSTALLER_RID3: u32 = 1831038044;
pub const SECURITY_TRUSTED_INSTALLER_RID4: u32 = 1853292631;
pub const SECURITY_TRUSTED_INSTALLER_RID5: u32 = 2271478464;
pub const ACCESS_MIN_MS_ACE_TYPE: u32 = 0;
pub const ACCESS_ALLOWED_ACE_TYPE: u32 = 0;
pub const ACCESS_DENIED_ACE_TYPE: u32 = 1;
pub const SYSTEM_AUDIT_ACE_TYPE: u32 = 2;
pub const SYSTEM_ALARM_ACE_TYPE: u32 = 3;
pub const ACCESS_MAX_MS_V2_ACE_TYPE: u32 = 3;
pub const ACCESS_ALLOWED_COMPOUND_ACE_TYPE: u32 = 4;
pub const ACCESS_MAX_MS_V3_ACE_TYPE: u32 = 4;
pub const ACCESS_MIN_MS_OBJECT_ACE_TYPE: u32 = 5;
pub const ACCESS_ALLOWED_OBJECT_ACE_TYPE: u32 = 5;
pub const ACCESS_DENIED_OBJECT_ACE_TYPE: u32 = 6;
pub const SYSTEM_AUDIT_OBJECT_ACE_TYPE: u32 = 7;
pub const SYSTEM_ALARM_OBJECT_ACE_TYPE: u32 = 8;
pub const ACCESS_MAX_MS_OBJECT_ACE_TYPE: u32 = 8;
pub const ACCESS_MAX_MS_V4_ACE_TYPE: u32 = 8;
pub const ACCESS_MAX_MS_ACE_TYPE: u32 = 8;
pub const ACCESS_ALLOWED_CALLBACK_ACE_TYPE: u32 = 9;
pub const ACCESS_DENIED_CALLBACK_ACE_TYPE: u32 = 10;
pub const ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE: u32 = 11;
pub const ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE: u32 = 12;
pub const SYSTEM_AUDIT_CALLBACK_ACE_TYPE: u32 = 13;
pub const SYSTEM_ALARM_CALLBACK_ACE_TYPE: u32 = 14;
pub const SYSTEM_AUDIT_CALLBACK_OBJECT_ACE_TYPE: u32 = 15;
pub const SYSTEM_ALARM_CALLBACK_OBJECT_ACE_TYPE: u32 = 16;
pub const SYSTEM_MANDATORY_LABEL_ACE_TYPE: u32 = 17;
pub const SYSTEM_RESOURCE_ATTRIBUTE_ACE_TYPE: u32 = 18;
pub const SYSTEM_SCOPED_POLICY_ID_ACE_TYPE: u32 = 19;
pub const SYSTEM_PROCESS_TRUST_LABEL_ACE_TYPE: u32 = 20;
pub const SYSTEM_ACCESS_FILTER_ACE_TYPE: u32 = 21;
pub const ACCESS_MAX_MS_V5_ACE_TYPE: u32 = 21;
pub const OBJECT_INHERIT_ACE: u32 = 1;
pub const CONTAINER_INHERIT_ACE: u32 = 2;
pub const NO_PROPAGATE_INHERIT_ACE: u32 = 4;
pub const INHERIT_ONLY_ACE: u32 = 8;
pub const INHERITED_ACE: u32 = 16;
pub const VALID_INHERIT_FLAGS: u32 = 31;
pub const CRITICAL_ACE_FLAG: u32 = 32;
pub const SUCCESSFUL_ACCESS_ACE_FLAG: u32 = 64;
pub const FAILED_ACCESS_ACE_FLAG: u32 = 128;
pub const TRUST_PROTECTED_FILTER_ACE_FLAG: u32 = 64;
pub const SYSTEM_MANDATORY_LABEL_NO_WRITE_UP: u32 = 1;
pub const SYSTEM_MANDATORY_LABEL_NO_READ_UP: u32 = 2;
pub const SYSTEM_MANDATORY_LABEL_NO_EXECUTE_UP: u32 = 4;
pub const SYSTEM_MANDATORY_LABEL_VALID_MASK: u32 = 7;
pub const SYSTEM_PROCESS_TRUST_LABEL_VALID_MASK: u32 = 16777215;
pub const SYSTEM_PROCESS_TRUST_NOCONSTRAINT_MASK: u32 = 4294967295;
pub const SYSTEM_ACCESS_FILTER_VALID_MASK: u32 = 16777215;
pub const SYSTEM_ACCESS_FILTER_NOCONSTRAINT_MASK: u32 = 4294967295;
pub const SE_OWNER_DEFAULTED: u32 = 1;
pub const SE_GROUP_DEFAULTED: u32 = 2;
pub const SE_DACL_PRESENT: u32 = 4;
pub const SE_DACL_DEFAULTED: u32 = 8;
pub const SE_SACL_PRESENT: u32 = 16;
pub const SE_SACL_DEFAULTED: u32 = 32;
pub const SE_DACL_UNTRUSTED: u32 = 64;
pub const SE_SERVER_SECURITY: u32 = 128;
pub const SE_DACL_AUTO_INHERIT_REQ: u32 = 256;
pub const SE_SACL_AUTO_INHERIT_REQ: u32 = 512;
pub const SE_DACL_AUTO_INHERITED: u32 = 1024;
pub const SE_SACL_AUTO_INHERITED: u32 = 2048;
pub const SE_DACL_PROTECTED: u32 = 4096;
pub const SE_SACL_PROTECTED: u32 = 8192;
pub const SE_RM_CONTROL_VALID: u32 = 16384;
pub const SE_SELF_RELATIVE: u32 = 32768;
pub const ACCESS_OBJECT_GUID: u32 = 0;
pub const ACCESS_PROPERTY_SET_GUID: u32 = 1;
pub const ACCESS_PROPERTY_GUID: u32 = 2;
pub const ACCESS_MAX_LEVEL: u32 = 4;
pub const AUDIT_ALLOW_NO_PRIVILEGE: u32 = 1;
pub const ACCESS_DS_SOURCE_A: &[u8; 3] = b"DS\0";
pub const ACCESS_DS_SOURCE_W: &[u8; 3] = b"DS\0";
pub const ACCESS_DS_OBJECT_TYPE_NAME_A: &[u8; 25] = b"Directory Service Object\0";
pub const ACCESS_DS_OBJECT_TYPE_NAME_W: &[u8; 25] = b"Directory Service Object\0";
pub const ACCESS_REASON_TYPE_MASK: u32 = 16711680;
pub const ACCESS_REASON_DATA_MASK: u32 = 65535;
pub const ACCESS_REASON_STAGING_MASK: u32 = 2147483648;
pub const ACCESS_REASON_EXDATA_MASK: u32 = 2130706432;
pub const SE_SECURITY_DESCRIPTOR_FLAG_NO_OWNER_ACE: u32 = 1;
pub const SE_SECURITY_DESCRIPTOR_FLAG_NO_LABEL_ACE: u32 = 2;
pub const SE_SECURITY_DESCRIPTOR_FLAG_NO_ACCESS_FILTER_ACE: u32 = 4;
pub const SE_SECURITY_DESCRIPTOR_VALID_FLAGS: u32 = 7;
pub const SE_ACCESS_CHECK_FLAG_NO_LEARNING_MODE_LOGGING: u32 = 8;
pub const SE_ACCESS_CHECK_VALID_FLAGS: u32 = 8;
pub const TOKEN_ASSIGN_PRIMARY: u32 = 1;
pub const TOKEN_DUPLICATE: u32 = 2;
pub const TOKEN_IMPERSONATE: u32 = 4;
pub const TOKEN_QUERY: u32 = 8;
pub const TOKEN_QUERY_SOURCE: u32 = 16;
pub const TOKEN_ADJUST_PRIVILEGES: u32 = 32;
pub const TOKEN_ADJUST_GROUPS: u32 = 64;
pub const TOKEN_ADJUST_DEFAULT: u32 = 128;
pub const TOKEN_ADJUST_SESSIONID: u32 = 256;
pub const TOKEN_ALL_ACCESS_P: u32 = 983295;
pub const TOKEN_ALL_ACCESS: u32 = 983551;
pub const TOKEN_READ: u32 = 131080;
pub const TOKEN_WRITE: u32 = 131296;
pub const TOKEN_EXECUTE: u32 = 131072;
pub const TOKEN_TRUST_CONSTRAINT_MASK: u32 = 131096;
pub const TOKEN_TRUST_ALLOWED_MASK: u32 = 131102;
pub const TOKEN_ACCESS_PSEUDO_HANDLE_WIN8: u32 = 24;
pub const TOKEN_ACCESS_PSEUDO_HANDLE: u32 = 24;
pub const TOKEN_MANDATORY_POLICY_OFF: u32 = 0;
pub const TOKEN_MANDATORY_POLICY_NO_WRITE_UP: u32 = 1;
pub const TOKEN_MANDATORY_POLICY_NEW_PROCESS_MIN: u32 = 2;
pub const TOKEN_MANDATORY_POLICY_VALID_MASK: u32 = 3;
pub const POLICY_AUDIT_SUBCATEGORY_COUNT: u32 = 59;
pub const TOKEN_SOURCE_LENGTH: u32 = 8;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_INVALID: u32 = 0;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_INT64: u32 = 1;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_UINT64: u32 = 2;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_STRING: u32 = 3;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_FQBN: u32 = 4;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_SID: u32 = 5;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_BOOLEAN: u32 = 6;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_OCTET_STRING: u32 = 16;
pub const CLAIM_SECURITY_ATTRIBUTE_NON_INHERITABLE: u32 = 1;
pub const CLAIM_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE: u32 = 2;
pub const CLAIM_SECURITY_ATTRIBUTE_USE_FOR_DENY_ONLY: u32 = 4;
pub const CLAIM_SECURITY_ATTRIBUTE_DISABLED_BY_DEFAULT: u32 = 8;
pub const CLAIM_SECURITY_ATTRIBUTE_DISABLED: u32 = 16;
pub const CLAIM_SECURITY_ATTRIBUTE_MANDATORY: u32 = 32;
pub const CLAIM_SECURITY_ATTRIBUTE_VALID_FLAGS: u32 = 63;
pub const CLAIM_SECURITY_ATTRIBUTE_CUSTOM_FLAGS: u32 = 4294901760;
pub const CLAIM_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1: u32 = 1;
pub const CLAIM_SECURITY_ATTRIBUTES_INFORMATION_VERSION: u32 = 1;
pub const SEGMENT_HEAP_PARAMETERS_VERSION: u32 = 3;
pub const SEGMENT_HEAP_FLG_USE_PAGE_HEAP: u32 = 1;
pub const SEGMENT_HEAP_PARAMS_VALID_FLAGS: u32 = 1;
pub const RTL_HEAP_MEMORY_LIMIT_CURRENT_VERSION: u32 = 1;
pub const HEAP_NO_SERIALIZE: u32 = 1;
pub const HEAP_GROWABLE: u32 = 2;
pub const HEAP_GENERATE_EXCEPTIONS: u32 = 4;
pub const HEAP_ZERO_MEMORY: u32 = 8;
pub const HEAP_REALLOC_IN_PLACE_ONLY: u32 = 16;
pub const HEAP_TAIL_CHECKING_ENABLED: u32 = 32;
pub const HEAP_FREE_CHECKING_ENABLED: u32 = 64;
pub const HEAP_DISABLE_COALESCE_ON_FREE: u32 = 128;
pub const HEAP_CREATE_ALIGN_16: u32 = 65536;
pub const HEAP_CREATE_ENABLE_TRACING: u32 = 131072;
pub const HEAP_CREATE_ENABLE_EXECUTE: u32 = 262144;
pub const HEAP_SETTABLE_USER_VALUE: u32 = 256;
pub const HEAP_SETTABLE_USER_FLAG1: u32 = 512;
pub const HEAP_SETTABLE_USER_FLAG2: u32 = 1024;
pub const HEAP_SETTABLE_USER_FLAG3: u32 = 2048;
pub const HEAP_SETTABLE_USER_FLAGS: u32 = 3584;
pub const HEAP_CLASS_0: u32 = 0;
pub const HEAP_CLASS_1: u32 = 4096;
pub const HEAP_CLASS_2: u32 = 8192;
pub const HEAP_CLASS_3: u32 = 12288;
pub const HEAP_CLASS_4: u32 = 16384;
pub const HEAP_CLASS_5: u32 = 20480;
pub const HEAP_CLASS_6: u32 = 24576;
pub const HEAP_CLASS_7: u32 = 28672;
pub const HEAP_CLASS_8: u32 = 32768;
pub const HEAP_CLASS_MASK: u32 = 61440;
pub const HEAP_MAXIMUM_TAG: u32 = 4095;
pub const HEAP_GLOBAL_TAG: u32 = 2048;
pub const HEAP_PSEUDO_TAG_FLAG: u32 = 32768;
pub const HEAP_TAG_SHIFT: u32 = 18;
pub const HEAP_TAG_MASK: u32 = 1073479680;
pub const HEAP_CREATE_SEGMENT_HEAP: u32 = 256;
pub const HEAP_CREATE_HARDENED: u32 = 512;
pub const HEAP_CREATE_VALID_MASK: u32 = 521215;
pub const RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE: u32 = 1;
pub const RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING: u32 = 2;
pub const COMPRESSION_FORMAT_NONE: u32 = 0;
pub const COMPRESSION_FORMAT_DEFAULT: u32 = 1;
pub const COMPRESSION_FORMAT_LZNT1: u32 = 2;
pub const COMPRESSION_FORMAT_XPRESS: u32 = 3;
pub const COMPRESSION_FORMAT_XPRESS_HUFF: u32 = 4;
pub const COMPRESSION_FORMAT_XP10: u32 = 5;
pub const COMPRESSION_FORMAT_MAX: u32 = 5;
pub const COMPRESSION_ENGINE_STANDARD: u32 = 0;
pub const COMPRESSION_ENGINE_MAXIMUM: u32 = 256;
pub const COMPRESSION_ENGINE_HIBER: u32 = 512;
pub const COMPRESSION_ENGINE_MAX: u32 = 512;
pub const COMPRESSION_FORMAT_MASK: u32 = 255;
pub const COMPRESSION_ENGINE_MASK: u32 = 65280;
pub const COMPRESSION_FORMAT_ENGINE_MASK: u32 = 65535;
pub const MAX_UNICODE_STACK_BUFFER_LENGTH: u32 = 256;
pub const RTL_SYSTEM_VOLUME_INFORMATION_FOLDER: &[u8; 26] = b"System Volume Information\0";
pub const PSMP_MINIMUM_SYSAPP_CLAIM_VALUES: u32 = 2;
pub const PSMP_MAXIMUM_SYSAPP_CLAIM_VALUES: u32 = 4;
pub const MSV1_0_PACKAGE_NAME: &[u8; 38] = b"MICROSOFT_AUTHENTICATION_PACKAGE_V1_0\0";
pub const MSV1_0_PACKAGE_NAMEW: &[u8; 38] = b"MICROSOFT_AUTHENTICATION_PACKAGE_V1_0\0";
pub const MSV1_0_SUBAUTHENTICATION_KEY: &[u8; 44] =
    b"SYSTEM\\CurrentControlSet\\Control\\Lsa\\MSV1_0\0";
pub const MSV1_0_SUBAUTHENTICATION_VALUE: &[u8; 5] = b"Auth\0";
pub const MSV1_0_CHALLENGE_LENGTH: u32 = 8;
pub const MSV1_0_USER_SESSION_KEY_LENGTH: u32 = 16;
pub const MSV1_0_LANMAN_SESSION_KEY_LENGTH: u32 = 8;
pub const MSV1_0_CLEARTEXT_PASSWORD_ALLOWED: u32 = 2;
pub const MSV1_0_UPDATE_LOGON_STATISTICS: u32 = 4;
pub const MSV1_0_RETURN_USER_PARAMETERS: u32 = 8;
pub const MSV1_0_DONT_TRY_GUEST_ACCOUNT: u32 = 16;
pub const MSV1_0_ALLOW_SERVER_TRUST_ACCOUNT: u32 = 32;
pub const MSV1_0_RETURN_PASSWORD_EXPIRY: u32 = 64;
pub const MSV1_0_USE_CLIENT_CHALLENGE: u32 = 128;
pub const MSV1_0_TRY_GUEST_ACCOUNT_ONLY: u32 = 256;
pub const MSV1_0_RETURN_PROFILE_PATH: u32 = 512;
pub const MSV1_0_TRY_SPECIFIED_DOMAIN_ONLY: u32 = 1024;
pub const MSV1_0_ALLOW_WORKSTATION_TRUST_ACCOUNT: u32 = 2048;
pub const MSV1_0_DISABLE_PERSONAL_FALLBACK: u32 = 4096;
pub const MSV1_0_ALLOW_FORCE_GUEST: u32 = 8192;
pub const MSV1_0_CLEARTEXT_PASSWORD_SUPPLIED: u32 = 16384;
pub const MSV1_0_USE_DOMAIN_FOR_ROUTING_ONLY: u32 = 32768;
pub const MSV1_0_SUBAUTHENTICATION_DLL_EX: u32 = 1048576;
pub const MSV1_0_ALLOW_MSVCHAPV2: u32 = 65536;
pub const MSV1_0_S4U2SELF: u32 = 131072;
pub const MSV1_0_CHECK_LOGONHOURS_FOR_S4U: u32 = 262144;
pub const MSV1_0_INTERNET_DOMAIN: u32 = 524288;
pub const MSV1_0_SUBAUTHENTICATION_DLL: u32 = 4278190080;
pub const MSV1_0_SUBAUTHENTICATION_DLL_SHIFT: u32 = 24;
pub const MSV1_0_MNS_LOGON: u32 = 16777216;
pub const MSV1_0_SUBAUTHENTICATION_DLL_RAS: u32 = 2;
pub const MSV1_0_SUBAUTHENTICATION_DLL_IIS: u32 = 132;
pub const MSV1_0_S4U_LOGON_FLAG_CHECK_LOGONHOURS: u32 = 2;
pub const LOGON_GUEST: u32 = 1;
pub const LOGON_NOENCRYPTION: u32 = 2;
pub const LOGON_CACHED_ACCOUNT: u32 = 4;
pub const LOGON_USED_LM_PASSWORD: u32 = 8;
pub const LOGON_EXTRA_SIDS: u32 = 32;
pub const LOGON_SUBAUTH_SESSION_KEY: u32 = 64;
pub const LOGON_SERVER_TRUST_ACCOUNT: u32 = 128;
pub const LOGON_NTLMV2_ENABLED: u32 = 256;
pub const LOGON_RESOURCE_GROUPS: u32 = 512;
pub const LOGON_PROFILE_PATH_RETURNED: u32 = 1024;
pub const LOGON_NT_V2: u32 = 2048;
pub const LOGON_LM_V2: u32 = 4096;
pub const LOGON_NTLM_V2: u32 = 8192;
pub const LOGON_OPTIMIZED: u32 = 16384;
pub const LOGON_WINLOGON: u32 = 32768;
pub const LOGON_PKINIT: u32 = 65536;
pub const LOGON_NO_OPTIMIZED: u32 = 131072;
pub const LOGON_NO_ELEVATION: u32 = 262144;
pub const LOGON_MANAGED_SERVICE: u32 = 524288;
pub const MSV1_0_SUBAUTHENTICATION_FLAGS: u32 = 4278190080;
pub const LOGON_GRACE_LOGON: u32 = 16777216;
pub const MSV1_0_OWF_PASSWORD_LENGTH: u32 = 16;
pub const MSV1_0_SHA_PASSWORD_LENGTH: u32 = 20;
pub const MSV1_0_CREDENTIAL_KEY_LENGTH: u32 = 20;
pub const MSV1_0_CRED_LM_PRESENT: u32 = 1;
pub const MSV1_0_CRED_NT_PRESENT: u32 = 2;
pub const MSV1_0_CRED_REMOVED: u32 = 4;
pub const MSV1_0_CRED_CREDKEY_PRESENT: u32 = 8;
pub const MSV1_0_CRED_SHA_PRESENT: u32 = 16;
pub const MSV1_0_CRED_VERSION: u32 = 0;
pub const MSV1_0_CRED_VERSION_V2: u32 = 2;
pub const MSV1_0_CRED_VERSION_V3: u32 = 4;
pub const MSV1_0_CRED_VERSION_IUM: u32 = 4294901761;
pub const MSV1_0_CRED_VERSION_REMOTE: u32 = 4294901762;
pub const MSV1_0_CRED_VERSION_ARSO: u32 = 4294901763;
pub const MSV1_0_CRED_VERSION_RESERVED_1: u32 = 4294967294;
pub const MSV1_0_CRED_VERSION_INVALID: u32 = 4294967295;
pub const MSV1_0_NTLM3_RESPONSE_LENGTH: u32 = 16;
pub const MSV1_0_NTLM3_OWF_LENGTH: u32 = 16;
pub const MSV1_0_MAX_NTLM3_LIFE: u32 = 129600;
pub const MSV1_0_MAX_AVL_SIZE: u32 = 64000;
pub const MSV1_0_AV_FLAG_FORCE_GUEST: u32 = 1;
pub const MSV1_0_AV_FLAG_MIC_HANDSHAKE_MESSAGES: u32 = 2;
pub const MSV1_0_AV_FLAG_UNVERIFIED_TARGET: u32 = 4;
pub const USE_PRIMARY_PASSWORD: u32 = 1;
pub const RETURN_PRIMARY_USERNAME: u32 = 2;
pub const RETURN_PRIMARY_LOGON_DOMAINNAME: u32 = 4;
pub const RETURN_NON_NT_USER_SESSION_KEY: u32 = 8;
pub const GENERATE_CLIENT_CHALLENGE: u32 = 16;
pub const GCR_NTLM3_PARMS: u32 = 32;
pub const GCR_TARGET_INFO: u32 = 64;
pub const RETURN_RESERVED_PARAMETER: u32 = 128;
pub const GCR_ALLOW_NTLM: u32 = 256;
pub const GCR_USE_OEM_SET: u32 = 512;
pub const GCR_MACHINE_CREDENTIAL: u32 = 1024;
pub const GCR_USE_OWF_PASSWORD: u32 = 2048;
pub const GCR_ALLOW_LM: u32 = 4096;
pub const GCR_ALLOW_NO_TARGET: u32 = 8192;
pub const GCR_VSM_PROTECTED_PASSWORD: u32 = 16384;
pub const FILE_CLEANUP_UNKNOWN: u32 = 0;
pub const FILE_CLEANUP_WRONG_DEVICE: u32 = 1;
pub const FILE_CLEANUP_FILE_REMAINS: u32 = 2;
pub const FILE_CLEANUP_FILE_DELETED: u32 = 4;
pub const FILE_CLEANUP_LINK_DELETED: u32 = 8;
pub const FILE_CLEANUP_STREAM_DELETED: u32 = 16;
pub const FILE_CLEANUP_POSIX_STYLE_DELETE: u32 = 32;
pub const FILE_OPLOCK_BROKEN_TO_LEVEL_2: u32 = 7;
pub const FILE_OPLOCK_BROKEN_TO_NONE: u32 = 8;
pub const FILE_OPBATCH_BREAK_UNDERWAY: u32 = 9;
pub const FILE_NOTIFY_CHANGE_FILE_NAME: u32 = 1;
pub const FILE_NOTIFY_CHANGE_DIR_NAME: u32 = 2;
pub const FILE_NOTIFY_CHANGE_NAME: u32 = 3;
pub const FILE_NOTIFY_CHANGE_ATTRIBUTES: u32 = 4;
pub const FILE_NOTIFY_CHANGE_SIZE: u32 = 8;
pub const FILE_NOTIFY_CHANGE_LAST_WRITE: u32 = 16;
pub const FILE_NOTIFY_CHANGE_LAST_ACCESS: u32 = 32;
pub const FILE_NOTIFY_CHANGE_CREATION: u32 = 64;
pub const FILE_NOTIFY_CHANGE_EA: u32 = 128;
pub const FILE_NOTIFY_CHANGE_SECURITY: u32 = 256;
pub const FILE_NOTIFY_CHANGE_STREAM_NAME: u32 = 512;
pub const FILE_NOTIFY_CHANGE_STREAM_SIZE: u32 = 1024;
pub const FILE_NOTIFY_CHANGE_STREAM_WRITE: u32 = 2048;
pub const FILE_NOTIFY_VALID_MASK: u32 = 4095;
pub const FILE_ACTION_ADDED: u32 = 1;
pub const FILE_ACTION_REMOVED: u32 = 2;
pub const FILE_ACTION_MODIFIED: u32 = 3;
pub const FILE_ACTION_RENAMED_OLD_NAME: u32 = 4;
pub const FILE_ACTION_RENAMED_NEW_NAME: u32 = 5;
pub const FILE_ACTION_ADDED_STREAM: u32 = 6;
pub const FILE_ACTION_REMOVED_STREAM: u32 = 7;
pub const FILE_ACTION_MODIFIED_STREAM: u32 = 8;
pub const FILE_ACTION_REMOVED_BY_DELETE: u32 = 9;
pub const FILE_ACTION_ID_NOT_TUNNELLED: u32 = 10;
pub const FILE_ACTION_TUNNELLED_ID_COLLISION: u32 = 11;
pub const FILE_PIPE_BYTE_STREAM_TYPE: u32 = 0;
pub const FILE_PIPE_MESSAGE_TYPE: u32 = 1;
pub const FILE_PIPE_ACCEPT_REMOTE_CLIENTS: u32 = 0;
pub const FILE_PIPE_REJECT_REMOTE_CLIENTS: u32 = 2;
pub const FILE_PIPE_TYPE_VALID_MASK: u32 = 3;
pub const FILE_PIPE_QUEUE_OPERATION: u32 = 0;
pub const FILE_PIPE_COMPLETE_OPERATION: u32 = 1;
pub const FILE_PIPE_BYTE_STREAM_MODE: u32 = 0;
pub const FILE_PIPE_MESSAGE_MODE: u32 = 1;
pub const FILE_PIPE_INBOUND: u32 = 0;
pub const FILE_PIPE_OUTBOUND: u32 = 1;
pub const FILE_PIPE_FULL_DUPLEX: u32 = 2;
pub const FILE_PIPE_DISCONNECTED_STATE: u32 = 1;
pub const FILE_PIPE_LISTENING_STATE: u32 = 2;
pub const FILE_PIPE_CONNECTED_STATE: u32 = 3;
pub const FILE_PIPE_CLOSING_STATE: u32 = 4;
pub const FILE_PIPE_CLIENT_END: u32 = 0;
pub const FILE_PIPE_SERVER_END: u32 = 1;
pub const FILE_CASE_SENSITIVE_SEARCH: u32 = 1;
pub const FILE_CASE_PRESERVED_NAMES: u32 = 2;
pub const FILE_UNICODE_ON_DISK: u32 = 4;
pub const FILE_PERSISTENT_ACLS: u32 = 8;
pub const FILE_FILE_COMPRESSION: u32 = 16;
pub const FILE_VOLUME_QUOTAS: u32 = 32;
pub const FILE_SUPPORTS_SPARSE_FILES: u32 = 64;
pub const FILE_SUPPORTS_REPARSE_POINTS: u32 = 128;
pub const FILE_SUPPORTS_REMOTE_STORAGE: u32 = 256;
pub const FILE_RETURNS_CLEANUP_RESULT_INFO: u32 = 512;
pub const FILE_SUPPORTS_POSIX_UNLINK_RENAME: u32 = 1024;
pub const FILE_SUPPORTS_BYPASS_IO: u32 = 2048;
pub const FILE_SUPPORTS_STREAM_SNAPSHOTS: u32 = 4096;
pub const FILE_SUPPORTS_CASE_SENSITIVE_DIRS: u32 = 8192;
pub const FILE_VOLUME_IS_COMPRESSED: u32 = 32768;
pub const FILE_SUPPORTS_OBJECT_IDS: u32 = 65536;
pub const FILE_SUPPORTS_ENCRYPTION: u32 = 131072;
pub const FILE_NAMED_STREAMS: u32 = 262144;
pub const FILE_READ_ONLY_VOLUME: u32 = 524288;
pub const FILE_SEQUENTIAL_WRITE_ONCE: u32 = 1048576;
pub const FILE_SUPPORTS_TRANSACTIONS: u32 = 2097152;
pub const FILE_SUPPORTS_HARD_LINKS: u32 = 4194304;
pub const FILE_SUPPORTS_EXTENDED_ATTRIBUTES: u32 = 8388608;
pub const FILE_SUPPORTS_OPEN_BY_FILE_ID: u32 = 16777216;
pub const FILE_SUPPORTS_USN_JOURNAL: u32 = 33554432;
pub const FILE_SUPPORTS_INTEGRITY_STREAMS: u32 = 67108864;
pub const FILE_SUPPORTS_BLOCK_REFCOUNTING: u32 = 134217728;
pub const FILE_SUPPORTS_SPARSE_VDL: u32 = 268435456;
pub const FILE_DAX_VOLUME: u32 = 536870912;
pub const FILE_SUPPORTS_GHOSTING: u32 = 1073741824;
pub const FILE_NEED_EA: u32 = 128;
pub const FILE_EA_TYPE_BINARY: u32 = 65534;
pub const FILE_EA_TYPE_ASCII: u32 = 65533;
pub const FILE_EA_TYPE_BITMAP: u32 = 65531;
pub const FILE_EA_TYPE_METAFILE: u32 = 65530;
pub const FILE_EA_TYPE_ICON: u32 = 65529;
pub const FILE_EA_TYPE_EA: u32 = 65518;
pub const FILE_EA_TYPE_MVMT: u32 = 65503;
pub const FILE_EA_TYPE_MVST: u32 = 65502;
pub const FILE_EA_TYPE_ASN1: u32 = 65501;
pub const FILE_EA_TYPE_FAMILY_IDS: u32 = 65281;
pub const FILE_NAME_FLAG_HARDLINK: u32 = 0;
pub const FILE_NAME_FLAG_NTFS: u32 = 1;
pub const FILE_NAME_FLAG_DOS: u32 = 2;
pub const FILE_NAME_FLAG_BOTH: u32 = 3;
pub const FILE_NAME_FLAGS_UNSPECIFIED: u32 = 128;
pub const FILE_ID_GLOBAL_TX_DIR_INFO_FLAG_WRITELOCKED: u32 = 1;
pub const FILE_ID_GLOBAL_TX_DIR_INFO_FLAG_VISIBLE_TO_TX: u32 = 2;
pub const FILE_ID_GLOBAL_TX_DIR_INFO_FLAG_VISIBLE_OUTSIDE_TX: u32 = 4;
pub const ANSI_DOS_STAR: u8 = 60u8;
pub const ANSI_DOS_QM: u8 = 62u8;
pub const ANSI_DOS_DOT: u8 = 34u8;
pub const DOS_STAR: u8 = 60u8;
pub const DOS_QM: u8 = 62u8;
pub const DOS_DOT: u8 = 34u8;
pub const NO_8DOT3_NAME_PRESENT: u32 = 1;
pub const REMOVED_8DOT3_NAME: u32 = 2;
pub const LX_FILE_METADATA_HAS_UID: u32 = 1;
pub const LX_FILE_METADATA_HAS_GID: u32 = 2;
pub const LX_FILE_METADATA_HAS_MODE: u32 = 4;
pub const LX_FILE_METADATA_HAS_DEVICE_ID: u32 = 8;
pub const LX_FILE_CASE_SENSITIVE_DIR: u32 = 16;
pub const FILE_CS_FLAG_CASE_SENSITIVE_DIR: u32 = 1;
pub const FILE_LINK_REPLACE_IF_EXISTS: u32 = 1;
pub const FILE_LINK_POSIX_SEMANTICS: u32 = 2;
pub const FILE_LINK_SUPPRESS_STORAGE_RESERVE_INHERITANCE: u32 = 8;
pub const FILE_LINK_NO_INCREASE_AVAILABLE_SPACE: u32 = 16;
pub const FILE_LINK_NO_DECREASE_AVAILABLE_SPACE: u32 = 32;
pub const FILE_LINK_PRESERVE_AVAILABLE_SPACE: u32 = 48;
pub const FILE_LINK_IGNORE_READONLY_ATTRIBUTE: u32 = 64;
pub const FILE_LINK_FORCE_RESIZE_TARGET_SR: u32 = 128;
pub const FILE_LINK_FORCE_RESIZE_SOURCE_SR: u32 = 256;
pub const FILE_LINK_FORCE_RESIZE_SR: u32 = 384;
pub const FILE_RENAME_REPLACE_IF_EXISTS: u32 = 1;
pub const FILE_RENAME_POSIX_SEMANTICS: u32 = 2;
pub const FILE_RENAME_SUPPRESS_PIN_STATE_INHERITANCE: u32 = 4;
pub const FILE_RENAME_SUPPRESS_STORAGE_RESERVE_INHERITANCE: u32 = 8;
pub const FILE_RENAME_NO_INCREASE_AVAILABLE_SPACE: u32 = 16;
pub const FILE_RENAME_NO_DECREASE_AVAILABLE_SPACE: u32 = 32;
pub const FILE_RENAME_PRESERVE_AVAILABLE_SPACE: u32 = 48;
pub const FILE_RENAME_IGNORE_READONLY_ATTRIBUTE: u32 = 64;
pub const FILE_RENAME_FORCE_RESIZE_TARGET_SR: u32 = 128;
pub const FILE_RENAME_FORCE_RESIZE_SOURCE_SR: u32 = 256;
pub const FILE_RENAME_FORCE_RESIZE_SR: u32 = 384;
pub const REMOTE_PROTOCOL_FLAG_LOOPBACK: u32 = 1;
pub const REMOTE_PROTOCOL_FLAG_OFFLINE: u32 = 2;
pub const REMOTE_PROTOCOL_FLAG_PERSISTENT_HANDLE: u32 = 4;
pub const REMOTE_PROTOCOL_FLAG_PRIVACY: u32 = 8;
pub const REMOTE_PROTOCOL_FLAG_INTEGRITY: u32 = 16;
pub const REMOTE_PROTOCOL_FLAG_MUTUAL_AUTH: u32 = 32;
pub const RPI_SMB2_SHARECAP_TIMEWARP: u32 = 2;
pub const RPI_SMB2_SHARECAP_DFS: u32 = 8;
pub const RPI_SMB2_SHARECAP_CONTINUOUS_AVAILABILITY: u32 = 16;
pub const RPI_SMB2_SHARECAP_SCALEOUT: u32 = 32;
pub const RPI_SMB2_SHARECAP_CLUSTER: u32 = 64;
pub const RPI_SMB2_SHARECAP_ENCRYPTED: u32 = 128;
pub const RPI_SMB2_SHARECAP_ACCESS_BASED_DIRECTORY_ENUM: u32 = 256;
pub const RPI_SMB2_SHARECAP_IDENTITY_REMOTING: u32 = 512;
pub const RPI_SMB2_SHARECAP_ASYMMETRIC_SCALEOUT: u32 = 1024;
pub const RPI_SMB2_SHAREFLAG_ENCRYPT_DATA: u32 = 1;
pub const RPI_SMB2_SHAREFLAG_COMPRESS_DATA: u32 = 2;
pub const RPI_SMB2_SHARETYPE_DISK: u32 = 0;
pub const RPI_SMB2_SHARETYPE_PIPE: u32 = 1;
pub const RPI_SMB2_SHARETYPE_PRINT: u32 = 2;
pub const RPI_SMB2_SERVERCAP_DFS: u32 = 1;
pub const RPI_SMB2_SERVERCAP_LEASING: u32 = 2;
pub const RPI_SMB2_SERVERCAP_LARGEMTU: u32 = 4;
pub const RPI_SMB2_SERVERCAP_MULTICHANNEL: u32 = 8;
pub const RPI_SMB2_SERVERCAP_PERSISTENT_HANDLES: u32 = 16;
pub const RPI_SMB2_SERVERCAP_DIRECTORY_LEASING: u32 = 32;
pub const RPI_SMB2_SERVERCAP_ENCRYPTION_AWARE: u32 = 64;
pub const FILE_VC_QUOTA_NONE: u32 = 0;
pub const FILE_VC_QUOTA_TRACK: u32 = 1;
pub const FILE_VC_QUOTA_ENFORCE: u32 = 2;
pub const FILE_VC_QUOTA_MASK: u32 = 3;
pub const FILE_VC_CONTENT_INDEX_DISABLED: u32 = 8;
pub const FILE_VC_LOG_QUOTA_THRESHOLD: u32 = 16;
pub const FILE_VC_LOG_QUOTA_LIMIT: u32 = 32;
pub const FILE_VC_LOG_VOLUME_THRESHOLD: u32 = 64;
pub const FILE_VC_LOG_VOLUME_LIMIT: u32 = 128;
pub const FILE_VC_QUOTAS_INCOMPLETE: u32 = 256;
pub const FILE_VC_QUOTAS_REBUILDING: u32 = 512;
pub const FILE_VC_VALID_MASK: u32 = 1023;
pub const FLAGS_END_OF_FILE_INFO_EX_EXTEND_PAGING: u32 = 1;
pub const FLAGS_END_OF_FILE_INFO_EX_NO_EXTRA_PAGING_EXTEND: u32 = 2;
pub const FLAGS_END_OF_FILE_INFO_EX_TIME_CONSTRAINED: u32 = 4;
pub const FLAGS_DELAY_REASONS_LOG_FILE_FULL: u32 = 1;
pub const FLAGS_DELAY_REASONS_BITMAP_SCANNED: u32 = 2;
pub const GET_VOLUME_BITMAP_FLAG_MASK_METADATA: u32 = 1;
pub const FLAG_USN_TRACK_MODIFIED_RANGES_ENABLE: u32 = 1;
pub const USN_PAGE_SIZE: u32 = 4096;
pub const USN_REASON_DATA_OVERWRITE: u32 = 1;
pub const USN_REASON_DATA_EXTEND: u32 = 2;
pub const USN_REASON_DATA_TRUNCATION: u32 = 4;
pub const USN_REASON_NAMED_DATA_OVERWRITE: u32 = 16;
pub const USN_REASON_NAMED_DATA_EXTEND: u32 = 32;
pub const USN_REASON_NAMED_DATA_TRUNCATION: u32 = 64;
pub const USN_REASON_FILE_CREATE: u32 = 256;
pub const USN_REASON_FILE_DELETE: u32 = 512;
pub const USN_REASON_EA_CHANGE: u32 = 1024;
pub const USN_REASON_SECURITY_CHANGE: u32 = 2048;
pub const USN_REASON_RENAME_OLD_NAME: u32 = 4096;
pub const USN_REASON_RENAME_NEW_NAME: u32 = 8192;
pub const USN_REASON_INDEXABLE_CHANGE: u32 = 16384;
pub const USN_REASON_BASIC_INFO_CHANGE: u32 = 32768;
pub const USN_REASON_HARD_LINK_CHANGE: u32 = 65536;
pub const USN_REASON_COMPRESSION_CHANGE: u32 = 131072;
pub const USN_REASON_ENCRYPTION_CHANGE: u32 = 262144;
pub const USN_REASON_OBJECT_ID_CHANGE: u32 = 524288;
pub const USN_REASON_REPARSE_POINT_CHANGE: u32 = 1048576;
pub const USN_REASON_STREAM_CHANGE: u32 = 2097152;
pub const USN_REASON_TRANSACTED_CHANGE: u32 = 4194304;
pub const USN_REASON_INTEGRITY_CHANGE: u32 = 8388608;
pub const USN_REASON_DESIRED_STORAGE_CLASS_CHANGE: u32 = 16777216;
pub const USN_REASON_CLOSE: u32 = 2147483648;
pub const USN_DELETE_FLAG_DELETE: u32 = 1;
pub const USN_DELETE_FLAG_NOTIFY: u32 = 2;
pub const USN_DELETE_VALID_FLAGS: u32 = 3;
pub const USN_SOURCE_DATA_MANAGEMENT: u32 = 1;
pub const USN_SOURCE_AUXILIARY_DATA: u32 = 2;
pub const USN_SOURCE_REPLICATION_MANAGEMENT: u32 = 4;
pub const USN_SOURCE_CLIENT_REPLICATION_MANAGEMENT: u32 = 8;
pub const USN_SOURCE_VALID_FLAGS: u32 = 15;
pub const MARK_HANDLE_PROTECT_CLUSTERS: u32 = 1;
pub const MARK_HANDLE_TXF_SYSTEM_LOG: u32 = 4;
pub const MARK_HANDLE_NOT_TXF_SYSTEM_LOG: u32 = 8;
pub const MARK_HANDLE_REALTIME: u32 = 32;
pub const MARK_HANDLE_NOT_REALTIME: u32 = 64;
pub const MARK_HANDLE_CLOUD_SYNC: u32 = 2048;
pub const MARK_HANDLE_READ_COPY: u32 = 128;
pub const MARK_HANDLE_NOT_READ_COPY: u32 = 256;
pub const MARK_HANDLE_FILTER_METADATA: u32 = 512;
pub const MARK_HANDLE_RETURN_PURGE_FAILURE: u32 = 1024;
pub const MARK_HANDLE_DISABLE_FILE_METADATA_OPTIMIZATION: u32 = 4096;
pub const MARK_HANDLE_ENABLE_USN_SOURCE_ON_PAGING_IO: u32 = 8192;
pub const MARK_HANDLE_SKIP_COHERENCY_SYNC_DISALLOW_WRITES: u32 = 16384;
pub const MARK_HANDLE_SUPPRESS_VOLUME_OPEN_FLUSH: u32 = 32768;
pub const MARK_HANDLE_ENABLE_CPU_CACHE: u32 = 268435456;
pub const VOLUME_IS_DIRTY: u32 = 1;
pub const VOLUME_UPGRADE_SCHEDULED: u32 = 2;
pub const VOLUME_SESSION_OPEN: u32 = 4;
pub const FILE_PREFETCH_TYPE_FOR_CREATE: u32 = 1;
pub const FILE_PREFETCH_TYPE_FOR_DIRENUM: u32 = 2;
pub const FILE_PREFETCH_TYPE_FOR_CREATE_EX: u32 = 3;
pub const FILE_PREFETCH_TYPE_FOR_DIRENUM_EX: u32 = 4;
pub const FILE_PREFETCH_TYPE_MAX: u32 = 4;
pub const FILESYSTEM_STATISTICS_TYPE_NTFS: u32 = 1;
pub const FILESYSTEM_STATISTICS_TYPE_FAT: u32 = 2;
pub const FILESYSTEM_STATISTICS_TYPE_EXFAT: u32 = 3;
pub const FILESYSTEM_STATISTICS_TYPE_REFS: u32 = 4;
pub const FILE_ZERO_DATA_INFORMATION_FLAG_PRESERVE_CACHED_DATA: u32 = 1;
pub const FILE_SET_ENCRYPTION: u32 = 1;
pub const FILE_CLEAR_ENCRYPTION: u32 = 2;
pub const STREAM_SET_ENCRYPTION: u32 = 3;
pub const STREAM_CLEAR_ENCRYPTION: u32 = 4;
pub const MAXIMUM_ENCRYPTION_VALUE: u32 = 4;
pub const ENCRYPTION_FORMAT_DEFAULT: u32 = 1;
pub const ENCRYPTED_DATA_INFO_SPARSE_FILE: u32 = 1;
pub const COPYFILE_SIS_LINK: u32 = 1;
pub const COPYFILE_SIS_REPLACE: u32 = 2;
pub const COPYFILE_SIS_FLAGS: u32 = 3;
pub const SET_REPAIR_ENABLED: u32 = 1;
pub const SET_REPAIR_WARN_ABOUT_DATA_LOSS: u32 = 8;
pub const SET_REPAIR_DISABLED_AND_BUGCHECK_ON_CORRUPT: u32 = 16;
pub const SET_REPAIR_VALID_MASK: u32 = 25;
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_IN_USE: u32 = 1;
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_REUSED: u32 = 2;
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_EXIST: u32 = 4;
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_BASE_RECORD: u32 = 8;
pub const FILE_INITIATE_REPAIR_HINT1_SYSTEM_FILE: u32 = 16;
pub const FILE_INITIATE_REPAIR_HINT1_NOT_IMPLEMENTED: u32 = 32;
pub const FILE_INITIATE_REPAIR_HINT1_UNABLE_TO_REPAIR: u32 = 64;
pub const FILE_INITIATE_REPAIR_HINT1_REPAIR_DISABLED: u32 = 128;
pub const FILE_INITIATE_REPAIR_HINT1_RECURSIVELY_CORRUPTED: u32 = 256;
pub const FILE_INITIATE_REPAIR_HINT1_ORPHAN_GENERATED: u32 = 512;
pub const FILE_INITIATE_REPAIR_HINT1_REPAIRED: u32 = 1024;
pub const FILE_INITIATE_REPAIR_HINT1_NOTHING_WRONG: u32 = 2048;
pub const FILE_INITIATE_REPAIR_HINT1_ATTRIBUTE_NOT_FOUND: u32 = 4096;
pub const FILE_INITIATE_REPAIR_HINT1_POTENTIAL_CROSSLINK: u32 = 8192;
pub const FILE_INITIATE_REPAIR_HINT1_STALE_INFORMATION: u32 = 16384;
pub const FILE_INITIATE_REPAIR_HINT1_CLUSTERS_ALREADY_IN_USE: u32 = 32768;
pub const FILE_INITIATE_REPAIR_HINT1_LCN_NOT_EXIST: u32 = 65536;
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_RUN_LENGTH: u32 = 131072;
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_ORPHAN: u32 = 262144;
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_IS_BASE_RECORD: u32 = 524288;
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_ARRAY_LENGTH_COUNT: u32 = 1048576;
pub const FILE_INITIATE_REPAIR_HINT1_SID_VALID: u32 = 2097152;
pub const FILE_INITIATE_REPAIR_HINT1_SID_MISMATCH: u32 = 4194304;
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_PARENT: u32 = 8388608;
pub const FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_IN_USE: u32 = 16777216;
pub const FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_REUSED: u32 = 33554432;
pub const FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_EXIST: u32 = 67108864;
pub const FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_BASE_RECORD: u32 = 134217728;
pub const FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_INDEX: u32 = 268435456;
pub const FILE_INITIATE_REPAIR_HINT1_VALID_INDEX_ENTRY: u32 = 536870912;
pub const FILE_INITIATE_REPAIR_HINT1_OUT_OF_GENERIC_NAMES: u32 = 1073741824;
pub const FILE_INITIATE_REPAIR_HINT1_OUT_OF_RESOURCE: u32 = 2147483648;
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_LCN: u64 = 4294967296;
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_VCN: u64 = 8589934592;
pub const FILE_INITIATE_REPAIR_HINT1_NAME_CONFLICT: u64 = 17179869184;
pub const FILE_INITIATE_REPAIR_HINT1_ORPHAN: u64 = 34359738368;
pub const FILE_INITIATE_REPAIR_HINT1_ATTRIBUTE_TOO_SMALL: u64 = 68719476736;
pub const FILE_INITIATE_REPAIR_HINT1_ATTRIBUTE_NON_RESIDENT: u64 = 137438953472;
pub const FILE_INITIATE_REPAIR_HINT1_DENY_DEFRAG: u64 = 274877906944;
pub const FILE_INITIATE_REPAIR_HINT1_PREVIOUS_PARENT_STILL_VALID: u64 = 549755813888;
pub const FILE_INITIATE_REPAIR_HINT1_INDEX_ENTRY_MISMATCH: u64 = 1099511627776;
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_ORPHAN_RECOVERY_NAME: u64 = 2199023255552;
pub const FILE_INITIATE_REPAIR_HINT1_MULTIPLE_FILE_NAME_ATTRIBUTES: u64 = 4398046511104;
pub const TXFS_RM_FLAG_LOGGING_MODE: u32 = 1;
pub const TXFS_RM_FLAG_RENAME_RM: u32 = 2;
pub const TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MAX: u32 = 4;
pub const TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MIN: u32 = 8;
pub const TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS: u32 = 16;
pub const TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT: u32 = 32;
pub const TXFS_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE: u32 = 64;
pub const TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX: u32 = 128;
pub const TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN: u32 = 256;
pub const TXFS_RM_FLAG_GROW_LOG: u32 = 1024;
pub const TXFS_RM_FLAG_SHRINK_LOG: u32 = 2048;
pub const TXFS_RM_FLAG_ENFORCE_MINIMUM_SIZE: u32 = 4096;
pub const TXFS_RM_FLAG_PRESERVE_CHANGES: u32 = 8192;
pub const TXFS_RM_FLAG_RESET_RM_AT_NEXT_START: u32 = 16384;
pub const TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START: u32 = 32768;
pub const TXFS_RM_FLAG_PREFER_CONSISTENCY: u32 = 65536;
pub const TXFS_RM_FLAG_PREFER_AVAILABILITY: u32 = 131072;
pub const TXFS_LOGGING_MODE_SIMPLE: u32 = 1;
pub const TXFS_LOGGING_MODE_FULL: u32 = 2;
pub const TXFS_TRANSACTION_STATE_NONE: u32 = 0;
pub const TXFS_TRANSACTION_STATE_ACTIVE: u32 = 1;
pub const TXFS_TRANSACTION_STATE_PREPARED: u32 = 2;
pub const TXFS_TRANSACTION_STATE_NOTACTIVE: u32 = 3;
pub const TXFS_MODIFY_RM_VALID_FLAGS: u32 = 261631;
pub const TXFS_RM_STATE_NOT_STARTED: u32 = 0;
pub const TXFS_RM_STATE_STARTING: u32 = 1;
pub const TXFS_RM_STATE_ACTIVE: u32 = 2;
pub const TXFS_RM_STATE_SHUTTING_DOWN: u32 = 3;
pub const TXFS_QUERY_RM_INFORMATION_VALID_FLAGS: u32 = 246192;
pub const TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_REDO_LSN: u32 = 1;
pub const TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_VIRTUAL_CLOCK: u32 = 2;
pub const TXFS_ROLLFORWARD_REDO_VALID_FLAGS: u32 = 3;
pub const TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MAX: u32 = 1;
pub const TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MIN: u32 = 2;
pub const TXFS_START_RM_FLAG_LOG_CONTAINER_SIZE: u32 = 4;
pub const TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS: u32 = 8;
pub const TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT: u32 = 16;
pub const TXFS_START_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE: u32 = 32;
pub const TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX: u32 = 64;
pub const TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN: u32 = 128;
pub const TXFS_START_RM_FLAG_RECOVER_BEST_EFFORT: u32 = 512;
pub const TXFS_START_RM_FLAG_LOGGING_MODE: u32 = 1024;
pub const TXFS_START_RM_FLAG_PRESERVE_CHANGES: u32 = 2048;
pub const TXFS_START_RM_FLAG_PREFER_CONSISTENCY: u32 = 4096;
pub const TXFS_START_RM_FLAG_PREFER_AVAILABILITY: u32 = 8192;
pub const TXFS_START_RM_VALID_FLAGS: u32 = 15999;
pub const TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY_FLAG_CREATED: u32 = 1;
pub const TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY_FLAG_DELETED: u32 = 2;
pub const TXFS_TRANSACTED_VERSION_NONTRANSACTED: u32 = 4294967294;
pub const TXFS_TRANSACTED_VERSION_UNCOMMITTED: u32 = 4294967295;
pub const TXFS_SAVEPOINT_SET: u32 = 1;
pub const TXFS_SAVEPOINT_ROLLBACK: u32 = 2;
pub const TXFS_SAVEPOINT_CLEAR: u32 = 4;
pub const TXFS_SAVEPOINT_CLEAR_ALL: u32 = 16;
pub const PERSISTENT_VOLUME_STATE_SHORT_NAME_CREATION_DISABLED: u32 = 1;
pub const PERSISTENT_VOLUME_STATE_VOLUME_SCRUB_DISABLED: u32 = 2;
pub const PERSISTENT_VOLUME_STATE_GLOBAL_METADATA_NO_SEEK_PENALTY: u32 = 4;
pub const PERSISTENT_VOLUME_STATE_LOCAL_METADATA_NO_SEEK_PENALTY: u32 = 8;
pub const PERSISTENT_VOLUME_STATE_NO_HEAT_GATHERING: u32 = 16;
pub const PERSISTENT_VOLUME_STATE_CONTAINS_BACKING_WIM: u32 = 32;
pub const PERSISTENT_VOLUME_STATE_BACKED_BY_WIM: u32 = 64;
pub const PERSISTENT_VOLUME_STATE_NO_WRITE_AUTO_TIERING: u32 = 128;
pub const PERSISTENT_VOLUME_STATE_TXF_DISABLED: u32 = 256;
pub const PERSISTENT_VOLUME_STATE_REALLOCATE_ALL_DATA_WRITES: u32 = 512;
pub const PERSISTENT_VOLUME_STATE_CHKDSK_RAN_ONCE: u32 = 1024;
pub const PERSISTENT_VOLUME_STATE_MODIFIED_BY_CHKDSK: u32 = 2048;
pub const PERSISTENT_VOLUME_STATE_DAX_FORMATTED: u32 = 4096;
pub const OPLOCK_LEVEL_CACHE_READ: u32 = 1;
pub const OPLOCK_LEVEL_CACHE_HANDLE: u32 = 2;
pub const OPLOCK_LEVEL_CACHE_WRITE: u32 = 4;
pub const REQUEST_OPLOCK_INPUT_FLAG_REQUEST: u32 = 1;
pub const REQUEST_OPLOCK_INPUT_FLAG_ACK: u32 = 2;
pub const REQUEST_OPLOCK_INPUT_FLAG_COMPLETE_ACK_ON_CLOSE: u32 = 4;
pub const REQUEST_OPLOCK_CURRENT_VERSION: u32 = 1;
pub const REQUEST_OPLOCK_OUTPUT_FLAG_ACK_REQUIRED: u32 = 1;
pub const REQUEST_OPLOCK_OUTPUT_FLAG_MODES_PROVIDED: u32 = 2;
pub const REQUEST_OPLOCK_OUTPUT_FLAG_WRITABLE_SECTION_PRESENT: u32 = 4;
pub const QUERY_DEPENDENT_VOLUME_REQUEST_FLAG_HOST_VOLUMES: u32 = 1;
pub const QUERY_DEPENDENT_VOLUME_REQUEST_FLAG_GUEST_VOLUMES: u32 = 2;
pub const SD_GLOBAL_CHANGE_TYPE_MACHINE_SID: u32 = 1;
pub const SD_GLOBAL_CHANGE_TYPE_QUERY_STATS: u32 = 65536;
pub const SD_GLOBAL_CHANGE_TYPE_ENUM_SDS: u32 = 131072;
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_PAGE_FILE: u32 = 1;
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_DENY_DEFRAG_SET: u32 = 2;
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_FS_SYSTEM_FILE: u32 = 4;
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_TXF_SYSTEM_FILE: u32 = 8;
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_MASK: u32 = 4278190080;
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_DATA: u32 = 16777216;
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_INDEX: u32 = 33554432;
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_SYSTEM: u32 = 50331648;
pub const FILE_TYPE_NOTIFICATION_FLAG_USAGE_BEGIN: u32 = 1;
pub const FILE_TYPE_NOTIFICATION_FLAG_USAGE_END: u32 = 2;
pub const CSV_MGMTLOCK_CHECK_VOLUME_REDIRECTED: u32 = 1;
pub const CSV_INVALID_DEVICE_NUMBER: u32 = 4294967295;
pub const CSV_QUERY_MDS_PATH_V2_VERSION_1: u32 = 1;
pub const CSV_QUERY_MDS_PATH_FLAG_STORAGE_ON_THIS_NODE_IS_CONNECTED: u32 = 1;
pub const CSV_QUERY_MDS_PATH_FLAG_CSV_DIRECT_IO_ENABLED: u32 = 2;
pub const CSV_QUERY_MDS_PATH_FLAG_SMB_BYPASS_CSV_ENABLED: u32 = 4;
pub const QUERY_FILE_LAYOUT_RESTART: u32 = 1;
pub const QUERY_FILE_LAYOUT_INCLUDE_NAMES: u32 = 2;
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAMS: u32 = 4;
pub const QUERY_FILE_LAYOUT_INCLUDE_EXTENTS: u32 = 8;
pub const QUERY_FILE_LAYOUT_INCLUDE_EXTRA_INFO: u32 = 16;
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAMS_WITH_NO_CLUSTERS_ALLOCATED: u32 = 32;
pub const QUERY_FILE_LAYOUT_INCLUDE_FULL_PATH_IN_NAMES: u32 = 64;
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION: u32 = 128;
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_DSC_ATTRIBUTE: u32 = 256;
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_TXF_ATTRIBUTE: u32 = 512;
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_EFS_ATTRIBUTE: u32 = 1024;
pub const QUERY_FILE_LAYOUT_INCLUDE_ONLY_FILES_WITH_SPECIFIC_ATTRIBUTES: u32 = 2048;
pub const QUERY_FILE_LAYOUT_INCLUDE_FILES_WITH_DSC_ATTRIBUTE: u32 = 4096;
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_DATA_ATTRIBUTE: u32 = 8192;
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_REPARSE_ATTRIBUTE: u32 = 16384;
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_EA_ATTRIBUTE: u32 = 32768;
pub const QUERY_FILE_LAYOUT_SINGLE_INSTANCED: u32 = 1;
pub const FILE_LAYOUT_NAME_ENTRY_PRIMARY: u32 = 1;
pub const FILE_LAYOUT_NAME_ENTRY_DOS: u32 = 2;
pub const STREAM_LAYOUT_ENTRY_IMMOVABLE: u32 = 1;
pub const STREAM_LAYOUT_ENTRY_PINNED: u32 = 2;
pub const STREAM_LAYOUT_ENTRY_RESIDENT: u32 = 4;
pub const STREAM_LAYOUT_ENTRY_NO_CLUSTERS_ALLOCATED: u32 = 8;
pub const STREAM_LAYOUT_ENTRY_HAS_INFORMATION: u32 = 16;
pub const STREAM_EXTENT_ENTRY_AS_RETRIEVAL_POINTERS: u32 = 1;
pub const STREAM_EXTENT_ENTRY_ALL_EXTENTS: u32 = 2;
pub const CHECKSUM_TYPE_NONE: u32 = 0;
pub const CHECKSUM_TYPE_CRC32: u32 = 1;
pub const CHECKSUM_TYPE_CRC64: u32 = 2;
pub const CHECKSUM_TYPE_ECC: u32 = 3;
pub const CHECKSUM_TYPE_SHA256: u32 = 4;
pub const CHECKSUM_TYPE_FIRST_UNUSED_TYPE: u32 = 5;
pub const FSCTL_INTEGRITY_FLAG_CHECKSUM_ENFORCEMENT_OFF: u32 = 1;
pub const OFFLOAD_READ_FLAG_ALL_ZERO_BEYOND_CURRENT_RANGE: u32 = 1;
pub const SET_PURGE_FAILURE_MODE_ENABLED: u32 = 1;
pub const SET_PURGE_FAILURE_MODE_DISABLED: u32 = 2;
pub const FILE_REGION_USAGE_VALID_CACHED_DATA: u32 = 1;
pub const FILE_REGION_USAGE_VALID_NONCACHED_DATA: u32 = 2;
pub const FILE_REGION_USAGE_OTHER_PAGE_ALIGNMENT: u32 = 4;
pub const FILE_REGION_USAGE_LARGE_PAGE_ALIGNMENT: u32 = 8;
pub const FILE_REGION_USAGE_HUGE_PAGE_ALIGNMENT: u32 = 16;
pub const FILE_REGION_USAGE_QUERY_ALIGNMENT: u32 = 24;
pub const VALID_WRITE_USN_REASON_MASK: u32 = 2147483649;
pub const FILE_STORAGE_TIER_NAME_LENGTH: u32 = 256;
pub const FILE_STORAGE_TIER_DESCRIPTION_LENGTH: u32 = 512;
pub const FILE_STORAGE_TIER_FLAG_NO_SEEK_PENALTY: u32 = 131072;
pub const FILE_STORAGE_TIER_FLAG_WRITE_BACK_CACHE: u32 = 2097152;
pub const FILE_STORAGE_TIER_FLAG_READ_CACHE: u32 = 4194304;
pub const FILE_STORAGE_TIER_FLAG_PARITY: u32 = 8388608;
pub const FILE_STORAGE_TIER_FLAG_SMR: u32 = 16777216;
pub const QUERY_STORAGE_CLASSES_FLAGS_MEASURE_WRITE: u32 = 2147483648;
pub const QUERY_STORAGE_CLASSES_FLAGS_MEASURE_READ: u32 = 1073741824;
pub const QUERY_STORAGE_CLASSES_FLAGS_NO_DEFRAG_VOLUME: u32 = 536870912;
pub const QUERY_FILE_LAYOUT_REPARSE_DATA_INVALID: u32 = 1;
pub const QUERY_FILE_LAYOUT_REPARSE_TAG_INVALID: u32 = 2;
pub const DUPLICATE_EXTENTS_DATA_EX_SOURCE_ATOMIC: u32 = 1;
pub const DUPLICATE_EXTENTS_DATA_EX_ASYNC: u32 = 2;
pub const REFS_SMR_VOLUME_INFO_OUTPUT_VERSION_V0: u32 = 0;
pub const REFS_SMR_VOLUME_INFO_OUTPUT_VERSION_V1: u32 = 1;
pub const REFS_SMR_VOLUME_GC_PARAMETERS_VERSION_V1: u32 = 1;
pub const STREAMS_INVALID_ID: u32 = 0;
pub const STREAMS_MAX_ID: u32 = 65535;
pub const STREAMS_ASSOCIATE_ID_CLEAR: u32 = 1;
pub const STREAMS_ASSOCIATE_ID_SET: u32 = 2;
pub const DAX_ALLOC_ALIGNMENT_FLAG_MANDATORY: u32 = 1;
pub const DAX_ALLOC_ALIGNMENT_FLAG_FALLBACK_SPECIFIED: u32 = 2;
pub const WOF_CURRENT_VERSION: u32 = 1;
pub const WOF_PROVIDER_WIM: u32 = 1;
pub const WOF_PROVIDER_FILE: u32 = 2;
pub const WOF_PROVIDER_CLOUD: u32 = 3;
pub const WIM_PROVIDER_HASH_SIZE: u32 = 20;
pub const WIM_PROVIDER_CURRENT_VERSION: u32 = 1;
pub const WIM_PROVIDER_EXTERNAL_FLAG_NOT_ACTIVE: u32 = 1;
pub const WIM_PROVIDER_EXTERNAL_FLAG_SUSPENDED: u32 = 2;
pub const WIM_BOOT_OS_WIM: u32 = 1;
pub const WIM_BOOT_NOT_OS_WIM: u32 = 0;
pub const FILE_PROVIDER_CURRENT_VERSION: u32 = 1;
pub const FILE_PROVIDER_SINGLE_FILE: u32 = 1;
pub const FILE_PROVIDER_COMPRESSION_XPRESS4K: u32 = 0;
pub const FILE_PROVIDER_COMPRESSION_LZX: u32 = 1;
pub const FILE_PROVIDER_COMPRESSION_XPRESS8K: u32 = 2;
pub const FILE_PROVIDER_COMPRESSION_XPRESS16K: u32 = 3;
pub const FILE_PROVIDER_COMPRESSION_MAXIMUM: u32 = 4;
pub const FILE_PROVIDER_FLAG_COMPRESS_ON_WRITE: u32 = 1;
pub const CONTAINER_VOLUME_STATE_HOSTING_CONTAINER: u32 = 1;
pub const CONTAINER_ROOT_INFO_FLAG_SCRATCH_ROOT: u32 = 1;
pub const CONTAINER_ROOT_INFO_FLAG_LAYER_ROOT: u32 = 2;
pub const CONTAINER_ROOT_INFO_FLAG_VIRTUALIZATION_ROOT: u32 = 4;
pub const CONTAINER_ROOT_INFO_FLAG_VIRTUALIZATION_TARGET_ROOT: u32 = 8;
pub const CONTAINER_ROOT_INFO_FLAG_VIRTUALIZATION_EXCEPTION_ROOT: u32 = 16;
pub const CONTAINER_ROOT_INFO_FLAG_BIND_ROOT: u32 = 32;
pub const CONTAINER_ROOT_INFO_FLAG_BIND_TARGET_ROOT: u32 = 64;
pub const CONTAINER_ROOT_INFO_FLAG_BIND_EXCEPTION_ROOT: u32 = 128;
pub const CONTAINER_ROOT_INFO_FLAG_BIND_DO_NOT_MAP_NAME: u32 = 256;
pub const CONTAINER_ROOT_INFO_FLAG_UNION_LAYER_ROOT: u32 = 512;
pub const CONTAINER_ROOT_INFO_VALID_FLAGS: u32 = 1023;
pub const PROJFS_PROTOCOL_VERSION: u32 = 3;
pub const SYMLINK_FLAG_RELATIVE: u32 = 1;
pub const SYMLINK_DIRECTORY: u32 = 2147483648;
pub const SYMLINK_FILE: u32 = 1073741824;
pub const SYMLINK_RESERVED_MASK: u32 = 4026531840;
pub const MAXIMUM_REPARSE_DATA_BUFFER_SIZE: u32 = 16384;
pub const IO_REPARSE_TAG_RESERVED_ZERO: u32 = 0;
pub const IO_REPARSE_TAG_RESERVED_ONE: u32 = 1;
pub const IO_REPARSE_TAG_RESERVED_TWO: u32 = 2;
pub const IO_REPARSE_TAG_RESERVED_RANGE: u32 = 2;
pub const IO_REPARSE_TAG_VALID_VALUES: u32 = 4026597375;
pub const IO_REPARSE_TAG_RESERVED_INVALID: u32 = 3221258240;
pub const IO_REPARSE_TAG_MOUNT_POINT: u32 = 2684354563;
pub const IO_REPARSE_TAG_HSM: u32 = 3221225476;
pub const IO_REPARSE_TAG_DRIVE_EXTENDER: u32 = 2147483653;
pub const IO_REPARSE_TAG_HSM2: u32 = 2147483654;
pub const IO_REPARSE_TAG_SIS: u32 = 2147483655;
pub const IO_REPARSE_TAG_WIM: u32 = 2147483656;
pub const IO_REPARSE_TAG_CSV: u32 = 2147483657;
pub const IO_REPARSE_TAG_DFS: u32 = 2147483658;
pub const IO_REPARSE_TAG_FILTER_MANAGER: u32 = 2147483659;
pub const IO_REPARSE_TAG_SYMLINK: u32 = 2684354572;
pub const IO_REPARSE_TAG_IIS_CACHE: u32 = 2684354576;
pub const IO_REPARSE_TAG_DFSR: u32 = 2147483666;
pub const IO_REPARSE_TAG_DEDUP: u32 = 2147483667;
pub const IO_REPARSE_TAG_APPXSTRM: u32 = 3221225492;
pub const IO_REPARSE_TAG_NFS: u32 = 2147483668;
pub const IO_REPARSE_TAG_FILE_PLACEHOLDER: u32 = 2147483669;
pub const IO_REPARSE_TAG_DFM: u32 = 2147483670;
pub const IO_REPARSE_TAG_WOF: u32 = 2147483671;
pub const IO_REPARSE_TAG_WCI: u32 = 2147483672;
pub const IO_REPARSE_TAG_WCI_1: u32 = 2415923224;
pub const IO_REPARSE_TAG_GLOBAL_REPARSE: u32 = 2684354585;
pub const IO_REPARSE_TAG_CLOUD: u32 = 2415919130;
pub const IO_REPARSE_TAG_CLOUD_1: u32 = 2415923226;
pub const IO_REPARSE_TAG_CLOUD_2: u32 = 2415927322;
pub const IO_REPARSE_TAG_CLOUD_3: u32 = 2415931418;
pub const IO_REPARSE_TAG_CLOUD_4: u32 = 2415935514;
pub const IO_REPARSE_TAG_CLOUD_5: u32 = 2415939610;
pub const IO_REPARSE_TAG_CLOUD_6: u32 = 2415943706;
pub const IO_REPARSE_TAG_CLOUD_7: u32 = 2415947802;
pub const IO_REPARSE_TAG_CLOUD_8: u32 = 2415951898;
pub const IO_REPARSE_TAG_CLOUD_9: u32 = 2415955994;
pub const IO_REPARSE_TAG_CLOUD_A: u32 = 2415960090;
pub const IO_REPARSE_TAG_CLOUD_B: u32 = 2415964186;
pub const IO_REPARSE_TAG_CLOUD_C: u32 = 2415968282;
pub const IO_REPARSE_TAG_CLOUD_D: u32 = 2415972378;
pub const IO_REPARSE_TAG_CLOUD_E: u32 = 2415976474;
pub const IO_REPARSE_TAG_CLOUD_F: u32 = 2415980570;
pub const IO_REPARSE_TAG_CLOUD_MASK: u32 = 61440;
pub const IO_REPARSE_TAG_APPEXECLINK: u32 = 2147483675;
pub const IO_REPARSE_TAG_PROJFS: u32 = 2415919132;
pub const IO_REPARSE_TAG_LX_SYMLINK: u32 = 2684354589;
pub const IO_REPARSE_TAG_STORAGE_SYNC: u32 = 2147483678;
pub const IO_REPARSE_TAG_WCI_TOMBSTONE: u32 = 2684354591;
pub const IO_REPARSE_TAG_UNHANDLED: u32 = 2147483680;
pub const IO_REPARSE_TAG_ONEDRIVE: u32 = 2147483681;
pub const IO_REPARSE_TAG_PROJFS_TOMBSTONE: u32 = 2684354594;
pub const IO_REPARSE_TAG_AF_UNIX: u32 = 2147483683;
pub const IO_REPARSE_TAG_LX_FIFO: u32 = 2147483684;
pub const IO_REPARSE_TAG_LX_CHR: u32 = 2147483685;
pub const IO_REPARSE_TAG_LX_BLK: u32 = 2147483686;
pub const IO_REPARSE_TAG_WCI_LINK: u32 = 2684354599;
pub const IO_REPARSE_TAG_WCI_LINK_1: u32 = 2684358695;
pub const IO_REPARSE_TAG_DATALESS_CIM: u32 = 2684354600;
pub const IO_REPARSE_TAG_IFSTEST_CONGRUENT: u32 = 9;
pub const IO_REPARSE_TAG_MOONWALK_HSM: u32 = 10;
pub const IO_REPARSE_TAG_TSINGHUA_UNIVERSITY_RESEARCH: u32 = 11;
pub const IO_REPARSE_TAG_ARKIVIO: u32 = 12;
pub const IO_REPARSE_TAG_SOLUTIONSOFT: u32 = 536870925;
pub const IO_REPARSE_TAG_COMMVAULT: u32 = 14;
pub const IO_REPARSE_TAG_OVERTONE: u32 = 15;
pub const IO_REPARSE_TAG_SYMANTEC_HSM2: u32 = 16;
pub const IO_REPARSE_TAG_ENIGMA_HSM: u32 = 17;
pub const IO_REPARSE_TAG_SYMANTEC_HSM: u32 = 18;
pub const IO_REPARSE_TAG_INTERCOPE_HSM: u32 = 19;
pub const IO_REPARSE_TAG_KOM_NETWORKS_HSM: u32 = 20;
pub const IO_REPARSE_TAG_MEMORY_TECH_HSM: u32 = 21;
pub const IO_REPARSE_TAG_BRIDGEHEAD_HSM: u32 = 22;
pub const IO_REPARSE_TAG_OSR_SAMPLE: u32 = 536870935;
pub const IO_REPARSE_TAG_GLOBAL360_HSM: u32 = 24;
pub const IO_REPARSE_TAG_ALTIRIS_HSM: u32 = 25;
pub const IO_REPARSE_TAG_HERMES_HSM: u32 = 26;
pub const IO_REPARSE_TAG_POINTSOFT_HSM: u32 = 27;
pub const IO_REPARSE_TAG_GRAU_DATASTORAGE_HSM: u32 = 28;
pub const IO_REPARSE_TAG_COMMVAULT_HSM: u32 = 29;
pub const IO_REPARSE_TAG_DATASTOR_SIS: u32 = 30;
pub const IO_REPARSE_TAG_EDSI_HSM: u32 = 31;
pub const IO_REPARSE_TAG_HP_HSM: u32 = 32;
pub const IO_REPARSE_TAG_SER_HSM: u32 = 33;
pub const IO_REPARSE_TAG_DOUBLE_TAKE_HSM: u32 = 34;
pub const IO_REPARSE_TAG_WISDATA_HSM: u32 = 35;
pub const IO_REPARSE_TAG_MIMOSA_HSM: u32 = 36;
pub const IO_REPARSE_TAG_HSAG_HSM: u32 = 37;
pub const IO_REPARSE_TAG_ADA_HSM: u32 = 38;
pub const IO_REPARSE_TAG_AUTN_HSM: u32 = 39;
pub const IO_REPARSE_TAG_NEXSAN_HSM: u32 = 40;
pub const IO_REPARSE_TAG_DOUBLE_TAKE_SIS: u32 = 41;
pub const IO_REPARSE_TAG_SONY_HSM: u32 = 42;
pub const IO_REPARSE_TAG_ELTAN_HSM: u32 = 43;
pub const IO_REPARSE_TAG_UTIXO_HSM: u32 = 44;
pub const IO_REPARSE_TAG_QUEST_HSM: u32 = 45;
pub const IO_REPARSE_TAG_DATAGLOBAL_HSM: u32 = 46;
pub const IO_REPARSE_TAG_QI_TECH_HSM: u32 = 536870959;
pub const IO_REPARSE_TAG_DATAFIRST_HSM: u32 = 48;
pub const IO_REPARSE_TAG_C2CSYSTEMS_HSM: u32 = 49;
pub const IO_REPARSE_TAG_WATERFORD: u32 = 50;
pub const IO_REPARSE_TAG_RIVERBED_HSM: u32 = 51;
pub const IO_REPARSE_TAG_CARINGO_HSM: u32 = 52;
pub const IO_REPARSE_TAG_MAXISCALE_HSM: u32 = 536870965;
pub const IO_REPARSE_TAG_CITRIX_PM: u32 = 54;
pub const IO_REPARSE_TAG_OPENAFS_DFS: u32 = 55;
pub const IO_REPARSE_TAG_ZLTI_HSM: u32 = 56;
pub const IO_REPARSE_TAG_EMC_HSM: u32 = 57;
pub const IO_REPARSE_TAG_VMWARE_PM: u32 = 58;
pub const IO_REPARSE_TAG_ARCO_BACKUP: u32 = 59;
pub const IO_REPARSE_TAG_CARROLL_HSM: u32 = 60;
pub const IO_REPARSE_TAG_COMTRADE_HSM: u32 = 61;
pub const IO_REPARSE_TAG_EASEVAULT_HSM: u32 = 62;
pub const IO_REPARSE_TAG_HDS_HSM: u32 = 63;
pub const IO_REPARSE_TAG_MAGINATICS_RDR: u32 = 64;
pub const IO_REPARSE_TAG_GOOGLE_HSM: u32 = 65;
pub const IO_REPARSE_TAG_QUADDRA_HSM: u32 = 66;
pub const IO_REPARSE_TAG_HP_BACKUP: u32 = 67;
pub const IO_REPARSE_TAG_DROPBOX_HSM: u32 = 68;
pub const IO_REPARSE_TAG_ADOBE_HSM: u32 = 69;
pub const IO_REPARSE_TAG_HP_DATA_PROTECT: u32 = 70;
pub const IO_REPARSE_TAG_ACTIVISION_HSM: u32 = 71;
pub const IO_REPARSE_TAG_HDS_HCP_HSM: u32 = 72;
pub const IO_REPARSE_TAG_AURISTOR_FS: u32 = 73;
pub const IO_REPARSE_TAG_ITSTATION: u32 = 74;
pub const IO_REPARSE_TAG_SPHARSOFT: u32 = 75;
pub const IO_REPARSE_TAG_ALERTBOOT: u32 = 536870988;
pub const IO_REPARSE_TAG_MTALOS: u32 = 77;
pub const IO_REPARSE_TAG_CTERA_HSM: u32 = 78;
pub const IO_REPARSE_TAG_NIPPON_HSM: u32 = 79;
pub const IO_REPARSE_TAG_REDSTOR_HSM: u32 = 80;
pub const IO_REPARSE_TAG_NEUSHIELD: u32 = 81;
pub const IO_REPARSE_TAG_DOR_HSM: u32 = 82;
pub const IO_REPARSE_TAG_SHX_BACKUP: u32 = 83;
pub const IO_REPARSE_TAG_NVIDIA_UNIONFS: u32 = 536870996;
pub const IO_REPARSE_TAG_HUBSTOR_HSM: u32 = 85;
pub const IO_REPARSE_TAG_IMANAGE_HSM: u32 = 536870998;
pub const IO_REPARSE_TAG_EASEFILTER_HSM: u32 = 87;
pub const IO_REPARSE_TAG_ACRONIS_HSM_0: u32 = 96;
pub const IO_REPARSE_TAG_ACRONIS_HSM_1: u32 = 97;
pub const IO_REPARSE_TAG_ACRONIS_HSM_2: u32 = 98;
pub const IO_REPARSE_TAG_ACRONIS_HSM_3: u32 = 99;
pub const IO_REPARSE_TAG_ACRONIS_HSM_4: u32 = 100;
pub const IO_REPARSE_TAG_ACRONIS_HSM_5: u32 = 101;
pub const IO_REPARSE_TAG_ACRONIS_HSM_6: u32 = 102;
pub const IO_REPARSE_TAG_ACRONIS_HSM_7: u32 = 103;
pub const IO_REPARSE_TAG_ACRONIS_HSM_8: u32 = 104;
pub const IO_REPARSE_TAG_ACRONIS_HSM_9: u32 = 105;
pub const IO_REPARSE_TAG_ACRONIS_HSM_A: u32 = 106;
pub const IO_REPARSE_TAG_ACRONIS_HSM_B: u32 = 107;
pub const IO_REPARSE_TAG_ACRONIS_HSM_C: u32 = 108;
pub const IO_REPARSE_TAG_ACRONIS_HSM_D: u32 = 109;
pub const IO_REPARSE_TAG_ACRONIS_HSM_E: u32 = 110;
pub const IO_REPARSE_TAG_ACRONIS_HSM_F: u32 = 111;
pub const REPARSE_DATA_EX_FLAG_GIVEN_TAG_OR_NONE: u32 = 1;
pub const SUPPORTED_FS_FEATURES_OFFLOAD_READ: u32 = 1;
pub const SUPPORTED_FS_FEATURES_OFFLOAD_WRITE: u32 = 2;
pub const SUPPORTED_FS_FEATURES_QUERY_OPEN: u32 = 4;
pub const SUPPORTED_FS_FEATURES_BYPASS_IO: u32 = 8;
pub const SUPPORTED_FS_FEATURES_VALID_MASK: u32 = 15;
pub const SCRUB_DATA_INPUT_FLAG_RESUME: u32 = 1;
pub const SCRUB_DATA_INPUT_FLAG_SKIP_IN_SYNC: u32 = 2;
pub const SCRUB_DATA_INPUT_FLAG_SKIP_NON_INTEGRITY_DATA: u32 = 4;
pub const SCRUB_DATA_INPUT_FLAG_IGNORE_REDUNDANCY: u32 = 8;
pub const SCRUB_DATA_INPUT_FLAG_SKIP_DATA: u32 = 16;
pub const SCRUB_DATA_INPUT_FLAG_SCRUB_BY_OBJECT_ID: u32 = 32;
pub const SCRUB_DATA_INPUT_FLAG_OPLOCK_NOT_ACQUIRED: u32 = 64;
pub const SCRUB_DATA_OUTPUT_FLAG_INCOMPLETE: u32 = 1;
pub const SCRUB_DATA_OUTPUT_FLAG_NON_USER_DATA_RANGE: u32 = 65536;
pub const SCRUB_DATA_OUTPUT_FLAG_PARITY_EXTENT_DATA_RETURNED: u32 = 131072;
pub const SCRUB_DATA_OUTPUT_FLAG_RESUME_CONTEXT_LENGTH_SPECIFIED: u32 = 262144;
pub const SHUFFLE_FILE_FLAG_SKIP_INITIALIZING_NEW_CLUSTERS: u32 = 1;
pub const FILE_PIPE_READ_DATA: u32 = 0;
pub const FILE_PIPE_WRITE_SPACE: u32 = 1;
pub const FILE_PIPE_COMPUTER_NAME_LENGTH: u32 = 15;
pub const FILE_PIPE_SYMLINK_FLAG_GLOBAL: u32 = 1;
pub const FILE_PIPE_SYMLINK_FLAG_RELATIVE: u32 = 2;
pub const FILE_PIPE_SYMLINK_VALID_FLAGS: u32 = 3;
pub const QUERY_DIRECT_ACCESS_IMAGE_EXTENTS: u32 = 1;
pub const QUERY_DIRECT_ACCESS_DATA_EXTENTS: u32 = 2;
pub const IO_QOS_MAX_RESERVATION: u32 = 1000000000;
pub const SMB_CCF_APP_INSTANCE_EA_NAME: &[u8; 29] = b"ClusteredApplicationInstance\0";
pub const NETWORK_APP_INSTANCE_CSV_FLAGS_VALID_ONLY_IF_CSV_COORDINATOR: u32 = 1;
pub const LX_FILE_METADATA_UID_EA_NAME: &[u8; 7] = b"$LXUID\0";
pub const LX_FILE_METADATA_GID_EA_NAME: &[u8; 7] = b"$LXGID\0";
pub const LX_FILE_METADATA_MODE_EA_NAME: &[u8; 7] = b"$LXMOD\0";
pub const LX_FILE_METADATA_DEVICE_ID_EA_NAME: &[u8; 7] = b"$LXDEV\0";
pub const VALID_COPY_FILE_CHUNK_FLAGS: u32 = 0;
pub const SYSTEM_PAGE_PRIORITY_BITS: u32 = 3;
pub const SYSTEM_PAGE_PRIORITY_LEVELS: u32 = 8;
pub const TOKEN_HAS_TRAVERSE_PRIVILEGE: u32 = 1;
pub const TOKEN_HAS_BACKUP_PRIVILEGE: u32 = 2;
pub const TOKEN_HAS_RESTORE_PRIVILEGE: u32 = 4;
pub const TOKEN_WRITE_RESTRICTED: u32 = 8;
pub const TOKEN_IS_RESTRICTED: u32 = 16;
pub const TOKEN_SESSION_NOT_REFERENCED: u32 = 32;
pub const TOKEN_SANDBOX_INERT: u32 = 64;
pub const TOKEN_HAS_IMPERSONATE_PRIVILEGE: u32 = 128;
pub const SE_BACKUP_PRIVILEGES_CHECKED: u32 = 256;
pub const TOKEN_VIRTUALIZE_ALLOWED: u32 = 512;
pub const TOKEN_VIRTUALIZE_ENABLED: u32 = 1024;
pub const TOKEN_IS_FILTERED: u32 = 2048;
pub const TOKEN_UIACCESS: u32 = 4096;
pub const TOKEN_NOT_LOW: u32 = 8192;
pub const TOKEN_LOWBOX: u32 = 16384;
pub const TOKEN_HAS_OWN_CLAIM_ATTRIBUTES: u32 = 32768;
pub const TOKEN_PRIVATE_NAMESPACE: u32 = 65536;
pub const TOKEN_DO_NOT_USE_GLOBAL_ATTRIBS_FOR_QUERY: u32 = 131072;
pub const SPECIAL_ENCRYPTED_OPEN: u32 = 262144;
pub const TOKEN_NO_CHILD_PROCESS: u32 = 524288;
pub const TOKEN_NO_CHILD_PROCESS_UNLESS_SECURE: u32 = 1048576;
pub const TOKEN_AUDIT_NO_CHILD_PROCESS: u32 = 2097152;
pub const TOKEN_ENFORCE_REDIRECTION_TRUST: u32 = 4194304;
pub const TOKEN_AUDIT_REDIRECTION_TRUST: u32 = 8388608;
pub const TOKEN_LEARNING_MODE_LOGGING: u32 = 16777216;
pub const TOKEN_PERMISSIVE_LEARNING_MODE: u32 = 50331648;
pub const TOKEN_INHERIT_SECURITY_FLAGS: u32 = 3670016;
pub const SECURITY_DESCRIPTOR_DO_NOT_FREE: u32 = 67108864;
pub const IO_OPEN_PAGING_FILE: u32 = 2;
pub const IO_OPEN_TARGET_DIRECTORY: u32 = 4;
pub const IO_STOP_ON_SYMLINK: u32 = 8;
pub const IO_MM_PAGING_FILE: u32 = 16;
pub const IO_IGNORE_READONLY_ATTRIBUTE: u32 = 64;
pub const FS_FILTER_SECTION_SYNC_IN_FLAG_DONT_UPDATE_LAST_ACCESS: u32 = 1;
pub const FS_FILTER_SECTION_SYNC_IN_FLAG_DONT_UPDATE_LAST_WRITE: u32 = 2;
pub const FS_FILTER_SECTION_SYNC_SUPPORTS_ASYNC_PARALLEL_IO: u32 = 1;
pub const FS_FILTER_SECTION_SYNC_SUPPORTS_DIRECT_MAP_DATA: u32 = 2;
pub const FS_FILTER_SECTION_SYNC_SUPPORTS_DIRECT_MAP_IMAGE: u32 = 4;
pub const FS_FILTER_SECTION_SYNC_IMAGE_EXTENTS_ARE_NOT_RVA: u32 = 8;
pub const DO_SUPPORTS_PERSISTENT_ACLS: u32 = 131072;
pub const IO_FILE_OBJECT_NON_PAGED_POOL_CHARGE: u32 = 64;
pub const IO_FILE_OBJECT_PAGED_POOL_CHARGE: u32 = 1024;
pub const IO_CREATE_STREAM_FILE_RAISE_ON_ERROR: u32 = 1;
pub const IO_CREATE_STREAM_FILE_LITE: u32 = 2;
pub const EFS_TRACKED_OFFSET_HEADER_FLAG: u32 = 1;
pub const SPACES_TRACKED_OFFSET_HEADER_FLAG: u32 = 2;
pub const MM_FORCE_CLOSED_DATA: u32 = 1;
pub const MM_FORCE_CLOSED_IMAGE: u32 = 2;
pub const MM_FORCE_CLOSED_LATER_OK: u32 = 4;
pub const MM_IS_FILE_SECTION_ACTIVE_IMAGE: u32 = 1;
pub const MM_IS_FILE_SECTION_ACTIVE_DATA: u32 = 2;
pub const MM_IS_FILE_SECTION_ACTIVE_USER: u32 = 4;
pub const MM_PREFETCH_FLAGS_MASK: u32 = 127;
pub const DEVICE_RESET_RESERVED_0: u32 = 1;
pub const DEVICE_RESET_RESERVED_1: u32 = 2;
pub const DEVICE_RESET_KEEP_STACK: u32 = 4;
pub const FSRTL_FCB_HEADER_V0: u32 = 0;
pub const FSRTL_FCB_HEADER_V1: u32 = 1;
pub const FSRTL_FCB_HEADER_V2: u32 = 2;
pub const FSRTL_FCB_HEADER_V3: u32 = 3;
pub const FSRTL_FCB_HEADER_V4: u32 = 4;
pub const FSRTL_FLAG_FILE_MODIFIED: u32 = 1;
pub const FSRTL_FLAG_FILE_LENGTH_CHANGED: u32 = 2;
pub const FSRTL_FLAG_LIMIT_MODIFIED_PAGES: u32 = 4;
pub const FSRTL_FLAG_ACQUIRE_MAIN_RSRC_EX: u32 = 8;
pub const FSRTL_FLAG_ACQUIRE_MAIN_RSRC_SH: u32 = 16;
pub const FSRTL_FLAG_USER_MAPPED_FILE: u32 = 32;
pub const FSRTL_FLAG_ADVANCED_HEADER: u32 = 64;
pub const FSRTL_FLAG_EOF_ADVANCE_ACTIVE: u32 = 128;
pub const FSRTL_FLAG2_DO_MODIFIED_WRITE: u32 = 1;
pub const FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS: u32 = 2;
pub const FSRTL_FLAG2_PURGE_WHEN_MAPPED: u32 = 4;
pub const FSRTL_FLAG2_IS_PAGING_FILE: u32 = 8;
pub const FSRTL_FLAG2_WRITABLE_USER_MAPPED_FILE: u32 = 16;
pub const FSRTL_FLAG2_BYPASSIO_STREAM_PAUSED: u32 = 32;
pub const FSRTL_AUXILIARY_FLAG_DEALLOCATE: u32 = 1;
pub const FSRTL_ADD_TC_CASE_SENSITIVE: u32 = 1;
pub const FSRTL_ADD_TC_KEY_BY_SHORT_NAME: u32 = 2;
pub const FSRTL_FIND_TC_CASE_SENSITIVE: u32 = 1;
pub const FSRTL_FAT_LEGAL: u32 = 1;
pub const FSRTL_HPFS_LEGAL: u32 = 2;
pub const FSRTL_NTFS_LEGAL: u32 = 4;
pub const FSRTL_WILD_CHARACTER: u32 = 8;
pub const FSRTL_OLE_LEGAL: u32 = 16;
pub const FSRTL_NTFS_STREAM_LEGAL: u32 = 20;
pub const MCB_FLAG_RAISE_ON_ALLOCATION_FAILURE: u32 = 1;
pub const OPLOCK_FLAG_COMPLETE_IF_OPLOCKED: u32 = 1;
pub const OPLOCK_FLAG_OPLOCK_KEY_CHECK_ONLY: u32 = 2;
pub const OPLOCK_FLAG_BACK_OUT_ATOMIC_OPLOCK: u32 = 4;
pub const OPLOCK_FLAG_IGNORE_OPLOCK_KEYS: u32 = 8;
pub const OPLOCK_FLAG_PARENT_OBJECT: u32 = 16;
pub const OPLOCK_FLAG_CLOSING_DELETE_ON_CLOSE: u32 = 32;
pub const OPLOCK_FLAG_REMOVING_FILE_OR_LINK: u32 = 64;
pub const OPLOCK_FLAG_BREAKING_FOR_SHARING_VIOLATION: u32 = 128;
pub const OPLOCK_UPPER_FLAG_CHECK_NO_BREAK: u32 = 65536;
pub const OPLOCK_UPPER_FLAG_NOTIFY_REFRESH_READ: u32 = 131072;
pub const OPLOCK_FSCTRL_FLAG_ALL_KEYS_MATCH: u32 = 1;
pub const FSRTL_VOLUME_DISMOUNT: u32 = 1;
pub const FSRTL_VOLUME_DISMOUNT_FAILED: u32 = 2;
pub const FSRTL_VOLUME_LOCK: u32 = 3;
pub const FSRTL_VOLUME_LOCK_FAILED: u32 = 4;
pub const FSRTL_VOLUME_UNLOCK: u32 = 5;
pub const FSRTL_VOLUME_MOUNT: u32 = 6;
pub const FSRTL_VOLUME_NEEDS_CHKDSK: u32 = 7;
pub const FSRTL_VOLUME_WORM_NEAR_FULL: u32 = 8;
pub const FSRTL_VOLUME_WEARING_OUT: u32 = 9;
pub const FSRTL_VOLUME_FORCED_CLOSED: u32 = 10;
pub const FSRTL_VOLUME_INFO_MAKE_COMPAT: u32 = 11;
pub const FSRTL_VOLUME_PREPARING_EJECT: u32 = 12;
pub const FSRTL_VOLUME_CHANGE_SIZE: u32 = 13;
pub const FSRTL_VOLUME_BACKGROUND_FORMAT: u32 = 14;
pub const FSRTL_UNC_PROVIDER_FLAGS_MAILSLOTS_SUPPORTED: u32 = 1;
pub const FSRTL_UNC_PROVIDER_FLAGS_CSC_ENABLED: u32 = 2;
pub const FSRTL_UNC_PROVIDER_FLAGS_DOMAIN_SVC_AWARE: u32 = 4;
pub const FSRTL_UNC_PROVIDER_FLAGS_CONTAINER_AWARE: u32 = 8;
pub const FSRTL_UNC_REGISTRATION_VERSION_0200: u32 = 512;
pub const FSRTL_UNC_REGISTRATION_VERSION_0201: u32 = 513;
pub const FSRTL_UNC_REGISTRATION_CURRENT_VERSION: u32 = 513;
pub const FSRTL_UNC_HARDENING_CAPABILITIES_MUTUAL_AUTH: u32 = 1;
pub const FSRTL_UNC_HARDENING_CAPABILITIES_INTEGRITY: u32 = 2;
pub const FSRTL_UNC_HARDENING_CAPABILITIES_PRIVACY: u32 = 4;
pub const FSRTL_ALLOCATE_ECPLIST_FLAG_CHARGE_QUOTA: u32 = 1;
pub const FSRTL_ALLOCATE_ECP_FLAG_CHARGE_QUOTA: u32 = 1;
pub const FSRTL_ALLOCATE_ECP_FLAG_NONPAGED_POOL: u32 = 2;
pub const FSRTL_ECP_LOOKASIDE_FLAG_NONPAGED_POOL: u32 = 2;
pub const NETWORK_OPEN_ECP_IN_FLAG_DISABLE_HANDLE_COLLAPSING: u32 = 1;
pub const NETWORK_OPEN_ECP_IN_FLAG_DISABLE_HANDLE_DURABILITY: u32 = 2;
pub const NETWORK_OPEN_ECP_IN_FLAG_FORCE_MAX_EOF_HACK: u32 = 1073741824;
pub const NETWORK_OPEN_ECP_IN_FLAG_FORCE_BUFFERED_SYNCHRONOUS_IO_HACK: u32 = 2147483648;
pub const NETWORK_OPEN_ECP_IN_FLAG_DISABLE_OPLOCKS: u32 = 4;
pub const NETWORK_OPEN_ECP_IN_FLAG_REQ_MUTUAL_AUTH: u32 = 8;
pub const NETWORK_OPEN_ECP_OUT_FLAG_RET_MUTUAL_AUTH: u32 = 8;
pub const SRV_OPEN_ECP_CONTEXT_VERSION_2: u32 = 2;
pub const CSV_SET_HANDLE_PROPERTIES_ECP_CONTEXT_FLAGS_VALID_ONLY_IF_CSV_COORDINATOR: u32 = 1;
pub const OPEN_REPARSE_POINT_TAG_ENCOUNTERED: u32 = 1;
pub const OPEN_REPARSE_POINT_REPARSE_IF_CHILD_EXISTS: u32 = 2;
pub const OPEN_REPARSE_POINT_REPARSE_IF_CHILD_NOT_EXISTS: u32 = 4;
pub const OPEN_REPARSE_POINT_REPARSE_IF_DIRECTORY_FINAL_COMPONENT: u32 = 8;
pub const OPEN_REPARSE_POINT_REPARSE_IF_NON_DIRECTORY_NON_FINAL_COMPONENT: u32 = 16;
pub const OPEN_REPARSE_POINT_REPARSE_IF_NON_DIRECTORY_FINAL_COMPONENT: u32 = 32;
pub const OPEN_REPARSE_POINT_OVERRIDE_CREATE_OPTION: u32 = 64;
pub const OPEN_REPARSE_POINT_RETURN_REPARSE_DATA_BUFFER: u32 = 128;
pub const OPEN_REPARSE_POINT_VERSION_EX: u32 = 2147483648;
pub const OPEN_REPARSE_POINT_REPARSE_IF_NON_FINAL_COMPONENT: u32 = 22;
pub const OPEN_REPARSE_POINT_REPARSE_IF_DIRECTORY_FINAL_COMPONENT_ALWAYS: u32 = 72;
pub const OPEN_REPARSE_POINT_REPARSE_IF_NON_DIRECTORY_NON_FINAL_COMPONENT_ALWAYS: u32 = 80;
pub const OPEN_REPARSE_POINT_REPARSE_IF_NON_DIRECTORY_FINAL_COMPONENT_ALWAYS: u32 = 96;
pub const OPEN_REPARSE_POINT_REPARSE_IF_FINAL_COMPONENT: u32 = 40;
pub const OPEN_REPARSE_POINT_REPARSE_IF_FINAL_COMPONENT_ALWAYS: u32 = 104;
pub const OPEN_REPARSE_POINT_REPARSE_ALWAYS: u32 = 126;
pub const CREATE_REDIRECTION_FLAGS_SERVICED_FROM_LAYER: u32 = 1;
pub const CREATE_REDIRECTION_FLAGS_SERVICED_FROM_SCRATCH: u32 = 2;
pub const CREATE_REDIRECTION_FLAGS_SERVICED_FROM_REGISTERED_LAYER: u32 = 4;
pub const CREATE_REDIRECTION_FLAGS_SERVICED_FROM_REMOTE_LAYER: u32 = 8;
pub const CREATE_REDIRECTION_FLAGS_SERVICED_FROM_USER_MODE: u32 = 16;
pub const WCIFS_REDIRECTION_FLAGS_CREATE_SERVICED_FROM_LAYER: u32 = 1;
pub const WCIFS_REDIRECTION_FLAGS_CREATE_SERVICED_FROM_SCRATCH: u32 = 2;
pub const WCIFS_REDIRECTION_FLAGS_CREATE_SERVICED_FROM_REGISTERED_LAYER: u32 = 4;
pub const WCIFS_REDIRECTION_FLAGS_CREATE_SERVICED_FROM_REMOTE_LAYER: u32 = 8;
pub const ATOMIC_CREATE_ECP_IN_FLAG_SPARSE_SPECIFIED: u32 = 1;
pub const ATOMIC_CREATE_ECP_IN_FLAG_REPARSE_POINT_SPECIFIED: u32 = 2;
pub const ATOMIC_CREATE_ECP_IN_FLAG_EOF_SPECIFIED: u32 = 4;
pub const ATOMIC_CREATE_ECP_IN_FLAG_VDL_SPECIFIED: u32 = 8;
pub const ATOMIC_CREATE_ECP_IN_FLAG_TIMESTAMPS_SPECIFIED: u32 = 16;
pub const ATOMIC_CREATE_ECP_IN_FLAG_FILE_ATTRIBUTES_SPECIFIED: u32 = 32;
pub const ATOMIC_CREATE_ECP_IN_FLAG_SUPPRESS_FILE_ATTRIBUTE_INHERITANCE: u32 = 64;
pub const ATOMIC_CREATE_ECP_IN_FLAG_OP_FLAGS_SPECIFIED: u32 = 128;
pub const ATOMIC_CREATE_ECP_IN_FLAG_OPERATION_MASK: u32 = 255;
pub const ATOMIC_CREATE_ECP_IN_FLAG_BEST_EFFORT: u32 = 256;
pub const ATOMIC_CREATE_ECP_IN_FLAG_SUPPRESS_PARENT_TIMESTAMPS_UPDATE: u32 = 512;
pub const ATOMIC_CREATE_ECP_IN_FLAG_SUPPRESS_DIR_CHANGE_NOTIFY: u32 = 1024;
pub const ATOMIC_CREATE_ECP_IN_FLAG_MARK_USN_SOURCE_INFO: u32 = 2048;
pub const ATOMIC_CREATE_ECP_IN_FLAG_WRITE_USN_CLOSE_RECORD: u32 = 4096;
pub const ATOMIC_CREATE_ECP_IN_FLAG_GEN_FLAGS_SPECIFIED: u32 = 32768;
pub const ATOMIC_CREATE_ECP_IN_OP_FLAG_CASE_SENSITIVE_FLAGS_SPECIFIED: u32 = 1;
pub const ATOMIC_CREATE_ECP_OUT_FLAG_SPARSE_SET: u32 = 1;
pub const ATOMIC_CREATE_ECP_OUT_FLAG_REPARSE_POINT_SET: u32 = 2;
pub const ATOMIC_CREATE_ECP_OUT_FLAG_EOF_SET: u32 = 4;
pub const ATOMIC_CREATE_ECP_OUT_FLAG_VDL_SET: u32 = 8;
pub const ATOMIC_CREATE_ECP_OUT_FLAG_TIMESTAMPS_SET: u32 = 16;
pub const ATOMIC_CREATE_ECP_OUT_FLAG_FILE_ATTRIBUTES_SET: u32 = 32;
pub const ATOMIC_CREATE_ECP_OUT_FLAG_FILE_ATTRIBUTE_INHERITANCE_SUPPRESSED: u32 = 64;
pub const ATOMIC_CREATE_ECP_OUT_FLAG_OP_FLAGS_HONORED: u32 = 128;
pub const ATOMIC_CREATE_ECP_OUT_FLAG_OPERATION_MASK: u32 = 255;
pub const ATOMIC_CREATE_ECP_OUT_FLAG_TIMESTAMPS_RETURNED: u32 = 256;
pub const ATOMIC_CREATE_ECP_OUT_FLAG_FILE_ATTRIBUTES_RETURNED: u32 = 512;
pub const ATOMIC_CREATE_ECP_OUT_FLAG_USN_SOURCE_INFO_MARKED: u32 = 1024;
pub const ATOMIC_CREATE_ECP_OUT_FLAG_USN_CLOSE_RECORD_WRITTEN: u32 = 2048;
pub const ATOMIC_CREATE_ECP_OUT_FLAG_USN_RETURNED: u32 = 4096;
pub const ATOMIC_CREATE_ECP_OUT_OP_FLAG_CASE_SENSITIVE_FLAGS_SET: u32 = 1;
pub const ECP_OPEN_PARAMETERS_FLAG_OPEN_FOR_READ: u32 = 1;
pub const ECP_OPEN_PARAMETERS_FLAG_OPEN_FOR_WRITE: u32 = 2;
pub const ECP_OPEN_PARAMETERS_FLAG_OPEN_FOR_DELETE: u32 = 4;
pub const ECP_OPEN_PARAMETERS_FLAG_IGNORE_DIR_CASE_SENSITIVITY: u32 = 8;
pub const ECP_OPEN_PARAMETERS_FLAG_FAIL_ON_CASE_SENSITIVE_DIR: u32 = 16;
pub const OPLOCK_FS_FILTER_FLAGS_MASK: u32 = 8;
pub const QoCFileStatInformation: u32 = 1;
pub const QoCFileLxInformation: u32 = 2;
pub const QoCFileEaInformation: u32 = 4;
pub const FSRTL_CC_FLUSH_ERROR_FLAG_NO_HARD_ERROR: u32 = 1;
pub const FSRTL_CC_FLUSH_ERROR_FLAG_NO_LOG_ENTRY: u32 = 2;
pub const FSRTL_VIRTDISK_FULLY_ALLOCATED: u32 = 1;
pub const FSRTL_VIRTDISK_NO_DRIVE_LETTER: u32 = 2;
pub const FSRTL_DRIVER_BACKING_FLAG_USE_PAGE_FILE: u32 = 1;
pub const VACB_MAPPING_GRANULARITY: u32 = 262144;
pub const VACB_OFFSET_SHIFT: u32 = 18;
pub const CACHE_MANAGER_CALLBACKS_EX_V1: u32 = 1;
pub const CC_ACQUIRE_DONT_WAIT: u32 = 1;
pub const CC_ACQUIRE_SUPPORTS_ASYNC_LAZYWRITE: u32 = 1;
pub const UNINITIALIZE_CACHE_MAPS: u32 = 1;
pub const DO_NOT_RETRY_PURGE: u32 = 2;
pub const DO_NOT_PURGE_DIRTY_PAGES: u32 = 4;
pub const PURGE_WITH_ACTIVE_VIEWS: u32 = 8;
pub const CC_FLUSH_AND_PURGE_NO_PURGE: u32 = 1;
pub const CC_FLUSH_AND_PURGE_GATHER_DIRTY_BITS: u32 = 2;
pub const CC_FLUSH_AND_PURGE_WRITEABLE_VIEWS_NOTSEEN: u32 = 4;
pub const PIN_WAIT: u32 = 1;
pub const PIN_EXCLUSIVE: u32 = 2;
pub const PIN_NO_READ: u32 = 4;
pub const PIN_IF_BCB: u32 = 8;
pub const PIN_CALLER_TRACKS_DIRTY_DATA: u32 = 32;
pub const PIN_HIGH_PRIORITY: u32 = 64;
pub const PIN_VERIFY_REQUIRED: u32 = 128;
pub const MAP_WAIT: u32 = 1;
pub const MAP_NO_READ: u32 = 16;
pub const MAP_HIGH_PRIORITY: u32 = 64;
pub const MAP_DISABLE_PAGEFAULT_CLUSTERING: u32 = 256;
pub const CACHE_USE_DIRECT_ACCESS_MAPPING: u32 = 1;
pub const CACHE_VALID_FLAGS: u32 = 1;
pub const CC_AGGRESSIVE_UNMAP_BEHIND: u32 = 1;
pub const CC_DISABLE_READ_AHEAD: u32 = 2;
pub const CC_DISABLE_WRITE_BEHIND: u32 = 4;
pub const CC_DISABLE_DIRTY_PAGE_TRACKING: u32 = 8;
pub const CC_ENABLE_DISK_IO_ACCOUNTING: u32 = 16;
pub const CC_DISABLE_UNMAP_BEHIND: u32 = 32;
pub const CC_ENABLE_CPU_CACHE: u32 = 268435456;
pub const ISSP_LEVEL: u32 = 32;
pub const ISSP_MODE: u32 = 0;
pub const SECPKG_FLAG_INTEGRITY: u32 = 1;
pub const SECPKG_FLAG_PRIVACY: u32 = 2;
pub const SECPKG_FLAG_TOKEN_ONLY: u32 = 4;
pub const SECPKG_FLAG_DATAGRAM: u32 = 8;
pub const SECPKG_FLAG_CONNECTION: u32 = 16;
pub const SECPKG_FLAG_MULTI_REQUIRED: u32 = 32;
pub const SECPKG_FLAG_CLIENT_ONLY: u32 = 64;
pub const SECPKG_FLAG_EXTENDED_ERROR: u32 = 128;
pub const SECPKG_FLAG_IMPERSONATION: u32 = 256;
pub const SECPKG_FLAG_ACCEPT_WIN32_NAME: u32 = 512;
pub const SECPKG_FLAG_STREAM: u32 = 1024;
pub const SECPKG_FLAG_NEGOTIABLE: u32 = 2048;
pub const SECPKG_FLAG_GSS_COMPATIBLE: u32 = 4096;
pub const SECPKG_FLAG_LOGON: u32 = 8192;
pub const SECPKG_FLAG_ASCII_BUFFERS: u32 = 16384;
pub const SECPKG_FLAG_FRAGMENT: u32 = 32768;
pub const SECPKG_FLAG_MUTUAL_AUTH: u32 = 65536;
pub const SECPKG_FLAG_DELEGATION: u32 = 131072;
pub const SECPKG_FLAG_READONLY_WITH_CHECKSUM: u32 = 262144;
pub const SECPKG_FLAG_RESTRICTED_TOKENS: u32 = 524288;
pub const SECPKG_FLAG_NEGO_EXTENDER: u32 = 1048576;
pub const SECPKG_FLAG_NEGOTIABLE2: u32 = 2097152;
pub const SECPKG_FLAG_APPCONTAINER_PASSTHROUGH: u32 = 4194304;
pub const SECPKG_FLAG_APPCONTAINER_CHECKS: u32 = 8388608;
pub const SECPKG_FLAG_CREDENTIAL_ISOLATION_ENABLED: u32 = 16777216;
pub const SECPKG_FLAG_APPLY_LOOPBACK: u32 = 33554432;
pub const SECPKG_ID_NONE: u32 = 65535;
pub const SECPKG_CALLFLAGS_APPCONTAINER: u32 = 1;
pub const SECPKG_CALLFLAGS_APPCONTAINER_AUTHCAPABLE: u32 = 2;
pub const SECPKG_CALLFLAGS_FORCE_SUPPLIED: u32 = 4;
pub const SECPKG_CALLFLAGS_APPCONTAINER_UPNCAPABLE: u32 = 8;
pub const SECBUFFER_VERSION: u32 = 0;
pub const SECBUFFER_EMPTY: u32 = 0;
pub const SECBUFFER_DATA: u32 = 1;
pub const SECBUFFER_TOKEN: u32 = 2;
pub const SECBUFFER_PKG_PARAMS: u32 = 3;
pub const SECBUFFER_MISSING: u32 = 4;
pub const SECBUFFER_EXTRA: u32 = 5;
pub const SECBUFFER_STREAM_TRAILER: u32 = 6;
pub const SECBUFFER_STREAM_HEADER: u32 = 7;
pub const SECBUFFER_NEGOTIATION_INFO: u32 = 8;
pub const SECBUFFER_PADDING: u32 = 9;
pub const SECBUFFER_STREAM: u32 = 10;
pub const SECBUFFER_MECHLIST: u32 = 11;
pub const SECBUFFER_MECHLIST_SIGNATURE: u32 = 12;
pub const SECBUFFER_TARGET: u32 = 13;
pub const SECBUFFER_CHANNEL_BINDINGS: u32 = 14;
pub const SECBUFFER_CHANGE_PASS_RESPONSE: u32 = 15;
pub const SECBUFFER_TARGET_HOST: u32 = 16;
pub const SECBUFFER_ALERT: u32 = 17;
pub const SECBUFFER_APPLICATION_PROTOCOLS: u32 = 18;
pub const SECBUFFER_SRTP_PROTECTION_PROFILES: u32 = 19;
pub const SECBUFFER_SRTP_MASTER_KEY_IDENTIFIER: u32 = 20;
pub const SECBUFFER_TOKEN_BINDING: u32 = 21;
pub const SECBUFFER_PRESHARED_KEY: u32 = 22;
pub const SECBUFFER_PRESHARED_KEY_IDENTITY: u32 = 23;
pub const SECBUFFER_DTLS_MTU: u32 = 24;
pub const SECBUFFER_SEND_GENERIC_TLS_EXTENSION: u32 = 25;
pub const SECBUFFER_SUBSCRIBE_GENERIC_TLS_EXTENSION: u32 = 26;
pub const SECBUFFER_FLAGS: u32 = 27;
pub const SECBUFFER_TRAFFIC_SECRETS: u32 = 28;
pub const SECBUFFER_CERTIFICATE_REQUEST_CONTEXT: u32 = 29;
pub const SECBUFFER_CHANNEL_BINDINGS_RESULT: u32 = 30;
pub const SECBUFFER_ATTRMASK: u32 = 4026531840;
pub const SECBUFFER_READONLY: u32 = 2147483648;
pub const SECBUFFER_READONLY_WITH_CHECKSUM: u32 = 268435456;
pub const SECBUFFER_RESERVED: u32 = 1610612736;
pub const SEC_CHANNEL_BINDINGS_AUDIT_BINDINGS: u32 = 1;
pub const SEC_CHANNEL_BINDINGS_VALID_FLAGS: u32 = 1;
pub const SEC_CHANNEL_BINDINGS_RESULT_CLIENT_SUPPORT: u32 = 1;
pub const SEC_CHANNEL_BINDINGS_RESULT_ABSENT: u32 = 2;
pub const SEC_CHANNEL_BINDINGS_RESULT_NOTVALID_MISMATCH: u32 = 4;
pub const SEC_CHANNEL_BINDINGS_RESULT_NOTVALID_MISSING: u32 = 8;
pub const SEC_CHANNEL_BINDINGS_RESULT_VALID_MATCHED: u32 = 16;
pub const SEC_CHANNEL_BINDINGS_RESULT_VALID_PROXY: u32 = 32;
pub const SEC_CHANNEL_BINDINGS_RESULT_VALID_MISSING: u32 = 64;
pub const SEC_CHANNEL_BINDINGS_RESULT_VALID: u32 = 112;
pub const SEC_CHANNEL_BINDINGS_RESULT_NOTVALID: u32 = 12;
pub const SZ_ALG_MAX_SIZE: u32 = 64;
pub const SECURITY_NATIVE_DREP: u32 = 16;
pub const SECURITY_NETWORK_DREP: u32 = 0;
pub const SECPKG_CRED_INBOUND: u32 = 1;
pub const SECPKG_CRED_OUTBOUND: u32 = 2;
pub const SECPKG_CRED_BOTH: u32 = 3;
pub const SECPKG_CRED_DEFAULT: u32 = 4;
pub const SECPKG_CRED_RESERVED: u32 = 4026531840;
pub const SECPKG_CRED_AUTOLOGON_RESTRICTED: u32 = 16;
pub const SECPKG_CRED_PROCESS_POLICY_ONLY: u32 = 32;
pub const ISC_REQ_DELEGATE: u32 = 1;
pub const ISC_REQ_MUTUAL_AUTH: u32 = 2;
pub const ISC_REQ_REPLAY_DETECT: u32 = 4;
pub const ISC_REQ_SEQUENCE_DETECT: u32 = 8;
pub const ISC_REQ_CONFIDENTIALITY: u32 = 16;
pub const ISC_REQ_USE_SESSION_KEY: u32 = 32;
pub const ISC_REQ_PROMPT_FOR_CREDS: u32 = 64;
pub const ISC_REQ_USE_SUPPLIED_CREDS: u32 = 128;
pub const ISC_REQ_ALLOCATE_MEMORY: u32 = 256;
pub const ISC_REQ_USE_DCE_STYLE: u32 = 512;
pub const ISC_REQ_DATAGRAM: u32 = 1024;
pub const ISC_REQ_CONNECTION: u32 = 2048;
pub const ISC_REQ_CALL_LEVEL: u32 = 4096;
pub const ISC_REQ_FRAGMENT_SUPPLIED: u32 = 8192;
pub const ISC_REQ_EXTENDED_ERROR: u32 = 16384;
pub const ISC_REQ_STREAM: u32 = 32768;
pub const ISC_REQ_INTEGRITY: u32 = 65536;
pub const ISC_REQ_IDENTIFY: u32 = 131072;
pub const ISC_REQ_NULL_SESSION: u32 = 262144;
pub const ISC_REQ_MANUAL_CRED_VALIDATION: u32 = 524288;
pub const ISC_REQ_RESERVED1: u32 = 1048576;
pub const ISC_REQ_FRAGMENT_TO_FIT: u32 = 2097152;
pub const ISC_REQ_FORWARD_CREDENTIALS: u32 = 4194304;
pub const ISC_REQ_NO_INTEGRITY: u32 = 8388608;
pub const ISC_REQ_USE_HTTP_STYLE: u32 = 16777216;
pub const ISC_REQ_UNVERIFIED_TARGET_NAME: u32 = 536870912;
pub const ISC_REQ_CONFIDENTIALITY_ONLY: u32 = 1073741824;
pub const ISC_REQ_MESSAGES: u64 = 4294967296;
pub const ISC_REQ_DEFERRED_CRED_VALIDATION: u64 = 8589934592;
pub const ISC_REQ_NO_POST_HANDSHAKE_AUTH: u64 = 17179869184;
pub const ISC_RET_DELEGATE: u32 = 1;
pub const ISC_RET_MUTUAL_AUTH: u32 = 2;
pub const ISC_RET_REPLAY_DETECT: u32 = 4;
pub const ISC_RET_SEQUENCE_DETECT: u32 = 8;
pub const ISC_RET_CONFIDENTIALITY: u32 = 16;
pub const ISC_RET_USE_SESSION_KEY: u32 = 32;
pub const ISC_RET_USED_COLLECTED_CREDS: u32 = 64;
pub const ISC_RET_USED_SUPPLIED_CREDS: u32 = 128;
pub const ISC_RET_ALLOCATED_MEMORY: u32 = 256;
pub const ISC_RET_USED_DCE_STYLE: u32 = 512;
pub const ISC_RET_DATAGRAM: u32 = 1024;
pub const ISC_RET_CONNECTION: u32 = 2048;
pub const ISC_RET_INTERMEDIATE_RETURN: u32 = 4096;
pub const ISC_RET_CALL_LEVEL: u32 = 8192;
pub const ISC_RET_EXTENDED_ERROR: u32 = 16384;
pub const ISC_RET_STREAM: u32 = 32768;
pub const ISC_RET_INTEGRITY: u32 = 65536;
pub const ISC_RET_IDENTIFY: u32 = 131072;
pub const ISC_RET_NULL_SESSION: u32 = 262144;
pub const ISC_RET_MANUAL_CRED_VALIDATION: u32 = 524288;
pub const ISC_RET_RESERVED1: u32 = 1048576;
pub const ISC_RET_FRAGMENT_ONLY: u32 = 2097152;
pub const ISC_RET_FORWARD_CREDENTIALS: u32 = 4194304;
pub const ISC_RET_USED_HTTP_STYLE: u32 = 16777216;
pub const ISC_RET_NO_ADDITIONAL_TOKEN: u32 = 33554432;
pub const ISC_RET_REAUTHENTICATION: u32 = 134217728;
pub const ISC_RET_CONFIDENTIALITY_ONLY: u32 = 1073741824;
pub const ISC_RET_MESSAGES: u64 = 4294967296;
pub const ISC_RET_DEFERRED_CRED_VALIDATION: u64 = 8589934592;
pub const ISC_RET_NO_POST_HANDSHAKE_AUTH: u64 = 17179869184;
pub const ASC_REQ_DELEGATE: u32 = 1;
pub const ASC_REQ_MUTUAL_AUTH: u32 = 2;
pub const ASC_REQ_REPLAY_DETECT: u32 = 4;
pub const ASC_REQ_SEQUENCE_DETECT: u32 = 8;
pub const ASC_REQ_CONFIDENTIALITY: u32 = 16;
pub const ASC_REQ_USE_SESSION_KEY: u32 = 32;
pub const ASC_REQ_SESSION_TICKET: u32 = 64;
pub const ASC_REQ_ALLOCATE_MEMORY: u32 = 256;
pub const ASC_REQ_USE_DCE_STYLE: u32 = 512;
pub const ASC_REQ_DATAGRAM: u32 = 1024;
pub const ASC_REQ_CONNECTION: u32 = 2048;
pub const ASC_REQ_CALL_LEVEL: u32 = 4096;
pub const ASC_REQ_FRAGMENT_SUPPLIED: u32 = 8192;
pub const ASC_REQ_EXTENDED_ERROR: u32 = 32768;
pub const ASC_REQ_STREAM: u32 = 65536;
pub const ASC_REQ_INTEGRITY: u32 = 131072;
pub const ASC_REQ_LICENSING: u32 = 262144;
pub const ASC_REQ_IDENTIFY: u32 = 524288;
pub const ASC_REQ_ALLOW_NULL_SESSION: u32 = 1048576;
pub const ASC_REQ_ALLOW_NON_USER_LOGONS: u32 = 2097152;
pub const ASC_REQ_ALLOW_CONTEXT_REPLAY: u32 = 4194304;
pub const ASC_REQ_FRAGMENT_TO_FIT: u32 = 8388608;
pub const ASC_REQ_NO_TOKEN: u32 = 16777216;
pub const ASC_REQ_PROXY_BINDINGS: u32 = 67108864;
pub const ASC_REQ_ALLOW_MISSING_BINDINGS: u32 = 268435456;
pub const ASC_REQ_MESSAGES: u64 = 4294967296;
pub const ASC_RET_DELEGATE: u32 = 1;
pub const ASC_RET_MUTUAL_AUTH: u32 = 2;
pub const ASC_RET_REPLAY_DETECT: u32 = 4;
pub const ASC_RET_SEQUENCE_DETECT: u32 = 8;
pub const ASC_RET_CONFIDENTIALITY: u32 = 16;
pub const ASC_RET_USE_SESSION_KEY: u32 = 32;
pub const ASC_RET_SESSION_TICKET: u32 = 64;
pub const ASC_RET_ALLOCATED_MEMORY: u32 = 256;
pub const ASC_RET_USED_DCE_STYLE: u32 = 512;
pub const ASC_RET_DATAGRAM: u32 = 1024;
pub const ASC_RET_CONNECTION: u32 = 2048;
pub const ASC_RET_CALL_LEVEL: u32 = 8192;
pub const ASC_RET_THIRD_LEG_FAILED: u32 = 16384;
pub const ASC_RET_EXTENDED_ERROR: u32 = 32768;
pub const ASC_RET_STREAM: u32 = 65536;
pub const ASC_RET_INTEGRITY: u32 = 131072;
pub const ASC_RET_LICENSING: u32 = 262144;
pub const ASC_RET_IDENTIFY: u32 = 524288;
pub const ASC_RET_NULL_SESSION: u32 = 1048576;
pub const ASC_RET_ALLOW_NON_USER_LOGONS: u32 = 2097152;
pub const ASC_RET_ALLOW_CONTEXT_REPLAY: u32 = 4194304;
pub const ASC_RET_FRAGMENT_ONLY: u32 = 8388608;
pub const ASC_RET_NO_TOKEN: u32 = 16777216;
pub const ASC_RET_NO_ADDITIONAL_TOKEN: u32 = 33554432;
pub const ASC_RET_MESSAGES: u64 = 4294967296;
pub const SECPKG_CRED_ATTR_NAMES: u32 = 1;
pub const SECPKG_CRED_ATTR_SSI_PROVIDER: u32 = 2;
pub const SECPKG_CRED_ATTR_KDC_PROXY_SETTINGS: u32 = 3;
pub const SECPKG_CRED_ATTR_CERT: u32 = 4;
pub const SECPKG_CRED_ATTR_PAC_BYPASS: u32 = 5;
pub const KDC_PROXY_SETTINGS_V1: u32 = 1;
pub const KDC_PROXY_SETTINGS_FLAGS_FORCEPROXY: u32 = 1;
pub const SECPKG_ATTR_SIZES: u32 = 0;
pub const SECPKG_ATTR_NAMES: u32 = 1;
pub const SECPKG_ATTR_LIFESPAN: u32 = 2;
pub const SECPKG_ATTR_DCE_INFO: u32 = 3;
pub const SECPKG_ATTR_STREAM_SIZES: u32 = 4;
pub const SECPKG_ATTR_KEY_INFO: u32 = 5;
pub const SECPKG_ATTR_AUTHORITY: u32 = 6;
pub const SECPKG_ATTR_PROTO_INFO: u32 = 7;
pub const SECPKG_ATTR_PASSWORD_EXPIRY: u32 = 8;
pub const SECPKG_ATTR_SESSION_KEY: u32 = 9;
pub const SECPKG_ATTR_PACKAGE_INFO: u32 = 10;
pub const SECPKG_ATTR_USER_FLAGS: u32 = 11;
pub const SECPKG_ATTR_NEGOTIATION_INFO: u32 = 12;
pub const SECPKG_ATTR_NATIVE_NAMES: u32 = 13;
pub const SECPKG_ATTR_FLAGS: u32 = 14;
pub const SECPKG_ATTR_USE_VALIDATED: u32 = 15;
pub const SECPKG_ATTR_CREDENTIAL_NAME: u32 = 16;
pub const SECPKG_ATTR_TARGET_INFORMATION: u32 = 17;
pub const SECPKG_ATTR_ACCESS_TOKEN: u32 = 18;
pub const SECPKG_ATTR_TARGET: u32 = 19;
pub const SECPKG_ATTR_AUTHENTICATION_ID: u32 = 20;
pub const SECPKG_ATTR_LOGOFF_TIME: u32 = 21;
pub const SECPKG_ATTR_NEGO_KEYS: u32 = 22;
pub const SECPKG_ATTR_PROMPTING_NEEDED: u32 = 24;
pub const SECPKG_ATTR_UNIQUE_BINDINGS: u32 = 25;
pub const SECPKG_ATTR_ENDPOINT_BINDINGS: u32 = 26;
pub const SECPKG_ATTR_CLIENT_SPECIFIED_TARGET: u32 = 27;
pub const SECPKG_ATTR_LAST_CLIENT_TOKEN_STATUS: u32 = 30;
pub const SECPKG_ATTR_NEGO_PKG_INFO: u32 = 31;
pub const SECPKG_ATTR_NEGO_STATUS: u32 = 32;
pub const SECPKG_ATTR_CONTEXT_DELETED: u32 = 33;
pub const SECPKG_ATTR_DTLS_MTU: u32 = 34;
pub const SECPKG_ATTR_DATAGRAM_SIZES: u32 = 4;
pub const SECPKG_ATTR_SUBJECT_SECURITY_ATTRIBUTES: u32 = 128;
pub const SECPKG_ATTR_APPLICATION_PROTOCOL: u32 = 35;
pub const SECPKG_ATTR_NEGOTIATED_TLS_EXTENSIONS: u32 = 36;
pub const SECPKG_ATTR_IS_LOOPBACK: u32 = 37;
pub const SECPKG_ATTR_NEGO_INFO_FLAG_NO_KERBEROS: u32 = 1;
pub const SECPKG_ATTR_NEGO_INFO_FLAG_NO_NTLM: u32 = 2;
pub const SECPKG_CONTEXT_EXPORT_RESET_NEW: u32 = 1;
pub const SECPKG_CONTEXT_EXPORT_DELETE_OLD: u32 = 2;
pub const SECPKG_CONTEXT_EXPORT_TO_KERNEL: u32 = 4;
pub const SECQOP_WRAP_NO_ENCRYPT: u32 = 2147483649;
pub const SECQOP_WRAP_OOB_DATA: u32 = 1073741824;
pub const SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION: u32 = 1;
pub const SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION_2: u32 = 2;
pub const SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION_3: u32 = 3;
pub const SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION_4: u32 = 4;
pub const SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION_5: u32 = 5;
pub const SEC_WINNT_AUTH_IDENTITY_VERSION_2: u32 = 513;
pub const SEC_WINNT_AUTH_IDENTITY_ANSI: u32 = 1;
pub const SEC_WINNT_AUTH_IDENTITY_UNICODE: u32 = 2;
pub const SEC_WINNT_AUTH_IDENTITY_VERSION: u32 = 512;
pub const SEC_WINNT_AUTH_IDENTITY_MARSHALLED: u32 = 4;
pub const SEC_WINNT_AUTH_IDENTITY_ONLY: u32 = 8;
pub const UNDERSTANDS_LONG_NAMES: u32 = 1;
pub const NO_LONG_NAMES: u32 = 2;
pub const DD_MUP_DEVICE_NAME: &[u8; 12] = b"\\Device\\Mup\0";
pub const EA_NAME_NETWORK_OPEN_ECP_PRIVACY: &[u8; 52] =
    b"ECP{c584edbf-00df-4d28-00b8-8435baca8911e8}-PRIVACY\0";
pub const EA_NAME_NETWORK_OPEN_ECP_PRIVACY_U: &[u8; 52] =
    b"ECP{c584edbf-00df-4d28-00b8-8435baca8911e8}-PRIVACY\0";
pub const EA_NAME_NETWORK_OPEN_ECP_INTEGRITY: &[u8; 54] =
    b"ECP{c584edbf-00df-4d28-00b8-8435baca8911e8}-INTEGRITY\0";
pub const EA_NAME_NETWORK_OPEN_ECP_INTEGRITY_U: &[u8; 54] =
    b"ECP{c584edbf-00df-4d28-00b8-8435baca8911e8}-INTEGRITY\0";
pub const WNNC_NET_MSNET: u32 = 65536;
pub const WNNC_NET_SMB: u32 = 131072;
pub const WNNC_NET_NETWARE: u32 = 196608;
pub const WNNC_NET_VINES: u32 = 262144;
pub const WNNC_NET_10NET: u32 = 327680;
pub const WNNC_NET_LOCUS: u32 = 393216;
pub const WNNC_NET_SUN_PC_NFS: u32 = 458752;
pub const WNNC_NET_LANSTEP: u32 = 524288;
pub const WNNC_NET_9TILES: u32 = 589824;
pub const WNNC_NET_LANTASTIC: u32 = 655360;
pub const WNNC_NET_AS400: u32 = 720896;
pub const WNNC_NET_FTP_NFS: u32 = 786432;
pub const WNNC_NET_PATHWORKS: u32 = 851968;
pub const WNNC_NET_LIFENET: u32 = 917504;
pub const WNNC_NET_POWERLAN: u32 = 983040;
pub const WNNC_NET_BWNFS: u32 = 1048576;
pub const WNNC_NET_COGENT: u32 = 1114112;
pub const WNNC_NET_FARALLON: u32 = 1179648;
pub const WNNC_NET_APPLETALK: u32 = 1245184;
pub const WNNC_NET_INTERGRAPH: u32 = 1310720;
pub const WNNC_NET_SYMFONET: u32 = 1376256;
pub const WNNC_NET_CLEARCASE: u32 = 1441792;
pub const WNNC_NET_FRONTIER: u32 = 1507328;
pub const WNNC_NET_BMC: u32 = 1572864;
pub const WNNC_NET_DCE: u32 = 1638400;
pub const WNNC_NET_AVID: u32 = 1703936;
pub const WNNC_NET_DOCUSPACE: u32 = 1769472;
pub const WNNC_NET_MANGOSOFT: u32 = 1835008;
pub const WNNC_NET_SERNET: u32 = 1900544;
pub const WNNC_NET_RIVERFRONT1: u32 = 1966080;
pub const WNNC_NET_RIVERFRONT2: u32 = 2031616;
pub const WNNC_NET_DECORB: u32 = 2097152;
pub const WNNC_NET_PROTSTOR: u32 = 2162688;
pub const WNNC_NET_FJ_REDIR: u32 = 2228224;
pub const WNNC_NET_DISTINCT: u32 = 2293760;
pub const WNNC_NET_TWINS: u32 = 2359296;
pub const WNNC_NET_RDR2SAMPLE: u32 = 2424832;
pub const WNNC_NET_CSC: u32 = 2490368;
pub const WNNC_NET_3IN1: u32 = 2555904;
pub const WNNC_NET_EXTENDNET: u32 = 2686976;
pub const WNNC_NET_STAC: u32 = 2752512;
pub const WNNC_NET_FOXBAT: u32 = 2818048;
pub const WNNC_NET_YAHOO: u32 = 2883584;
pub const WNNC_NET_EXIFS: u32 = 2949120;
pub const WNNC_NET_DAV: u32 = 3014656;
pub const WNNC_NET_KNOWARE: u32 = 3080192;
pub const WNNC_NET_OBJECT_DIRE: u32 = 3145728;
pub const WNNC_NET_MASFAX: u32 = 3211264;
pub const WNNC_NET_HOB_NFS: u32 = 3276800;
pub const WNNC_NET_SHIVA: u32 = 3342336;
pub const WNNC_NET_IBMAL: u32 = 3407872;
pub const WNNC_NET_LOCK: u32 = 3473408;
pub const WNNC_NET_TERMSRV: u32 = 3538944;
pub const WNNC_NET_SRT: u32 = 3604480;
pub const WNNC_NET_QUINCY: u32 = 3670016;
pub const WNNC_NET_OPENAFS: u32 = 3735552;
pub const WNNC_NET_AVID1: u32 = 3801088;
pub const WNNC_NET_DFS: u32 = 3866624;
pub const WNNC_NET_KWNP: u32 = 3932160;
pub const WNNC_NET_ZENWORKS: u32 = 3997696;
pub const WNNC_NET_DRIVEONWEB: u32 = 4063232;
pub const WNNC_NET_VMWARE: u32 = 4128768;
pub const WNNC_NET_RSFX: u32 = 4194304;
pub const WNNC_NET_MFILES: u32 = 4259840;
pub const WNNC_NET_MS_NFS: u32 = 4325376;
pub const WNNC_NET_GOOGLE: u32 = 4390912;
pub const WNNC_NET_NDFS: u32 = 4456448;
pub const WNNC_NET_DOCUSHARE: u32 = 4521984;
pub const WNNC_NET_AURISTOR_FS: u32 = 4587520;
pub const WNNC_NET_SECUREAGENT: u32 = 4653056;
pub const WNNC_NET_9P: u32 = 4718592;
pub const WNNC_CRED_MANAGER: u32 = 4294901760;
pub const WNNC_NET_LANMAN: u32 = 131072;
pub const VOLSNAPCONTROLTYPE: u32 = 83;
pub type va_list = *mut core::ffi::c_char;
unsafe extern "C" {
    pub fn __va_start(arg1: *mut *mut core::ffi::c_char, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = core::ffi::c_ushort;
unsafe extern "C" {
    pub fn __security_init_cookie();
}
unsafe extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
unsafe extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
unsafe extern "C" {
    pub static mut __security_cookie: usize;
}
pub const _EXCEPTION_DISPOSITION_ExceptionContinueExecution: _EXCEPTION_DISPOSITION = 0;
pub const _EXCEPTION_DISPOSITION_ExceptionContinueSearch: _EXCEPTION_DISPOSITION = 1;
pub const _EXCEPTION_DISPOSITION_ExceptionNestedException: _EXCEPTION_DISPOSITION = 2;
pub const _EXCEPTION_DISPOSITION_ExceptionCollidedUnwind: _EXCEPTION_DISPOSITION = 3;
pub type _EXCEPTION_DISPOSITION = core::ffi::c_int;
pub use self::_EXCEPTION_DISPOSITION as EXCEPTION_DISPOSITION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_CONTEXT {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn __C_specific_handler(
        ExceptionRecord: *mut _EXCEPTION_RECORD,
        EstablisherFrame: *mut core::ffi::c_void,
        ContextRecord: *mut _CONTEXT,
        DispatcherContext: *mut _DISPATCHER_CONTEXT,
    ) -> EXCEPTION_DISPOSITION;
}
unsafe extern "C" {
    pub fn _exception_code() -> core::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn _exception_info() -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn _abnormal_termination() -> core::ffi::c_int;
}
pub type __crt_bool = bool;
unsafe extern "C" {
    pub fn _invalid_parameter_noinfo();
}
unsafe extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn() -> !;
}
unsafe extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: core::ffi::c_uint,
        _Reserved: usize,
    ) -> !;
}
pub type errno_t = core::ffi::c_int;
pub type wint_t = core::ffi::c_ushort;
pub type wctype_t = core::ffi::c_ushort;
pub type __time32_t = core::ffi::c_long;
pub type __time64_t = core::ffi::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const core::ffi::c_ushort,
    pub _locale_mb_cur_max: core::ffi::c_int,
    pub _locale_lc_codepage: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: core::ffi::c_ulong,
    pub _Byte: core::ffi::c_ushort,
    pub _State: core::ffi::c_ushort,
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
unsafe extern "C" {
    pub fn iswalnum(_C: wint_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn iswalpha(_C: wint_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn iswascii(_C: wint_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn iswblank(_C: wint_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn iswcntrl(_C: wint_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn iswdigit(_C: wint_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn iswgraph(_C: wint_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn iswlower(_C: wint_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn iswprint(_C: wint_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn iswpunct(_C: wint_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn iswspace(_C: wint_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn iswupper(_C: wint_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn iswxdigit(_C: wint_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __iswcsymf(_C: wint_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __iswcsym(_C: wint_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _iswalnum_l(_C: wint_t, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _iswalpha_l(_C: wint_t, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _iswblank_l(_C: wint_t, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _iswcntrl_l(_C: wint_t, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _iswdigit_l(_C: wint_t, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _iswgraph_l(_C: wint_t, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _iswlower_l(_C: wint_t, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _iswprint_l(_C: wint_t, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _iswpunct_l(_C: wint_t, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _iswspace_l(_C: wint_t, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _iswupper_l(_C: wint_t, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _iswxdigit_l(_C: wint_t, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _iswcsymf_l(_C: wint_t, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _iswcsym_l(_C: wint_t, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn towupper(_C: wint_t) -> wint_t;
}
unsafe extern "C" {
    pub fn towlower(_C: wint_t) -> wint_t;
}
unsafe extern "C" {
    pub fn iswctype(_C: wint_t, _Type: wctype_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _towupper_l(_C: wint_t, _Locale: _locale_t) -> wint_t;
}
unsafe extern "C" {
    pub fn _towlower_l(_C: wint_t, _Locale: _locale_t) -> wint_t;
}
unsafe extern "C" {
    pub fn _iswctype_l(_C: wint_t, _Type: wctype_t, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn isleadbyte(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _isleadbyte_l(_C: core::ffi::c_int, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn is_wctype(_C: wint_t, _Type: wctype_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _isctype(_C: core::ffi::c_int, _Type: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _isctype_l(
        _C: core::ffi::c_int,
        _Type: core::ffi::c_int,
        _Locale: _locale_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn isalpha(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _isalpha_l(_C: core::ffi::c_int, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn isupper(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _isupper_l(_C: core::ffi::c_int, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn islower(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _islower_l(_C: core::ffi::c_int, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn isdigit(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _isdigit_l(_C: core::ffi::c_int, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn isxdigit(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _isxdigit_l(_C: core::ffi::c_int, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn isspace(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _isspace_l(_C: core::ffi::c_int, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn ispunct(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _ispunct_l(_C: core::ffi::c_int, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn isblank(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _isblank_l(_C: core::ffi::c_int, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn isalnum(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _isalnum_l(_C: core::ffi::c_int, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn isprint(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _isprint_l(_C: core::ffi::c_int, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn isgraph(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _isgraph_l(_C: core::ffi::c_int, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn iscntrl(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _iscntrl_l(_C: core::ffi::c_int, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn toupper(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn tolower(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _tolower(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _tolower_l(_C: core::ffi::c_int, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _toupper(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _toupper_l(_C: core::ffi::c_int, _Locale: _locale_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __isascii(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __toascii(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __iscsymf(_C: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __iscsym(_C: core::ffi::c_int) -> core::ffi::c_int;
}
pub type POINTER_64_INT = core::ffi::c_ulonglong;
pub type INT8 = core::ffi::c_schar;
pub type PINT8 = *mut core::ffi::c_schar;
pub type INT16 = core::ffi::c_short;
pub type PINT16 = *mut core::ffi::c_short;
pub type INT32 = core::ffi::c_int;
pub type PINT32 = *mut core::ffi::c_int;
pub type INT64 = core::ffi::c_longlong;
pub type PINT64 = *mut core::ffi::c_longlong;
pub type UINT8 = core::ffi::c_uchar;
pub type PUINT8 = *mut core::ffi::c_uchar;
pub type UINT16 = core::ffi::c_ushort;
pub type PUINT16 = *mut core::ffi::c_ushort;
pub type UINT32 = core::ffi::c_uint;
pub type PUINT32 = *mut core::ffi::c_uint;
pub type UINT64 = core::ffi::c_ulonglong;
pub type PUINT64 = *mut core::ffi::c_ulonglong;
pub type LONG32 = core::ffi::c_int;
pub type PLONG32 = *mut core::ffi::c_int;
pub type ULONG32 = core::ffi::c_uint;
pub type PULONG32 = *mut core::ffi::c_uint;
pub type DWORD32 = core::ffi::c_uint;
pub type PDWORD32 = *mut core::ffi::c_uint;
pub type INT_PTR = core::ffi::c_longlong;
pub type PINT_PTR = *mut core::ffi::c_longlong;
pub type UINT_PTR = core::ffi::c_ulonglong;
pub type PUINT_PTR = *mut core::ffi::c_ulonglong;
pub type LONG_PTR = core::ffi::c_longlong;
pub type PLONG_PTR = *mut core::ffi::c_longlong;
pub type ULONG_PTR = core::ffi::c_ulonglong;
pub type PULONG_PTR = *mut core::ffi::c_ulonglong;
pub type PHANDLE64 = *mut *mut core::ffi::c_void;
pub type SHANDLE_PTR = core::ffi::c_longlong;
pub type HANDLE_PTR = core::ffi::c_ulonglong;
pub type UHALF_PTR = core::ffi::c_uint;
pub type PUHALF_PTR = *mut core::ffi::c_uint;
pub type HALF_PTR = core::ffi::c_int;
pub type PHALF_PTR = *mut core::ffi::c_int;
pub type SIZE_T = ULONG_PTR;
pub type PSIZE_T = *mut ULONG_PTR;
pub type SSIZE_T = LONG_PTR;
pub type PSSIZE_T = *mut LONG_PTR;
pub type DWORD_PTR = ULONG_PTR;
pub type PDWORD_PTR = *mut ULONG_PTR;
pub type LONG64 = core::ffi::c_longlong;
pub type PLONG64 = *mut core::ffi::c_longlong;
pub type ULONG64 = core::ffi::c_ulonglong;
pub type PULONG64 = *mut core::ffi::c_ulonglong;
pub type DWORD64 = core::ffi::c_ulonglong;
pub type PDWORD64 = *mut core::ffi::c_ulonglong;
pub type KAFFINITY = ULONG_PTR;
pub type PKAFFINITY = *mut KAFFINITY;
pub type CHAR = core::ffi::c_char;
pub type SHORT = core::ffi::c_short;
pub type LONG = core::ffi::c_long;
pub type INT = core::ffi::c_int;
pub type WCHAR = wchar_t;
pub type PWCHAR = *mut WCHAR;
pub type LPWCH = *mut WCHAR;
pub type PWCH = *mut WCHAR;
pub type LPCWCH = *const WCHAR;
pub type PCWCH = *const WCHAR;
pub type NWPSTR = *mut WCHAR;
pub type LPWSTR = *mut WCHAR;
pub type PWSTR = *mut WCHAR;
pub type PZPWSTR = *mut PWSTR;
pub type PCZPWSTR = *const PWSTR;
pub type LPUWSTR = *mut WCHAR;
pub type PUWSTR = *mut WCHAR;
pub type LPCWSTR = *const WCHAR;
pub type PCWSTR = *const WCHAR;
pub type PZPCWSTR = *mut PCWSTR;
pub type PCZPCWSTR = *const PCWSTR;
pub type LPCUWSTR = *const WCHAR;
pub type PCUWSTR = *const WCHAR;
pub type PZZWSTR = *mut WCHAR;
pub type PCZZWSTR = *const WCHAR;
pub type PUZZWSTR = *mut WCHAR;
pub type PCUZZWSTR = *const WCHAR;
pub type PNZWCH = *mut WCHAR;
pub type PCNZWCH = *const WCHAR;
pub type PUNZWCH = *mut WCHAR;
pub type PCUNZWCH = *const WCHAR;
pub type LPCWCHAR = *const WCHAR;
pub type PCWCHAR = *const WCHAR;
pub type LPCUWCHAR = *const WCHAR;
pub type PCUWCHAR = *const WCHAR;
pub type UCSCHAR = core::ffi::c_ulong;
pub type PUCSCHAR = *mut UCSCHAR;
pub type PCUCSCHAR = *const UCSCHAR;
pub type PUCSSTR = *mut UCSCHAR;
pub type PUUCSSTR = *mut UCSCHAR;
pub type PCUCSSTR = *const UCSCHAR;
pub type PCUUCSSTR = *const UCSCHAR;
pub type PUUCSCHAR = *mut UCSCHAR;
pub type PCUUCSCHAR = *const UCSCHAR;
pub type PCHAR = *mut CHAR;
pub type LPCH = *mut CHAR;
pub type PCH = *mut CHAR;
pub type LPCCH = *const CHAR;
pub type PCCH = *const CHAR;
pub type NPSTR = *mut CHAR;
pub type LPSTR = *mut CHAR;
pub type PSTR = *mut CHAR;
pub type PZPSTR = *mut PSTR;
pub type PCZPSTR = *const PSTR;
pub type LPCSTR = *const CHAR;
pub type PCSTR = *const CHAR;
pub type PZPCSTR = *mut PCSTR;
pub type PCZPCSTR = *const PCSTR;
pub type PZZSTR = *mut CHAR;
pub type PCZZSTR = *const CHAR;
pub type PNZCH = *mut CHAR;
pub type PCNZCH = *const CHAR;
pub type TCHAR = core::ffi::c_char;
pub type PTCHAR = *mut core::ffi::c_char;
pub type TUCHAR = core::ffi::c_uchar;
pub type PTUCHAR = *mut core::ffi::c_uchar;
pub type LPTCH = LPCH;
pub type PTCH = LPCH;
pub type LPCTCH = LPCCH;
pub type PCTCH = LPCCH;
pub type PTSTR = LPSTR;
pub type LPTSTR = LPSTR;
pub type PUTSTR = LPSTR;
pub type LPUTSTR = LPSTR;
pub type PCTSTR = LPCSTR;
pub type LPCTSTR = LPCSTR;
pub type PCUTSTR = LPCSTR;
pub type LPCUTSTR = LPCSTR;
pub type PZZTSTR = PZZSTR;
pub type PUZZTSTR = PZZSTR;
pub type PCZZTSTR = PCZZSTR;
pub type PCUZZTSTR = PCZZSTR;
pub type PZPTSTR = PZPSTR;
pub type PNZTCH = PNZCH;
pub type PUNZTCH = PNZCH;
pub type PCNZTCH = PCNZCH;
pub type PCUNZTCH = PCNZCH;
pub type DOUBLE = f64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _QUAD {
    pub __bindgen_anon_1: _QUAD__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _QUAD__bindgen_ty_1 {
    pub UseThisFieldToCopy: core::ffi::c_longlong,
    pub DoNotUseThisField: f64,
}
pub type QUAD = _QUAD;
pub type PSHORT = *mut SHORT;
pub type PLONG = *mut LONG;
pub type PQUAD = *mut QUAD;
pub type UCHAR = core::ffi::c_uchar;
pub type USHORT = core::ffi::c_ushort;
pub type ULONG = core::ffi::c_ulong;
pub type UQUAD = QUAD;
pub type PUCHAR = *mut UCHAR;
pub type PUSHORT = *mut USHORT;
pub type PULONG = *mut ULONG;
pub type PUQUAD = *mut UQUAD;
pub type PCUCHAR = *const UCHAR;
pub type PCUSHORT = *const USHORT;
pub type PCULONG = *const ULONG;
pub type PCUQUAD = *const UQUAD;
pub type SCHAR = core::ffi::c_schar;
pub type PSCHAR = *mut SCHAR;
pub type PCSCHAR = *const SCHAR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESSOR_NUMBER {
    pub Group: USHORT,
    pub Number: UCHAR,
    pub Reserved: UCHAR,
}
pub type PROCESSOR_NUMBER = _PROCESSOR_NUMBER;
pub type PPROCESSOR_NUMBER = *mut _PROCESSOR_NUMBER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GROUP_AFFINITY {
    pub Mask: KAFFINITY,
    pub Group: USHORT,
    pub Reserved: [USHORT; 3usize],
}
pub type GROUP_AFFINITY = _GROUP_AFFINITY;
pub type PGROUP_AFFINITY = *mut _GROUP_AFFINITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GROUP_AFFINITY32 {
    pub Mask: ULONG,
    pub Group: USHORT,
    pub Reserved: [USHORT; 3usize],
}
pub type GROUP_AFFINITY32 = _GROUP_AFFINITY32;
pub type PGROUP_AFFINITY32 = *mut _GROUP_AFFINITY32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GROUP_AFFINITY64 {
    pub Mask: core::ffi::c_ulonglong,
    pub Group: USHORT,
    pub Reserved: [USHORT; 3usize],
}
pub type GROUP_AFFINITY64 = _GROUP_AFFINITY64;
pub type PGROUP_AFFINITY64 = *mut _GROUP_AFFINITY64;
pub type HANDLE = *mut core::ffi::c_void;
pub type PHANDLE = *mut HANDLE;
pub type FCHAR = UCHAR;
pub type FSHORT = USHORT;
pub type FLONG = ULONG;
pub type HRESULT = core::ffi::c_long;
pub type CCHAR = core::ffi::c_char;
pub type CSHORT = core::ffi::c_short;
pub type CLONG = ULONG;
pub type PCCHAR = *mut CCHAR;
pub type PCSHORT = *mut CSHORT;
pub type PCLONG = *mut CLONG;
pub type LCID = ULONG;
pub type PLCID = PULONG;
pub type LANGID = USHORT;
pub const COMPARTMENT_ID_UNSPECIFIED_COMPARTMENT_ID: COMPARTMENT_ID = 0;
pub const COMPARTMENT_ID_DEFAULT_COMPARTMENT_ID: COMPARTMENT_ID = 1;
pub type COMPARTMENT_ID = core::ffi::c_int;
pub type PCOMPARTMENT_ID = *mut COMPARTMENT_ID;
pub type LOGICAL = ULONG;
pub type PLOGICAL = *mut ULONG;
pub type NTSTATUS = LONG;
pub type PNTSTATUS = *mut NTSTATUS;
pub type PCNTSTATUS = *const NTSTATUS;
pub type SECURITY_STATUS = core::ffi::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLOAT128 {
    pub LowPart: core::ffi::c_longlong,
    pub HighPart: core::ffi::c_longlong,
}
pub type FLOAT128 = _FLOAT128;
pub type PFLOAT128 = *mut FLOAT128;
pub type LONGLONG = core::ffi::c_longlong;
pub type ULONGLONG = core::ffi::c_ulonglong;
pub type PLONGLONG = *mut LONGLONG;
pub type PULONGLONG = *mut ULONGLONG;
pub type USN = LONGLONG;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LARGE_INTEGER {
    pub __bindgen_anon_1: _LARGE_INTEGER__bindgen_ty_1,
    pub u: _LARGE_INTEGER__bindgen_ty_2,
    pub QuadPart: LONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_1 {
    pub LowPart: ULONG,
    pub HighPart: LONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_2 {
    pub LowPart: ULONG,
    pub HighPart: LONG,
}
pub type LARGE_INTEGER = _LARGE_INTEGER;
pub type PLARGE_INTEGER = *mut LARGE_INTEGER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ULARGE_INTEGER {
    pub __bindgen_anon_1: _ULARGE_INTEGER__bindgen_ty_1,
    pub u: _ULARGE_INTEGER__bindgen_ty_2,
    pub QuadPart: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_1 {
    pub LowPart: ULONG,
    pub HighPart: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_2 {
    pub LowPart: ULONG,
    pub HighPart: ULONG,
}
pub type ULARGE_INTEGER = _ULARGE_INTEGER;
pub type PULARGE_INTEGER = *mut ULARGE_INTEGER;
pub type RTL_REFERENCE_COUNT = LONG_PTR;
pub type PRTL_REFERENCE_COUNT = *mut LONG_PTR;
pub type RTL_REFERENCE_COUNT32 = LONG;
pub type PRTL_REFERENCE_COUNT32 = *mut LONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LUID {
    pub LowPart: ULONG,
    pub HighPart: LONG,
}
pub type LUID = _LUID;
pub type PLUID = *mut _LUID;
pub type DWORDLONG = ULONGLONG;
pub type PDWORDLONG = *mut DWORDLONG;
pub type PHYSICAL_ADDRESS = LARGE_INTEGER;
pub type PPHYSICAL_ADDRESS = *mut LARGE_INTEGER;
unsafe extern "C" {
    pub fn _rotl8(Value: core::ffi::c_uchar, Shift: core::ffi::c_uchar) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _rotl16(Value: core::ffi::c_ushort, Shift: core::ffi::c_uchar) -> core::ffi::c_ushort;
}
unsafe extern "C" {
    pub fn _rotr8(Value: core::ffi::c_uchar, Shift: core::ffi::c_uchar) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _rotr16(Value: core::ffi::c_ushort, Shift: core::ffi::c_uchar) -> core::ffi::c_ushort;
}
unsafe extern "C" {
    pub fn _rotl(Value: core::ffi::c_uint, Shift: core::ffi::c_int) -> core::ffi::c_uint;
}
unsafe extern "C" {
    pub fn _rotl64(
        Value: core::ffi::c_ulonglong,
        Shift: core::ffi::c_int,
    ) -> core::ffi::c_ulonglong;
}
unsafe extern "C" {
    pub fn _rotr(Value: core::ffi::c_uint, Shift: core::ffi::c_int) -> core::ffi::c_uint;
}
unsafe extern "C" {
    pub fn _rotr64(
        Value: core::ffi::c_ulonglong,
        Shift: core::ffi::c_int,
    ) -> core::ffi::c_ulonglong;
}
pub const _EVENT_TYPE_NotificationEvent: _EVENT_TYPE = 0;
pub const _EVENT_TYPE_SynchronizationEvent: _EVENT_TYPE = 1;
pub type _EVENT_TYPE = core::ffi::c_int;
pub use self::_EVENT_TYPE as EVENT_TYPE;
pub const _TIMER_TYPE_NotificationTimer: _TIMER_TYPE = 0;
pub const _TIMER_TYPE_SynchronizationTimer: _TIMER_TYPE = 1;
pub type _TIMER_TYPE = core::ffi::c_int;
pub use self::_TIMER_TYPE as TIMER_TYPE;
pub const _WAIT_TYPE_WaitAll: _WAIT_TYPE = 0;
pub const _WAIT_TYPE_WaitAny: _WAIT_TYPE = 1;
pub const _WAIT_TYPE_WaitNotification: _WAIT_TYPE = 2;
pub const _WAIT_TYPE_WaitDequeue: _WAIT_TYPE = 3;
pub const _WAIT_TYPE_WaitDpc: _WAIT_TYPE = 4;
pub type _WAIT_TYPE = core::ffi::c_int;
pub use self::_WAIT_TYPE as WAIT_TYPE;
pub type PSZ = *mut CHAR;
pub type PCSZ = *const core::ffi::c_char;
pub type RTL_STRING_LENGTH_TYPE = USHORT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STRING {
    pub Length: USHORT,
    pub MaximumLength: USHORT,
    pub Buffer: PCHAR,
}
pub type STRING = _STRING;
pub type PSTRING = *mut STRING;
pub type ANSI_STRING = STRING;
pub type PANSI_STRING = PSTRING;
pub type OEM_STRING = STRING;
pub type POEM_STRING = PSTRING;
pub type PCOEM_STRING = *const STRING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CSTRING {
    pub Length: USHORT,
    pub MaximumLength: USHORT,
    pub Buffer: *const core::ffi::c_char,
}
pub type CSTRING = _CSTRING;
pub type PCSTRING = *mut CSTRING;
pub type CANSI_STRING = STRING;
pub type PCANSI_STRING = PSTRING;
pub type UTF8_STRING = STRING;
pub type PUTF8_STRING = PSTRING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UNICODE_STRING {
    pub Length: USHORT,
    pub MaximumLength: USHORT,
    pub Buffer: PWCH,
}
pub type UNICODE_STRING = _UNICODE_STRING;
pub type PUNICODE_STRING = *mut UNICODE_STRING;
pub type PCUNICODE_STRING = *const UNICODE_STRING;
pub type BOOLEAN = UCHAR;
pub type PBOOLEAN = *mut BOOLEAN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LIST_ENTRY {
    pub Flink: *mut _LIST_ENTRY,
    pub Blink: *mut _LIST_ENTRY,
}
pub type LIST_ENTRY = _LIST_ENTRY;
pub type PLIST_ENTRY = *mut _LIST_ENTRY;
pub type PRLIST_ENTRY = *mut _LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SINGLE_LIST_ENTRY {
    pub Next: *mut _SINGLE_LIST_ENTRY,
}
pub type SINGLE_LIST_ENTRY = _SINGLE_LIST_ENTRY;
pub type PSINGLE_LIST_ENTRY = *mut _SINGLE_LIST_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_BALANCED_NODE {
    pub __bindgen_anon_1: _RTL_BALANCED_NODE__bindgen_ty_1,
    pub __bindgen_anon_2: _RTL_BALANCED_NODE__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_BALANCED_NODE__bindgen_ty_1 {
    pub Children: [*mut _RTL_BALANCED_NODE; 2usize],
    pub __bindgen_anon_1: _RTL_BALANCED_NODE__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_BALANCED_NODE__bindgen_ty_1__bindgen_ty_1 {
    pub Left: *mut _RTL_BALANCED_NODE,
    pub Right: *mut _RTL_BALANCED_NODE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_BALANCED_NODE__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub ParentValue: ULONG_PTR,
}
impl _RTL_BALANCED_NODE__bindgen_ty_2 {
    #[inline]
    pub fn Red(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Red(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Red_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Red_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Balance(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Balance(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Balance_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Balance_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(Red: UCHAR, Balance: UCHAR) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Red: u8 = unsafe { ::core::mem::transmute(Red) };
            Red as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let Balance: u8 = unsafe { ::core::mem::transmute(Balance) };
            Balance as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type RTL_BALANCED_NODE = _RTL_BALANCED_NODE;
pub type PRTL_BALANCED_NODE = *mut _RTL_BALANCED_NODE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LIST_ENTRY32 {
    pub Flink: ULONG,
    pub Blink: ULONG,
}
pub type PLIST_ENTRY32 = *mut LIST_ENTRY32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LIST_ENTRY64 {
    pub Flink: ULONGLONG,
    pub Blink: ULONGLONG,
}
pub type PLIST_ENTRY64 = *mut LIST_ENTRY64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SINGLE_LIST_ENTRY32 {
    pub Next: ULONG,
}
pub type SINGLE_LIST_ENTRY32 = _SINGLE_LIST_ENTRY32;
pub type PSINGLE_LIST_ENTRY32 = *mut _SINGLE_LIST_ENTRY32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WNF_STATE_NAME {
    pub Data: [ULONG; 2usize],
}
pub type WNF_STATE_NAME = _WNF_STATE_NAME;
pub type PWNF_STATE_NAME = *mut _WNF_STATE_NAME;
pub type PCWNF_STATE_NAME = *const _WNF_STATE_NAME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STRING32 {
    pub Length: USHORT,
    pub MaximumLength: USHORT,
    pub Buffer: ULONG,
}
pub type STRING32 = _STRING32;
pub type PSTRING32 = *mut STRING32;
pub type UNICODE_STRING32 = STRING32;
pub type PUNICODE_STRING32 = *mut UNICODE_STRING32;
pub type ANSI_STRING32 = STRING32;
pub type PANSI_STRING32 = *mut ANSI_STRING32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STRING64 {
    pub Length: USHORT,
    pub MaximumLength: USHORT,
    pub Buffer: ULONGLONG,
}
pub type STRING64 = _STRING64;
pub type PSTRING64 = *mut STRING64;
pub type UNICODE_STRING64 = STRING64;
pub type PUNICODE_STRING64 = *mut UNICODE_STRING64;
pub type ANSI_STRING64 = STRING64;
pub type PANSI_STRING64 = *mut ANSI_STRING64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_ATTRIBUTES64 {
    pub Length: ULONG,
    pub RootDirectory: ULONG64,
    pub ObjectName: ULONG64,
    pub Attributes: ULONG,
    pub SecurityDescriptor: ULONG64,
    pub SecurityQualityOfService: ULONG64,
}
pub type OBJECT_ATTRIBUTES64 = _OBJECT_ATTRIBUTES64;
pub type POBJECT_ATTRIBUTES64 = *mut OBJECT_ATTRIBUTES64;
pub type PCOBJECT_ATTRIBUTES64 = *const OBJECT_ATTRIBUTES64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_ATTRIBUTES32 {
    pub Length: ULONG,
    pub RootDirectory: ULONG,
    pub ObjectName: ULONG,
    pub Attributes: ULONG,
    pub SecurityDescriptor: ULONG,
    pub SecurityQualityOfService: ULONG,
}
pub type OBJECT_ATTRIBUTES32 = _OBJECT_ATTRIBUTES32;
pub type POBJECT_ATTRIBUTES32 = *mut OBJECT_ATTRIBUTES32;
pub type PCOBJECT_ATTRIBUTES32 = *const OBJECT_ATTRIBUTES32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_ATTRIBUTES {
    pub Length: ULONG,
    pub RootDirectory: HANDLE,
    pub ObjectName: PUNICODE_STRING,
    pub Attributes: ULONG,
    pub SecurityDescriptor: PVOID,
    pub SecurityQualityOfService: PVOID,
}
pub type OBJECT_ATTRIBUTES = _OBJECT_ATTRIBUTES;
pub type POBJECT_ATTRIBUTES = *mut OBJECT_ATTRIBUTES;
pub type PCOBJECT_ATTRIBUTES = *const OBJECT_ATTRIBUTES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUID {
    pub Data1: core::ffi::c_ulong,
    pub Data2: core::ffi::c_ushort,
    pub Data3: core::ffi::c_ushort,
    pub Data4: [core::ffi::c_uchar; 8usize],
}
pub type GUID = _GUID;
pub type LPGUID = *mut GUID;
pub type LPCGUID = *const GUID;
pub type IID = GUID;
pub type LPIID = *mut IID;
pub type CLSID = GUID;
pub type LPCLSID = *mut CLSID;
pub type FMTID = GUID;
pub type LPFMTID = *mut FMTID;
unsafe extern "C" {
    pub fn _errno() -> *mut core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _set_errno(_Value: core::ffi::c_int) -> errno_t;
}
unsafe extern "C" {
    pub fn _get_errno(_Value: *mut core::ffi::c_int) -> errno_t;
}
unsafe extern "C" {
    pub fn __doserrno() -> *mut core::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn _set_doserrno(_Value: core::ffi::c_ulong) -> errno_t;
}
unsafe extern "C" {
    pub fn _get_doserrno(_Value: *mut core::ffi::c_ulong) -> errno_t;
}
unsafe extern "C" {
    pub fn memchr(
        _Buf: *const core::ffi::c_void,
        _Val: core::ffi::c_int,
        _MaxCount: core::ffi::c_ulonglong,
    ) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn memcmp(
        _Buf1: *const core::ffi::c_void,
        _Buf2: *const core::ffi::c_void,
        _Size: core::ffi::c_ulonglong,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn memcpy(
        _Dst: *mut core::ffi::c_void,
        _Src: *const core::ffi::c_void,
        _Size: core::ffi::c_ulonglong,
    ) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn memmove(
        _Dst: *mut core::ffi::c_void,
        _Src: *const core::ffi::c_void,
        _Size: core::ffi::c_ulonglong,
    ) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn memset(
        _Dst: *mut core::ffi::c_void,
        _Val: core::ffi::c_int,
        _Size: core::ffi::c_ulonglong,
    ) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn strchr(_Str: *const core::ffi::c_char, _Val: core::ffi::c_int)
                  -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strrchr(_Str: *const core::ffi::c_char, _Ch: core::ffi::c_int)
                   -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strstr(
        _Str: *const core::ffi::c_char,
        _SubStr: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn wcschr(
        _Str: *const core::ffi::c_ushort,
        _Ch: core::ffi::c_ushort,
    ) -> *mut core::ffi::c_ushort;
}
unsafe extern "C" {
    pub fn wcsrchr(_Str: *const wchar_t, _Ch: wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcsstr(_Str: *const wchar_t, _SubStr: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn _memicmp(
        _Buf1: *const core::ffi::c_void,
        _Buf2: *const core::ffi::c_void,
        _Size: usize,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _memicmp_l(
        _Buf1: *const core::ffi::c_void,
        _Buf2: *const core::ffi::c_void,
        _Size: usize,
        _Locale: _locale_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn memccpy(
        _Dst: *mut core::ffi::c_void,
        _Src: *const core::ffi::c_void,
        _Val: core::ffi::c_int,
        _Size: core::ffi::c_ulonglong,
    ) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn memicmp(
        _Buf1: *const core::ffi::c_void,
        _Buf2: *const core::ffi::c_void,
        _Size: usize,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wcscat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn wcscpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn wcsncat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn wcsncpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn wcstok_s(
        _String: *mut wchar_t,
        _Delimiter: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn _wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcscat(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcscmp(
        _String1: *const core::ffi::c_ushort,
        _String2: *const core::ffi::c_ushort,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wcscpy(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcscspn(_String: *const wchar_t, _Control: *const wchar_t) -> usize;
}
unsafe extern "C" {
    pub fn wcslen(_String: *const core::ffi::c_ushort) -> core::ffi::c_ulonglong;
}
unsafe extern "C" {
    pub fn wcsnlen(_Source: *const wchar_t, _MaxCount: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcsncat(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: usize,
    ) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcsncmp(
        _String1: *const core::ffi::c_ushort,
        _String2: *const core::ffi::c_ushort,
        _MaxCount: core::ffi::c_ulonglong,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wcsncpy(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: usize,
    ) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcspbrk(_String: *const wchar_t, _Control: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcsspn(_String: *const wchar_t, _Control: *const wchar_t) -> usize;
}
unsafe extern "C" {
    pub fn wcstok(
        _String: *mut wchar_t,
        _Delimiter: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn _wcserror(_ErrorNumber: core::ffi::c_int) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn _wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _ErrorNumber: core::ffi::c_int,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn __wcserror(_String: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn __wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _ErrorMessage: *const wchar_t,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn _wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _wcsicmp_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _wcsnicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _wcsnicmp_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _wcsnset_s(
        _Destination: *mut wchar_t,
        _SizeInWords: usize,
        _Value: wchar_t,
        _MaxCount: usize,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn _wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: usize) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn _wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn _wcsset_s(_Destination: *mut wchar_t, _SizeInWords: usize, _Value: wchar_t) -> errno_t;
}
unsafe extern "C" {
    pub fn _wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn _wcslwr_s(_String: *mut wchar_t, _SizeInWords: usize) -> errno_t;
}
unsafe extern "C" {
    pub fn _wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn _wcslwr_s_l(_String: *mut wchar_t, _SizeInWords: usize, _Locale: _locale_t) -> errno_t;
}
unsafe extern "C" {
    pub fn _wcslwr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn _wcsupr_s(_String: *mut wchar_t, _Size: usize) -> errno_t;
}
unsafe extern "C" {
    pub fn _wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn _wcsupr_s_l(_String: *mut wchar_t, _Size: usize, _Locale: _locale_t) -> errno_t;
}
unsafe extern "C" {
    pub fn _wcsupr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcsxfrm(_Destination: *mut wchar_t, _Source: *const wchar_t, _MaxCount: usize) -> usize;
}
unsafe extern "C" {
    pub fn _wcsxfrm_l(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn wcscoll(_String1: *const wchar_t, _String2: *const wchar_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _wcscoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _wcsicoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _wcsncoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _wcsncoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _wcsnicoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _wcsnicoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wcsnicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: usize) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
unsafe extern "C" {
    pub fn wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn strcpy_s(
        _Destination: *mut core::ffi::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const core::ffi::c_char,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn strcat_s(
        _Destination: *mut core::ffi::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const core::ffi::c_char,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn strerror_s(
        _Buffer: *mut core::ffi::c_char,
        _SizeInBytes: usize,
        _ErrorNumber: core::ffi::c_int,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn strncat_s(
        _Destination: *mut core::ffi::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const core::ffi::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn strncpy_s(
        _Destination: *mut core::ffi::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const core::ffi::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn strtok_s(
        _String: *mut core::ffi::c_char,
        _Delimiter: *const core::ffi::c_char,
        _Context: *mut *mut core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _memccpy(
        _Dst: *mut core::ffi::c_void,
        _Src: *const core::ffi::c_void,
        _Val: core::ffi::c_int,
        _MaxCount: usize,
    ) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn strcat(
        _Destination: *mut core::ffi::c_char,
        _Source: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strcmp(
        _Str1: *const core::ffi::c_char,
        _Str2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _strcmpi(
        _String1: *const core::ffi::c_char,
        _String2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn strcoll(
        _String1: *const core::ffi::c_char,
        _String2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _strcoll_l(
        _String1: *const core::ffi::c_char,
        _String2: *const core::ffi::c_char,
        _Locale: _locale_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn strcpy(
        _Destination: *mut core::ffi::c_char,
        _Source: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strcspn(
        _Str: *const core::ffi::c_char,
        _Control: *const core::ffi::c_char,
    ) -> core::ffi::c_ulonglong;
}
unsafe extern "C" {
    pub fn _strdup(_Source: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _strerror(_ErrorMessage: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _strerror_s(
        _Buffer: *mut core::ffi::c_char,
        _SizeInBytes: usize,
        _ErrorMessage: *const core::ffi::c_char,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn strerror(_ErrorMessage: core::ffi::c_int) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _stricmp(
        _String1: *const core::ffi::c_char,
        _String2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _stricoll(
        _String1: *const core::ffi::c_char,
        _String2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _stricoll_l(
        _String1: *const core::ffi::c_char,
        _String2: *const core::ffi::c_char,
        _Locale: _locale_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _stricmp_l(
        _String1: *const core::ffi::c_char,
        _String2: *const core::ffi::c_char,
        _Locale: _locale_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn strlen(_Str: *const core::ffi::c_char) -> core::ffi::c_ulonglong;
}
unsafe extern "C" {
    pub fn _strlwr_s(_String: *mut core::ffi::c_char, _Size: usize) -> errno_t;
}
unsafe extern "C" {
    pub fn _strlwr(_String: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _strlwr_s_l(
        _String: *mut core::ffi::c_char,
        _Size: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn _strlwr_l(_String: *mut core::ffi::c_char, _Locale: _locale_t)
                     -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strncat(
        _Destination: *mut core::ffi::c_char,
        _Source: *const core::ffi::c_char,
        _Count: core::ffi::c_ulonglong,
    ) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strncmp(
        _Str1: *const core::ffi::c_char,
        _Str2: *const core::ffi::c_char,
        _MaxCount: core::ffi::c_ulonglong,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _strnicmp(
        _String1: *const core::ffi::c_char,
        _String2: *const core::ffi::c_char,
        _MaxCount: usize,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _strnicmp_l(
        _String1: *const core::ffi::c_char,
        _String2: *const core::ffi::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _strnicoll(
        _String1: *const core::ffi::c_char,
        _String2: *const core::ffi::c_char,
        _MaxCount: usize,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _strnicoll_l(
        _String1: *const core::ffi::c_char,
        _String2: *const core::ffi::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _strncoll(
        _String1: *const core::ffi::c_char,
        _String2: *const core::ffi::c_char,
        _MaxCount: usize,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _strncoll_l(
        _String1: *const core::ffi::c_char,
        _String2: *const core::ffi::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __strncnt(_String: *const core::ffi::c_char, _Count: usize) -> usize;
}
unsafe extern "C" {
    pub fn strncpy(
        _Destination: *mut core::ffi::c_char,
        _Source: *const core::ffi::c_char,
        _Count: core::ffi::c_ulonglong,
    ) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strnlen(_String: *const core::ffi::c_char, _MaxCount: usize) -> usize;
}
unsafe extern "C" {
    pub fn _strnset_s(
        _String: *mut core::ffi::c_char,
        _SizeInBytes: usize,
        _Value: core::ffi::c_int,
        _MaxCount: usize,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn _strnset(
        _Destination: *mut core::ffi::c_char,
        _Value: core::ffi::c_int,
        _Count: usize,
    ) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strpbrk(
        _Str: *const core::ffi::c_char,
        _Control: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _strrev(_Str: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _strset_s(
        _Destination: *mut core::ffi::c_char,
        _DestinationSize: usize,
        _Value: core::ffi::c_int,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn _strset(
        _Destination: *mut core::ffi::c_char,
        _Value: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strspn(
        _Str: *const core::ffi::c_char,
        _Control: *const core::ffi::c_char,
    ) -> core::ffi::c_ulonglong;
}
unsafe extern "C" {
    pub fn strtok(
        _String: *mut core::ffi::c_char,
        _Delimiter: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _strupr_s(_String: *mut core::ffi::c_char, _Size: usize) -> errno_t;
}
unsafe extern "C" {
    pub fn _strupr(_String: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _strupr_s_l(
        _String: *mut core::ffi::c_char,
        _Size: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn _strupr_l(_String: *mut core::ffi::c_char, _Locale: _locale_t)
                     -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strxfrm(
        _Destination: *mut core::ffi::c_char,
        _Source: *const core::ffi::c_char,
        _MaxCount: core::ffi::c_ulonglong,
    ) -> core::ffi::c_ulonglong;
}
unsafe extern "C" {
    pub fn _strxfrm_l(
        _Destination: *mut core::ffi::c_char,
        _Source: *const core::ffi::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strdup(_String: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strcmpi(
        _String1: *const core::ffi::c_char,
        _String2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn stricmp(
        _String1: *const core::ffi::c_char,
        _String2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn strlwr(_String: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strnicmp(
        _String1: *const core::ffi::c_char,
        _String2: *const core::ffi::c_char,
        _MaxCount: usize,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn strnset(
        _String: *mut core::ffi::c_char,
        _Value: core::ffi::c_int,
        _MaxCount: usize,
    ) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strrev(_String: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strset(
        _String: *mut core::ffi::c_char,
        _Value: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strupr(_String: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECTID {
    pub Lineage: GUID,
    pub Uniquifier: ULONG,
}
pub type OBJECTID = _OBJECTID;
unsafe extern "C" {
    pub fn _RTL_CONSTANT_STRING_type_check(s: *const core::ffi::c_void) -> core::ffi::c_char;
}
pub type PEXCEPTION_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut _EXCEPTION_RECORD,
        arg2: PVOID,
        arg3: *mut _CONTEXT,
        arg4: PVOID,
    ) -> EXCEPTION_DISPOSITION,
>;
pub type KIRQL = UCHAR;
pub type PKIRQL = *mut KIRQL;
pub const _NT_PRODUCT_TYPE_NtProductWinNt: _NT_PRODUCT_TYPE = 1;
pub const _NT_PRODUCT_TYPE_NtProductLanManNt: _NT_PRODUCT_TYPE = 2;
pub const _NT_PRODUCT_TYPE_NtProductServer: _NT_PRODUCT_TYPE = 3;
pub type _NT_PRODUCT_TYPE = core::ffi::c_int;
pub use self::_NT_PRODUCT_TYPE as NT_PRODUCT_TYPE;
pub type PNT_PRODUCT_TYPE = *mut _NT_PRODUCT_TYPE;
pub const _SUITE_TYPE_SmallBusiness: _SUITE_TYPE = 0;
pub const _SUITE_TYPE_Enterprise: _SUITE_TYPE = 1;
pub const _SUITE_TYPE_BackOffice: _SUITE_TYPE = 2;
pub const _SUITE_TYPE_CommunicationServer: _SUITE_TYPE = 3;
pub const _SUITE_TYPE_TerminalServer: _SUITE_TYPE = 4;
pub const _SUITE_TYPE_SmallBusinessRestricted: _SUITE_TYPE = 5;
pub const _SUITE_TYPE_EmbeddedNT: _SUITE_TYPE = 6;
pub const _SUITE_TYPE_DataCenter: _SUITE_TYPE = 7;
pub const _SUITE_TYPE_SingleUserTS: _SUITE_TYPE = 8;
pub const _SUITE_TYPE_Personal: _SUITE_TYPE = 9;
pub const _SUITE_TYPE_Blade: _SUITE_TYPE = 10;
pub const _SUITE_TYPE_EmbeddedRestricted: _SUITE_TYPE = 11;
pub const _SUITE_TYPE_SecurityAppliance: _SUITE_TYPE = 12;
pub const _SUITE_TYPE_StorageServer: _SUITE_TYPE = 13;
pub const _SUITE_TYPE_ComputeServer: _SUITE_TYPE = 14;
pub const _SUITE_TYPE_WHServer: _SUITE_TYPE = 15;
pub const _SUITE_TYPE_PhoneNT: _SUITE_TYPE = 16;
pub const _SUITE_TYPE_MultiUserTS: _SUITE_TYPE = 17;
pub const _SUITE_TYPE_MaxSuiteType: _SUITE_TYPE = 18;
pub type _SUITE_TYPE = core::ffi::c_int;
pub use self::_SUITE_TYPE as SUITE_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _bindgen_ty_1 {
    pub x: core::ffi::c_char,
    pub test: LARGE_INTEGER,
}
pub type __C_ASSERT__ = [core::ffi::c_char; 1usize];
pub type __prefast_analysis_mode_flag0 = core::ffi::c_int;
pub type __prefast_analysis_mode_flag1 = core::ffi::c_int;
pub type PACCESS_STATE = *mut _ACCESS_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CALLBACK_OBJECT {
    _unused: [u8; 0],
}
pub type PCALLBACK_OBJECT = *mut _CALLBACK_OBJECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KPROCESS {
    _unused: [u8; 0],
}
pub type PEPROCESS = *mut _KPROCESS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTHREAD {
    _unused: [u8; 0],
}
pub type PETHREAD = *mut _KTHREAD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_TIMER {
    _unused: [u8; 0],
}
pub type PIO_TIMER = *mut _IO_TIMER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KINTERRUPT {
    _unused: [u8; 0],
}
pub type PKINTERRUPT = *mut _KINTERRUPT;
pub type PKTHREAD = *mut _KTHREAD;
pub type PRKTHREAD = *mut _KTHREAD;
pub type PKPROCESS = *mut _KPROCESS;
pub type PRKPROCESS = *mut _KPROCESS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_TYPE {
    _unused: [u8; 0],
}
pub type POBJECT_TYPE = *mut _OBJECT_TYPE;
pub type PSECURITY_QUALITY_OF_SERVICE = *mut _SECURITY_QUALITY_OF_SERVICE;
pub type PCONTEXT = *mut _CONTEXT;
pub type PIO_STACK_LOCATION = *mut _IO_STACK_LOCATION;
pub type PVPB = *mut _VPB;
pub type PFILE_GET_QUOTA_INFORMATION = *mut _FILE_GET_QUOTA_INFORMATION;
unsafe extern "C" {
    pub fn __readgsqword(Offset: core::ffi::c_ulong) -> core::ffi::c_ulonglong;
}
pub const MCA_EXCEPTION_TYPE_HAL_MCE_RECORD: MCA_EXCEPTION_TYPE = 0;
pub const MCA_EXCEPTION_TYPE_HAL_MCA_RECORD: MCA_EXCEPTION_TYPE = 1;
pub type MCA_EXCEPTION_TYPE = core::ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MCI_ADDR {
    pub __bindgen_anon_1: _MCI_ADDR__bindgen_ty_1,
    pub QuadPart: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MCI_ADDR__bindgen_ty_1 {
    pub Address: ULONG,
    pub Reserved: ULONG,
}
pub type MCI_ADDR = _MCI_ADDR;
pub type PMCI_ADDR = *mut _MCI_ADDR;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MCI_STATS {
    pub MciStatus: _MCI_STATS__bindgen_ty_1,
    pub QuadPart: ULONG64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MCI_STATS__bindgen_ty_1 {
    pub McaErrorCode: USHORT,
    pub ModelErrorCode: USHORT,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _MCI_STATS__bindgen_ty_1 {
    #[inline]
    pub fn OtherInformation(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set_OtherInformation(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn OtherInformation_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                25u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_OtherInformation_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                25u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ContextCorrupt(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ContextCorrupt(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ContextCorrupt_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ContextCorrupt_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AddressValid(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AddressValid(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AddressValid_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AddressValid_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MiscValid(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MiscValid(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MiscValid_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MiscValid_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ErrorEnabled(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ErrorEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ErrorEnabled_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ErrorEnabled_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectedError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectedError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectedError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                29usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectedError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                29usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn StatusOverFlow(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_StatusOverFlow(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn StatusOverFlow_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_StatusOverFlow_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Valid(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Valid(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Valid_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Valid_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OtherInformation: ULONG,
        ContextCorrupt: ULONG,
        AddressValid: ULONG,
        MiscValid: ULONG,
        ErrorEnabled: ULONG,
        UncorrectedError: ULONG,
        StatusOverFlow: ULONG,
        Valid: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 25u8, {
            let OtherInformation: u32 = unsafe { ::core::mem::transmute(OtherInformation) };
            OtherInformation as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let ContextCorrupt: u32 = unsafe { ::core::mem::transmute(ContextCorrupt) };
            ContextCorrupt as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let AddressValid: u32 = unsafe { ::core::mem::transmute(AddressValid) };
            AddressValid as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let MiscValid: u32 = unsafe { ::core::mem::transmute(MiscValid) };
            MiscValid as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let ErrorEnabled: u32 = unsafe { ::core::mem::transmute(ErrorEnabled) };
            ErrorEnabled as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let UncorrectedError: u32 = unsafe { ::core::mem::transmute(UncorrectedError) };
            UncorrectedError as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let StatusOverFlow: u32 = unsafe { ::core::mem::transmute(StatusOverFlow) };
            StatusOverFlow as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let Valid: u32 = unsafe { ::core::mem::transmute(Valid) };
            Valid as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type MCI_STATS = _MCI_STATS;
pub type PMCI_STATS = *mut _MCI_STATS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MCA_EXCEPTION {
    pub VersionNumber: ULONG,
    pub ExceptionType: MCA_EXCEPTION_TYPE,
    pub TimeStamp: LARGE_INTEGER,
    pub ProcessorNumber: ULONG,
    pub Reserved1: ULONG,
    pub u: _MCA_EXCEPTION__bindgen_ty_1,
    pub ExtCnt: ULONG,
    pub Reserved3: ULONG,
    pub ExtReg: [ULONGLONG; 24usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MCA_EXCEPTION__bindgen_ty_1 {
    pub Mca: _MCA_EXCEPTION__bindgen_ty_1__bindgen_ty_1,
    pub Mce: _MCA_EXCEPTION__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MCA_EXCEPTION__bindgen_ty_1__bindgen_ty_1 {
    pub BankNumber: UCHAR,
    pub Reserved2: [UCHAR; 7usize],
    pub Status: MCI_STATS,
    pub Address: MCI_ADDR,
    pub Misc: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MCA_EXCEPTION__bindgen_ty_1__bindgen_ty_2 {
    pub Address: ULONGLONG,
    pub Type: ULONGLONG,
}
pub type MCA_EXCEPTION = _MCA_EXCEPTION;
pub type PMCA_EXCEPTION = *mut _MCA_EXCEPTION;
pub type CMC_EXCEPTION = MCA_EXCEPTION;
pub type PCMC_EXCEPTION = *mut MCA_EXCEPTION;
pub type CPE_EXCEPTION = MCA_EXCEPTION;
pub type PCPE_EXCEPTION = *mut MCA_EXCEPTION;
pub type ERROR_SEVERITY = UCHAR;
pub type PERROR_SEVERITY = *mut UCHAR;
pub const _ERROR_SEVERITY_VALUE_ErrorRecoverable: _ERROR_SEVERITY_VALUE = 0;
pub const _ERROR_SEVERITY_VALUE_ErrorFatal: _ERROR_SEVERITY_VALUE = 1;
pub const _ERROR_SEVERITY_VALUE_ErrorCorrected: _ERROR_SEVERITY_VALUE = 2;
pub const _ERROR_SEVERITY_VALUE_ErrorOthers: _ERROR_SEVERITY_VALUE = 3;
pub type _ERROR_SEVERITY_VALUE = core::ffi::c_int;
pub use self::_ERROR_SEVERITY_VALUE as ERROR_SEVERITY_VALUE;
unsafe extern "C" {
    pub static mut KeNumberProcessors: CCHAR;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KSYSTEM_TIME {
    pub LowPart: ULONG,
    pub High1Time: LONG,
    pub High2Time: LONG,
}
pub type KSYSTEM_TIME = _KSYSTEM_TIME;
pub type PKSYSTEM_TIME = *mut _KSYSTEM_TIME;
pub type KPRIORITY = LONG;
pub type KSPIN_LOCK = ULONG_PTR;
pub type PKSPIN_LOCK = *mut KSPIN_LOCK;
pub type KSPIN_LOCK_QUEUE_NUMBER = ULONG64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KSPIN_LOCK_QUEUE {
    pub Next: *mut _KSPIN_LOCK_QUEUE,
    pub Lock: PKSPIN_LOCK,
}
pub type KSPIN_LOCK_QUEUE = _KSPIN_LOCK_QUEUE;
pub type PKSPIN_LOCK_QUEUE = *mut _KSPIN_LOCK_QUEUE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KLOCK_QUEUE_HANDLE {
    pub LockQueue: KSPIN_LOCK_QUEUE,
    pub OldIrql: KIRQL,
}
pub type KLOCK_QUEUE_HANDLE = _KLOCK_QUEUE_HANDLE;
pub type PKLOCK_QUEUE_HANDLE = *mut _KLOCK_QUEUE_HANDLE;
pub const _KPROFILE_SOURCE_ProfileTime: _KPROFILE_SOURCE = 0;
pub const _KPROFILE_SOURCE_ProfileAlignmentFixup: _KPROFILE_SOURCE = 1;
pub const _KPROFILE_SOURCE_ProfileTotalIssues: _KPROFILE_SOURCE = 2;
pub const _KPROFILE_SOURCE_ProfilePipelineDry: _KPROFILE_SOURCE = 3;
pub const _KPROFILE_SOURCE_ProfileLoadInstructions: _KPROFILE_SOURCE = 4;
pub const _KPROFILE_SOURCE_ProfilePipelineFrozen: _KPROFILE_SOURCE = 5;
pub const _KPROFILE_SOURCE_ProfileBranchInstructions: _KPROFILE_SOURCE = 6;
pub const _KPROFILE_SOURCE_ProfileTotalNonissues: _KPROFILE_SOURCE = 7;
pub const _KPROFILE_SOURCE_ProfileDcacheMisses: _KPROFILE_SOURCE = 8;
pub const _KPROFILE_SOURCE_ProfileIcacheMisses: _KPROFILE_SOURCE = 9;
pub const _KPROFILE_SOURCE_ProfileCacheMisses: _KPROFILE_SOURCE = 10;
pub const _KPROFILE_SOURCE_ProfileBranchMispredictions: _KPROFILE_SOURCE = 11;
pub const _KPROFILE_SOURCE_ProfileStoreInstructions: _KPROFILE_SOURCE = 12;
pub const _KPROFILE_SOURCE_ProfileFpInstructions: _KPROFILE_SOURCE = 13;
pub const _KPROFILE_SOURCE_ProfileIntegerInstructions: _KPROFILE_SOURCE = 14;
pub const _KPROFILE_SOURCE_Profile2Issue: _KPROFILE_SOURCE = 15;
pub const _KPROFILE_SOURCE_Profile3Issue: _KPROFILE_SOURCE = 16;
pub const _KPROFILE_SOURCE_Profile4Issue: _KPROFILE_SOURCE = 17;
pub const _KPROFILE_SOURCE_ProfileSpecialInstructions: _KPROFILE_SOURCE = 18;
pub const _KPROFILE_SOURCE_ProfileTotalCycles: _KPROFILE_SOURCE = 19;
pub const _KPROFILE_SOURCE_ProfileIcacheIssues: _KPROFILE_SOURCE = 20;
pub const _KPROFILE_SOURCE_ProfileDcacheAccesses: _KPROFILE_SOURCE = 21;
pub const _KPROFILE_SOURCE_ProfileMemoryBarrierCycles: _KPROFILE_SOURCE = 22;
pub const _KPROFILE_SOURCE_ProfileLoadLinkedIssues: _KPROFILE_SOURCE = 23;
pub const _KPROFILE_SOURCE_ProfileMaximum: _KPROFILE_SOURCE = 24;
pub type _KPROFILE_SOURCE = core::ffi::c_int;
pub use self::_KPROFILE_SOURCE as KPROFILE_SOURCE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DPC_WATCHDOG_GLOBAL_TRIAGE_BLOCK {
    pub Signature: ULONG,
    pub Revision: USHORT,
    pub Size: USHORT,
    pub DpcWatchdogProfileOffset: USHORT,
    pub DpcWatchdogProfileLength: ULONG,
}
pub type DPC_WATCHDOG_GLOBAL_TRIAGE_BLOCK = _DPC_WATCHDOG_GLOBAL_TRIAGE_BLOCK;
pub type PDPC_WATCHDOG_GLOBAL_TRIAGE_BLOCK = *mut _DPC_WATCHDOG_GLOBAL_TRIAGE_BLOCK;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _M128A {
    pub Low: ULONGLONG,
    pub High: LONGLONG,
}
pub type M128A = _M128A;
pub type PM128A = *mut _M128A;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _XSAVE_FORMAT {
    pub ControlWord: USHORT,
    pub StatusWord: USHORT,
    pub TagWord: UCHAR,
    pub Reserved1: UCHAR,
    pub ErrorOpcode: USHORT,
    pub ErrorOffset: ULONG,
    pub ErrorSelector: USHORT,
    pub Reserved2: USHORT,
    pub DataOffset: ULONG,
    pub DataSelector: USHORT,
    pub Reserved3: USHORT,
    pub MxCsr: ULONG,
    pub MxCsr_Mask: ULONG,
    pub FloatRegisters: [M128A; 8usize],
    pub XmmRegisters: [M128A; 16usize],
    pub Reserved4: [UCHAR; 96usize],
}
pub type XSAVE_FORMAT = _XSAVE_FORMAT;
pub type PXSAVE_FORMAT = *mut _XSAVE_FORMAT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XSAVE_CET_U_FORMAT {
    pub Ia32CetUMsr: ULONG64,
    pub Ia32Pl3SspMsr: ULONG64,
}
pub type XSAVE_CET_U_FORMAT = _XSAVE_CET_U_FORMAT;
pub type PXSAVE_CET_U_FORMAT = *mut _XSAVE_CET_U_FORMAT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XSAVE_AREA_HEADER {
    pub Mask: ULONG64,
    pub CompactionMask: ULONG64,
    pub Reserved2: [ULONG64; 6usize],
}
pub type XSAVE_AREA_HEADER = _XSAVE_AREA_HEADER;
pub type PXSAVE_AREA_HEADER = *mut _XSAVE_AREA_HEADER;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _XSAVE_AREA {
    pub LegacyState: XSAVE_FORMAT,
    pub Header: XSAVE_AREA_HEADER,
}
pub type XSAVE_AREA = _XSAVE_AREA;
pub type PXSAVE_AREA = *mut _XSAVE_AREA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XSTATE_CONTEXT {
    pub Mask: ULONG64,
    pub Length: ULONG,
    pub Reserved1: ULONG,
    pub Area: PXSAVE_AREA,
    pub Buffer: PVOID,
}
pub type XSTATE_CONTEXT = _XSTATE_CONTEXT;
pub type PXSTATE_CONTEXT = *mut _XSTATE_CONTEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KERNEL_CET_CONTEXT {
    pub Ssp: ULONG64,
    pub Rip: ULONG64,
    pub SegCs: USHORT,
    pub __bindgen_anon_1: _KERNEL_CET_CONTEXT__bindgen_ty_1,
    pub Fill: [USHORT; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KERNEL_CET_CONTEXT__bindgen_ty_1 {
    pub AllFlags: USHORT,
    pub __bindgen_anon_1: _KERNEL_CET_CONTEXT__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KERNEL_CET_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _KERNEL_CET_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn UseWrss(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UseWrss(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UseWrss_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_UseWrss_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PopShadowStackOne(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PopShadowStackOne(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PopShadowStackOne_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PopShadowStackOne_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Unused(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 14u8) as u16) }
    }
    #[inline]
    pub fn set_Unused(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Unused_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                14u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Unused_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                14u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        UseWrss: USHORT,
        PopShadowStackOne: USHORT,
        Unused: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let UseWrss: u16 = unsafe { ::core::mem::transmute(UseWrss) };
            UseWrss as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PopShadowStackOne: u16 = unsafe { ::core::mem::transmute(PopShadowStackOne) };
            PopShadowStackOne as u64
        });
        __bindgen_bitfield_unit.set(2usize, 14u8, {
            let Unused: u16 = unsafe { ::core::mem::transmute(Unused) };
            Unused as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type KERNEL_CET_CONTEXT = _KERNEL_CET_CONTEXT;
pub type PKERNEL_CET_CONTEXT = *mut _KERNEL_CET_CONTEXT;
unsafe extern "C" {
    pub fn _bittest(
        Base: *const core::ffi::c_long,
        Offset: core::ffi::c_long,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _bittestandcomplement(
        Base: *mut core::ffi::c_long,
        Offset: core::ffi::c_long,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _bittestandset(
        Base: *mut core::ffi::c_long,
        Offset: core::ffi::c_long,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _bittestandreset(
        Base: *mut core::ffi::c_long,
        Offset: core::ffi::c_long,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _interlockedbittestandset(
        Base: *mut core::ffi::c_long,
        Offset: core::ffi::c_long,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _interlockedbittestandreset(
        Base: *mut core::ffi::c_long,
        Offset: core::ffi::c_long,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _bittest64(
        Base: *const core::ffi::c_longlong,
        Offset: core::ffi::c_longlong,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _bittestandcomplement64(
        Base: *mut core::ffi::c_longlong,
        Offset: core::ffi::c_longlong,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _bittestandset64(
        Base: *mut core::ffi::c_longlong,
        Offset: core::ffi::c_longlong,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _bittestandreset64(
        Base: *mut core::ffi::c_longlong,
        Offset: core::ffi::c_longlong,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _interlockedbittestandset64(
        Base: *mut core::ffi::c_longlong,
        Offset: core::ffi::c_longlong,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _interlockedbittestandreset64(
        Base: *mut core::ffi::c_longlong,
        Offset: core::ffi::c_longlong,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _BitScanForward(
        Index: *mut core::ffi::c_ulong,
        Mask: core::ffi::c_ulong,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _BitScanReverse(
        Index: *mut core::ffi::c_ulong,
        Mask: core::ffi::c_ulong,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _BitScanForward64(
        Index: *mut core::ffi::c_ulong,
        Mask: core::ffi::c_ulonglong,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _BitScanReverse64(
        Index: *mut core::ffi::c_ulong,
        Mask: core::ffi::c_ulonglong,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _InterlockedIncrement16(Addend: *mut core::ffi::c_short) -> core::ffi::c_short;
}
unsafe extern "C" {
    pub fn _InterlockedDecrement16(Addend: *mut core::ffi::c_short) -> core::ffi::c_short;
}
unsafe extern "C" {
    pub fn _InterlockedCompareExchange16(
        Destination: *mut core::ffi::c_short,
        ExChange: core::ffi::c_short,
        Comperand: core::ffi::c_short,
    ) -> core::ffi::c_short;
}
unsafe extern "C" {
    pub fn _InterlockedAnd(
        Destination: *mut core::ffi::c_long,
        Value: core::ffi::c_long,
    ) -> core::ffi::c_long;
}
unsafe extern "C" {
    pub fn _InterlockedOr(
        Destination: *mut core::ffi::c_long,
        Value: core::ffi::c_long,
    ) -> core::ffi::c_long;
}
unsafe extern "C" {
    pub fn _InterlockedXor(
        Destination: *mut core::ffi::c_long,
        Value: core::ffi::c_long,
    ) -> core::ffi::c_long;
}
unsafe extern "C" {
    pub fn _InterlockedAnd64(
        Destination: *mut core::ffi::c_longlong,
        Value: core::ffi::c_longlong,
    ) -> core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn _InterlockedOr64(
        Destination: *mut core::ffi::c_longlong,
        Value: core::ffi::c_longlong,
    ) -> core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn _InterlockedXor64(
        Destination: *mut core::ffi::c_longlong,
        Value: core::ffi::c_longlong,
    ) -> core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn _InterlockedIncrement(Addend: *mut core::ffi::c_long) -> core::ffi::c_long;
}
unsafe extern "C" {
    pub fn _InterlockedDecrement(Addend: *mut core::ffi::c_long) -> core::ffi::c_long;
}
unsafe extern "C" {
    pub fn _InterlockedExchange(
        Target: *mut core::ffi::c_long,
        Value: core::ffi::c_long,
    ) -> core::ffi::c_long;
}
unsafe extern "C" {
    pub fn _InterlockedExchangeAdd(
        Addend: *mut core::ffi::c_long,
        Value: core::ffi::c_long,
    ) -> core::ffi::c_long;
}
unsafe extern "C" {
    pub fn _InterlockedCompareExchange(
        Destination: *mut core::ffi::c_long,
        ExChange: core::ffi::c_long,
        Comperand: core::ffi::c_long,
    ) -> core::ffi::c_long;
}
unsafe extern "C" {
    pub fn _InterlockedIncrement64(Addend: *mut core::ffi::c_longlong) -> core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn _InterlockedDecrement64(Addend: *mut core::ffi::c_longlong) -> core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn _InterlockedExchange64(
        Target: *mut core::ffi::c_longlong,
        Value: core::ffi::c_longlong,
    ) -> core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn _InterlockedExchangeAdd64(
        Addend: *mut core::ffi::c_longlong,
        Value: core::ffi::c_longlong,
    ) -> core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn _InterlockedCompareExchange64(
        Destination: *mut core::ffi::c_longlong,
        ExChange: core::ffi::c_longlong,
        Comperand: core::ffi::c_longlong,
    ) -> core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn _InterlockedCompareExchange128(
        Destination: *mut core::ffi::c_longlong,
        ExchangeHigh: core::ffi::c_longlong,
        ExchangeLow: core::ffi::c_longlong,
        ComparandResult: *mut core::ffi::c_longlong,
    ) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn _InterlockedCompareExchangePointer(
        Destination: *mut *mut core::ffi::c_void,
        Exchange: *mut core::ffi::c_void,
        Comperand: *mut core::ffi::c_void,
    ) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn _InterlockedExchangePointer(
        Target: *mut *mut core::ffi::c_void,
        Value: *mut core::ffi::c_void,
    ) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn _InterlockedExchange8(
        Target: *mut core::ffi::c_char,
        Value: core::ffi::c_char,
    ) -> core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _InterlockedExchange16(
        Destination: *mut core::ffi::c_short,
        ExChange: core::ffi::c_short,
    ) -> core::ffi::c_short;
}
unsafe extern "C" {
    pub fn _InterlockedExchangeAdd8(
        _Addend: *mut core::ffi::c_char,
        _Value: core::ffi::c_char,
    ) -> core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _InterlockedAnd8(
        Destination: *mut core::ffi::c_char,
        Value: core::ffi::c_char,
    ) -> core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _InterlockedOr8(
        Destination: *mut core::ffi::c_char,
        Value: core::ffi::c_char,
    ) -> core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _InterlockedXor8(
        Destination: *mut core::ffi::c_char,
        Value: core::ffi::c_char,
    ) -> core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _InterlockedAnd16(
        Destination: *mut core::ffi::c_short,
        Value: core::ffi::c_short,
    ) -> core::ffi::c_short;
}
unsafe extern "C" {
    pub fn _InterlockedOr16(
        Destination: *mut core::ffi::c_short,
        Value: core::ffi::c_short,
    ) -> core::ffi::c_short;
}
unsafe extern "C" {
    pub fn _InterlockedXor16(
        Destination: *mut core::ffi::c_short,
        Value: core::ffi::c_short,
    ) -> core::ffi::c_short;
}
unsafe extern "C" {
    pub fn __cpuidex(
        CPUInfo: *mut core::ffi::c_int,
        Function: core::ffi::c_int,
        SubLeaf: core::ffi::c_int,
    );
}
unsafe extern "C" {
    pub fn _mm_clflush(Address: *const core::ffi::c_void);
}
unsafe extern "C" {
    pub fn _ReadWriteBarrier();
}
unsafe extern "C" {
    pub fn __faststorefence();
}
unsafe extern "C" {
    pub fn _mm_lfence();
}
unsafe extern "C" {
    pub fn _mm_mfence();
}
unsafe extern "C" {
    pub fn _mm_sfence();
}
unsafe extern "C" {
    pub fn _mm_pause();
}
unsafe extern "C" {
    pub fn _mm_prefetch(a: *const core::ffi::c_char, sel: core::ffi::c_int);
}
unsafe extern "C" {
    pub fn _m_prefetchw(Source: *const core::ffi::c_void);
}
unsafe extern "C" {
    pub fn _mm_getcsr() -> core::ffi::c_uint;
}
unsafe extern "C" {
    pub fn _mm_setcsr(MxCsr: core::ffi::c_uint);
}
unsafe extern "C" {
    pub fn __getcallerseflags() -> core::ffi::c_uint;
}
unsafe extern "C" {
    pub fn __segmentlimit(Selector: ULONG) -> ULONG;
}
unsafe extern "C" {
    pub fn __readpmc(Counter: ULONG) -> ULONG64;
}
unsafe extern "C" {
    pub fn __rdtsc() -> core::ffi::c_ulonglong;
}
unsafe extern "C" {
    pub fn __movsb(Destination: PUCHAR, Source: *const UCHAR, Count: SIZE_T);
}
unsafe extern "C" {
    pub fn __movsw(Destination: PUSHORT, Source: *const USHORT, Count: SIZE_T);
}
unsafe extern "C" {
    pub fn __movsd(Destination: PULONG, Source: *const ULONG, Count: SIZE_T);
}
unsafe extern "C" {
    pub fn __movsq(Destination: PULONG64, Source: *const ULONG64, Count: SIZE_T);
}
unsafe extern "C" {
    pub fn __stosb(
        Destination: *mut core::ffi::c_uchar,
        Value: core::ffi::c_uchar,
        Count: core::ffi::c_ulonglong,
    );
}
unsafe extern "C" {
    pub fn __stosw(Destination: PUSHORT, Value: USHORT, Count: SIZE_T);
}
unsafe extern "C" {
    pub fn __stosd(Destination: PULONG, Value: ULONG, Count: SIZE_T);
}
unsafe extern "C" {
    pub fn __stosq(Destination: PULONG64, Value: ULONG64, Count: SIZE_T);
}
unsafe extern "C" {
    pub fn __mulh(
        Multiplier: core::ffi::c_longlong,
        Multiplicand: core::ffi::c_longlong,
    ) -> core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn __umulh(
        Multiplier: core::ffi::c_ulonglong,
        Multiplicand: core::ffi::c_ulonglong,
    ) -> core::ffi::c_ulonglong;
}
unsafe extern "C" {
    pub fn __popcnt64(operand: core::ffi::c_ulonglong) -> core::ffi::c_ulonglong;
}
unsafe extern "C" {
    pub fn __shiftleft128(
        LowPart: core::ffi::c_ulonglong,
        HighPart: core::ffi::c_ulonglong,
        Shift: core::ffi::c_uchar,
    ) -> core::ffi::c_ulonglong;
}
unsafe extern "C" {
    pub fn __shiftright128(
        LowPart: core::ffi::c_ulonglong,
        HighPart: core::ffi::c_ulonglong,
        Shift: core::ffi::c_uchar,
    ) -> core::ffi::c_ulonglong;
}
unsafe extern "C" {
    pub fn _mul128(
        Multiplier: core::ffi::c_longlong,
        Multiplicand: core::ffi::c_longlong,
        HighProduct: *mut core::ffi::c_longlong,
    ) -> core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn UnsignedMultiply128(
        Multiplier: ULONG64,
        Multiplicand: ULONG64,
        HighProduct: *mut ULONG64,
    ) -> ULONG64;
}
unsafe extern "C" {
    pub fn _umul128(
        Multiplier: core::ffi::c_ulonglong,
        Multiplicand: core::ffi::c_ulonglong,
        HighProduct: *mut core::ffi::c_ulonglong,
    ) -> core::ffi::c_ulonglong;
}
unsafe extern "C" {
    pub fn __readgsbyte(Offset: core::ffi::c_ulong) -> core::ffi::c_uchar;
}
unsafe extern "C" {
    pub fn __readgsword(Offset: core::ffi::c_ulong) -> core::ffi::c_ushort;
}
unsafe extern "C" {
    pub fn __readgsdword(Offset: core::ffi::c_ulong) -> core::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn __writegsbyte(Offset: ULONG, Data: UCHAR);
}
unsafe extern "C" {
    pub fn __writegsword(Offset: ULONG, Data: USHORT);
}
unsafe extern "C" {
    pub fn __writegsdword(Offset: ULONG, Data: ULONG);
}
unsafe extern "C" {
    pub fn __writegsqword(Offset: ULONG, Data: ULONG64);
}
unsafe extern "C" {
    pub fn __incgsbyte(Offset: ULONG);
}
unsafe extern "C" {
    pub fn __addgsbyte(Offset: ULONG, Value: UCHAR);
}
unsafe extern "C" {
    pub fn __incgsword(Offset: ULONG);
}
unsafe extern "C" {
    pub fn __addgsword(Offset: ULONG, Value: USHORT);
}
unsafe extern "C" {
    pub fn __incgsdword(Offset: ULONG);
}
unsafe extern "C" {
    pub fn __addgsdword(Offset: ULONG, Value: ULONG);
}
unsafe extern "C" {
    pub fn __incgsqword(Offset: ULONG);
}
unsafe extern "C" {
    pub fn __addgsqword(Offset: ULONG, Value: ULONG64);
}
pub type XMM_SAVE_AREA32 = XSAVE_FORMAT;
pub type PXMM_SAVE_AREA32 = *mut XSAVE_FORMAT;
unsafe extern "C" {
    pub fn __int2c() -> !;
}
pub type PACCESS_TOKEN = PVOID;
pub type PSECURITY_DESCRIPTOR = PVOID;
pub type PSID = PVOID;
pub type PCLAIMS_BLOB = PVOID;
pub type ACCESS_MASK = ULONG;
pub type PACCESS_MASK = *mut ACCESS_MASK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GENERIC_MAPPING {
    pub GenericRead: ACCESS_MASK,
    pub GenericWrite: ACCESS_MASK,
    pub GenericExecute: ACCESS_MASK,
    pub GenericAll: ACCESS_MASK,
}
pub type GENERIC_MAPPING = _GENERIC_MAPPING;
pub type PGENERIC_MAPPING = *mut GENERIC_MAPPING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LUID_AND_ATTRIBUTES {
    pub Luid: LUID,
    pub Attributes: ULONG,
}
pub type LUID_AND_ATTRIBUTES = _LUID_AND_ATTRIBUTES;
pub type PLUID_AND_ATTRIBUTES = *mut _LUID_AND_ATTRIBUTES;
pub type LUID_AND_ATTRIBUTES_ARRAY = [LUID_AND_ATTRIBUTES; 1usize];
pub type PLUID_AND_ATTRIBUTES_ARRAY = *mut LUID_AND_ATTRIBUTES_ARRAY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACL {
    pub AclRevision: UCHAR,
    pub Sbz1: UCHAR,
    pub AclSize: USHORT,
    pub AceCount: USHORT,
    pub Sbz2: USHORT,
}
pub type ACL = _ACL;
pub type PACL = *mut ACL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRIVILEGE_SET {
    pub PrivilegeCount: ULONG,
    pub Control: ULONG,
    pub Privilege: [LUID_AND_ATTRIBUTES; 1usize],
}
pub type PRIVILEGE_SET = _PRIVILEGE_SET;
pub type PPRIVILEGE_SET = *mut _PRIVILEGE_SET;
pub const _SECURITY_IMPERSONATION_LEVEL_SecurityAnonymous: _SECURITY_IMPERSONATION_LEVEL = 0;
pub const _SECURITY_IMPERSONATION_LEVEL_SecurityIdentification: _SECURITY_IMPERSONATION_LEVEL = 1;
pub const _SECURITY_IMPERSONATION_LEVEL_SecurityImpersonation: _SECURITY_IMPERSONATION_LEVEL = 2;
pub const _SECURITY_IMPERSONATION_LEVEL_SecurityDelegation: _SECURITY_IMPERSONATION_LEVEL = 3;
pub type _SECURITY_IMPERSONATION_LEVEL = core::ffi::c_int;
pub use self::_SECURITY_IMPERSONATION_LEVEL as SECURITY_IMPERSONATION_LEVEL;
pub type PSECURITY_IMPERSONATION_LEVEL = *mut _SECURITY_IMPERSONATION_LEVEL;
pub type SECURITY_CONTEXT_TRACKING_MODE = BOOLEAN;
pub type PSECURITY_CONTEXT_TRACKING_MODE = *mut BOOLEAN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_QUALITY_OF_SERVICE {
    pub Length: ULONG,
    pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    pub ContextTrackingMode: SECURITY_CONTEXT_TRACKING_MODE,
    pub EffectiveOnly: BOOLEAN,
}
pub type SECURITY_QUALITY_OF_SERVICE = _SECURITY_QUALITY_OF_SERVICE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_IMPERSONATION_STATE {
    pub Token: PACCESS_TOKEN,
    pub CopyOnOpen: BOOLEAN,
    pub EffectiveOnly: BOOLEAN,
    pub Level: SECURITY_IMPERSONATION_LEVEL,
}
pub type SE_IMPERSONATION_STATE = _SE_IMPERSONATION_STATE;
pub type PSE_IMPERSONATION_STATE = *mut _SE_IMPERSONATION_STATE;
pub type SECURITY_INFORMATION = ULONG;
pub type PSECURITY_INFORMATION = *mut ULONG;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeNone: _SE_ADT_PARAMETER_TYPE = 0;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeString: _SE_ADT_PARAMETER_TYPE = 1;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeFileSpec: _SE_ADT_PARAMETER_TYPE = 2;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeUlong: _SE_ADT_PARAMETER_TYPE = 3;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeSid: _SE_ADT_PARAMETER_TYPE = 4;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeLogonId: _SE_ADT_PARAMETER_TYPE = 5;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeNoLogonId: _SE_ADT_PARAMETER_TYPE = 6;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeAccessMask: _SE_ADT_PARAMETER_TYPE = 7;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypePrivs: _SE_ADT_PARAMETER_TYPE = 8;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeObjectTypes: _SE_ADT_PARAMETER_TYPE = 9;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeHexUlong: _SE_ADT_PARAMETER_TYPE = 10;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypePtr: _SE_ADT_PARAMETER_TYPE = 11;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeTime: _SE_ADT_PARAMETER_TYPE = 12;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeGuid: _SE_ADT_PARAMETER_TYPE = 13;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeLuid: _SE_ADT_PARAMETER_TYPE = 14;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeHexInt64: _SE_ADT_PARAMETER_TYPE = 15;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeStringList: _SE_ADT_PARAMETER_TYPE = 16;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeSidList: _SE_ADT_PARAMETER_TYPE = 17;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeDuration: _SE_ADT_PARAMETER_TYPE = 18;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeUserAccountControl: _SE_ADT_PARAMETER_TYPE = 19;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeNoUac: _SE_ADT_PARAMETER_TYPE = 20;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeMessage: _SE_ADT_PARAMETER_TYPE = 21;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeDateTime: _SE_ADT_PARAMETER_TYPE = 22;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeSockAddr: _SE_ADT_PARAMETER_TYPE = 23;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeSD: _SE_ADT_PARAMETER_TYPE = 24;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeLogonHours: _SE_ADT_PARAMETER_TYPE = 25;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeLogonIdNoSid: _SE_ADT_PARAMETER_TYPE = 26;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeUlongNoConv: _SE_ADT_PARAMETER_TYPE = 27;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeSockAddrNoPort: _SE_ADT_PARAMETER_TYPE = 28;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeAccessReason: _SE_ADT_PARAMETER_TYPE = 29;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeStagingReason: _SE_ADT_PARAMETER_TYPE = 30;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeResourceAttribute: _SE_ADT_PARAMETER_TYPE = 31;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeClaims: _SE_ADT_PARAMETER_TYPE = 32;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeLogonIdAsSid: _SE_ADT_PARAMETER_TYPE = 33;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeMultiSzString: _SE_ADT_PARAMETER_TYPE = 34;
pub const _SE_ADT_PARAMETER_TYPE_SeAdtParmTypeLogonIdEx: _SE_ADT_PARAMETER_TYPE = 35;
pub type _SE_ADT_PARAMETER_TYPE = core::ffi::c_int;
pub use self::_SE_ADT_PARAMETER_TYPE as SE_ADT_PARAMETER_TYPE;
pub type PSE_ADT_PARAMETER_TYPE = *mut _SE_ADT_PARAMETER_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_ADT_OBJECT_TYPE {
    pub ObjectType: GUID,
    pub Flags: USHORT,
    pub Level: USHORT,
    pub AccessMask: ACCESS_MASK,
}
pub type SE_ADT_OBJECT_TYPE = _SE_ADT_OBJECT_TYPE;
pub type PSE_ADT_OBJECT_TYPE = *mut _SE_ADT_OBJECT_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_ADT_PARAMETER_ARRAY_ENTRY {
    pub Type: SE_ADT_PARAMETER_TYPE,
    pub Length: ULONG,
    pub Data: [ULONG_PTR; 2usize],
    pub Address: PVOID,
}
pub type SE_ADT_PARAMETER_ARRAY_ENTRY = _SE_ADT_PARAMETER_ARRAY_ENTRY;
pub type PSE_ADT_PARAMETER_ARRAY_ENTRY = *mut _SE_ADT_PARAMETER_ARRAY_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_ADT_ACCESS_REASON {
    pub AccessMask: ACCESS_MASK,
    pub AccessReasons: [ULONG; 32usize],
    pub ObjectTypeIndex: ULONG,
    pub AccessGranted: ULONG,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
}
pub type SE_ADT_ACCESS_REASON = _SE_ADT_ACCESS_REASON;
pub type PSE_ADT_ACCESS_REASON = *mut _SE_ADT_ACCESS_REASON;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_ADT_CLAIMS {
    pub Length: ULONG,
    pub Claims: PCLAIMS_BLOB,
}
pub type SE_ADT_CLAIMS = _SE_ADT_CLAIMS;
pub type PSE_ADT_CLAIMS = *mut _SE_ADT_CLAIMS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_ADT_PARAMETER_ARRAY {
    pub CategoryId: ULONG,
    pub AuditId: ULONG,
    pub ParameterCount: ULONG,
    pub Length: ULONG,
    pub FlatSubCategoryId: USHORT,
    pub Type: USHORT,
    pub Flags: ULONG,
    pub Parameters: [SE_ADT_PARAMETER_ARRAY_ENTRY; 32usize],
}
pub type SE_ADT_PARAMETER_ARRAY = _SE_ADT_PARAMETER_ARRAY;
pub type PSE_ADT_PARAMETER_ARRAY = *mut _SE_ADT_PARAMETER_ARRAY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_ADT_PARAMETER_ARRAY_EX {
    pub CategoryId: ULONG,
    pub AuditId: ULONG,
    pub Version: ULONG,
    pub ParameterCount: ULONG,
    pub Length: ULONG,
    pub FlatSubCategoryId: USHORT,
    pub Type: USHORT,
    pub Flags: ULONG,
    pub Parameters: [SE_ADT_PARAMETER_ARRAY_ENTRY; 32usize],
}
pub type SE_ADT_PARAMETER_ARRAY_EX = _SE_ADT_PARAMETER_ARRAY_EX;
pub type PSE_ADT_PARAMETER_ARRAY_EX = *mut _SE_ADT_PARAMETER_ARRAY_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STATUS_BLOCK {
    pub __bindgen_anon_1: _IO_STATUS_BLOCK__bindgen_ty_1,
    pub Information: ULONG_PTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STATUS_BLOCK__bindgen_ty_1 {
    pub Status: NTSTATUS,
    pub Pointer: PVOID,
}
pub type IO_STATUS_BLOCK = _IO_STATUS_BLOCK;
pub type PIO_STATUS_BLOCK = *mut _IO_STATUS_BLOCK;
pub type IO_STATUS_BLOCK64 = IO_STATUS_BLOCK;
pub type PIO_STATUS_BLOCK64 = *mut IO_STATUS_BLOCK64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STATUS_BLOCK32 {
    pub Status: NTSTATUS,
    pub Information: ULONG,
}
pub type IO_STATUS_BLOCK32 = _IO_STATUS_BLOCK32;
pub type PIO_STATUS_BLOCK32 = *mut _IO_STATUS_BLOCK32;
pub type PIO_APC_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(ApcContext: PVOID, IoStatusBlock: PIO_STATUS_BLOCK, Reserved: ULONG),
>;
pub const _IO_SESSION_EVENT_IoSessionEventIgnore: _IO_SESSION_EVENT = 0;
pub const _IO_SESSION_EVENT_IoSessionEventCreated: _IO_SESSION_EVENT = 1;
pub const _IO_SESSION_EVENT_IoSessionEventTerminated: _IO_SESSION_EVENT = 2;
pub const _IO_SESSION_EVENT_IoSessionEventConnected: _IO_SESSION_EVENT = 3;
pub const _IO_SESSION_EVENT_IoSessionEventDisconnected: _IO_SESSION_EVENT = 4;
pub const _IO_SESSION_EVENT_IoSessionEventLogon: _IO_SESSION_EVENT = 5;
pub const _IO_SESSION_EVENT_IoSessionEventLogoff: _IO_SESSION_EVENT = 6;
pub const _IO_SESSION_EVENT_IoSessionEventMax: _IO_SESSION_EVENT = 7;
pub type _IO_SESSION_EVENT = core::ffi::c_int;
pub use self::_IO_SESSION_EVENT as IO_SESSION_EVENT;
pub type PIO_SESSION_EVENT = *mut _IO_SESSION_EVENT;
pub const _IO_SESSION_STATE_IoSessionStateCreated: _IO_SESSION_STATE = 1;
pub const _IO_SESSION_STATE_IoSessionStateInitialized: _IO_SESSION_STATE = 2;
pub const _IO_SESSION_STATE_IoSessionStateConnected: _IO_SESSION_STATE = 3;
pub const _IO_SESSION_STATE_IoSessionStateDisconnected: _IO_SESSION_STATE = 4;
pub const _IO_SESSION_STATE_IoSessionStateDisconnectedLoggedOn: _IO_SESSION_STATE = 5;
pub const _IO_SESSION_STATE_IoSessionStateLoggedOn: _IO_SESSION_STATE = 6;
pub const _IO_SESSION_STATE_IoSessionStateLoggedOff: _IO_SESSION_STATE = 7;
pub const _IO_SESSION_STATE_IoSessionStateTerminated: _IO_SESSION_STATE = 8;
pub const _IO_SESSION_STATE_IoSessionStateMax: _IO_SESSION_STATE = 9;
pub type _IO_SESSION_STATE = core::ffi::c_int;
pub use self::_IO_SESSION_STATE as IO_SESSION_STATE;
pub type PIO_SESSION_STATE = *mut _IO_SESSION_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_SESSION_CONNECT_INFO {
    pub SessionId: ULONG,
    pub LocalSession: BOOLEAN,
}
pub type IO_SESSION_CONNECT_INFO = _IO_SESSION_CONNECT_INFO;
pub type PIO_SESSION_CONNECT_INFO = *mut _IO_SESSION_CONNECT_INFO;
pub const _FILE_INFORMATION_CLASS_FileDirectoryInformation: _FILE_INFORMATION_CLASS = 1;
pub const _FILE_INFORMATION_CLASS_FileFullDirectoryInformation: _FILE_INFORMATION_CLASS = 2;
pub const _FILE_INFORMATION_CLASS_FileBothDirectoryInformation: _FILE_INFORMATION_CLASS = 3;
pub const _FILE_INFORMATION_CLASS_FileBasicInformation: _FILE_INFORMATION_CLASS = 4;
pub const _FILE_INFORMATION_CLASS_FileStandardInformation: _FILE_INFORMATION_CLASS = 5;
pub const _FILE_INFORMATION_CLASS_FileInternalInformation: _FILE_INFORMATION_CLASS = 6;
pub const _FILE_INFORMATION_CLASS_FileEaInformation: _FILE_INFORMATION_CLASS = 7;
pub const _FILE_INFORMATION_CLASS_FileAccessInformation: _FILE_INFORMATION_CLASS = 8;
pub const _FILE_INFORMATION_CLASS_FileNameInformation: _FILE_INFORMATION_CLASS = 9;
pub const _FILE_INFORMATION_CLASS_FileRenameInformation: _FILE_INFORMATION_CLASS = 10;
pub const _FILE_INFORMATION_CLASS_FileLinkInformation: _FILE_INFORMATION_CLASS = 11;
pub const _FILE_INFORMATION_CLASS_FileNamesInformation: _FILE_INFORMATION_CLASS = 12;
pub const _FILE_INFORMATION_CLASS_FileDispositionInformation: _FILE_INFORMATION_CLASS = 13;
pub const _FILE_INFORMATION_CLASS_FilePositionInformation: _FILE_INFORMATION_CLASS = 14;
pub const _FILE_INFORMATION_CLASS_FileFullEaInformation: _FILE_INFORMATION_CLASS = 15;
pub const _FILE_INFORMATION_CLASS_FileModeInformation: _FILE_INFORMATION_CLASS = 16;
pub const _FILE_INFORMATION_CLASS_FileAlignmentInformation: _FILE_INFORMATION_CLASS = 17;
pub const _FILE_INFORMATION_CLASS_FileAllInformation: _FILE_INFORMATION_CLASS = 18;
pub const _FILE_INFORMATION_CLASS_FileAllocationInformation: _FILE_INFORMATION_CLASS = 19;
pub const _FILE_INFORMATION_CLASS_FileEndOfFileInformation: _FILE_INFORMATION_CLASS = 20;
pub const _FILE_INFORMATION_CLASS_FileAlternateNameInformation: _FILE_INFORMATION_CLASS = 21;
pub const _FILE_INFORMATION_CLASS_FileStreamInformation: _FILE_INFORMATION_CLASS = 22;
pub const _FILE_INFORMATION_CLASS_FilePipeInformation: _FILE_INFORMATION_CLASS = 23;
pub const _FILE_INFORMATION_CLASS_FilePipeLocalInformation: _FILE_INFORMATION_CLASS = 24;
pub const _FILE_INFORMATION_CLASS_FilePipeRemoteInformation: _FILE_INFORMATION_CLASS = 25;
pub const _FILE_INFORMATION_CLASS_FileMailslotQueryInformation: _FILE_INFORMATION_CLASS = 26;
pub const _FILE_INFORMATION_CLASS_FileMailslotSetInformation: _FILE_INFORMATION_CLASS = 27;
pub const _FILE_INFORMATION_CLASS_FileCompressionInformation: _FILE_INFORMATION_CLASS = 28;
pub const _FILE_INFORMATION_CLASS_FileObjectIdInformation: _FILE_INFORMATION_CLASS = 29;
pub const _FILE_INFORMATION_CLASS_FileCompletionInformation: _FILE_INFORMATION_CLASS = 30;
pub const _FILE_INFORMATION_CLASS_FileMoveClusterInformation: _FILE_INFORMATION_CLASS = 31;
pub const _FILE_INFORMATION_CLASS_FileQuotaInformation: _FILE_INFORMATION_CLASS = 32;
pub const _FILE_INFORMATION_CLASS_FileReparsePointInformation: _FILE_INFORMATION_CLASS = 33;
pub const _FILE_INFORMATION_CLASS_FileNetworkOpenInformation: _FILE_INFORMATION_CLASS = 34;
pub const _FILE_INFORMATION_CLASS_FileAttributeTagInformation: _FILE_INFORMATION_CLASS = 35;
pub const _FILE_INFORMATION_CLASS_FileTrackingInformation: _FILE_INFORMATION_CLASS = 36;
pub const _FILE_INFORMATION_CLASS_FileIdBothDirectoryInformation: _FILE_INFORMATION_CLASS = 37;
pub const _FILE_INFORMATION_CLASS_FileIdFullDirectoryInformation: _FILE_INFORMATION_CLASS = 38;
pub const _FILE_INFORMATION_CLASS_FileValidDataLengthInformation: _FILE_INFORMATION_CLASS = 39;
pub const _FILE_INFORMATION_CLASS_FileShortNameInformation: _FILE_INFORMATION_CLASS = 40;
pub const _FILE_INFORMATION_CLASS_FileIoCompletionNotificationInformation: _FILE_INFORMATION_CLASS =
    41;
pub const _FILE_INFORMATION_CLASS_FileIoStatusBlockRangeInformation: _FILE_INFORMATION_CLASS = 42;
pub const _FILE_INFORMATION_CLASS_FileIoPriorityHintInformation: _FILE_INFORMATION_CLASS = 43;
pub const _FILE_INFORMATION_CLASS_FileSfioReserveInformation: _FILE_INFORMATION_CLASS = 44;
pub const _FILE_INFORMATION_CLASS_FileSfioVolumeInformation: _FILE_INFORMATION_CLASS = 45;
pub const _FILE_INFORMATION_CLASS_FileHardLinkInformation: _FILE_INFORMATION_CLASS = 46;
pub const _FILE_INFORMATION_CLASS_FileProcessIdsUsingFileInformation: _FILE_INFORMATION_CLASS = 47;
pub const _FILE_INFORMATION_CLASS_FileNormalizedNameInformation: _FILE_INFORMATION_CLASS = 48;
pub const _FILE_INFORMATION_CLASS_FileNetworkPhysicalNameInformation: _FILE_INFORMATION_CLASS = 49;
pub const _FILE_INFORMATION_CLASS_FileIdGlobalTxDirectoryInformation: _FILE_INFORMATION_CLASS = 50;
pub const _FILE_INFORMATION_CLASS_FileIsRemoteDeviceInformation: _FILE_INFORMATION_CLASS = 51;
pub const _FILE_INFORMATION_CLASS_FileUnusedInformation: _FILE_INFORMATION_CLASS = 52;
pub const _FILE_INFORMATION_CLASS_FileNumaNodeInformation: _FILE_INFORMATION_CLASS = 53;
pub const _FILE_INFORMATION_CLASS_FileStandardLinkInformation: _FILE_INFORMATION_CLASS = 54;
pub const _FILE_INFORMATION_CLASS_FileRemoteProtocolInformation: _FILE_INFORMATION_CLASS = 55;
pub const _FILE_INFORMATION_CLASS_FileRenameInformationBypassAccessCheck: _FILE_INFORMATION_CLASS =
    56;
pub const _FILE_INFORMATION_CLASS_FileLinkInformationBypassAccessCheck: _FILE_INFORMATION_CLASS =
    57;
pub const _FILE_INFORMATION_CLASS_FileVolumeNameInformation: _FILE_INFORMATION_CLASS = 58;
pub const _FILE_INFORMATION_CLASS_FileIdInformation: _FILE_INFORMATION_CLASS = 59;
pub const _FILE_INFORMATION_CLASS_FileIdExtdDirectoryInformation: _FILE_INFORMATION_CLASS = 60;
pub const _FILE_INFORMATION_CLASS_FileReplaceCompletionInformation: _FILE_INFORMATION_CLASS = 61;
pub const _FILE_INFORMATION_CLASS_FileHardLinkFullIdInformation: _FILE_INFORMATION_CLASS = 62;
pub const _FILE_INFORMATION_CLASS_FileIdExtdBothDirectoryInformation: _FILE_INFORMATION_CLASS = 63;
pub const _FILE_INFORMATION_CLASS_FileDispositionInformationEx: _FILE_INFORMATION_CLASS = 64;
pub const _FILE_INFORMATION_CLASS_FileRenameInformationEx: _FILE_INFORMATION_CLASS = 65;
pub const _FILE_INFORMATION_CLASS_FileRenameInformationExBypassAccessCheck:
_FILE_INFORMATION_CLASS = 66;
pub const _FILE_INFORMATION_CLASS_FileDesiredStorageClassInformation: _FILE_INFORMATION_CLASS = 67;
pub const _FILE_INFORMATION_CLASS_FileStatInformation: _FILE_INFORMATION_CLASS = 68;
pub const _FILE_INFORMATION_CLASS_FileMemoryPartitionInformation: _FILE_INFORMATION_CLASS = 69;
pub const _FILE_INFORMATION_CLASS_FileStatLxInformation: _FILE_INFORMATION_CLASS = 70;
pub const _FILE_INFORMATION_CLASS_FileCaseSensitiveInformation: _FILE_INFORMATION_CLASS = 71;
pub const _FILE_INFORMATION_CLASS_FileLinkInformationEx: _FILE_INFORMATION_CLASS = 72;
pub const _FILE_INFORMATION_CLASS_FileLinkInformationExBypassAccessCheck: _FILE_INFORMATION_CLASS =
    73;
pub const _FILE_INFORMATION_CLASS_FileStorageReserveIdInformation: _FILE_INFORMATION_CLASS = 74;
pub const _FILE_INFORMATION_CLASS_FileCaseSensitiveInformationForceAccessCheck:
_FILE_INFORMATION_CLASS = 75;
pub const _FILE_INFORMATION_CLASS_FileKnownFolderInformation: _FILE_INFORMATION_CLASS = 76;
pub const _FILE_INFORMATION_CLASS_FileStatBasicInformation: _FILE_INFORMATION_CLASS = 77;
pub const _FILE_INFORMATION_CLASS_FileId64ExtdDirectoryInformation: _FILE_INFORMATION_CLASS = 78;
pub const _FILE_INFORMATION_CLASS_FileId64ExtdBothDirectoryInformation: _FILE_INFORMATION_CLASS =
    79;
pub const _FILE_INFORMATION_CLASS_FileIdAllExtdDirectoryInformation: _FILE_INFORMATION_CLASS = 80;
pub const _FILE_INFORMATION_CLASS_FileIdAllExtdBothDirectoryInformation: _FILE_INFORMATION_CLASS =
    81;
pub const _FILE_INFORMATION_CLASS_FileMaximumInformation: _FILE_INFORMATION_CLASS = 82;
pub type _FILE_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_FILE_INFORMATION_CLASS as FILE_INFORMATION_CLASS;
pub type PFILE_INFORMATION_CLASS = *mut _FILE_INFORMATION_CLASS;
pub const _DIRECTORY_NOTIFY_INFORMATION_CLASS_DirectoryNotifyInformation:
_DIRECTORY_NOTIFY_INFORMATION_CLASS = 1;
pub const _DIRECTORY_NOTIFY_INFORMATION_CLASS_DirectoryNotifyExtendedInformation:
_DIRECTORY_NOTIFY_INFORMATION_CLASS = 2;
pub const _DIRECTORY_NOTIFY_INFORMATION_CLASS_DirectoryNotifyFullInformation:
_DIRECTORY_NOTIFY_INFORMATION_CLASS = 3;
pub const _DIRECTORY_NOTIFY_INFORMATION_CLASS_DirectoryNotifyMaximumInformation:
_DIRECTORY_NOTIFY_INFORMATION_CLASS = 4;
pub type _DIRECTORY_NOTIFY_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_DIRECTORY_NOTIFY_INFORMATION_CLASS as DIRECTORY_NOTIFY_INFORMATION_CLASS;
pub type PDIRECTORY_NOTIFY_INFORMATION_CLASS = *mut _DIRECTORY_NOTIFY_INFORMATION_CLASS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_BASIC_INFORMATION {
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub FileAttributes: ULONG,
}
pub type FILE_BASIC_INFORMATION = _FILE_BASIC_INFORMATION;
pub type PFILE_BASIC_INFORMATION = *mut _FILE_BASIC_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STANDARD_INFORMATION {
    pub AllocationSize: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub NumberOfLinks: ULONG,
    pub DeletePending: BOOLEAN,
    pub Directory: BOOLEAN,
}
pub type FILE_STANDARD_INFORMATION = _FILE_STANDARD_INFORMATION;
pub type PFILE_STANDARD_INFORMATION = *mut _FILE_STANDARD_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STANDARD_INFORMATION_EX {
    pub AllocationSize: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub NumberOfLinks: ULONG,
    pub DeletePending: BOOLEAN,
    pub Directory: BOOLEAN,
    pub AlternateStream: BOOLEAN,
    pub MetadataAttribute: BOOLEAN,
}
pub type FILE_STANDARD_INFORMATION_EX = _FILE_STANDARD_INFORMATION_EX;
pub type PFILE_STANDARD_INFORMATION_EX = *mut _FILE_STANDARD_INFORMATION_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_POSITION_INFORMATION {
    pub CurrentByteOffset: LARGE_INTEGER,
}
pub type FILE_POSITION_INFORMATION = _FILE_POSITION_INFORMATION;
pub type PFILE_POSITION_INFORMATION = *mut _FILE_POSITION_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_NETWORK_OPEN_INFORMATION {
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub FileAttributes: ULONG,
}
pub type FILE_NETWORK_OPEN_INFORMATION = _FILE_NETWORK_OPEN_INFORMATION;
pub type PFILE_NETWORK_OPEN_INFORMATION = *mut _FILE_NETWORK_OPEN_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FULL_EA_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub Flags: UCHAR,
    pub EaNameLength: UCHAR,
    pub EaValueLength: USHORT,
    pub EaName: [CHAR; 1usize],
}
pub type FILE_FULL_EA_INFORMATION = _FILE_FULL_EA_INFORMATION;
pub type PFILE_FULL_EA_INFORMATION = *mut _FILE_FULL_EA_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_SFIO_RESERVE_INFORMATION {
    pub RequestsPerPeriod: ULONG,
    pub Period: ULONG,
    pub RetryFailures: BOOLEAN,
    pub Discardable: BOOLEAN,
    pub RequestSize: ULONG,
    pub NumOutstandingRequests: ULONG,
}
pub type FILE_SFIO_RESERVE_INFORMATION = _FILE_SFIO_RESERVE_INFORMATION;
pub type PFILE_SFIO_RESERVE_INFORMATION = *mut _FILE_SFIO_RESERVE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_SFIO_VOLUME_INFORMATION {
    pub MaximumRequestsPerPeriod: ULONG,
    pub MinimumPeriod: ULONG,
    pub MinimumTransferSize: ULONG,
}
pub type FILE_SFIO_VOLUME_INFORMATION = _FILE_SFIO_VOLUME_INFORMATION;
pub type PFILE_SFIO_VOLUME_INFORMATION = *mut _FILE_SFIO_VOLUME_INFORMATION;
pub const _IO_PRIORITY_HINT_IoPriorityVeryLow: _IO_PRIORITY_HINT = 0;
pub const _IO_PRIORITY_HINT_IoPriorityLow: _IO_PRIORITY_HINT = 1;
pub const _IO_PRIORITY_HINT_IoPriorityNormal: _IO_PRIORITY_HINT = 2;
pub const _IO_PRIORITY_HINT_IoPriorityHigh: _IO_PRIORITY_HINT = 3;
pub const _IO_PRIORITY_HINT_IoPriorityCritical: _IO_PRIORITY_HINT = 4;
pub const _IO_PRIORITY_HINT_MaxIoPriorityTypes: _IO_PRIORITY_HINT = 5;
pub type _IO_PRIORITY_HINT = core::ffi::c_int;
pub use self::_IO_PRIORITY_HINT as IO_PRIORITY_HINT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_IO_PRIORITY_HINT_INFORMATION {
    pub PriorityHint: IO_PRIORITY_HINT,
}
pub type FILE_IO_PRIORITY_HINT_INFORMATION = _FILE_IO_PRIORITY_HINT_INFORMATION;
pub type PFILE_IO_PRIORITY_HINT_INFORMATION = *mut _FILE_IO_PRIORITY_HINT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_IO_PRIORITY_HINT_INFORMATION_EX {
    pub PriorityHint: IO_PRIORITY_HINT,
    pub BoostOutstanding: BOOLEAN,
}
pub type FILE_IO_PRIORITY_HINT_INFORMATION_EX = _FILE_IO_PRIORITY_HINT_INFORMATION_EX;
pub type PFILE_IO_PRIORITY_HINT_INFORMATION_EX = *mut _FILE_IO_PRIORITY_HINT_INFORMATION_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_IO_COMPLETION_NOTIFICATION_INFORMATION {
    pub Flags: ULONG,
}
pub type FILE_IO_COMPLETION_NOTIFICATION_INFORMATION = _FILE_IO_COMPLETION_NOTIFICATION_INFORMATION;
pub type PFILE_IO_COMPLETION_NOTIFICATION_INFORMATION =
*mut _FILE_IO_COMPLETION_NOTIFICATION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PROCESS_IDS_USING_FILE_INFORMATION {
    pub NumberOfProcessIdsInList: ULONG,
    pub ProcessIdList: [ULONG_PTR; 1usize],
}
pub type FILE_PROCESS_IDS_USING_FILE_INFORMATION = _FILE_PROCESS_IDS_USING_FILE_INFORMATION;
pub type PFILE_PROCESS_IDS_USING_FILE_INFORMATION = *mut _FILE_PROCESS_IDS_USING_FILE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_IS_REMOTE_DEVICE_INFORMATION {
    pub IsRemote: BOOLEAN,
}
pub type FILE_IS_REMOTE_DEVICE_INFORMATION = _FILE_IS_REMOTE_DEVICE_INFORMATION;
pub type PFILE_IS_REMOTE_DEVICE_INFORMATION = *mut _FILE_IS_REMOTE_DEVICE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_NUMA_NODE_INFORMATION {
    pub NodeNumber: USHORT,
}
pub type FILE_NUMA_NODE_INFORMATION = _FILE_NUMA_NODE_INFORMATION;
pub type PFILE_NUMA_NODE_INFORMATION = *mut _FILE_NUMA_NODE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_IOSTATUSBLOCK_RANGE_INFORMATION {
    pub IoStatusBlockRange: PUCHAR,
    pub Length: ULONG,
}
pub type FILE_IOSTATUSBLOCK_RANGE_INFORMATION = _FILE_IOSTATUSBLOCK_RANGE_INFORMATION;
pub type PFILE_IOSTATUSBLOCK_RANGE_INFORMATION = *mut _FILE_IOSTATUSBLOCK_RANGE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_MEMORY_PARTITION_INFORMATION {
    pub OwnerPartitionHandle: ULONG_PTR,
    pub Flags: _FILE_MEMORY_PARTITION_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_MEMORY_PARTITION_INFORMATION__bindgen_ty_1 {
    pub __bindgen_anon_1: _FILE_MEMORY_PARTITION_INFORMATION__bindgen_ty_1__bindgen_ty_1,
    pub AllFlags: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_MEMORY_PARTITION_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub NoCrossPartitionAccess: UCHAR,
    pub Spare: [UCHAR; 3usize],
}
pub type FILE_MEMORY_PARTITION_INFORMATION = _FILE_MEMORY_PARTITION_INFORMATION;
pub type PFILE_MEMORY_PARTITION_INFORMATION = *mut _FILE_MEMORY_PARTITION_INFORMATION;
pub const _FSINFOCLASS_FileFsVolumeInformation: _FSINFOCLASS = 1;
pub const _FSINFOCLASS_FileFsLabelInformation: _FSINFOCLASS = 2;
pub const _FSINFOCLASS_FileFsSizeInformation: _FSINFOCLASS = 3;
pub const _FSINFOCLASS_FileFsDeviceInformation: _FSINFOCLASS = 4;
pub const _FSINFOCLASS_FileFsAttributeInformation: _FSINFOCLASS = 5;
pub const _FSINFOCLASS_FileFsControlInformation: _FSINFOCLASS = 6;
pub const _FSINFOCLASS_FileFsFullSizeInformation: _FSINFOCLASS = 7;
pub const _FSINFOCLASS_FileFsObjectIdInformation: _FSINFOCLASS = 8;
pub const _FSINFOCLASS_FileFsDriverPathInformation: _FSINFOCLASS = 9;
pub const _FSINFOCLASS_FileFsVolumeFlagsInformation: _FSINFOCLASS = 10;
pub const _FSINFOCLASS_FileFsSectorSizeInformation: _FSINFOCLASS = 11;
pub const _FSINFOCLASS_FileFsDataCopyInformation: _FSINFOCLASS = 12;
pub const _FSINFOCLASS_FileFsMetadataSizeInformation: _FSINFOCLASS = 13;
pub const _FSINFOCLASS_FileFsFullSizeInformationEx: _FSINFOCLASS = 14;
pub const _FSINFOCLASS_FileFsGuidInformation: _FSINFOCLASS = 15;
pub const _FSINFOCLASS_FileFsMaximumInformation: _FSINFOCLASS = 16;
pub type _FSINFOCLASS = core::ffi::c_int;
pub use self::_FSINFOCLASS as FS_INFORMATION_CLASS;
pub type PFS_INFORMATION_CLASS = *mut _FSINFOCLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FS_DEVICE_INFORMATION {
    pub DeviceType: ULONG,
    pub Characteristics: ULONG,
}
pub type FILE_FS_DEVICE_INFORMATION = _FILE_FS_DEVICE_INFORMATION;
pub type PFILE_FS_DEVICE_INFORMATION = *mut _FILE_FS_DEVICE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_SEGMENT_ELEMENT {
    pub Buffer: *mut core::ffi::c_void,
    pub Alignment: ULONGLONG,
}
pub type FILE_SEGMENT_ELEMENT = _FILE_SEGMENT_ELEMENT;
pub type PFILE_SEGMENT_ELEMENT = *mut _FILE_SEGMENT_ELEMENT;
pub const _INTERFACE_TYPE_InterfaceTypeUndefined: _INTERFACE_TYPE = -1;
pub const _INTERFACE_TYPE_Internal: _INTERFACE_TYPE = 0;
pub const _INTERFACE_TYPE_Isa: _INTERFACE_TYPE = 1;
pub const _INTERFACE_TYPE_Eisa: _INTERFACE_TYPE = 2;
pub const _INTERFACE_TYPE_MicroChannel: _INTERFACE_TYPE = 3;
pub const _INTERFACE_TYPE_TurboChannel: _INTERFACE_TYPE = 4;
pub const _INTERFACE_TYPE_PCIBus: _INTERFACE_TYPE = 5;
pub const _INTERFACE_TYPE_VMEBus: _INTERFACE_TYPE = 6;
pub const _INTERFACE_TYPE_NuBus: _INTERFACE_TYPE = 7;
pub const _INTERFACE_TYPE_PCMCIABus: _INTERFACE_TYPE = 8;
pub const _INTERFACE_TYPE_CBus: _INTERFACE_TYPE = 9;
pub const _INTERFACE_TYPE_MPIBus: _INTERFACE_TYPE = 10;
pub const _INTERFACE_TYPE_MPSABus: _INTERFACE_TYPE = 11;
pub const _INTERFACE_TYPE_ProcessorInternal: _INTERFACE_TYPE = 12;
pub const _INTERFACE_TYPE_InternalPowerBus: _INTERFACE_TYPE = 13;
pub const _INTERFACE_TYPE_PNPISABus: _INTERFACE_TYPE = 14;
pub const _INTERFACE_TYPE_PNPBus: _INTERFACE_TYPE = 15;
pub const _INTERFACE_TYPE_Vmcs: _INTERFACE_TYPE = 16;
pub const _INTERFACE_TYPE_ACPIBus: _INTERFACE_TYPE = 17;
pub const _INTERFACE_TYPE_MaximumInterfaceType: _INTERFACE_TYPE = 18;
pub type _INTERFACE_TYPE = core::ffi::c_int;
pub use self::_INTERFACE_TYPE as INTERFACE_TYPE;
pub type PINTERFACE_TYPE = *mut _INTERFACE_TYPE;
pub const _DMA_WIDTH_Width8Bits: _DMA_WIDTH = 0;
pub const _DMA_WIDTH_Width16Bits: _DMA_WIDTH = 1;
pub const _DMA_WIDTH_Width32Bits: _DMA_WIDTH = 2;
pub const _DMA_WIDTH_Width64Bits: _DMA_WIDTH = 3;
pub const _DMA_WIDTH_WidthNoWrap: _DMA_WIDTH = 4;
pub const _DMA_WIDTH_MaximumDmaWidth: _DMA_WIDTH = 5;
pub type _DMA_WIDTH = core::ffi::c_int;
pub use self::_DMA_WIDTH as DMA_WIDTH;
pub type PDMA_WIDTH = *mut _DMA_WIDTH;
pub const _DMA_SPEED_Compatible: _DMA_SPEED = 0;
pub const _DMA_SPEED_TypeA: _DMA_SPEED = 1;
pub const _DMA_SPEED_TypeB: _DMA_SPEED = 2;
pub const _DMA_SPEED_TypeC: _DMA_SPEED = 3;
pub const _DMA_SPEED_TypeF: _DMA_SPEED = 4;
pub const _DMA_SPEED_MaximumDmaSpeed: _DMA_SPEED = 5;
pub type _DMA_SPEED = core::ffi::c_int;
pub use self::_DMA_SPEED as DMA_SPEED;
pub type PDMA_SPEED = *mut _DMA_SPEED;
pub type PINTERFACE_REFERENCE = ::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
pub type PINTERFACE_DEREFERENCE = ::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_ERROR_LOG_PACKET {
    pub MajorFunctionCode: UCHAR,
    pub RetryCount: UCHAR,
    pub DumpDataSize: USHORT,
    pub NumberOfStrings: USHORT,
    pub StringOffset: USHORT,
    pub EventCategory: USHORT,
    pub ErrorCode: NTSTATUS,
    pub UniqueErrorValue: ULONG,
    pub FinalStatus: NTSTATUS,
    pub SequenceNumber: ULONG,
    pub IoControlCode: ULONG,
    pub DeviceOffset: LARGE_INTEGER,
    pub DumpData: [ULONG; 1usize],
}
pub type IO_ERROR_LOG_PACKET = _IO_ERROR_LOG_PACKET;
pub type PIO_ERROR_LOG_PACKET = *mut _IO_ERROR_LOG_PACKET;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_ERROR_LOG_MESSAGE {
    pub Type: USHORT,
    pub Size: USHORT,
    pub DriverNameLength: USHORT,
    pub TimeStamp: LARGE_INTEGER,
    pub DriverNameOffset: ULONG,
    pub EntryData: IO_ERROR_LOG_PACKET,
}
pub type IO_ERROR_LOG_MESSAGE = _IO_ERROR_LOG_MESSAGE;
pub type PIO_ERROR_LOG_MESSAGE = *mut _IO_ERROR_LOG_MESSAGE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KEY_BASIC_INFORMATION {
    pub LastWriteTime: LARGE_INTEGER,
    pub TitleIndex: ULONG,
    pub NameLength: ULONG,
    pub Name: [WCHAR; 1usize],
}
pub type KEY_BASIC_INFORMATION = _KEY_BASIC_INFORMATION;
pub type PKEY_BASIC_INFORMATION = *mut _KEY_BASIC_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KEY_NODE_INFORMATION {
    pub LastWriteTime: LARGE_INTEGER,
    pub TitleIndex: ULONG,
    pub ClassOffset: ULONG,
    pub ClassLength: ULONG,
    pub NameLength: ULONG,
    pub Name: [WCHAR; 1usize],
}
pub type KEY_NODE_INFORMATION = _KEY_NODE_INFORMATION;
pub type PKEY_NODE_INFORMATION = *mut _KEY_NODE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KEY_FULL_INFORMATION {
    pub LastWriteTime: LARGE_INTEGER,
    pub TitleIndex: ULONG,
    pub ClassOffset: ULONG,
    pub ClassLength: ULONG,
    pub SubKeys: ULONG,
    pub MaxNameLen: ULONG,
    pub MaxClassLen: ULONG,
    pub Values: ULONG,
    pub MaxValueNameLen: ULONG,
    pub MaxValueDataLen: ULONG,
    pub Class: [WCHAR; 1usize],
}
pub type KEY_FULL_INFORMATION = _KEY_FULL_INFORMATION;
pub type PKEY_FULL_INFORMATION = *mut _KEY_FULL_INFORMATION;
pub const _KEY_INFORMATION_CLASS_KeyBasicInformation: _KEY_INFORMATION_CLASS = 0;
pub const _KEY_INFORMATION_CLASS_KeyNodeInformation: _KEY_INFORMATION_CLASS = 1;
pub const _KEY_INFORMATION_CLASS_KeyFullInformation: _KEY_INFORMATION_CLASS = 2;
pub const _KEY_INFORMATION_CLASS_KeyNameInformation: _KEY_INFORMATION_CLASS = 3;
pub const _KEY_INFORMATION_CLASS_KeyCachedInformation: _KEY_INFORMATION_CLASS = 4;
pub const _KEY_INFORMATION_CLASS_KeyFlagsInformation: _KEY_INFORMATION_CLASS = 5;
pub const _KEY_INFORMATION_CLASS_KeyVirtualizationInformation: _KEY_INFORMATION_CLASS = 6;
pub const _KEY_INFORMATION_CLASS_KeyHandleTagsInformation: _KEY_INFORMATION_CLASS = 7;
pub const _KEY_INFORMATION_CLASS_KeyTrustInformation: _KEY_INFORMATION_CLASS = 8;
pub const _KEY_INFORMATION_CLASS_KeyLayerInformation: _KEY_INFORMATION_CLASS = 9;
pub const _KEY_INFORMATION_CLASS_MaxKeyInfoClass: _KEY_INFORMATION_CLASS = 10;
pub type _KEY_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_KEY_INFORMATION_CLASS as KEY_INFORMATION_CLASS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KEY_WRITE_TIME_INFORMATION {
    pub LastWriteTime: LARGE_INTEGER,
}
pub type KEY_WRITE_TIME_INFORMATION = _KEY_WRITE_TIME_INFORMATION;
pub type PKEY_WRITE_TIME_INFORMATION = *mut _KEY_WRITE_TIME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KEY_WOW64_FLAGS_INFORMATION {
    pub UserFlags: ULONG,
}
pub type KEY_WOW64_FLAGS_INFORMATION = _KEY_WOW64_FLAGS_INFORMATION;
pub type PKEY_WOW64_FLAGS_INFORMATION = *mut _KEY_WOW64_FLAGS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KEY_CONTROL_FLAGS_INFORMATION {
    pub ControlFlags: ULONG,
}
pub type KEY_CONTROL_FLAGS_INFORMATION = _KEY_CONTROL_FLAGS_INFORMATION;
pub type PKEY_CONTROL_FLAGS_INFORMATION = *mut _KEY_CONTROL_FLAGS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KEY_SET_VIRTUALIZATION_INFORMATION {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KEY_SET_VIRTUALIZATION_INFORMATION {
    #[inline]
    pub fn VirtualTarget(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VirtualTarget(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VirtualTarget_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VirtualTarget_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VirtualStore(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VirtualStore(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VirtualStore_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VirtualStore_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VirtualSource(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VirtualSource(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VirtualSource_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VirtualSource_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                29u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                29u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        VirtualTarget: ULONG,
        VirtualStore: ULONG,
        VirtualSource: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let VirtualTarget: u32 = unsafe { ::core::mem::transmute(VirtualTarget) };
            VirtualTarget as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let VirtualStore: u32 = unsafe { ::core::mem::transmute(VirtualStore) };
            VirtualStore as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let VirtualSource: u32 = unsafe { ::core::mem::transmute(VirtualSource) };
            VirtualSource as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type KEY_SET_VIRTUALIZATION_INFORMATION = _KEY_SET_VIRTUALIZATION_INFORMATION;
pub type PKEY_SET_VIRTUALIZATION_INFORMATION = *mut _KEY_SET_VIRTUALIZATION_INFORMATION;
pub const _KEY_SET_INFORMATION_CLASS_KeyWriteTimeInformation: _KEY_SET_INFORMATION_CLASS = 0;
pub const _KEY_SET_INFORMATION_CLASS_KeyWow64FlagsInformation: _KEY_SET_INFORMATION_CLASS = 1;
pub const _KEY_SET_INFORMATION_CLASS_KeyControlFlagsInformation: _KEY_SET_INFORMATION_CLASS = 2;
pub const _KEY_SET_INFORMATION_CLASS_KeySetVirtualizationInformation: _KEY_SET_INFORMATION_CLASS =
    3;
pub const _KEY_SET_INFORMATION_CLASS_KeySetDebugInformation: _KEY_SET_INFORMATION_CLASS = 4;
pub const _KEY_SET_INFORMATION_CLASS_KeySetHandleTagsInformation: _KEY_SET_INFORMATION_CLASS = 5;
pub const _KEY_SET_INFORMATION_CLASS_KeySetLayerInformation: _KEY_SET_INFORMATION_CLASS = 6;
pub const _KEY_SET_INFORMATION_CLASS_MaxKeySetInfoClass: _KEY_SET_INFORMATION_CLASS = 7;
pub type _KEY_SET_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_KEY_SET_INFORMATION_CLASS as KEY_SET_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KEY_VALUE_BASIC_INFORMATION {
    pub TitleIndex: ULONG,
    pub Type: ULONG,
    pub NameLength: ULONG,
    pub Name: [WCHAR; 1usize],
}
pub type KEY_VALUE_BASIC_INFORMATION = _KEY_VALUE_BASIC_INFORMATION;
pub type PKEY_VALUE_BASIC_INFORMATION = *mut _KEY_VALUE_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KEY_VALUE_FULL_INFORMATION {
    pub TitleIndex: ULONG,
    pub Type: ULONG,
    pub DataOffset: ULONG,
    pub DataLength: ULONG,
    pub NameLength: ULONG,
    pub Name: [WCHAR; 1usize],
}
pub type KEY_VALUE_FULL_INFORMATION = _KEY_VALUE_FULL_INFORMATION;
pub type PKEY_VALUE_FULL_INFORMATION = *mut _KEY_VALUE_FULL_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KEY_VALUE_PARTIAL_INFORMATION {
    pub TitleIndex: ULONG,
    pub Type: ULONG,
    pub DataLength: ULONG,
    pub Data: [UCHAR; 1usize],
}
pub type KEY_VALUE_PARTIAL_INFORMATION = _KEY_VALUE_PARTIAL_INFORMATION;
pub type PKEY_VALUE_PARTIAL_INFORMATION = *mut _KEY_VALUE_PARTIAL_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 {
    pub Type: ULONG,
    pub DataLength: ULONG,
    pub Data: [UCHAR; 1usize],
}
pub type KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 = _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64;
pub type PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64 = *mut _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KEY_VALUE_LAYER_INFORMATION {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KEY_VALUE_LAYER_INFORMATION {
    #[inline]
    pub fn IsTombstone(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsTombstone(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IsTombstone_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IsTombstone_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        IsTombstone: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let IsTombstone: u32 = unsafe { ::core::mem::transmute(IsTombstone) };
            IsTombstone as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type KEY_VALUE_LAYER_INFORMATION = _KEY_VALUE_LAYER_INFORMATION;
pub type PKEY_VALUE_LAYER_INFORMATION = *mut _KEY_VALUE_LAYER_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KEY_VALUE_ENTRY {
    pub ValueName: PUNICODE_STRING,
    pub DataLength: ULONG,
    pub DataOffset: ULONG,
    pub Type: ULONG,
}
pub type KEY_VALUE_ENTRY = _KEY_VALUE_ENTRY;
pub type PKEY_VALUE_ENTRY = *mut _KEY_VALUE_ENTRY;
pub const _KEY_VALUE_INFORMATION_CLASS_KeyValueBasicInformation: _KEY_VALUE_INFORMATION_CLASS = 0;
pub const _KEY_VALUE_INFORMATION_CLASS_KeyValueFullInformation: _KEY_VALUE_INFORMATION_CLASS = 1;
pub const _KEY_VALUE_INFORMATION_CLASS_KeyValuePartialInformation: _KEY_VALUE_INFORMATION_CLASS = 2;
pub const _KEY_VALUE_INFORMATION_CLASS_KeyValueFullInformationAlign64:
_KEY_VALUE_INFORMATION_CLASS = 3;
pub const _KEY_VALUE_INFORMATION_CLASS_KeyValuePartialInformationAlign64:
_KEY_VALUE_INFORMATION_CLASS = 4;
pub const _KEY_VALUE_INFORMATION_CLASS_KeyValueLayerInformation: _KEY_VALUE_INFORMATION_CLASS = 5;
pub const _KEY_VALUE_INFORMATION_CLASS_MaxKeyValueInfoClass: _KEY_VALUE_INFORMATION_CLASS = 6;
pub type _KEY_VALUE_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_KEY_VALUE_INFORMATION_CLASS as KEY_VALUE_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KEY_TRUST_INFORMATION {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KEY_TRUST_INFORMATION {
    #[inline]
    pub fn TrustedKey(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TrustedKey(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TrustedKey_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_TrustedKey_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TrustedKey: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let TrustedKey: u32 = unsafe { ::core::mem::transmute(TrustedKey) };
            TrustedKey as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type KEY_TRUST_INFORMATION = _KEY_TRUST_INFORMATION;
pub type PKEY_TRUST_INFORMATION = *mut _KEY_TRUST_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_NAME_INFORMATION {
    pub Name: UNICODE_STRING,
}
pub type OBJECT_NAME_INFORMATION = _OBJECT_NAME_INFORMATION;
pub type POBJECT_NAME_INFORMATION = *mut _OBJECT_NAME_INFORMATION;
pub const _SECTION_INHERIT_ViewShare: _SECTION_INHERIT = 1;
pub const _SECTION_INHERIT_ViewUnmap: _SECTION_INHERIT = 2;
pub type _SECTION_INHERIT = core::ffi::c_int;
pub use self::_SECTION_INHERIT as SECTION_INHERIT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEM_ADDRESS_REQUIREMENTS {
    pub LowestStartingAddress: PVOID,
    pub HighestEndingAddress: PVOID,
    pub Alignment: SIZE_T,
}
pub type MEM_ADDRESS_REQUIREMENTS = _MEM_ADDRESS_REQUIREMENTS;
pub type PMEM_ADDRESS_REQUIREMENTS = *mut _MEM_ADDRESS_REQUIREMENTS;
pub const MEM_EXTENDED_PARAMETER_TYPE_MemExtendedParameterInvalidType: MEM_EXTENDED_PARAMETER_TYPE =
    0;
pub const MEM_EXTENDED_PARAMETER_TYPE_MemExtendedParameterAddressRequirements:
MEM_EXTENDED_PARAMETER_TYPE = 1;
pub const MEM_EXTENDED_PARAMETER_TYPE_MemExtendedParameterNumaNode: MEM_EXTENDED_PARAMETER_TYPE = 2;
pub const MEM_EXTENDED_PARAMETER_TYPE_MemExtendedParameterPartitionHandle:
MEM_EXTENDED_PARAMETER_TYPE = 3;
pub const MEM_EXTENDED_PARAMETER_TYPE_MemExtendedParameterUserPhysicalHandle:
MEM_EXTENDED_PARAMETER_TYPE = 4;
pub const MEM_EXTENDED_PARAMETER_TYPE_MemExtendedParameterAttributeFlags:
MEM_EXTENDED_PARAMETER_TYPE = 5;
pub const MEM_EXTENDED_PARAMETER_TYPE_MemExtendedParameterImageMachine:
MEM_EXTENDED_PARAMETER_TYPE = 6;
pub const MEM_EXTENDED_PARAMETER_TYPE_MemExtendedParameterMax: MEM_EXTENDED_PARAMETER_TYPE = 7;
pub type MEM_EXTENDED_PARAMETER_TYPE = core::ffi::c_int;
pub type PMEM_EXTENDED_PARAMETER_TYPE = *mut MEM_EXTENDED_PARAMETER_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MEM_EXTENDED_PARAMETER {
    pub __bindgen_anon_1: MEM_EXTENDED_PARAMETER__bindgen_ty_1,
    pub __bindgen_anon_2: MEM_EXTENDED_PARAMETER__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MEM_EXTENDED_PARAMETER__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl MEM_EXTENDED_PARAMETER__bindgen_ty_1 {
    #[inline]
    pub fn Type(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Type(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Type_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Type_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 56u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 56u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                56u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                56u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(Type: ULONG64, Reserved: ULONG64) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let Type: u64 = unsafe { ::core::mem::transmute(Type) };
            Type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 56u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MEM_EXTENDED_PARAMETER__bindgen_ty_2 {
    pub ULong64: ULONG64,
    pub Pointer: PVOID,
    pub Size: SIZE_T,
    pub Handle: HANDLE,
    pub ULong: ULONG,
}
pub type PMEM_EXTENDED_PARAMETER = *mut MEM_EXTENDED_PARAMETER;
pub const _MEM_DEDICATED_ATTRIBUTE_TYPE_MemDedicatedAttributeReadBandwidth:
_MEM_DEDICATED_ATTRIBUTE_TYPE = 0;
pub const _MEM_DEDICATED_ATTRIBUTE_TYPE_MemDedicatedAttributeReadLatency:
_MEM_DEDICATED_ATTRIBUTE_TYPE = 1;
pub const _MEM_DEDICATED_ATTRIBUTE_TYPE_MemDedicatedAttributeWriteBandwidth:
_MEM_DEDICATED_ATTRIBUTE_TYPE = 2;
pub const _MEM_DEDICATED_ATTRIBUTE_TYPE_MemDedicatedAttributeWriteLatency:
_MEM_DEDICATED_ATTRIBUTE_TYPE = 3;
pub const _MEM_DEDICATED_ATTRIBUTE_TYPE_MemDedicatedAttributeMax: _MEM_DEDICATED_ATTRIBUTE_TYPE = 4;
pub type _MEM_DEDICATED_ATTRIBUTE_TYPE = core::ffi::c_int;
pub use self::_MEM_DEDICATED_ATTRIBUTE_TYPE as MEM_DEDICATED_ATTRIBUTE_TYPE;
pub type PMEM_DEDICATED_ATTRIBUTE_TYPE = *mut _MEM_DEDICATED_ATTRIBUTE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_PARTITION_DEDICATED_MEMORY_OPEN_INFORMATION {
    pub DedicatedMemoryTypeId: ULONG64,
    pub HandleAttributes: ULONG,
    pub DesiredAccess: ACCESS_MASK,
    pub DedicatedMemoryPartitionHandle: HANDLE,
}
pub type MEMORY_PARTITION_DEDICATED_MEMORY_OPEN_INFORMATION =
_MEMORY_PARTITION_DEDICATED_MEMORY_OPEN_INFORMATION;
pub type PMEMORY_PARTITION_DEDICATED_MEMORY_OPEN_INFORMATION =
*mut _MEMORY_PARTITION_DEDICATED_MEMORY_OPEN_INFORMATION;
pub const MEM_SECTION_EXTENDED_PARAMETER_TYPE_MemSectionExtendedParameterInvalidType:
MEM_SECTION_EXTENDED_PARAMETER_TYPE = 0;
pub const MEM_SECTION_EXTENDED_PARAMETER_TYPE_MemSectionExtendedParameterUserPhysicalFlags:
MEM_SECTION_EXTENDED_PARAMETER_TYPE = 1;
pub const MEM_SECTION_EXTENDED_PARAMETER_TYPE_MemSectionExtendedParameterNumaNode:
MEM_SECTION_EXTENDED_PARAMETER_TYPE = 2;
pub const MEM_SECTION_EXTENDED_PARAMETER_TYPE_MemSectionExtendedParameterSigningLevel:
MEM_SECTION_EXTENDED_PARAMETER_TYPE = 3;
pub const MEM_SECTION_EXTENDED_PARAMETER_TYPE_MemSectionExtendedParameterMax:
MEM_SECTION_EXTENDED_PARAMETER_TYPE = 4;
pub type MEM_SECTION_EXTENDED_PARAMETER_TYPE = core::ffi::c_int;
pub type PMEM_SECTION_EXTENDED_PARAMETER_TYPE = *mut MEM_SECTION_EXTENDED_PARAMETER_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLIENT_ID {
    pub UniqueProcess: HANDLE,
    pub UniqueThread: HANDLE,
}
pub type CLIENT_ID = _CLIENT_ID;
pub type PCLIENT_ID = *mut CLIENT_ID;
pub const _PARTITION_INFORMATION_CLASS_SystemMemoryPartitionInformation:
_PARTITION_INFORMATION_CLASS = 0;
pub const _PARTITION_INFORMATION_CLASS_SystemMemoryPartitionDedicatedMemoryInformation:
_PARTITION_INFORMATION_CLASS = 9;
pub const _PARTITION_INFORMATION_CLASS_SystemMemoryPartitionOpenDedicatedMemory:
_PARTITION_INFORMATION_CLASS = 10;
pub type _PARTITION_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_PARTITION_INFORMATION_CLASS as PARTITION_INFORMATION_CLASS;
pub type PPARTITION_INFORMATION_CLASS = *mut _PARTITION_INFORMATION_CLASS;
unsafe extern "C" {
    pub fn NtManagePartition(
        TargetHandle: HANDLE,
        SourceHandle: HANDLE,
        PartitionInformationClass: PARTITION_INFORMATION_CLASS,
        PartitionInformation: PVOID,
        PartitionInformationLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub static GUID_MAX_POWER_SAVINGS: GUID;
}
unsafe extern "C" {
    pub static GUID_MIN_POWER_SAVINGS: GUID;
}
unsafe extern "C" {
    pub static GUID_TYPICAL_POWER_SAVINGS: GUID;
}
unsafe extern "C" {
    pub static NO_SUBGROUP_GUID: GUID;
}
unsafe extern "C" {
    pub static ALL_POWERSCHEMES_GUID: GUID;
}
unsafe extern "C" {
    pub static GUID_POWERSCHEME_PERSONALITY: GUID;
}
unsafe extern "C" {
    pub static GUID_ACTIVE_POWERSCHEME: GUID;
}
unsafe extern "C" {
    pub static GUID_IDLE_RESILIENCY_SUBGROUP: GUID;
}
unsafe extern "C" {
    pub static GUID_IDLE_RESILIENCY_PERIOD: GUID;
}
unsafe extern "C" {
    pub static GUID_DEEP_SLEEP_ENABLED: GUID;
}
unsafe extern "C" {
    pub static GUID_DEEP_SLEEP_PLATFORM_STATE: GUID;
}
unsafe extern "C" {
    pub static GUID_DISK_COALESCING_POWERDOWN_TIMEOUT: GUID;
}
unsafe extern "C" {
    pub static GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT: GUID;
}
unsafe extern "C" {
    pub static GUID_VIDEO_SUBGROUP: GUID;
}
unsafe extern "C" {
    pub static GUID_VIDEO_POWERDOWN_TIMEOUT: GUID;
}
unsafe extern "C" {
    pub static GUID_VIDEO_ANNOYANCE_TIMEOUT: GUID;
}
unsafe extern "C" {
    pub static GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE: GUID;
}
unsafe extern "C" {
    pub static GUID_VIDEO_DIM_TIMEOUT: GUID;
}
unsafe extern "C" {
    pub static GUID_VIDEO_ADAPTIVE_POWERDOWN: GUID;
}
unsafe extern "C" {
    pub static GUID_MONITOR_POWER_ON: GUID;
}
unsafe extern "C" {
    pub static GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS: GUID;
}
unsafe extern "C" {
    pub static GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS: GUID;
}
unsafe extern "C" {
    pub static GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS: GUID;
}
unsafe extern "C" {
    pub static GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS: GUID;
}
unsafe extern "C" {
    pub static GUID_CONSOLE_DISPLAY_STATE: GUID;
}
unsafe extern "C" {
    pub static GUID_ALLOW_DISPLAY_REQUIRED: GUID;
}
unsafe extern "C" {
    pub static GUID_VIDEO_CONSOLE_LOCK_TIMEOUT: GUID;
}
unsafe extern "C" {
    pub static GUID_ADVANCED_COLOR_QUALITY_BIAS: GUID;
}
unsafe extern "C" {
    pub static GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP: GUID;
}
unsafe extern "C" {
    pub static GUID_NON_ADAPTIVE_INPUT_TIMEOUT: GUID;
}
unsafe extern "C" {
    pub static GUID_ADAPTIVE_INPUT_CONTROLLER_STATE: GUID;
}
unsafe extern "C" {
    pub static GUID_DISK_SUBGROUP: GUID;
}
unsafe extern "C" {
    pub static GUID_DISK_MAX_POWER: GUID;
}
unsafe extern "C" {
    pub static GUID_DISK_POWERDOWN_TIMEOUT: GUID;
}
unsafe extern "C" {
    pub static GUID_DISK_IDLE_TIMEOUT: GUID;
}
unsafe extern "C" {
    pub static GUID_DISK_BURST_IGNORE_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_DISK_ADAPTIVE_POWERDOWN: GUID;
}
unsafe extern "C" {
    pub static GUID_DISK_NVME_NOPPME: GUID;
}
unsafe extern "C" {
    pub static GUID_SLEEP_SUBGROUP: GUID;
}
unsafe extern "C" {
    pub static GUID_SLEEP_IDLE_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_STANDBY_TIMEOUT: GUID;
}
unsafe extern "C" {
    pub static GUID_UNATTEND_SLEEP_TIMEOUT: GUID;
}
unsafe extern "C" {
    pub static GUID_HIBERNATE_TIMEOUT: GUID;
}
unsafe extern "C" {
    pub static GUID_HIBERNATE_FASTS4_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_CRITICAL_POWER_TRANSITION: GUID;
}
unsafe extern "C" {
    pub static GUID_SYSTEM_AWAYMODE: GUID;
}
unsafe extern "C" {
    pub static GUID_ALLOW_AWAYMODE: GUID;
}
unsafe extern "C" {
    pub static GUID_USER_PRESENCE_PREDICTION: GUID;
}
unsafe extern "C" {
    pub static GUID_STANDBY_BUDGET_GRACE_PERIOD: GUID;
}
unsafe extern "C" {
    pub static GUID_STANDBY_BUDGET_PERCENT: GUID;
}
unsafe extern "C" {
    pub static GUID_STANDBY_RESERVE_GRACE_PERIOD: GUID;
}
unsafe extern "C" {
    pub static GUID_STANDBY_RESERVE_TIME: GUID;
}
unsafe extern "C" {
    pub static GUID_STANDBY_RESET_PERCENT: GUID;
}
unsafe extern "C" {
    pub static GUID_HUPR_ADAPTIVE_AWAY_DISPLAY_TIMEOUT: GUID;
}
unsafe extern "C" {
    pub static GUID_HUPR_ADAPTIVE_INATTENTIVE_DIM_TIMEOUT: GUID;
}
unsafe extern "C" {
    pub static GUID_HUPR_ADAPTIVE_INATTENTIVE_DISPLAY_TIMEOUT: GUID;
}
unsafe extern "C" {
    pub static GUID_HUPR_ADAPTIVE_AWAY_DIM_TIMEOUT: GUID;
}
unsafe extern "C" {
    pub static GUID_ALLOW_STANDBY_STATES: GUID;
}
unsafe extern "C" {
    pub static GUID_ALLOW_RTC_WAKE: GUID;
}
unsafe extern "C" {
    pub static GUID_LEGACY_RTC_MITIGATION: GUID;
}
unsafe extern "C" {
    pub static GUID_ALLOW_SYSTEM_REQUIRED: GUID;
}
unsafe extern "C" {
    pub static GUID_POWER_SAVING_STATUS: GUID;
}
unsafe extern "C" {
    pub static GUID_ENERGY_SAVER_SUBGROUP: GUID;
}
unsafe extern "C" {
    pub static GUID_ENERGY_SAVER_BATTERY_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_ENERGY_SAVER_BRIGHTNESS: GUID;
}
unsafe extern "C" {
    pub static GUID_ENERGY_SAVER_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_SYSTEM_BUTTON_SUBGROUP: GUID;
}
unsafe extern "C" {
    pub static GUID_POWERBUTTON_ACTION: GUID;
}
unsafe extern "C" {
    pub static GUID_SLEEPBUTTON_ACTION: GUID;
}
unsafe extern "C" {
    pub static GUID_USERINTERFACEBUTTON_ACTION: GUID;
}
unsafe extern "C" {
    pub static GUID_LIDCLOSE_ACTION: GUID;
}
unsafe extern "C" {
    pub static GUID_LIDOPEN_POWERSTATE: GUID;
}
unsafe extern "C" {
    pub static GUID_BATTERY_SUBGROUP: GUID;
}
unsafe extern "C" {
    pub static GUID_BATTERY_DISCHARGE_ACTION_0: GUID;
}
unsafe extern "C" {
    pub static GUID_BATTERY_DISCHARGE_LEVEL_0: GUID;
}
unsafe extern "C" {
    pub static GUID_BATTERY_DISCHARGE_FLAGS_0: GUID;
}
unsafe extern "C" {
    pub static GUID_BATTERY_DISCHARGE_ACTION_1: GUID;
}
unsafe extern "C" {
    pub static GUID_BATTERY_DISCHARGE_LEVEL_1: GUID;
}
unsafe extern "C" {
    pub static GUID_BATTERY_DISCHARGE_FLAGS_1: GUID;
}
unsafe extern "C" {
    pub static GUID_BATTERY_DISCHARGE_ACTION_2: GUID;
}
unsafe extern "C" {
    pub static GUID_BATTERY_DISCHARGE_LEVEL_2: GUID;
}
unsafe extern "C" {
    pub static GUID_BATTERY_DISCHARGE_FLAGS_2: GUID;
}
unsafe extern "C" {
    pub static GUID_BATTERY_DISCHARGE_ACTION_3: GUID;
}
unsafe extern "C" {
    pub static GUID_BATTERY_DISCHARGE_LEVEL_3: GUID;
}
unsafe extern "C" {
    pub static GUID_BATTERY_DISCHARGE_FLAGS_3: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_SETTINGS_SUBGROUP: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_THROTTLE_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_THROTTLE_MAXIMUM: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_THROTTLE_MAXIMUM_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_THROTTLE_MINIMUM: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_THROTTLE_MINIMUM_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_FREQUENCY_LIMIT: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_FREQUENCY_LIMIT_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_ALLOW_THROTTLING: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_IDLESTATE_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERFSTATE_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_INCREASE_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_INCREASE_THRESHOLD_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_DECREASE_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_DECREASE_THRESHOLD_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_INCREASE_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_INCREASE_POLICY_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_DECREASE_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_DECREASE_POLICY_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_INCREASE_TIME: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_INCREASE_TIME_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_DECREASE_TIME: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_DECREASE_TIME_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_TIME_CHECK: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_BOOST_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_BOOST_MODE: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_AUTONOMOUS_MODE: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_ENERGY_PERFORMANCE_PREFERENCE: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_ENERGY_PERFORMANCE_PREFERENCE_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_AUTONOMOUS_ACTIVITY_WINDOW: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_DUTY_CYCLING: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_IDLE_ALLOW_SCALING: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_IDLE_DISABLE: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_IDLE_STATE_MAXIMUM: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_IDLE_TIME_CHECK: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_IDLE_DEMOTE_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_IDLE_PROMOTE_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_INCREASE_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_DECREASE_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_INCREASE_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_DECREASE_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_MAX_CORES: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_MAX_CORES_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_MIN_CORES: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_MIN_CORES_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_INCREASE_TIME: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_DECREASE_TIME: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_DECREASE_FACTOR: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_AFFINITY_WEIGHTING: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_DECREASE_FACTOR: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_WEIGHTING: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PARKING_CORE_OVERRIDE: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PARKING_PERF_STATE: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PARKING_PERF_STATE_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PARKING_CONCURRENCY_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PARKING_HEADROOM_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PARKING_DISTRIBUTION_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_SOFT_PARKING_LATENCY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_HISTORY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_HISTORY_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_INCREASE_HISTORY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_DECREASE_HISTORY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_CORE_PARKING_HISTORY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_LATENCY_HINT: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_LATENCY_HINT_PERF: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_PERF_LATENCY_HINT_PERF_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_MODULE_PARKING_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_COMPLEX_PARKING_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_SMT_UNPARKING_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_DISTRIBUTE_UTILITY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_HETEROGENEOUS_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_HETERO_DECREASE_TIME: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_HETERO_INCREASE_TIME: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_HETERO_DECREASE_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_HETERO_DECREASE_THRESHOLD_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_HETERO_INCREASE_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_HETERO_INCREASE_THRESHOLD_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CLASS0_FLOOR_PERF: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_CLASS1_INITIAL_PERF: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_THREAD_SCHEDULING_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_SHORT_THREAD_SCHEDULING_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_SHORT_THREAD_RUNTIME_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_SHORT_THREAD_ARCH_CLASS_UPPER_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_SHORT_THREAD_ARCH_CLASS_LOWER_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_LONG_THREAD_ARCH_CLASS_UPPER_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_LONG_THREAD_ARCH_CLASS_LOWER_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_SYSTEM_COOLING_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_DISABLE_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_DISABLE_THRESHOLD_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_ENABLE_THRESHOLD: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_ENABLE_THRESHOLD_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_DISABLE_TIME: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_DISABLE_TIME_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_ENABLE_TIME: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_ENABLE_TIME_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_EPP_CEILING: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_EPP_CEILING_1: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_PERF_FLOOR: GUID;
}
unsafe extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_PERF_FLOOR_1: GUID;
}
unsafe extern "C" {
    pub static GUID_LOCK_CONSOLE_ON_WAKE: GUID;
}
unsafe extern "C" {
    pub static GUID_DEVICE_IDLE_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_CONNECTIVITY_IN_STANDBY: GUID;
}
unsafe extern "C" {
    pub static GUID_DISCONNECTED_STANDBY_MODE: GUID;
}
unsafe extern "C" {
    pub static GUID_ACDC_POWER_SOURCE: GUID;
}
unsafe extern "C" {
    pub static GUID_LIDSWITCH_STATE_CHANGE: GUID;
}
unsafe extern "C" {
    pub static GUID_LIDSWITCH_STATE_RELIABILITY: GUID;
}
unsafe extern "C" {
    pub static GUID_BATTERY_PERCENTAGE_REMAINING: GUID;
}
unsafe extern "C" {
    pub static GUID_BATTERY_COUNT: GUID;
}
unsafe extern "C" {
    pub static GUID_GLOBAL_USER_PRESENCE: GUID;
}
unsafe extern "C" {
    pub static GUID_SESSION_DISPLAY_STATUS: GUID;
}
unsafe extern "C" {
    pub static GUID_SESSION_USER_PRESENCE: GUID;
}
unsafe extern "C" {
    pub static GUID_IDLE_BACKGROUND_TASK: GUID;
}
unsafe extern "C" {
    pub static GUID_BACKGROUND_TASK_NOTIFICATION: GUID;
}
unsafe extern "C" {
    pub static GUID_APPLAUNCH_BUTTON: GUID;
}
unsafe extern "C" {
    pub static GUID_PCIEXPRESS_SETTINGS_SUBGROUP: GUID;
}
unsafe extern "C" {
    pub static GUID_PCIEXPRESS_ASPM_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_ENABLE_SWITCH_FORCED_SHUTDOWN: GUID;
}
unsafe extern "C" {
    pub static GUID_INTSTEER_SUBGROUP: GUID;
}
unsafe extern "C" {
    pub static GUID_INTSTEER_MODE: GUID;
}
unsafe extern "C" {
    pub static GUID_INTSTEER_LOAD_PER_PROC_TRIGGER: GUID;
}
unsafe extern "C" {
    pub static GUID_INTSTEER_TIME_UNPARK_TRIGGER: GUID;
}
unsafe extern "C" {
    pub static GUID_GRAPHICS_SUBGROUP: GUID;
}
unsafe extern "C" {
    pub static GUID_GPU_PREFERENCE_POLICY: GUID;
}
unsafe extern "C" {
    pub static GUID_MIXED_REALITY_MODE: GUID;
}
unsafe extern "C" {
    pub static GUID_SPR_ACTIVE_SESSION_CHANGE: GUID;
}
pub const _SYSTEM_POWER_STATE_PowerSystemUnspecified: _SYSTEM_POWER_STATE = 0;
pub const _SYSTEM_POWER_STATE_PowerSystemWorking: _SYSTEM_POWER_STATE = 1;
pub const _SYSTEM_POWER_STATE_PowerSystemSleeping1: _SYSTEM_POWER_STATE = 2;
pub const _SYSTEM_POWER_STATE_PowerSystemSleeping2: _SYSTEM_POWER_STATE = 3;
pub const _SYSTEM_POWER_STATE_PowerSystemSleeping3: _SYSTEM_POWER_STATE = 4;
pub const _SYSTEM_POWER_STATE_PowerSystemHibernate: _SYSTEM_POWER_STATE = 5;
pub const _SYSTEM_POWER_STATE_PowerSystemShutdown: _SYSTEM_POWER_STATE = 6;
pub const _SYSTEM_POWER_STATE_PowerSystemMaximum: _SYSTEM_POWER_STATE = 7;
pub type _SYSTEM_POWER_STATE = core::ffi::c_int;
pub use self::_SYSTEM_POWER_STATE as SYSTEM_POWER_STATE;
pub type PSYSTEM_POWER_STATE = *mut _SYSTEM_POWER_STATE;
pub const POWER_ACTION_PowerActionNone: POWER_ACTION = 0;
pub const POWER_ACTION_PowerActionReserved: POWER_ACTION = 1;
pub const POWER_ACTION_PowerActionSleep: POWER_ACTION = 2;
pub const POWER_ACTION_PowerActionHibernate: POWER_ACTION = 3;
pub const POWER_ACTION_PowerActionShutdown: POWER_ACTION = 4;
pub const POWER_ACTION_PowerActionShutdownReset: POWER_ACTION = 5;
pub const POWER_ACTION_PowerActionShutdownOff: POWER_ACTION = 6;
pub const POWER_ACTION_PowerActionWarmEject: POWER_ACTION = 7;
pub const POWER_ACTION_PowerActionDisplayOff: POWER_ACTION = 8;
pub type POWER_ACTION = core::ffi::c_int;
pub type PPOWER_ACTION = *mut POWER_ACTION;
pub const _DEVICE_POWER_STATE_PowerDeviceUnspecified: _DEVICE_POWER_STATE = 0;
pub const _DEVICE_POWER_STATE_PowerDeviceD0: _DEVICE_POWER_STATE = 1;
pub const _DEVICE_POWER_STATE_PowerDeviceD1: _DEVICE_POWER_STATE = 2;
pub const _DEVICE_POWER_STATE_PowerDeviceD2: _DEVICE_POWER_STATE = 3;
pub const _DEVICE_POWER_STATE_PowerDeviceD3: _DEVICE_POWER_STATE = 4;
pub const _DEVICE_POWER_STATE_PowerDeviceMaximum: _DEVICE_POWER_STATE = 5;
pub type _DEVICE_POWER_STATE = core::ffi::c_int;
pub use self::_DEVICE_POWER_STATE as DEVICE_POWER_STATE;
pub type PDEVICE_POWER_STATE = *mut _DEVICE_POWER_STATE;
pub const _MONITOR_DISPLAY_STATE_PowerMonitorOff: _MONITOR_DISPLAY_STATE = 0;
pub const _MONITOR_DISPLAY_STATE_PowerMonitorOn: _MONITOR_DISPLAY_STATE = 1;
pub const _MONITOR_DISPLAY_STATE_PowerMonitorDim: _MONITOR_DISPLAY_STATE = 2;
pub type _MONITOR_DISPLAY_STATE = core::ffi::c_int;
pub use self::_MONITOR_DISPLAY_STATE as MONITOR_DISPLAY_STATE;
pub type PMONITOR_DISPLAY_STATE = *mut _MONITOR_DISPLAY_STATE;
pub const _USER_ACTIVITY_PRESENCE_PowerUserPresent: _USER_ACTIVITY_PRESENCE = 0;
pub const _USER_ACTIVITY_PRESENCE_PowerUserNotPresent: _USER_ACTIVITY_PRESENCE = 1;
pub const _USER_ACTIVITY_PRESENCE_PowerUserInactive: _USER_ACTIVITY_PRESENCE = 2;
pub const _USER_ACTIVITY_PRESENCE_PowerUserMaximum: _USER_ACTIVITY_PRESENCE = 3;
pub const _USER_ACTIVITY_PRESENCE_PowerUserInvalid: _USER_ACTIVITY_PRESENCE = 3;
pub type _USER_ACTIVITY_PRESENCE = core::ffi::c_int;
pub use self::_USER_ACTIVITY_PRESENCE as USER_ACTIVITY_PRESENCE;
pub type PUSER_ACTIVITY_PRESENCE = *mut _USER_ACTIVITY_PRESENCE;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _POWER_STATE {
    pub SystemState: SYSTEM_POWER_STATE,
    pub DeviceState: DEVICE_POWER_STATE,
}
pub type POWER_STATE = _POWER_STATE;
pub type PPOWER_STATE = *mut _POWER_STATE;
pub const _POWER_STATE_TYPE_SystemPowerState: _POWER_STATE_TYPE = 0;
pub const _POWER_STATE_TYPE_DevicePowerState: _POWER_STATE_TYPE = 1;
pub type _POWER_STATE_TYPE = core::ffi::c_int;
pub use self::_POWER_STATE_TYPE as POWER_STATE_TYPE;
pub type PPOWER_STATE_TYPE = *mut _POWER_STATE_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_POWER_STATE_CONTEXT {
    pub __bindgen_anon_1: _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1 {
    pub __bindgen_anon_1: _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1,
    pub ContextAsUlong: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TargetSystemState(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_TargetSystemState(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TargetSystemState_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_TargetSystemState_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EffectiveSystemState(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_EffectiveSystemState(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EffectiveSystemState_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_EffectiveSystemState_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CurrentSystemState(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_CurrentSystemState(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CurrentSystemState_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CurrentSystemState_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IgnoreHibernationPath(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IgnoreHibernationPath(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IgnoreHibernationPath_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IgnoreHibernationPath_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PseudoTransition(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PseudoTransition(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PseudoTransition_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PseudoTransition_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn KernelSoftReboot(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_KernelSoftReboot(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn KernelSoftReboot_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_KernelSoftReboot_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DirectedDripsTransition(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DirectedDripsTransition(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DirectedDripsTransition_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DirectedDripsTransition_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Reserved1: ULONG,
        TargetSystemState: ULONG,
        EffectiveSystemState: ULONG,
        CurrentSystemState: ULONG,
        IgnoreHibernationPath: ULONG,
        PseudoTransition: ULONG,
        KernelSoftReboot: ULONG,
        DirectedDripsTransition: ULONG,
        Reserved2: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let TargetSystemState: u32 = unsafe { ::core::mem::transmute(TargetSystemState) };
            TargetSystemState as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let EffectiveSystemState: u32 = unsafe { ::core::mem::transmute(EffectiveSystemState) };
            EffectiveSystemState as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let CurrentSystemState: u32 = unsafe { ::core::mem::transmute(CurrentSystemState) };
            CurrentSystemState as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let IgnoreHibernationPath: u32 =
                unsafe { ::core::mem::transmute(IgnoreHibernationPath) };
            IgnoreHibernationPath as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let PseudoTransition: u32 = unsafe { ::core::mem::transmute(PseudoTransition) };
            PseudoTransition as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let KernelSoftReboot: u32 = unsafe { ::core::mem::transmute(KernelSoftReboot) };
            KernelSoftReboot as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let DirectedDripsTransition: u32 =
                unsafe { ::core::mem::transmute(DirectedDripsTransition) };
            DirectedDripsTransition as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let Reserved2: u32 = unsafe { ::core::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type SYSTEM_POWER_STATE_CONTEXT = _SYSTEM_POWER_STATE_CONTEXT;
pub type PSYSTEM_POWER_STATE_CONTEXT = *mut _SYSTEM_POWER_STATE_CONTEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _COUNTED_REASON_CONTEXT {
    pub Version: ULONG,
    pub Flags: ULONG,
    pub __bindgen_anon_1: _COUNTED_REASON_CONTEXT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _COUNTED_REASON_CONTEXT__bindgen_ty_1 {
    pub __bindgen_anon_1: _COUNTED_REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1,
    pub SimpleString: UNICODE_STRING,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _COUNTED_REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    pub ResourceFileName: UNICODE_STRING,
    pub ResourceReasonId: USHORT,
    pub StringCount: ULONG,
    pub ReasonStrings: PUNICODE_STRING,
}
pub type COUNTED_REASON_CONTEXT = _COUNTED_REASON_CONTEXT;
pub type PCOUNTED_REASON_CONTEXT = *mut _COUNTED_REASON_CONTEXT;
pub type EXECUTION_STATE = ULONG;
pub type PEXECUTION_STATE = *mut ULONG;
pub const LATENCY_TIME_LT_DONT_CARE: LATENCY_TIME = 0;
pub const LATENCY_TIME_LT_LOWEST_LATENCY: LATENCY_TIME = 1;
pub type LATENCY_TIME = core::ffi::c_int;
pub const _POWER_REQUEST_TYPE_PowerRequestDisplayRequired: _POWER_REQUEST_TYPE = 0;
pub const _POWER_REQUEST_TYPE_PowerRequestSystemRequired: _POWER_REQUEST_TYPE = 1;
pub const _POWER_REQUEST_TYPE_PowerRequestAwayModeRequired: _POWER_REQUEST_TYPE = 2;
pub const _POWER_REQUEST_TYPE_PowerRequestExecutionRequired: _POWER_REQUEST_TYPE = 3;
pub type _POWER_REQUEST_TYPE = core::ffi::c_int;
pub use self::_POWER_REQUEST_TYPE as POWER_REQUEST_TYPE;
pub type PPOWER_REQUEST_TYPE = *mut _POWER_REQUEST_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CM_Power_Data_s {
    pub PD_Size: ULONG,
    pub PD_MostRecentPowerState: DEVICE_POWER_STATE,
    pub PD_Capabilities: ULONG,
    pub PD_D1Latency: ULONG,
    pub PD_D2Latency: ULONG,
    pub PD_D3Latency: ULONG,
    pub PD_PowerStateMapping: [DEVICE_POWER_STATE; 7usize],
    pub PD_DeepestSystemWake: SYSTEM_POWER_STATE,
}
pub type CM_POWER_DATA = CM_Power_Data_s;
pub type PCM_POWER_DATA = *mut CM_Power_Data_s;
pub const POWER_INFORMATION_LEVEL_SystemPowerPolicyAc: POWER_INFORMATION_LEVEL = 0;
pub const POWER_INFORMATION_LEVEL_SystemPowerPolicyDc: POWER_INFORMATION_LEVEL = 1;
pub const POWER_INFORMATION_LEVEL_VerifySystemPolicyAc: POWER_INFORMATION_LEVEL = 2;
pub const POWER_INFORMATION_LEVEL_VerifySystemPolicyDc: POWER_INFORMATION_LEVEL = 3;
pub const POWER_INFORMATION_LEVEL_SystemPowerCapabilities: POWER_INFORMATION_LEVEL = 4;
pub const POWER_INFORMATION_LEVEL_SystemBatteryState: POWER_INFORMATION_LEVEL = 5;
pub const POWER_INFORMATION_LEVEL_SystemPowerStateHandler: POWER_INFORMATION_LEVEL = 6;
pub const POWER_INFORMATION_LEVEL_ProcessorStateHandler: POWER_INFORMATION_LEVEL = 7;
pub const POWER_INFORMATION_LEVEL_SystemPowerPolicyCurrent: POWER_INFORMATION_LEVEL = 8;
pub const POWER_INFORMATION_LEVEL_AdministratorPowerPolicy: POWER_INFORMATION_LEVEL = 9;
pub const POWER_INFORMATION_LEVEL_SystemReserveHiberFile: POWER_INFORMATION_LEVEL = 10;
pub const POWER_INFORMATION_LEVEL_ProcessorInformation: POWER_INFORMATION_LEVEL = 11;
pub const POWER_INFORMATION_LEVEL_SystemPowerInformation: POWER_INFORMATION_LEVEL = 12;
pub const POWER_INFORMATION_LEVEL_ProcessorStateHandler2: POWER_INFORMATION_LEVEL = 13;
pub const POWER_INFORMATION_LEVEL_LastWakeTime: POWER_INFORMATION_LEVEL = 14;
pub const POWER_INFORMATION_LEVEL_LastSleepTime: POWER_INFORMATION_LEVEL = 15;
pub const POWER_INFORMATION_LEVEL_SystemExecutionState: POWER_INFORMATION_LEVEL = 16;
pub const POWER_INFORMATION_LEVEL_SystemPowerStateNotifyHandler: POWER_INFORMATION_LEVEL = 17;
pub const POWER_INFORMATION_LEVEL_ProcessorPowerPolicyAc: POWER_INFORMATION_LEVEL = 18;
pub const POWER_INFORMATION_LEVEL_ProcessorPowerPolicyDc: POWER_INFORMATION_LEVEL = 19;
pub const POWER_INFORMATION_LEVEL_VerifyProcessorPowerPolicyAc: POWER_INFORMATION_LEVEL = 20;
pub const POWER_INFORMATION_LEVEL_VerifyProcessorPowerPolicyDc: POWER_INFORMATION_LEVEL = 21;
pub const POWER_INFORMATION_LEVEL_ProcessorPowerPolicyCurrent: POWER_INFORMATION_LEVEL = 22;
pub const POWER_INFORMATION_LEVEL_SystemPowerStateLogging: POWER_INFORMATION_LEVEL = 23;
pub const POWER_INFORMATION_LEVEL_SystemPowerLoggingEntry: POWER_INFORMATION_LEVEL = 24;
pub const POWER_INFORMATION_LEVEL_SetPowerSettingValue: POWER_INFORMATION_LEVEL = 25;
pub const POWER_INFORMATION_LEVEL_NotifyUserPowerSetting: POWER_INFORMATION_LEVEL = 26;
pub const POWER_INFORMATION_LEVEL_PowerInformationLevelUnused0: POWER_INFORMATION_LEVEL = 27;
pub const POWER_INFORMATION_LEVEL_SystemMonitorHiberBootPowerOff: POWER_INFORMATION_LEVEL = 28;
pub const POWER_INFORMATION_LEVEL_SystemVideoState: POWER_INFORMATION_LEVEL = 29;
pub const POWER_INFORMATION_LEVEL_TraceApplicationPowerMessage: POWER_INFORMATION_LEVEL = 30;
pub const POWER_INFORMATION_LEVEL_TraceApplicationPowerMessageEnd: POWER_INFORMATION_LEVEL = 31;
pub const POWER_INFORMATION_LEVEL_ProcessorPerfStates: POWER_INFORMATION_LEVEL = 32;
pub const POWER_INFORMATION_LEVEL_ProcessorIdleStates: POWER_INFORMATION_LEVEL = 33;
pub const POWER_INFORMATION_LEVEL_ProcessorCap: POWER_INFORMATION_LEVEL = 34;
pub const POWER_INFORMATION_LEVEL_SystemWakeSource: POWER_INFORMATION_LEVEL = 35;
pub const POWER_INFORMATION_LEVEL_SystemHiberFileInformation: POWER_INFORMATION_LEVEL = 36;
pub const POWER_INFORMATION_LEVEL_TraceServicePowerMessage: POWER_INFORMATION_LEVEL = 37;
pub const POWER_INFORMATION_LEVEL_ProcessorLoad: POWER_INFORMATION_LEVEL = 38;
pub const POWER_INFORMATION_LEVEL_PowerShutdownNotification: POWER_INFORMATION_LEVEL = 39;
pub const POWER_INFORMATION_LEVEL_MonitorCapabilities: POWER_INFORMATION_LEVEL = 40;
pub const POWER_INFORMATION_LEVEL_SessionPowerInit: POWER_INFORMATION_LEVEL = 41;
pub const POWER_INFORMATION_LEVEL_SessionDisplayState: POWER_INFORMATION_LEVEL = 42;
pub const POWER_INFORMATION_LEVEL_PowerRequestCreate: POWER_INFORMATION_LEVEL = 43;
pub const POWER_INFORMATION_LEVEL_PowerRequestAction: POWER_INFORMATION_LEVEL = 44;
pub const POWER_INFORMATION_LEVEL_GetPowerRequestList: POWER_INFORMATION_LEVEL = 45;
pub const POWER_INFORMATION_LEVEL_ProcessorInformationEx: POWER_INFORMATION_LEVEL = 46;
pub const POWER_INFORMATION_LEVEL_NotifyUserModeLegacyPowerEvent: POWER_INFORMATION_LEVEL = 47;
pub const POWER_INFORMATION_LEVEL_GroupPark: POWER_INFORMATION_LEVEL = 48;
pub const POWER_INFORMATION_LEVEL_ProcessorIdleDomains: POWER_INFORMATION_LEVEL = 49;
pub const POWER_INFORMATION_LEVEL_WakeTimerList: POWER_INFORMATION_LEVEL = 50;
pub const POWER_INFORMATION_LEVEL_SystemHiberFileSize: POWER_INFORMATION_LEVEL = 51;
pub const POWER_INFORMATION_LEVEL_ProcessorIdleStatesHv: POWER_INFORMATION_LEVEL = 52;
pub const POWER_INFORMATION_LEVEL_ProcessorPerfStatesHv: POWER_INFORMATION_LEVEL = 53;
pub const POWER_INFORMATION_LEVEL_ProcessorPerfCapHv: POWER_INFORMATION_LEVEL = 54;
pub const POWER_INFORMATION_LEVEL_ProcessorSetIdle: POWER_INFORMATION_LEVEL = 55;
pub const POWER_INFORMATION_LEVEL_LogicalProcessorIdling: POWER_INFORMATION_LEVEL = 56;
pub const POWER_INFORMATION_LEVEL_UserPresence: POWER_INFORMATION_LEVEL = 57;
pub const POWER_INFORMATION_LEVEL_PowerSettingNotificationName: POWER_INFORMATION_LEVEL = 58;
pub const POWER_INFORMATION_LEVEL_GetPowerSettingValue: POWER_INFORMATION_LEVEL = 59;
pub const POWER_INFORMATION_LEVEL_IdleResiliency: POWER_INFORMATION_LEVEL = 60;
pub const POWER_INFORMATION_LEVEL_SessionRITState: POWER_INFORMATION_LEVEL = 61;
pub const POWER_INFORMATION_LEVEL_SessionConnectNotification: POWER_INFORMATION_LEVEL = 62;
pub const POWER_INFORMATION_LEVEL_SessionPowerCleanup: POWER_INFORMATION_LEVEL = 63;
pub const POWER_INFORMATION_LEVEL_SessionLockState: POWER_INFORMATION_LEVEL = 64;
pub const POWER_INFORMATION_LEVEL_SystemHiberbootState: POWER_INFORMATION_LEVEL = 65;
pub const POWER_INFORMATION_LEVEL_PlatformInformation: POWER_INFORMATION_LEVEL = 66;
pub const POWER_INFORMATION_LEVEL_PdcInvocation: POWER_INFORMATION_LEVEL = 67;
pub const POWER_INFORMATION_LEVEL_MonitorInvocation: POWER_INFORMATION_LEVEL = 68;
pub const POWER_INFORMATION_LEVEL_FirmwareTableInformationRegistered: POWER_INFORMATION_LEVEL = 69;
pub const POWER_INFORMATION_LEVEL_SetShutdownSelectedTime: POWER_INFORMATION_LEVEL = 70;
pub const POWER_INFORMATION_LEVEL_SuspendResumeInvocation: POWER_INFORMATION_LEVEL = 71;
pub const POWER_INFORMATION_LEVEL_PlmPowerRequestCreate: POWER_INFORMATION_LEVEL = 72;
pub const POWER_INFORMATION_LEVEL_ScreenOff: POWER_INFORMATION_LEVEL = 73;
pub const POWER_INFORMATION_LEVEL_CsDeviceNotification: POWER_INFORMATION_LEVEL = 74;
pub const POWER_INFORMATION_LEVEL_PlatformRole: POWER_INFORMATION_LEVEL = 75;
pub const POWER_INFORMATION_LEVEL_LastResumePerformance: POWER_INFORMATION_LEVEL = 76;
pub const POWER_INFORMATION_LEVEL_DisplayBurst: POWER_INFORMATION_LEVEL = 77;
pub const POWER_INFORMATION_LEVEL_ExitLatencySamplingPercentage: POWER_INFORMATION_LEVEL = 78;
pub const POWER_INFORMATION_LEVEL_RegisterSpmPowerSettings: POWER_INFORMATION_LEVEL = 79;
pub const POWER_INFORMATION_LEVEL_PlatformIdleStates: POWER_INFORMATION_LEVEL = 80;
pub const POWER_INFORMATION_LEVEL_ProcessorIdleVeto: POWER_INFORMATION_LEVEL = 81;
pub const POWER_INFORMATION_LEVEL_PlatformIdleVeto: POWER_INFORMATION_LEVEL = 82;
pub const POWER_INFORMATION_LEVEL_SystemBatteryStatePrecise: POWER_INFORMATION_LEVEL = 83;
pub const POWER_INFORMATION_LEVEL_ThermalEvent: POWER_INFORMATION_LEVEL = 84;
pub const POWER_INFORMATION_LEVEL_PowerRequestActionInternal: POWER_INFORMATION_LEVEL = 85;
pub const POWER_INFORMATION_LEVEL_BatteryDeviceState: POWER_INFORMATION_LEVEL = 86;
pub const POWER_INFORMATION_LEVEL_PowerInformationInternal: POWER_INFORMATION_LEVEL = 87;
pub const POWER_INFORMATION_LEVEL_ThermalStandby: POWER_INFORMATION_LEVEL = 88;
pub const POWER_INFORMATION_LEVEL_SystemHiberFileType: POWER_INFORMATION_LEVEL = 89;
pub const POWER_INFORMATION_LEVEL_PhysicalPowerButtonPress: POWER_INFORMATION_LEVEL = 90;
pub const POWER_INFORMATION_LEVEL_QueryPotentialDripsConstraint: POWER_INFORMATION_LEVEL = 91;
pub const POWER_INFORMATION_LEVEL_EnergyTrackerCreate: POWER_INFORMATION_LEVEL = 92;
pub const POWER_INFORMATION_LEVEL_EnergyTrackerQuery: POWER_INFORMATION_LEVEL = 93;
pub const POWER_INFORMATION_LEVEL_UpdateBlackBoxRecorder: POWER_INFORMATION_LEVEL = 94;
pub const POWER_INFORMATION_LEVEL_SessionAllowExternalDmaDevices: POWER_INFORMATION_LEVEL = 95;
pub const POWER_INFORMATION_LEVEL_SendSuspendResumeNotification: POWER_INFORMATION_LEVEL = 96;
pub const POWER_INFORMATION_LEVEL_BlackBoxRecorderDirectAccessBuffer: POWER_INFORMATION_LEVEL = 97;
pub const POWER_INFORMATION_LEVEL_PowerInformationLevelMaximum: POWER_INFORMATION_LEVEL = 98;
pub type POWER_INFORMATION_LEVEL = core::ffi::c_int;
pub const POWER_USER_PRESENCE_TYPE_UserNotPresent: POWER_USER_PRESENCE_TYPE = 0;
pub const POWER_USER_PRESENCE_TYPE_UserPresent: POWER_USER_PRESENCE_TYPE = 1;
pub const POWER_USER_PRESENCE_TYPE_UserUnknown: POWER_USER_PRESENCE_TYPE = 255;
pub type POWER_USER_PRESENCE_TYPE = core::ffi::c_int;
pub type PPOWER_USER_PRESENCE_TYPE = *mut POWER_USER_PRESENCE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_USER_PRESENCE {
    pub UserPresence: POWER_USER_PRESENCE_TYPE,
}
pub type POWER_USER_PRESENCE = _POWER_USER_PRESENCE;
pub type PPOWER_USER_PRESENCE = *mut _POWER_USER_PRESENCE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_SESSION_CONNECT {
    pub Connected: BOOLEAN,
    pub Console: BOOLEAN,
}
pub type POWER_SESSION_CONNECT = _POWER_SESSION_CONNECT;
pub type PPOWER_SESSION_CONNECT = *mut _POWER_SESSION_CONNECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_SESSION_TIMEOUTS {
    pub InputTimeout: ULONG,
    pub DisplayTimeout: ULONG,
}
pub type POWER_SESSION_TIMEOUTS = _POWER_SESSION_TIMEOUTS;
pub type PPOWER_SESSION_TIMEOUTS = *mut _POWER_SESSION_TIMEOUTS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_SESSION_RIT_STATE {
    pub Active: BOOLEAN,
    pub LastInputTime: ULONG64,
}
pub type POWER_SESSION_RIT_STATE = _POWER_SESSION_RIT_STATE;
pub type PPOWER_SESSION_RIT_STATE = *mut _POWER_SESSION_RIT_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_SESSION_WINLOGON {
    pub SessionId: ULONG,
    pub Console: BOOLEAN,
    pub Locked: BOOLEAN,
}
pub type POWER_SESSION_WINLOGON = _POWER_SESSION_WINLOGON;
pub type PPOWER_SESSION_WINLOGON = *mut _POWER_SESSION_WINLOGON;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES {
    pub IsAllowed: BOOLEAN,
}
pub type POWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES = _POWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES;
pub type PPOWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES = *mut _POWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_IDLE_RESILIENCY {
    pub CoalescingTimeout: ULONG,
    pub IdleResiliencyPeriod: ULONG,
}
pub type POWER_IDLE_RESILIENCY = _POWER_IDLE_RESILIENCY;
pub type PPOWER_IDLE_RESILIENCY = *mut _POWER_IDLE_RESILIENCY;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUnknown: POWER_MONITOR_REQUEST_REASON =
    0;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPowerButton:
POWER_MONITOR_REQUEST_REASON = 1;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonRemoteConnection:
POWER_MONITOR_REQUEST_REASON = 2;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonScMonitorpower:
POWER_MONITOR_REQUEST_REASON = 3;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInput: POWER_MONITOR_REQUEST_REASON =
    4;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonAcDcDisplayBurst:
POWER_MONITOR_REQUEST_REASON = 5;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserDisplayBurst:
POWER_MONITOR_REQUEST_REASON = 6;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPoSetSystemState:
POWER_MONITOR_REQUEST_REASON = 7;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonSetThreadExecutionState:
POWER_MONITOR_REQUEST_REASON = 8;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonFullWake: POWER_MONITOR_REQUEST_REASON =
    9;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonSessionUnlock:
POWER_MONITOR_REQUEST_REASON = 10;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonScreenOffRequest:
POWER_MONITOR_REQUEST_REASON = 11;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonIdleTimeout:
POWER_MONITOR_REQUEST_REASON = 12;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPolicyChange:
POWER_MONITOR_REQUEST_REASON = 13;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonSleepButton:
POWER_MONITOR_REQUEST_REASON = 14;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonLid: POWER_MONITOR_REQUEST_REASON = 15;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonBatteryCountChange:
POWER_MONITOR_REQUEST_REASON = 16;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonGracePeriod:
POWER_MONITOR_REQUEST_REASON = 17;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPnP: POWER_MONITOR_REQUEST_REASON = 18;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonDP: POWER_MONITOR_REQUEST_REASON = 19;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonSxTransition:
POWER_MONITOR_REQUEST_REASON = 20;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonSystemIdle:
POWER_MONITOR_REQUEST_REASON = 21;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonNearProximity:
POWER_MONITOR_REQUEST_REASON = 22;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonThermalStandby:
POWER_MONITOR_REQUEST_REASON = 23;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonResumePdc: POWER_MONITOR_REQUEST_REASON =
    24;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonResumeS4: POWER_MONITOR_REQUEST_REASON =
    25;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonTerminal: POWER_MONITOR_REQUEST_REASON =
    26;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPdcSignal: POWER_MONITOR_REQUEST_REASON =
    27;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonAcDcDisplayBurstSuppressed:
POWER_MONITOR_REQUEST_REASON = 28;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonSystemStateEntered:
POWER_MONITOR_REQUEST_REASON = 29;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonWinrt: POWER_MONITOR_REQUEST_REASON = 30;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputKeyboard:
POWER_MONITOR_REQUEST_REASON = 31;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputMouse:
POWER_MONITOR_REQUEST_REASON = 32;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputTouchpad:
POWER_MONITOR_REQUEST_REASON = 33;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputPen:
POWER_MONITOR_REQUEST_REASON = 34;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputAccelerometer:
POWER_MONITOR_REQUEST_REASON = 35;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputHid:
POWER_MONITOR_REQUEST_REASON = 36;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputPoUserPresent:
POWER_MONITOR_REQUEST_REASON = 37;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputSessionSwitch:
POWER_MONITOR_REQUEST_REASON = 38;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputInitialization:
POWER_MONITOR_REQUEST_REASON = 39;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPdcSignalWindowsMobilePwrNotif:
POWER_MONITOR_REQUEST_REASON = 40;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPdcSignalWindowsMobileShell:
POWER_MONITOR_REQUEST_REASON = 41;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPdcSignalHeyCortana:
POWER_MONITOR_REQUEST_REASON = 42;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPdcSignalHolographicShell:
POWER_MONITOR_REQUEST_REASON = 43;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPdcSignalFingerprint:
POWER_MONITOR_REQUEST_REASON = 44;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonDirectedDrips:
POWER_MONITOR_REQUEST_REASON = 45;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonDim: POWER_MONITOR_REQUEST_REASON = 46;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonBuiltinPanel:
POWER_MONITOR_REQUEST_REASON = 47;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonDisplayRequiredUnDim:
POWER_MONITOR_REQUEST_REASON = 48;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonBatteryCountChangeSuppressed:
POWER_MONITOR_REQUEST_REASON = 49;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonResumeModernStandby:
POWER_MONITOR_REQUEST_REASON = 50;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonTerminalInit:
POWER_MONITOR_REQUEST_REASON = 51;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPdcSignalSensorsHumanPresence:
POWER_MONITOR_REQUEST_REASON = 52;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonBatteryPreCritical:
POWER_MONITOR_REQUEST_REASON = 53;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputTouch:
POWER_MONITOR_REQUEST_REASON = 54;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonMax: POWER_MONITOR_REQUEST_REASON = 55;
pub type POWER_MONITOR_REQUEST_REASON = core::ffi::c_int;
pub const _POWER_MONITOR_REQUEST_TYPE_MonitorRequestTypeOff: _POWER_MONITOR_REQUEST_TYPE = 0;
pub const _POWER_MONITOR_REQUEST_TYPE_MonitorRequestTypeOnAndPresent: _POWER_MONITOR_REQUEST_TYPE =
    1;
pub const _POWER_MONITOR_REQUEST_TYPE_MonitorRequestTypeToggleOn: _POWER_MONITOR_REQUEST_TYPE = 2;
pub type _POWER_MONITOR_REQUEST_TYPE = core::ffi::c_int;
pub use self::_POWER_MONITOR_REQUEST_TYPE as POWER_MONITOR_REQUEST_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_MONITOR_INVOCATION {
    pub Console: BOOLEAN,
    pub RequestReason: POWER_MONITOR_REQUEST_REASON,
}
pub type POWER_MONITOR_INVOCATION = _POWER_MONITOR_INVOCATION;
pub type PPOWER_MONITOR_INVOCATION = *mut _POWER_MONITOR_INVOCATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RESUME_PERFORMANCE {
    pub PostTimeMs: ULONG,
    pub TotalResumeTimeMs: ULONGLONG,
    pub ResumeCompleteTimestamp: ULONGLONG,
}
pub type RESUME_PERFORMANCE = _RESUME_PERFORMANCE;
pub type PRESUME_PERFORMANCE = *mut _RESUME_PERFORMANCE;
pub const SYSTEM_POWER_CONDITION_PoAc: SYSTEM_POWER_CONDITION = 0;
pub const SYSTEM_POWER_CONDITION_PoDc: SYSTEM_POWER_CONDITION = 1;
pub const SYSTEM_POWER_CONDITION_PoHot: SYSTEM_POWER_CONDITION = 2;
pub const SYSTEM_POWER_CONDITION_PoConditionMaximum: SYSTEM_POWER_CONDITION = 3;
pub type SYSTEM_POWER_CONDITION = core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SET_POWER_SETTING_VALUE {
    pub Version: ULONG,
    pub Guid: GUID,
    pub PowerCondition: SYSTEM_POWER_CONDITION,
    pub DataLength: ULONG,
    pub Data: [UCHAR; 1usize],
}
pub type PSET_POWER_SETTING_VALUE = *mut SET_POWER_SETTING_VALUE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NOTIFY_USER_POWER_SETTING {
    pub Guid: GUID,
}
pub type PNOTIFY_USER_POWER_SETTING = *mut NOTIFY_USER_POWER_SETTING;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _APPLICATIONLAUNCH_SETTING_VALUE {
    pub ActivationTime: LARGE_INTEGER,
    pub Flags: ULONG,
    pub ButtonInstanceID: ULONG,
}
pub type APPLICATIONLAUNCH_SETTING_VALUE = _APPLICATIONLAUNCH_SETTING_VALUE;
pub type PAPPLICATIONLAUNCH_SETTING_VALUE = *mut _APPLICATIONLAUNCH_SETTING_VALUE;
pub const _POWER_PLATFORM_ROLE_PlatformRoleUnspecified: _POWER_PLATFORM_ROLE = 0;
pub const _POWER_PLATFORM_ROLE_PlatformRoleDesktop: _POWER_PLATFORM_ROLE = 1;
pub const _POWER_PLATFORM_ROLE_PlatformRoleMobile: _POWER_PLATFORM_ROLE = 2;
pub const _POWER_PLATFORM_ROLE_PlatformRoleWorkstation: _POWER_PLATFORM_ROLE = 3;
pub const _POWER_PLATFORM_ROLE_PlatformRoleEnterpriseServer: _POWER_PLATFORM_ROLE = 4;
pub const _POWER_PLATFORM_ROLE_PlatformRoleSOHOServer: _POWER_PLATFORM_ROLE = 5;
pub const _POWER_PLATFORM_ROLE_PlatformRoleAppliancePC: _POWER_PLATFORM_ROLE = 6;
pub const _POWER_PLATFORM_ROLE_PlatformRolePerformanceServer: _POWER_PLATFORM_ROLE = 7;
pub const _POWER_PLATFORM_ROLE_PlatformRoleSlate: _POWER_PLATFORM_ROLE = 8;
pub const _POWER_PLATFORM_ROLE_PlatformRoleMaximum: _POWER_PLATFORM_ROLE = 9;
pub type _POWER_PLATFORM_ROLE = core::ffi::c_int;
pub use self::_POWER_PLATFORM_ROLE as POWER_PLATFORM_ROLE;
pub type PPOWER_PLATFORM_ROLE = *mut _POWER_PLATFORM_ROLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_PLATFORM_INFORMATION {
    pub AoAc: BOOLEAN,
}
pub type POWER_PLATFORM_INFORMATION = _POWER_PLATFORM_INFORMATION;
pub type PPOWER_PLATFORM_INFORMATION = *mut _POWER_PLATFORM_INFORMATION;
pub const POWER_SETTING_ALTITUDE_ALTITUDE_GROUP_POLICY: POWER_SETTING_ALTITUDE = 0;
pub const POWER_SETTING_ALTITUDE_ALTITUDE_USER: POWER_SETTING_ALTITUDE = 1;
pub const POWER_SETTING_ALTITUDE_ALTITUDE_RUNTIME_OVERRIDE: POWER_SETTING_ALTITUDE = 2;
pub const POWER_SETTING_ALTITUDE_ALTITUDE_PROVISIONING: POWER_SETTING_ALTITUDE = 3;
pub const POWER_SETTING_ALTITUDE_ALTITUDE_OEM_CUSTOMIZATION: POWER_SETTING_ALTITUDE = 4;
pub const POWER_SETTING_ALTITUDE_ALTITUDE_INTERNAL_OVERRIDE: POWER_SETTING_ALTITUDE = 5;
pub const POWER_SETTING_ALTITUDE_ALTITUDE_OS_DEFAULT: POWER_SETTING_ALTITUDE = 6;
pub type POWER_SETTING_ALTITUDE = core::ffi::c_int;
pub type PPOWER_SETTING_ALTITUDE = *mut POWER_SETTING_ALTITUDE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BATTERY_REPORTING_SCALE {
    pub Granularity: ULONG,
    pub Capacity: ULONG,
}
pub type PBATTERY_REPORTING_SCALE = *mut BATTERY_REPORTING_SCALE;
unsafe extern "C" {
    pub fn NtPowerInformation(
        InformationLevel: POWER_INFORMATION_LEVEL,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
    ) -> NTSTATUS;
}
pub const _CM_SERVICE_NODE_TYPE_DriverType: _CM_SERVICE_NODE_TYPE = 1;
pub const _CM_SERVICE_NODE_TYPE_FileSystemType: _CM_SERVICE_NODE_TYPE = 2;
pub const _CM_SERVICE_NODE_TYPE_Win32ServiceOwnProcess: _CM_SERVICE_NODE_TYPE = 16;
pub const _CM_SERVICE_NODE_TYPE_Win32ServiceShareProcess: _CM_SERVICE_NODE_TYPE = 32;
pub const _CM_SERVICE_NODE_TYPE_AdapterType: _CM_SERVICE_NODE_TYPE = 4;
pub const _CM_SERVICE_NODE_TYPE_RecognizerType: _CM_SERVICE_NODE_TYPE = 8;
pub type _CM_SERVICE_NODE_TYPE = core::ffi::c_int;
pub use self::_CM_SERVICE_NODE_TYPE as SERVICE_NODE_TYPE;
pub const _CM_SERVICE_LOAD_TYPE_BootLoad: _CM_SERVICE_LOAD_TYPE = 0;
pub const _CM_SERVICE_LOAD_TYPE_SystemLoad: _CM_SERVICE_LOAD_TYPE = 1;
pub const _CM_SERVICE_LOAD_TYPE_AutoLoad: _CM_SERVICE_LOAD_TYPE = 2;
pub const _CM_SERVICE_LOAD_TYPE_DemandLoad: _CM_SERVICE_LOAD_TYPE = 3;
pub const _CM_SERVICE_LOAD_TYPE_DisableLoad: _CM_SERVICE_LOAD_TYPE = 4;
pub type _CM_SERVICE_LOAD_TYPE = core::ffi::c_int;
pub use self::_CM_SERVICE_LOAD_TYPE as SERVICE_LOAD_TYPE;
pub const _CM_ERROR_CONTROL_TYPE_IgnoreError: _CM_ERROR_CONTROL_TYPE = 0;
pub const _CM_ERROR_CONTROL_TYPE_NormalError: _CM_ERROR_CONTROL_TYPE = 1;
pub const _CM_ERROR_CONTROL_TYPE_SevereError: _CM_ERROR_CONTROL_TYPE = 2;
pub const _CM_ERROR_CONTROL_TYPE_CriticalError: _CM_ERROR_CONTROL_TYPE = 3;
pub type _CM_ERROR_CONTROL_TYPE = core::ffi::c_int;
pub use self::_CM_ERROR_CONTROL_TYPE as SERVICE_ERROR_TYPE;
pub type CM_RESOURCE_TYPE = core::ffi::c_int;
pub const _CM_SHARE_DISPOSITION_CmResourceShareUndetermined: _CM_SHARE_DISPOSITION = 0;
pub const _CM_SHARE_DISPOSITION_CmResourceShareDeviceExclusive: _CM_SHARE_DISPOSITION = 1;
pub const _CM_SHARE_DISPOSITION_CmResourceShareDriverExclusive: _CM_SHARE_DISPOSITION = 2;
pub const _CM_SHARE_DISPOSITION_CmResourceShareShared: _CM_SHARE_DISPOSITION = 3;
pub type _CM_SHARE_DISPOSITION = core::ffi::c_int;
pub use self::_CM_SHARE_DISPOSITION as CM_SHARE_DISPOSITION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
    pub Type: UCHAR,
    pub ShareDisposition: UCHAR,
    pub Flags: USHORT,
    pub u: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1 {
    pub Generic: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
    pub Port: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2,
    pub Interrupt: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3,
    pub MessageInterrupt: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4,
    pub Memory: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5,
    pub Dma: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6,
    pub DmaV3: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7,
    pub DevicePrivate: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8,
    pub BusNumber: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9,
    pub DeviceSpecificData: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10,
    pub Memory40: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11,
    pub Memory48: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12,
    pub Memory64: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13,
    pub Connection: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length: ULONG,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length: ULONG,
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 {
    pub Level: ULONG,
    pub Vector: ULONG,
    pub Affinity: KAFFINITY,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4 {
    pub __bindgen_anon_1: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    pub Raw:
        _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
    pub Translated:
        _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    pub Reserved: USHORT,
    pub MessageCount: USHORT,
    pub Vector: ULONG,
    pub Affinity: KAFFINITY,
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2 {
    pub Level: ULONG,
    pub Vector: ULONG,
    pub Affinity: KAFFINITY,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6 {
    pub Channel: ULONG,
    pub Port: ULONG,
    pub Reserved1: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7 {
    pub Channel: ULONG,
    pub RequestLine: ULONG,
    pub TransferWidth: UCHAR,
    pub Reserved1: UCHAR,
    pub Reserved2: UCHAR,
    pub Reserved3: UCHAR,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8 {
    pub Data: [ULONG; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9 {
    pub Start: ULONG,
    pub Length: ULONG,
    pub Reserved: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10 {
    pub DataSize: ULONG,
    pub Reserved1: ULONG,
    pub Reserved2: ULONG,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length40: ULONG,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length48: ULONG,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length64: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14 {
    pub Class: UCHAR,
    pub Type: UCHAR,
    pub Reserved1: UCHAR,
    pub Reserved2: UCHAR,
    pub IdLowPart: ULONG,
    pub IdHighPart: ULONG,
}
pub type CM_PARTIAL_RESOURCE_DESCRIPTOR = _CM_PARTIAL_RESOURCE_DESCRIPTOR;
pub type PCM_PARTIAL_RESOURCE_DESCRIPTOR = *mut _CM_PARTIAL_RESOURCE_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_LIST {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub Count: ULONG,
    pub PartialDescriptors: [CM_PARTIAL_RESOURCE_DESCRIPTOR; 1usize],
}
pub type CM_PARTIAL_RESOURCE_LIST = _CM_PARTIAL_RESOURCE_LIST;
pub type PCM_PARTIAL_RESOURCE_LIST = *mut _CM_PARTIAL_RESOURCE_LIST;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_FULL_RESOURCE_DESCRIPTOR {
    pub InterfaceType: INTERFACE_TYPE,
    pub BusNumber: ULONG,
    pub PartialResourceList: CM_PARTIAL_RESOURCE_LIST,
}
pub type CM_FULL_RESOURCE_DESCRIPTOR = _CM_FULL_RESOURCE_DESCRIPTOR;
pub type PCM_FULL_RESOURCE_DESCRIPTOR = *mut _CM_FULL_RESOURCE_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_RESOURCE_LIST {
    pub Count: ULONG,
    pub List: [CM_FULL_RESOURCE_DESCRIPTOR; 1usize],
}
pub type CM_RESOURCE_LIST = _CM_RESOURCE_LIST;
pub type PCM_RESOURCE_LIST = *mut _CM_RESOURCE_LIST;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_FLAGS {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _DEVICE_FLAGS {
    #[inline]
    pub fn Failed(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Failed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Failed_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Failed_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReadOnly(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReadOnly(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReadOnly_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReadOnly_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Removable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Removable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Removable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Removable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ConsoleIn(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ConsoleIn(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ConsoleIn_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ConsoleIn_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ConsoleOut(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ConsoleOut(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ConsoleOut_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ConsoleOut_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Input(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Input(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Input_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Input_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Output(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Output(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Output_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Output_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Failed: ULONG,
        ReadOnly: ULONG,
        Removable: ULONG,
        ConsoleIn: ULONG,
        ConsoleOut: ULONG,
        Input: ULONG,
        Output: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Failed: u32 = unsafe { ::core::mem::transmute(Failed) };
            Failed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ReadOnly: u32 = unsafe { ::core::mem::transmute(ReadOnly) };
            ReadOnly as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Removable: u32 = unsafe { ::core::mem::transmute(Removable) };
            Removable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ConsoleIn: u32 = unsafe { ::core::mem::transmute(ConsoleIn) };
            ConsoleIn as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ConsoleOut: u32 = unsafe { ::core::mem::transmute(ConsoleOut) };
            ConsoleOut as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Input: u32 = unsafe { ::core::mem::transmute(Input) };
            Input as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Output: u32 = unsafe { ::core::mem::transmute(Output) };
            Output as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type DEVICE_FLAGS = _DEVICE_FLAGS;
pub type PDEVICE_FLAGS = *mut _DEVICE_FLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_COMPONENT_INFORMATION {
    pub Flags: DEVICE_FLAGS,
    pub Version: ULONG,
    pub Key: ULONG,
    pub AffinityMask: KAFFINITY,
}
pub type CM_COMPONENT_INFORMATION = _CM_COMPONENT_INFORMATION;
pub type PCM_COMPONENT_INFORMATION = *mut _CM_COMPONENT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_ROM_BLOCK {
    pub Address: ULONG,
    pub Size: ULONG,
}
pub type CM_ROM_BLOCK = _CM_ROM_BLOCK;
pub type PCM_ROM_BLOCK = *mut _CM_ROM_BLOCK;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_INT13_DRIVE_PARAMETER {
    pub DriveSelect: USHORT,
    pub MaxCylinders: ULONG,
    pub SectorsPerTrack: USHORT,
    pub MaxHeads: USHORT,
    pub NumberDrives: USHORT,
}
pub type CM_INT13_DRIVE_PARAMETER = _CM_INT13_DRIVE_PARAMETER;
pub type PCM_INT13_DRIVE_PARAMETER = *mut _CM_INT13_DRIVE_PARAMETER;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_MCA_POS_DATA {
    pub AdapterId: USHORT,
    pub PosData1: UCHAR,
    pub PosData2: UCHAR,
    pub PosData3: UCHAR,
    pub PosData4: UCHAR,
}
pub type CM_MCA_POS_DATA = _CM_MCA_POS_DATA;
pub type PCM_MCA_POS_DATA = *mut _CM_MCA_POS_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EISA_MEMORY_TYPE {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _EISA_MEMORY_TYPE {
    #[inline]
    pub fn ReadWrite(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ReadWrite(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReadWrite_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ReadWrite_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Cached(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Cached(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Cached_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Cached_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved0(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved0_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved0_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Type(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Type(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Type_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Type_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Shared(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Shared(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Shared_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Shared_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MoreEntries(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MoreEntries(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MoreEntries_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_MoreEntries_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ReadWrite: UCHAR,
        Cached: UCHAR,
        Reserved0: UCHAR,
        Type: UCHAR,
        Shared: UCHAR,
        Reserved1: UCHAR,
        MoreEntries: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ReadWrite: u8 = unsafe { ::core::mem::transmute(ReadWrite) };
            ReadWrite as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Cached: u8 = unsafe { ::core::mem::transmute(Cached) };
            Cached as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Reserved0: u8 = unsafe { ::core::mem::transmute(Reserved0) };
            Reserved0 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let Type: u8 = unsafe { ::core::mem::transmute(Type) };
            Type as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Shared: u8 = unsafe { ::core::mem::transmute(Shared) };
            Shared as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Reserved1: u8 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let MoreEntries: u8 = unsafe { ::core::mem::transmute(MoreEntries) };
            MoreEntries as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type EISA_MEMORY_TYPE = _EISA_MEMORY_TYPE;
pub type PEISA_MEMORY_TYPE = *mut _EISA_MEMORY_TYPE;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _EISA_MEMORY_CONFIGURATION {
    pub ConfigurationByte: EISA_MEMORY_TYPE,
    pub DataSize: UCHAR,
    pub AddressLowWord: USHORT,
    pub AddressHighByte: UCHAR,
    pub MemorySize: USHORT,
}
pub type EISA_MEMORY_CONFIGURATION = _EISA_MEMORY_CONFIGURATION;
pub type PEISA_MEMORY_CONFIGURATION = *mut _EISA_MEMORY_CONFIGURATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EISA_IRQ_DESCRIPTOR {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _EISA_IRQ_DESCRIPTOR {
    #[inline]
    pub fn Interrupt(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_Interrupt(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Interrupt_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Interrupt_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LevelTriggered(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_LevelTriggered(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LevelTriggered_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_LevelTriggered_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Shared(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Shared(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Shared_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Shared_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MoreEntries(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MoreEntries(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MoreEntries_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_MoreEntries_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Interrupt: UCHAR,
        Reserved: UCHAR,
        LevelTriggered: UCHAR,
        Shared: UCHAR,
        MoreEntries: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let Interrupt: u8 = unsafe { ::core::mem::transmute(Interrupt) };
            Interrupt as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Reserved: u8 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let LevelTriggered: u8 = unsafe { ::core::mem::transmute(LevelTriggered) };
            LevelTriggered as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Shared: u8 = unsafe { ::core::mem::transmute(Shared) };
            Shared as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let MoreEntries: u8 = unsafe { ::core::mem::transmute(MoreEntries) };
            MoreEntries as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type EISA_IRQ_DESCRIPTOR = _EISA_IRQ_DESCRIPTOR;
pub type PEISA_IRQ_DESCRIPTOR = *mut _EISA_IRQ_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EISA_IRQ_CONFIGURATION {
    pub ConfigurationByte: EISA_IRQ_DESCRIPTOR,
    pub Reserved: UCHAR,
}
pub type EISA_IRQ_CONFIGURATION = _EISA_IRQ_CONFIGURATION;
pub type PEISA_IRQ_CONFIGURATION = *mut _EISA_IRQ_CONFIGURATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DMA_CONFIGURATION_BYTE0 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _DMA_CONFIGURATION_BYTE0 {
    #[inline]
    pub fn Channel(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_Channel(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Channel_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Channel_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Shared(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Shared(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Shared_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Shared_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MoreEntries(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MoreEntries(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MoreEntries_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_MoreEntries_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Channel: UCHAR,
        Reserved: UCHAR,
        Shared: UCHAR,
        MoreEntries: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let Channel: u8 = unsafe { ::core::mem::transmute(Channel) };
            Channel as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let Reserved: u8 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Shared: u8 = unsafe { ::core::mem::transmute(Shared) };
            Shared as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let MoreEntries: u8 = unsafe { ::core::mem::transmute(MoreEntries) };
            MoreEntries as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type DMA_CONFIGURATION_BYTE0 = _DMA_CONFIGURATION_BYTE0;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DMA_CONFIGURATION_BYTE1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _DMA_CONFIGURATION_BYTE1 {
    #[inline]
    pub fn Reserved0(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved0_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved0_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TransferSize(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_TransferSize(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TransferSize_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_TransferSize_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Timing(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Timing(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Timing_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Timing_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Reserved0: UCHAR,
        TransferSize: UCHAR,
        Timing: UCHAR,
        Reserved1: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let Reserved0: u8 = unsafe { ::core::mem::transmute(Reserved0) };
            Reserved0 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let TransferSize: u8 = unsafe { ::core::mem::transmute(TransferSize) };
            TransferSize as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let Timing: u8 = unsafe { ::core::mem::transmute(Timing) };
            Timing as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let Reserved1: u8 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type DMA_CONFIGURATION_BYTE1 = _DMA_CONFIGURATION_BYTE1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EISA_DMA_CONFIGURATION {
    pub ConfigurationByte0: DMA_CONFIGURATION_BYTE0,
    pub ConfigurationByte1: DMA_CONFIGURATION_BYTE1,
}
pub type EISA_DMA_CONFIGURATION = _EISA_DMA_CONFIGURATION;
pub type PEISA_DMA_CONFIGURATION = *mut _EISA_DMA_CONFIGURATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EISA_PORT_DESCRIPTOR {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _EISA_PORT_DESCRIPTOR {
    #[inline]
    pub fn NumberPorts(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_NumberPorts(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NumberPorts_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                5u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_NumberPorts_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Shared(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Shared(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Shared_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Shared_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MoreEntries(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MoreEntries(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MoreEntries_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_MoreEntries_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NumberPorts: UCHAR,
        Reserved: UCHAR,
        Shared: UCHAR,
        MoreEntries: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let NumberPorts: u8 = unsafe { ::core::mem::transmute(NumberPorts) };
            NumberPorts as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Reserved: u8 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Shared: u8 = unsafe { ::core::mem::transmute(Shared) };
            Shared as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let MoreEntries: u8 = unsafe { ::core::mem::transmute(MoreEntries) };
            MoreEntries as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type EISA_PORT_DESCRIPTOR = _EISA_PORT_DESCRIPTOR;
pub type PEISA_PORT_DESCRIPTOR = *mut _EISA_PORT_DESCRIPTOR;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _EISA_PORT_CONFIGURATION {
    pub Configuration: EISA_PORT_DESCRIPTOR,
    pub PortAddress: USHORT,
}
pub type EISA_PORT_CONFIGURATION = _EISA_PORT_CONFIGURATION;
pub type PEISA_PORT_CONFIGURATION = *mut _EISA_PORT_CONFIGURATION;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_EISA_SLOT_INFORMATION {
    pub ReturnCode: UCHAR,
    pub ReturnFlags: UCHAR,
    pub MajorRevision: UCHAR,
    pub MinorRevision: UCHAR,
    pub Checksum: USHORT,
    pub NumberFunctions: UCHAR,
    pub FunctionInformation: UCHAR,
    pub CompressedId: ULONG,
}
pub type CM_EISA_SLOT_INFORMATION = _CM_EISA_SLOT_INFORMATION;
pub type PCM_EISA_SLOT_INFORMATION = *mut _CM_EISA_SLOT_INFORMATION;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_EISA_FUNCTION_INFORMATION {
    pub CompressedId: ULONG,
    pub IdSlotFlags1: UCHAR,
    pub IdSlotFlags2: UCHAR,
    pub MinorRevision: UCHAR,
    pub MajorRevision: UCHAR,
    pub Selections: [UCHAR; 26usize],
    pub FunctionFlags: UCHAR,
    pub TypeString: [UCHAR; 80usize],
    pub EisaMemory: [EISA_MEMORY_CONFIGURATION; 9usize],
    pub EisaIrq: [EISA_IRQ_CONFIGURATION; 7usize],
    pub EisaDma: [EISA_DMA_CONFIGURATION; 4usize],
    pub EisaPort: [EISA_PORT_CONFIGURATION; 20usize],
    pub InitializationData: [UCHAR; 60usize],
}
pub type CM_EISA_FUNCTION_INFORMATION = _CM_EISA_FUNCTION_INFORMATION;
pub type PCM_EISA_FUNCTION_INFORMATION = *mut _CM_EISA_FUNCTION_INFORMATION;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PNP_BIOS_DEVICE_NODE {
    pub Size: USHORT,
    pub Node: UCHAR,
    pub ProductId: ULONG,
    pub DeviceType: [UCHAR; 3usize],
    pub DeviceAttributes: USHORT,
}
pub type CM_PNP_BIOS_DEVICE_NODE = _CM_PNP_BIOS_DEVICE_NODE;
pub type PCM_PNP_BIOS_DEVICE_NODE = *mut _CM_PNP_BIOS_DEVICE_NODE;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PNP_BIOS_INSTALLATION_CHECK {
    pub Signature: [UCHAR; 4usize],
    pub Revision: UCHAR,
    pub Length: UCHAR,
    pub ControlField: USHORT,
    pub Checksum: UCHAR,
    pub EventFlagAddress: ULONG,
    pub RealModeEntryOffset: USHORT,
    pub RealModeEntrySegment: USHORT,
    pub ProtectedModeEntryOffset: USHORT,
    pub ProtectedModeCodeBaseAddress: ULONG,
    pub OemDeviceId: ULONG,
    pub RealModeDataBaseAddress: USHORT,
    pub ProtectedModeDataBaseAddress: ULONG,
}
pub type CM_PNP_BIOS_INSTALLATION_CHECK = _CM_PNP_BIOS_INSTALLATION_CHECK;
pub type PCM_PNP_BIOS_INSTALLATION_CHECK = *mut _CM_PNP_BIOS_INSTALLATION_CHECK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_SCSI_DEVICE_DATA {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub HostIdentifier: UCHAR,
}
pub type CM_SCSI_DEVICE_DATA = _CM_SCSI_DEVICE_DATA;
pub type PCM_SCSI_DEVICE_DATA = *mut _CM_SCSI_DEVICE_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_VIDEO_DEVICE_DATA {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub VideoClock: ULONG,
}
pub type CM_VIDEO_DEVICE_DATA = _CM_VIDEO_DEVICE_DATA;
pub type PCM_VIDEO_DEVICE_DATA = *mut _CM_VIDEO_DEVICE_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_SONIC_DEVICE_DATA {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub DataConfigurationRegister: USHORT,
    pub EthernetAddress: [UCHAR; 8usize],
}
pub type CM_SONIC_DEVICE_DATA = _CM_SONIC_DEVICE_DATA;
pub type PCM_SONIC_DEVICE_DATA = *mut _CM_SONIC_DEVICE_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_SERIAL_DEVICE_DATA {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub BaudClock: ULONG,
}
pub type CM_SERIAL_DEVICE_DATA = _CM_SERIAL_DEVICE_DATA;
pub type PCM_SERIAL_DEVICE_DATA = *mut _CM_SERIAL_DEVICE_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_MONITOR_DEVICE_DATA {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub HorizontalScreenSize: USHORT,
    pub VerticalScreenSize: USHORT,
    pub HorizontalResolution: USHORT,
    pub VerticalResolution: USHORT,
    pub HorizontalDisplayTimeLow: USHORT,
    pub HorizontalDisplayTime: USHORT,
    pub HorizontalDisplayTimeHigh: USHORT,
    pub HorizontalBackPorchLow: USHORT,
    pub HorizontalBackPorch: USHORT,
    pub HorizontalBackPorchHigh: USHORT,
    pub HorizontalFrontPorchLow: USHORT,
    pub HorizontalFrontPorch: USHORT,
    pub HorizontalFrontPorchHigh: USHORT,
    pub HorizontalSyncLow: USHORT,
    pub HorizontalSync: USHORT,
    pub HorizontalSyncHigh: USHORT,
    pub VerticalBackPorchLow: USHORT,
    pub VerticalBackPorch: USHORT,
    pub VerticalBackPorchHigh: USHORT,
    pub VerticalFrontPorchLow: USHORT,
    pub VerticalFrontPorch: USHORT,
    pub VerticalFrontPorchHigh: USHORT,
    pub VerticalSyncLow: USHORT,
    pub VerticalSync: USHORT,
    pub VerticalSyncHigh: USHORT,
}
pub type CM_MONITOR_DEVICE_DATA = _CM_MONITOR_DEVICE_DATA;
pub type PCM_MONITOR_DEVICE_DATA = *mut _CM_MONITOR_DEVICE_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_FLOPPY_DEVICE_DATA {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub Size: [CHAR; 8usize],
    pub MaxDensity: ULONG,
    pub MountDensity: ULONG,
    pub StepRateHeadUnloadTime: UCHAR,
    pub HeadLoadTime: UCHAR,
    pub MotorOffTime: UCHAR,
    pub SectorLengthCode: UCHAR,
    pub SectorPerTrack: UCHAR,
    pub ReadWriteGapLength: UCHAR,
    pub DataTransferLength: UCHAR,
    pub FormatGapLength: UCHAR,
    pub FormatFillCharacter: UCHAR,
    pub HeadSettleTime: UCHAR,
    pub MotorSettleTime: UCHAR,
    pub MaximumTrackValue: UCHAR,
    pub DataTransferRate: UCHAR,
}
pub type CM_FLOPPY_DEVICE_DATA = _CM_FLOPPY_DEVICE_DATA;
pub type PCM_FLOPPY_DEVICE_DATA = *mut _CM_FLOPPY_DEVICE_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_KEYBOARD_DEVICE_DATA {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub Type: UCHAR,
    pub Subtype: UCHAR,
    pub KeyboardFlags: USHORT,
}
pub type CM_KEYBOARD_DEVICE_DATA = _CM_KEYBOARD_DEVICE_DATA;
pub type PCM_KEYBOARD_DEVICE_DATA = *mut _CM_KEYBOARD_DEVICE_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_DISK_GEOMETRY_DEVICE_DATA {
    pub BytesPerSector: ULONG,
    pub NumberOfCylinders: ULONG,
    pub SectorsPerTrack: ULONG,
    pub NumberOfHeads: ULONG,
}
pub type CM_DISK_GEOMETRY_DEVICE_DATA = _CM_DISK_GEOMETRY_DEVICE_DATA;
pub type PCM_DISK_GEOMETRY_DEVICE_DATA = *mut _CM_DISK_GEOMETRY_DEVICE_DATA;
pub const _IRQ_DEVICE_POLICY_IrqPolicyMachineDefault: _IRQ_DEVICE_POLICY = 0;
pub const _IRQ_DEVICE_POLICY_IrqPolicyAllCloseProcessors: _IRQ_DEVICE_POLICY = 1;
pub const _IRQ_DEVICE_POLICY_IrqPolicyOneCloseProcessor: _IRQ_DEVICE_POLICY = 2;
pub const _IRQ_DEVICE_POLICY_IrqPolicyAllProcessorsInMachine: _IRQ_DEVICE_POLICY = 3;
pub const _IRQ_DEVICE_POLICY_IrqPolicySpecifiedProcessors: _IRQ_DEVICE_POLICY = 4;
pub const _IRQ_DEVICE_POLICY_IrqPolicySpreadMessagesAcrossAllProcessors: _IRQ_DEVICE_POLICY = 5;
pub const _IRQ_DEVICE_POLICY_IrqPolicyAllProcessorsInMachineWhenSteered: _IRQ_DEVICE_POLICY = 6;
pub type _IRQ_DEVICE_POLICY = core::ffi::c_int;
pub use self::_IRQ_DEVICE_POLICY as IRQ_DEVICE_POLICY;
pub type PIRQ_DEVICE_POLICY = *mut _IRQ_DEVICE_POLICY;
pub const _IRQ_PRIORITY_IrqPriorityUndefined: _IRQ_PRIORITY = 0;
pub const _IRQ_PRIORITY_IrqPriorityLow: _IRQ_PRIORITY = 1;
pub const _IRQ_PRIORITY_IrqPriorityNormal: _IRQ_PRIORITY = 2;
pub const _IRQ_PRIORITY_IrqPriorityHigh: _IRQ_PRIORITY = 3;
pub type _IRQ_PRIORITY = core::ffi::c_int;
pub use self::_IRQ_PRIORITY as IRQ_PRIORITY;
pub type PIRQ_PRIORITY = *mut _IRQ_PRIORITY;
pub const _IRQ_GROUP_POLICY_GroupAffinityAllGroupZero: _IRQ_GROUP_POLICY = 0;
pub const _IRQ_GROUP_POLICY_GroupAffinityDontCare: _IRQ_GROUP_POLICY = 1;
pub type _IRQ_GROUP_POLICY = core::ffi::c_int;
pub use self::_IRQ_GROUP_POLICY as IRQ_GROUP_POLICY;
pub type PIRQ_GROUP_POLICY = *mut _IRQ_GROUP_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR {
    pub Option: UCHAR,
    pub Type: UCHAR,
    pub ShareDisposition: UCHAR,
    pub Spare1: UCHAR,
    pub Flags: USHORT,
    pub Spare2: USHORT,
    pub u: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1 {
    pub Port: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
    pub Memory: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2,
    pub Interrupt: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3,
    pub Dma: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4,
    pub DmaV3: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5,
    pub Generic: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6,
    pub DevicePrivate: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7,
    pub BusNumber: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8,
    pub ConfigData: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9,
    pub Memory40: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10,
    pub Memory48: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11,
    pub Memory64: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12,
    pub Connection: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    pub Length: ULONG,
    pub Alignment: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
    pub Length: ULONG,
    pub Alignment: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 {
    pub MinimumVector: ULONG,
    pub MaximumVector: ULONG,
    pub AffinityPolicy: IRQ_DEVICE_POLICY,
    pub PriorityPolicy: IRQ_PRIORITY,
    pub TargetedProcessors: KAFFINITY,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4 {
    pub MinimumChannel: ULONG,
    pub MaximumChannel: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5 {
    pub RequestLine: ULONG,
    pub Reserved: ULONG,
    pub Channel: ULONG,
    pub TransferWidth: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6 {
    pub Length: ULONG,
    pub Alignment: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7 {
    pub Data: [ULONG; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8 {
    pub Length: ULONG,
    pub MinBusNumber: ULONG,
    pub MaxBusNumber: ULONG,
    pub Reserved: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9 {
    pub Priority: ULONG,
    pub Reserved1: ULONG,
    pub Reserved2: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10 {
    pub Length40: ULONG,
    pub Alignment40: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11 {
    pub Length48: ULONG,
    pub Alignment48: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12 {
    pub Length64: ULONG,
    pub Alignment64: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13 {
    pub Class: UCHAR,
    pub Type: UCHAR,
    pub Reserved1: UCHAR,
    pub Reserved2: UCHAR,
    pub IdLowPart: ULONG,
    pub IdHighPart: ULONG,
}
pub type IO_RESOURCE_DESCRIPTOR = _IO_RESOURCE_DESCRIPTOR;
pub type PIO_RESOURCE_DESCRIPTOR = *mut _IO_RESOURCE_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_LIST {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub Count: ULONG,
    pub Descriptors: [IO_RESOURCE_DESCRIPTOR; 1usize],
}
pub type IO_RESOURCE_LIST = _IO_RESOURCE_LIST;
pub type PIO_RESOURCE_LIST = *mut _IO_RESOURCE_LIST;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_REQUIREMENTS_LIST {
    pub ListSize: ULONG,
    pub InterfaceType: INTERFACE_TYPE,
    pub BusNumber: ULONG,
    pub SlotNumber: ULONG,
    pub Reserved: [ULONG; 3usize],
    pub AlternativeLists: ULONG,
    pub List: [IO_RESOURCE_LIST; 1usize],
}
pub type IO_RESOURCE_REQUIREMENTS_LIST = _IO_RESOURCE_REQUIREMENTS_LIST;
pub type PIO_RESOURCE_REQUIREMENTS_LIST = *mut _IO_RESOURCE_REQUIREMENTS_LIST;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SLIST_ENTRY {
    pub Next: *mut _SLIST_ENTRY,
}
pub type SLIST_ENTRY = _SLIST_ENTRY;
pub type PSLIST_ENTRY = *mut _SLIST_ENTRY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _SLIST_HEADER {
    pub __bindgen_anon_1: _SLIST_HEADER__bindgen_ty_1,
    pub HeaderX64: _SLIST_HEADER__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SLIST_HEADER__bindgen_ty_1 {
    pub Alignment: ULONGLONG,
    pub Region: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SLIST_HEADER__bindgen_ty_2 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
}
impl _SLIST_HEADER__bindgen_ty_2 {
    #[inline]
    pub fn Depth(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_Depth(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Depth_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Depth_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Sequence(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 48u8) as u64) }
    }
    #[inline]
    pub fn set_Sequence(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 48u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Sequence_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                48u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Sequence_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                48u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(64usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(64usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                64usize,
                4u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                64usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NextEntry(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(68usize, 60u8) as u64) }
    }
    #[inline]
    pub fn set_NextEntry(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(68usize, 60u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NextEntry_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                68usize,
                60u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_NextEntry_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                68usize,
                60u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Depth: ULONGLONG,
        Sequence: ULONGLONG,
        Reserved: ULONGLONG,
        NextEntry: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let Depth: u64 = unsafe { ::core::mem::transmute(Depth) };
            Depth as u64
        });
        __bindgen_bitfield_unit.set(16usize, 48u8, {
            let Sequence: u64 = unsafe { ::core::mem::transmute(Sequence) };
            Sequence as u64
        });
        __bindgen_bitfield_unit.set(64usize, 4u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(68usize, 60u8, {
            let NextEntry: u64 = unsafe { ::core::mem::transmute(NextEntry) };
            NextEntry as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type SLIST_HEADER = _SLIST_HEADER;
pub type PSLIST_HEADER = *mut _SLIST_HEADER;
unsafe extern "C" {
    pub fn RtlAssert(
        VoidFailedAssertion: PVOID,
        VoidFileName: PVOID,
        LineNumber: ULONG,
        MutableMessage: PSTR,
    );
}
unsafe extern "C" {
    pub fn __fastfail(Code: core::ffi::c_uint) -> !;
}
unsafe extern "C" {
    pub fn RtlIntegerToUnicodeString(
        Value: ULONG,
        Base: ULONG,
        String: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlInt64ToUnicodeString(
        Value: ULONGLONG,
        Base: ULONG,
        String: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlUnicodeStringToInteger(
        String: PCUNICODE_STRING,
        Base: ULONG,
        Value: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlUnicodeStringToInt64(
        String: PCUNICODE_STRING,
        Base: ULONG,
        Number: PLONG64,
        EndPointer: *mut PWSTR,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub static mut NlsMbCodePageTag: *mut BOOLEAN;
}
unsafe extern "C" {
    pub static mut NlsMbOemCodePageTag: *mut BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlInitString(DestinationString: PSTRING, SourceString: PCSZ);
}
unsafe extern "C" {
    pub fn RtlInitAnsiString(DestinationString: PANSI_STRING, SourceString: PCSZ);
}
unsafe extern "C" {
    pub fn RtlInitUTF8String(DestinationString: PUTF8_STRING, SourceString: PCSZ);
}
unsafe extern "C" {
    pub fn RtlInitUnicodeString(DestinationString: PUNICODE_STRING, SourceString: PCWSTR);
}
pub type PRTL_QUERY_REGISTRY_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: PWSTR,
        arg2: ULONG,
        arg3: PVOID,
        arg4: ULONG,
        arg5: PVOID,
        arg6: PVOID,
    ) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_QUERY_REGISTRY_TABLE {
    pub QueryRoutine: PRTL_QUERY_REGISTRY_ROUTINE,
    pub Flags: ULONG,
    pub Name: PWSTR,
    pub EntryContext: PVOID,
    pub DefaultType: ULONG,
    pub DefaultData: PVOID,
    pub DefaultLength: ULONG,
}
pub type RTL_QUERY_REGISTRY_TABLE = _RTL_QUERY_REGISTRY_TABLE;
pub type PRTL_QUERY_REGISTRY_TABLE = *mut _RTL_QUERY_REGISTRY_TABLE;
unsafe extern "C" {
    pub fn RtlQueryRegistryValues(
        RelativeTo: ULONG,
        Path: PCWSTR,
        QueryTable: PRTL_QUERY_REGISTRY_TABLE,
        Context: PVOID,
        Environment: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmGetSystemRoutineAddress(SystemRoutineName: PUNICODE_STRING) -> PVOID;
}
unsafe extern "C" {
    pub fn RtlWriteRegistryValue(
        RelativeTo: ULONG,
        Path: PCWSTR,
        ValueName: PCWSTR,
        ValueType: ULONG,
        ValueData: PVOID,
        ValueLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlDeleteRegistryValue(RelativeTo: ULONG, Path: PCWSTR, ValueName: PCWSTR) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlCreateRegistryKey(RelativeTo: ULONG, Path: PWSTR) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlCheckRegistryKey(RelativeTo: ULONG, Path: PWSTR) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlInitAnsiStringEx(DestinationString: PANSI_STRING, SourceString: PCSZ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlInitStringEx(DestinationString: PSTRING, SourceString: PCSZ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlInitUTF8StringEx(DestinationString: PUTF8_STRING, SourceString: PCSZ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlAnsiStringToUnicodeString(
        DestinationString: PUNICODE_STRING,
        SourceString: PCANSI_STRING,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlUnicodeStringToAnsiString(
        DestinationString: PANSI_STRING,
        SourceString: PCUNICODE_STRING,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlCompareUnicodeStrings(
        String1: PCWCH,
        String1Length: SIZE_T,
        String2: PCWCH,
        String2Length: SIZE_T,
        CaseInSensitive: BOOLEAN,
    ) -> LONG;
}
unsafe extern "C" {
    pub fn RtlCompareUnicodeString(
        String1: PCUNICODE_STRING,
        String2: PCUNICODE_STRING,
        CaseInSensitive: BOOLEAN,
    ) -> LONG;
}
unsafe extern "C" {
    pub fn RtlEqualUnicodeString(
        String1: PCUNICODE_STRING,
        String2: PCUNICODE_STRING,
        CaseInSensitive: BOOLEAN,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlHashUnicodeString(
        String: PCUNICODE_STRING,
        CaseInSensitive: BOOLEAN,
        HashAlgorithm: ULONG,
        HashValue: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlCopyUnicodeString(DestinationString: PUNICODE_STRING, SourceString: PCUNICODE_STRING);
}
unsafe extern "C" {
    pub fn RtlAppendUnicodeStringToString(
        Destination: PUNICODE_STRING,
        Source: PCUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlAppendUnicodeToString(Destination: PUNICODE_STRING, Source: PCWSTR) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlUpcaseUnicodeChar(SourceCharacter: WCHAR) -> WCHAR;
}
unsafe extern "C" {
    pub fn RtlDowncaseUnicodeChar(SourceCharacter: WCHAR) -> WCHAR;
}
unsafe extern "C" {
    pub fn RtlFreeUnicodeString(UnicodeString: PUNICODE_STRING);
}
unsafe extern "C" {
    pub fn RtlFreeAnsiString(AnsiString: PANSI_STRING);
}
unsafe extern "C" {
    pub fn RtlFreeUTF8String(utf8String: PUTF8_STRING);
}
unsafe extern "C" {
    pub fn RtlxUnicodeStringToAnsiSize(UnicodeString: PCUNICODE_STRING) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlxAnsiStringToUnicodeSize(AnsiString: PCANSI_STRING) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlUnicodeToUTF8N(
        UTF8StringDestination: PCHAR,
        UTF8StringMaxByteCount: ULONG,
        UTF8StringActualByteCount: PULONG,
        UnicodeStringSource: PCWCH,
        UnicodeStringByteCount: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlUTF8ToUnicodeN(
        UnicodeStringDestination: PWSTR,
        UnicodeStringMaxByteCount: ULONG,
        UnicodeStringActualByteCount: PULONG,
        UTF8StringSource: PCCH,
        UTF8StringByteCount: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlUnicodeStringToUTF8String(
        DestinationString: PUTF8_STRING,
        SourceString: PCUNICODE_STRING,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlUTF8StringToUnicodeString(
        DestinationString: PUNICODE_STRING,
        SourceString: PUTF8_STRING,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlStringFromGUID(Guid: *const GUID, GuidString: PUNICODE_STRING) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlGUIDFromString(GuidString: PCUNICODE_STRING, Guid: *mut GUID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlGenerateClass5Guid(
        NamespaceGuid: *const GUID,
        Buffer: PVOID,
        BufferSize: ULONG,
        Guid: *mut GUID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlCopyMemoryNonTemporal(
        Destination: *mut core::ffi::c_void,
        Source: *const core::ffi::c_void,
        Length: SIZE_T,
    );
}
unsafe extern "C" {
    pub fn RtlFillMemoryNonTemporal(
        Destination: *mut core::ffi::c_void,
        Length: SIZE_T,
        Value: UCHAR,
    );
}
unsafe extern "C" {
    pub fn RtlPrefetchMemoryNonTemporal(Source: PVOID, Length: SIZE_T);
}
unsafe extern "C" {
    pub fn DbgBreakPointWithStatus(Status: ULONG);
}
unsafe extern "C" {
    pub fn DbgPrint(Format: PCSTR, ...) -> ULONG;
}
unsafe extern "C" {
    pub fn DbgPrintEx(ComponentId: ULONG, Level: ULONG, Format: PCSTR, ...) -> ULONG;
}
unsafe extern "C" {
    pub fn vDbgPrintEx(ComponentId: ULONG, Level: ULONG, Format: PCCH, arglist: va_list) -> ULONG;
}
unsafe extern "C" {
    pub fn vDbgPrintExWithPrefix(
        Prefix: PCCH,
        ComponentId: ULONG,
        Level: ULONG,
        Format: PCCH,
        arglist: va_list,
    ) -> ULONG;
}
unsafe extern "C" {
    pub fn DbgPrintReturnControlC(Format: PCCH, ...) -> ULONG;
}
unsafe extern "C" {
    pub fn DbgQueryDebugFilterState(ComponentId: ULONG, Level: ULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn DbgSetDebugFilterState(ComponentId: ULONG, Level: ULONG, State: BOOLEAN) -> NTSTATUS;
}
pub type PDEBUG_PRINT_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Output: PSTRING, ComponentId: ULONG, Level: ULONG)>;
unsafe extern "C" {
    pub fn DbgSetDebugPrintCallback(
        DebugPrintCallback: PDEBUG_PRINT_CALLBACK,
        Enable: BOOLEAN,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TIME_FIELDS {
    pub Year: CSHORT,
    pub Month: CSHORT,
    pub Day: CSHORT,
    pub Hour: CSHORT,
    pub Minute: CSHORT,
    pub Second: CSHORT,
    pub Milliseconds: CSHORT,
    pub Weekday: CSHORT,
}
pub type TIME_FIELDS = _TIME_FIELDS;
pub type PTIME_FIELDS = *mut TIME_FIELDS;
unsafe extern "C" {
    pub fn RtlTimeToTimeFields(Time: PLARGE_INTEGER, TimeFields: PTIME_FIELDS);
}
unsafe extern "C" {
    pub fn RtlTimeFieldsToTime(TimeFields: PTIME_FIELDS, Time: PLARGE_INTEGER) -> BOOLEAN;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_BITMAP {
    pub SizeOfBitMap: ULONG,
    pub Buffer: PULONG,
}
pub type RTL_BITMAP = _RTL_BITMAP;
pub type PRTL_BITMAP = *mut RTL_BITMAP;
unsafe extern "C" {
    pub fn RtlInitializeBitMap(
        BitMapHeader: PRTL_BITMAP,
        BitMapBuffer: PULONG,
        SizeOfBitMap: ULONG,
    );
}
unsafe extern "C" {
    pub fn RtlClearBit(BitMapHeader: PRTL_BITMAP, BitNumber: ULONG);
}
unsafe extern "C" {
    pub fn RtlSetBit(BitMapHeader: PRTL_BITMAP, BitNumber: ULONG);
}
unsafe extern "C" {
    pub fn RtlTestBit(BitMapHeader: PRTL_BITMAP, BitNumber: ULONG) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlClearAllBits(BitMapHeader: PRTL_BITMAP);
}
unsafe extern "C" {
    pub fn RtlSetAllBits(BitMapHeader: PRTL_BITMAP);
}
unsafe extern "C" {
    pub fn RtlFindClearBits(
        BitMapHeader: PRTL_BITMAP,
        NumberToFind: ULONG,
        HintIndex: ULONG,
    ) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlFindSetBits(
        BitMapHeader: PRTL_BITMAP,
        NumberToFind: ULONG,
        HintIndex: ULONG,
    ) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlFindClearBitsAndSet(
        BitMapHeader: PRTL_BITMAP,
        NumberToFind: ULONG,
        HintIndex: ULONG,
    ) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlFindSetBitsAndClear(
        BitMapHeader: PRTL_BITMAP,
        NumberToFind: ULONG,
        HintIndex: ULONG,
    ) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlClearBits(BitMapHeader: PRTL_BITMAP, StartingIndex: ULONG, NumberToClear: ULONG);
}
unsafe extern "C" {
    pub fn RtlSetBits(BitMapHeader: PRTL_BITMAP, StartingIndex: ULONG, NumberToSet: ULONG);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_BITMAP_RUN {
    pub StartingIndex: ULONG,
    pub NumberOfBits: ULONG,
}
pub type RTL_BITMAP_RUN = _RTL_BITMAP_RUN;
pub type PRTL_BITMAP_RUN = *mut RTL_BITMAP_RUN;
unsafe extern "C" {
    pub fn RtlFindClearRuns(
        BitMapHeader: PRTL_BITMAP,
        RunArray: PRTL_BITMAP_RUN,
        SizeOfRunArray: ULONG,
        LocateLongestRuns: BOOLEAN,
    ) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlFindLongestRunClear(BitMapHeader: PRTL_BITMAP, StartingIndex: PULONG) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlFindFirstRunClear(BitMapHeader: PRTL_BITMAP, StartingIndex: PULONG) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlNumberOfClearBitsInRange(
        BitMapHeader: PRTL_BITMAP,
        StartingIndex: ULONG,
        Length: ULONG,
    ) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlNumberOfSetBitsInRange(
        BitMapHeader: PRTL_BITMAP,
        StartingIndex: ULONG,
        Length: ULONG,
    ) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlNumberOfClearBits(BitMapHeader: PRTL_BITMAP) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlNumberOfSetBits(BitMapHeader: PRTL_BITMAP) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlAreBitsClear(
        BitMapHeader: PRTL_BITMAP,
        StartingIndex: ULONG,
        Length: ULONG,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlAreBitsSet(BitMapHeader: PRTL_BITMAP, StartingIndex: ULONG, Length: ULONG)
                         -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlFindNextForwardRunClear(
        BitMapHeader: PRTL_BITMAP,
        FromIndex: ULONG,
        StartingRunIndex: PULONG,
    ) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlFindLastBackwardRunClear(
        BitMapHeader: PRTL_BITMAP,
        FromIndex: ULONG,
        StartingRunIndex: PULONG,
    ) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlFindLeastSignificantBit(Set: ULONGLONG) -> CCHAR;
}
unsafe extern "C" {
    pub fn RtlFindMostSignificantBit(Set: ULONGLONG) -> CCHAR;
}
unsafe extern "C" {
    pub fn RtlNumberOfSetBitsUlongPtr(Target: ULONG_PTR) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlCopyBitMap(Source: PRTL_BITMAP, Destination: PRTL_BITMAP, TargetBit: ULONG);
}
unsafe extern "C" {
    pub fn RtlExtractBitMap(
        Source: PRTL_BITMAP,
        Destination: PRTL_BITMAP,
        TargetBit: ULONG,
        NumberOfBits: ULONG,
    );
}
unsafe extern "C" {
    pub fn RtlCreateSecurityDescriptor(
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        Revision: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlValidSecurityDescriptor(SecurityDescriptor: PSECURITY_DESCRIPTOR) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlLengthSecurityDescriptor(SecurityDescriptor: PSECURITY_DESCRIPTOR) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlValidRelativeSecurityDescriptor(
        SecurityDescriptorInput: PSECURITY_DESCRIPTOR,
        SecurityDescriptorLength: ULONG,
        RequiredInformation: SECURITY_INFORMATION,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlSetDaclSecurityDescriptor(
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        DaclPresent: BOOLEAN,
        Dacl: PACL,
        DaclDefaulted: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn _byteswap_ushort(arg1: core::ffi::c_ushort) -> core::ffi::c_ushort;
}
unsafe extern "C" {
    pub fn _byteswap_ulong(arg1: core::ffi::c_ulong) -> core::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn _byteswap_uint64(arg1: core::ffi::c_ulonglong) -> core::ffi::c_ulonglong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OSVERSIONINFOA {
    pub dwOSVersionInfoSize: ULONG,
    pub dwMajorVersion: ULONG,
    pub dwMinorVersion: ULONG,
    pub dwBuildNumber: ULONG,
    pub dwPlatformId: ULONG,
    pub szCSDVersion: [CHAR; 128usize],
}
pub type OSVERSIONINFOA = _OSVERSIONINFOA;
pub type POSVERSIONINFOA = *mut _OSVERSIONINFOA;
pub type LPOSVERSIONINFOA = *mut _OSVERSIONINFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OSVERSIONINFOW {
    pub dwOSVersionInfoSize: ULONG,
    pub dwMajorVersion: ULONG,
    pub dwMinorVersion: ULONG,
    pub dwBuildNumber: ULONG,
    pub dwPlatformId: ULONG,
    pub szCSDVersion: [WCHAR; 128usize],
}
pub type OSVERSIONINFOW = _OSVERSIONINFOW;
pub type POSVERSIONINFOW = *mut _OSVERSIONINFOW;
pub type LPOSVERSIONINFOW = *mut _OSVERSIONINFOW;
pub type RTL_OSVERSIONINFOW = _OSVERSIONINFOW;
pub type PRTL_OSVERSIONINFOW = *mut _OSVERSIONINFOW;
pub type OSVERSIONINFO = OSVERSIONINFOA;
pub type POSVERSIONINFO = POSVERSIONINFOA;
pub type LPOSVERSIONINFO = LPOSVERSIONINFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OSVERSIONINFOEXA {
    pub dwOSVersionInfoSize: ULONG,
    pub dwMajorVersion: ULONG,
    pub dwMinorVersion: ULONG,
    pub dwBuildNumber: ULONG,
    pub dwPlatformId: ULONG,
    pub szCSDVersion: [CHAR; 128usize],
    pub wServicePackMajor: USHORT,
    pub wServicePackMinor: USHORT,
    pub wSuiteMask: USHORT,
    pub wProductType: UCHAR,
    pub wReserved: UCHAR,
}
pub type OSVERSIONINFOEXA = _OSVERSIONINFOEXA;
pub type POSVERSIONINFOEXA = *mut _OSVERSIONINFOEXA;
pub type LPOSVERSIONINFOEXA = *mut _OSVERSIONINFOEXA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OSVERSIONINFOEXW {
    pub dwOSVersionInfoSize: ULONG,
    pub dwMajorVersion: ULONG,
    pub dwMinorVersion: ULONG,
    pub dwBuildNumber: ULONG,
    pub dwPlatformId: ULONG,
    pub szCSDVersion: [WCHAR; 128usize],
    pub wServicePackMajor: USHORT,
    pub wServicePackMinor: USHORT,
    pub wSuiteMask: USHORT,
    pub wProductType: UCHAR,
    pub wReserved: UCHAR,
}
pub type OSVERSIONINFOEXW = _OSVERSIONINFOEXW;
pub type POSVERSIONINFOEXW = *mut _OSVERSIONINFOEXW;
pub type LPOSVERSIONINFOEXW = *mut _OSVERSIONINFOEXW;
pub type RTL_OSVERSIONINFOEXW = _OSVERSIONINFOEXW;
pub type PRTL_OSVERSIONINFOEXW = *mut _OSVERSIONINFOEXW;
pub type OSVERSIONINFOEX = OSVERSIONINFOEXA;
pub type POSVERSIONINFOEX = POSVERSIONINFOEXA;
pub type LPOSVERSIONINFOEX = LPOSVERSIONINFOEXA;
unsafe extern "C" {
    pub fn VerSetConditionMask(
        ConditionMask: ULONGLONG,
        TypeMask: ULONG,
        Condition: UCHAR,
    ) -> ULONGLONG;
}
unsafe extern "C" {
    pub fn RtlGetVersion(lpVersionInformation: PRTL_OSVERSIONINFOW) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlVerifyVersionInfo(
        VersionInfo: PRTL_OSVERSIONINFOEXW,
        TypeMask: ULONG,
        ConditionMask: ULONGLONG,
    ) -> NTSTATUS;
}
pub type PFN_RTL_IS_NTDDI_VERSION_AVAILABLE =
::core::option::Option<unsafe extern "C" fn(Version: ULONG) -> BOOLEAN>;
pub type PFN_RTL_IS_SERVICE_PACK_VERSION_INSTALLED =
::core::option::Option<unsafe extern "C" fn(Version: ULONG) -> BOOLEAN>;
unsafe extern "C" {
    pub fn RtlIsNtDdiVersionAvailable(Version: ULONG) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlIsServicePackVersionInstalled(Version: ULONG) -> BOOLEAN;
}
pub const _DPFLTR_TYPE_DPFLTR_SYSTEM_ID: _DPFLTR_TYPE = 0;
pub const _DPFLTR_TYPE_DPFLTR_SMSS_ID: _DPFLTR_TYPE = 1;
pub const _DPFLTR_TYPE_DPFLTR_SETUP_ID: _DPFLTR_TYPE = 2;
pub const _DPFLTR_TYPE_DPFLTR_NTFS_ID: _DPFLTR_TYPE = 3;
pub const _DPFLTR_TYPE_DPFLTR_FSTUB_ID: _DPFLTR_TYPE = 4;
pub const _DPFLTR_TYPE_DPFLTR_CRASHDUMP_ID: _DPFLTR_TYPE = 5;
pub const _DPFLTR_TYPE_DPFLTR_CDAUDIO_ID: _DPFLTR_TYPE = 6;
pub const _DPFLTR_TYPE_DPFLTR_CDROM_ID: _DPFLTR_TYPE = 7;
pub const _DPFLTR_TYPE_DPFLTR_CLASSPNP_ID: _DPFLTR_TYPE = 8;
pub const _DPFLTR_TYPE_DPFLTR_DISK_ID: _DPFLTR_TYPE = 9;
pub const _DPFLTR_TYPE_DPFLTR_REDBOOK_ID: _DPFLTR_TYPE = 10;
pub const _DPFLTR_TYPE_DPFLTR_STORPROP_ID: _DPFLTR_TYPE = 11;
pub const _DPFLTR_TYPE_DPFLTR_SCSIPORT_ID: _DPFLTR_TYPE = 12;
pub const _DPFLTR_TYPE_DPFLTR_SCSIMINIPORT_ID: _DPFLTR_TYPE = 13;
pub const _DPFLTR_TYPE_DPFLTR_CONFIG_ID: _DPFLTR_TYPE = 14;
pub const _DPFLTR_TYPE_DPFLTR_I8042PRT_ID: _DPFLTR_TYPE = 15;
pub const _DPFLTR_TYPE_DPFLTR_SERMOUSE_ID: _DPFLTR_TYPE = 16;
pub const _DPFLTR_TYPE_DPFLTR_LSERMOUS_ID: _DPFLTR_TYPE = 17;
pub const _DPFLTR_TYPE_DPFLTR_KBDHID_ID: _DPFLTR_TYPE = 18;
pub const _DPFLTR_TYPE_DPFLTR_MOUHID_ID: _DPFLTR_TYPE = 19;
pub const _DPFLTR_TYPE_DPFLTR_KBDCLASS_ID: _DPFLTR_TYPE = 20;
pub const _DPFLTR_TYPE_DPFLTR_MOUCLASS_ID: _DPFLTR_TYPE = 21;
pub const _DPFLTR_TYPE_DPFLTR_TWOTRACK_ID: _DPFLTR_TYPE = 22;
pub const _DPFLTR_TYPE_DPFLTR_WMILIB_ID: _DPFLTR_TYPE = 23;
pub const _DPFLTR_TYPE_DPFLTR_ACPI_ID: _DPFLTR_TYPE = 24;
pub const _DPFLTR_TYPE_DPFLTR_AMLI_ID: _DPFLTR_TYPE = 25;
pub const _DPFLTR_TYPE_DPFLTR_HALIA64_ID: _DPFLTR_TYPE = 26;
pub const _DPFLTR_TYPE_DPFLTR_VIDEO_ID: _DPFLTR_TYPE = 27;
pub const _DPFLTR_TYPE_DPFLTR_SVCHOST_ID: _DPFLTR_TYPE = 28;
pub const _DPFLTR_TYPE_DPFLTR_VIDEOPRT_ID: _DPFLTR_TYPE = 29;
pub const _DPFLTR_TYPE_DPFLTR_TCPIP_ID: _DPFLTR_TYPE = 30;
pub const _DPFLTR_TYPE_DPFLTR_DMSYNTH_ID: _DPFLTR_TYPE = 31;
pub const _DPFLTR_TYPE_DPFLTR_NTOSPNP_ID: _DPFLTR_TYPE = 32;
pub const _DPFLTR_TYPE_DPFLTR_FASTFAT_ID: _DPFLTR_TYPE = 33;
pub const _DPFLTR_TYPE_DPFLTR_SAMSS_ID: _DPFLTR_TYPE = 34;
pub const _DPFLTR_TYPE_DPFLTR_PNPMGR_ID: _DPFLTR_TYPE = 35;
pub const _DPFLTR_TYPE_DPFLTR_NETAPI_ID: _DPFLTR_TYPE = 36;
pub const _DPFLTR_TYPE_DPFLTR_SCSERVER_ID: _DPFLTR_TYPE = 37;
pub const _DPFLTR_TYPE_DPFLTR_SCCLIENT_ID: _DPFLTR_TYPE = 38;
pub const _DPFLTR_TYPE_DPFLTR_SERIAL_ID: _DPFLTR_TYPE = 39;
pub const _DPFLTR_TYPE_DPFLTR_SERENUM_ID: _DPFLTR_TYPE = 40;
pub const _DPFLTR_TYPE_DPFLTR_UHCD_ID: _DPFLTR_TYPE = 41;
pub const _DPFLTR_TYPE_DPFLTR_RPCPROXY_ID: _DPFLTR_TYPE = 42;
pub const _DPFLTR_TYPE_DPFLTR_AUTOCHK_ID: _DPFLTR_TYPE = 43;
pub const _DPFLTR_TYPE_DPFLTR_DCOMSS_ID: _DPFLTR_TYPE = 44;
pub const _DPFLTR_TYPE_DPFLTR_UNIMODEM_ID: _DPFLTR_TYPE = 45;
pub const _DPFLTR_TYPE_DPFLTR_SIS_ID: _DPFLTR_TYPE = 46;
pub const _DPFLTR_TYPE_DPFLTR_FLTMGR_ID: _DPFLTR_TYPE = 47;
pub const _DPFLTR_TYPE_DPFLTR_WMICORE_ID: _DPFLTR_TYPE = 48;
pub const _DPFLTR_TYPE_DPFLTR_BURNENG_ID: _DPFLTR_TYPE = 49;
pub const _DPFLTR_TYPE_DPFLTR_IMAPI_ID: _DPFLTR_TYPE = 50;
pub const _DPFLTR_TYPE_DPFLTR_SXS_ID: _DPFLTR_TYPE = 51;
pub const _DPFLTR_TYPE_DPFLTR_FUSION_ID: _DPFLTR_TYPE = 52;
pub const _DPFLTR_TYPE_DPFLTR_IDLETASK_ID: _DPFLTR_TYPE = 53;
pub const _DPFLTR_TYPE_DPFLTR_SOFTPCI_ID: _DPFLTR_TYPE = 54;
pub const _DPFLTR_TYPE_DPFLTR_TAPE_ID: _DPFLTR_TYPE = 55;
pub const _DPFLTR_TYPE_DPFLTR_MCHGR_ID: _DPFLTR_TYPE = 56;
pub const _DPFLTR_TYPE_DPFLTR_IDEP_ID: _DPFLTR_TYPE = 57;
pub const _DPFLTR_TYPE_DPFLTR_PCIIDE_ID: _DPFLTR_TYPE = 58;
pub const _DPFLTR_TYPE_DPFLTR_FLOPPY_ID: _DPFLTR_TYPE = 59;
pub const _DPFLTR_TYPE_DPFLTR_FDC_ID: _DPFLTR_TYPE = 60;
pub const _DPFLTR_TYPE_DPFLTR_TERMSRV_ID: _DPFLTR_TYPE = 61;
pub const _DPFLTR_TYPE_DPFLTR_W32TIME_ID: _DPFLTR_TYPE = 62;
pub const _DPFLTR_TYPE_DPFLTR_PREFETCHER_ID: _DPFLTR_TYPE = 63;
pub const _DPFLTR_TYPE_DPFLTR_RSFILTER_ID: _DPFLTR_TYPE = 64;
pub const _DPFLTR_TYPE_DPFLTR_FCPORT_ID: _DPFLTR_TYPE = 65;
pub const _DPFLTR_TYPE_DPFLTR_PCI_ID: _DPFLTR_TYPE = 66;
pub const _DPFLTR_TYPE_DPFLTR_DMIO_ID: _DPFLTR_TYPE = 67;
pub const _DPFLTR_TYPE_DPFLTR_DMCONFIG_ID: _DPFLTR_TYPE = 68;
pub const _DPFLTR_TYPE_DPFLTR_DMADMIN_ID: _DPFLTR_TYPE = 69;
pub const _DPFLTR_TYPE_DPFLTR_WSOCKTRANSPORT_ID: _DPFLTR_TYPE = 70;
pub const _DPFLTR_TYPE_DPFLTR_VSS_ID: _DPFLTR_TYPE = 71;
pub const _DPFLTR_TYPE_DPFLTR_PNPMEM_ID: _DPFLTR_TYPE = 72;
pub const _DPFLTR_TYPE_DPFLTR_PROCESSOR_ID: _DPFLTR_TYPE = 73;
pub const _DPFLTR_TYPE_DPFLTR_DMSERVER_ID: _DPFLTR_TYPE = 74;
pub const _DPFLTR_TYPE_DPFLTR_SR_ID: _DPFLTR_TYPE = 75;
pub const _DPFLTR_TYPE_DPFLTR_INFINIBAND_ID: _DPFLTR_TYPE = 76;
pub const _DPFLTR_TYPE_DPFLTR_IHVDRIVER_ID: _DPFLTR_TYPE = 77;
pub const _DPFLTR_TYPE_DPFLTR_IHVVIDEO_ID: _DPFLTR_TYPE = 78;
pub const _DPFLTR_TYPE_DPFLTR_IHVAUDIO_ID: _DPFLTR_TYPE = 79;
pub const _DPFLTR_TYPE_DPFLTR_IHVNETWORK_ID: _DPFLTR_TYPE = 80;
pub const _DPFLTR_TYPE_DPFLTR_IHVSTREAMING_ID: _DPFLTR_TYPE = 81;
pub const _DPFLTR_TYPE_DPFLTR_IHVBUS_ID: _DPFLTR_TYPE = 82;
pub const _DPFLTR_TYPE_DPFLTR_HPS_ID: _DPFLTR_TYPE = 83;
pub const _DPFLTR_TYPE_DPFLTR_RTLTHREADPOOL_ID: _DPFLTR_TYPE = 84;
pub const _DPFLTR_TYPE_DPFLTR_LDR_ID: _DPFLTR_TYPE = 85;
pub const _DPFLTR_TYPE_DPFLTR_TCPIP6_ID: _DPFLTR_TYPE = 86;
pub const _DPFLTR_TYPE_DPFLTR_ISAPNP_ID: _DPFLTR_TYPE = 87;
pub const _DPFLTR_TYPE_DPFLTR_SHPC_ID: _DPFLTR_TYPE = 88;
pub const _DPFLTR_TYPE_DPFLTR_STORPORT_ID: _DPFLTR_TYPE = 89;
pub const _DPFLTR_TYPE_DPFLTR_STORMINIPORT_ID: _DPFLTR_TYPE = 90;
pub const _DPFLTR_TYPE_DPFLTR_PRINTSPOOLER_ID: _DPFLTR_TYPE = 91;
pub const _DPFLTR_TYPE_DPFLTR_VSSDYNDISK_ID: _DPFLTR_TYPE = 92;
pub const _DPFLTR_TYPE_DPFLTR_VERIFIER_ID: _DPFLTR_TYPE = 93;
pub const _DPFLTR_TYPE_DPFLTR_VDS_ID: _DPFLTR_TYPE = 94;
pub const _DPFLTR_TYPE_DPFLTR_VDSBAS_ID: _DPFLTR_TYPE = 95;
pub const _DPFLTR_TYPE_DPFLTR_VDSDYN_ID: _DPFLTR_TYPE = 96;
pub const _DPFLTR_TYPE_DPFLTR_VDSDYNDR_ID: _DPFLTR_TYPE = 97;
pub const _DPFLTR_TYPE_DPFLTR_VDSLDR_ID: _DPFLTR_TYPE = 98;
pub const _DPFLTR_TYPE_DPFLTR_VDSUTIL_ID: _DPFLTR_TYPE = 99;
pub const _DPFLTR_TYPE_DPFLTR_DFRGIFC_ID: _DPFLTR_TYPE = 100;
pub const _DPFLTR_TYPE_DPFLTR_DEFAULT_ID: _DPFLTR_TYPE = 101;
pub const _DPFLTR_TYPE_DPFLTR_MM_ID: _DPFLTR_TYPE = 102;
pub const _DPFLTR_TYPE_DPFLTR_DFSC_ID: _DPFLTR_TYPE = 103;
pub const _DPFLTR_TYPE_DPFLTR_WOW64_ID: _DPFLTR_TYPE = 104;
pub const _DPFLTR_TYPE_DPFLTR_ALPC_ID: _DPFLTR_TYPE = 105;
pub const _DPFLTR_TYPE_DPFLTR_WDI_ID: _DPFLTR_TYPE = 106;
pub const _DPFLTR_TYPE_DPFLTR_PERFLIB_ID: _DPFLTR_TYPE = 107;
pub const _DPFLTR_TYPE_DPFLTR_KTM_ID: _DPFLTR_TYPE = 108;
pub const _DPFLTR_TYPE_DPFLTR_IOSTRESS_ID: _DPFLTR_TYPE = 109;
pub const _DPFLTR_TYPE_DPFLTR_HEAP_ID: _DPFLTR_TYPE = 110;
pub const _DPFLTR_TYPE_DPFLTR_WHEA_ID: _DPFLTR_TYPE = 111;
pub const _DPFLTR_TYPE_DPFLTR_USERGDI_ID: _DPFLTR_TYPE = 112;
pub const _DPFLTR_TYPE_DPFLTR_MMCSS_ID: _DPFLTR_TYPE = 113;
pub const _DPFLTR_TYPE_DPFLTR_TPM_ID: _DPFLTR_TYPE = 114;
pub const _DPFLTR_TYPE_DPFLTR_THREADORDER_ID: _DPFLTR_TYPE = 115;
pub const _DPFLTR_TYPE_DPFLTR_ENVIRON_ID: _DPFLTR_TYPE = 116;
pub const _DPFLTR_TYPE_DPFLTR_EMS_ID: _DPFLTR_TYPE = 117;
pub const _DPFLTR_TYPE_DPFLTR_WDT_ID: _DPFLTR_TYPE = 118;
pub const _DPFLTR_TYPE_DPFLTR_FVEVOL_ID: _DPFLTR_TYPE = 119;
pub const _DPFLTR_TYPE_DPFLTR_NDIS_ID: _DPFLTR_TYPE = 120;
pub const _DPFLTR_TYPE_DPFLTR_NVCTRACE_ID: _DPFLTR_TYPE = 121;
pub const _DPFLTR_TYPE_DPFLTR_LUAFV_ID: _DPFLTR_TYPE = 122;
pub const _DPFLTR_TYPE_DPFLTR_APPCOMPAT_ID: _DPFLTR_TYPE = 123;
pub const _DPFLTR_TYPE_DPFLTR_USBSTOR_ID: _DPFLTR_TYPE = 124;
pub const _DPFLTR_TYPE_DPFLTR_SBP2PORT_ID: _DPFLTR_TYPE = 125;
pub const _DPFLTR_TYPE_DPFLTR_COVERAGE_ID: _DPFLTR_TYPE = 126;
pub const _DPFLTR_TYPE_DPFLTR_CACHEMGR_ID: _DPFLTR_TYPE = 127;
pub const _DPFLTR_TYPE_DPFLTR_MOUNTMGR_ID: _DPFLTR_TYPE = 128;
pub const _DPFLTR_TYPE_DPFLTR_CFR_ID: _DPFLTR_TYPE = 129;
pub const _DPFLTR_TYPE_DPFLTR_TXF_ID: _DPFLTR_TYPE = 130;
pub const _DPFLTR_TYPE_DPFLTR_KSECDD_ID: _DPFLTR_TYPE = 131;
pub const _DPFLTR_TYPE_DPFLTR_FLTREGRESS_ID: _DPFLTR_TYPE = 132;
pub const _DPFLTR_TYPE_DPFLTR_MPIO_ID: _DPFLTR_TYPE = 133;
pub const _DPFLTR_TYPE_DPFLTR_MSDSM_ID: _DPFLTR_TYPE = 134;
pub const _DPFLTR_TYPE_DPFLTR_UDFS_ID: _DPFLTR_TYPE = 135;
pub const _DPFLTR_TYPE_DPFLTR_PSHED_ID: _DPFLTR_TYPE = 136;
pub const _DPFLTR_TYPE_DPFLTR_STORVSP_ID: _DPFLTR_TYPE = 137;
pub const _DPFLTR_TYPE_DPFLTR_LSASS_ID: _DPFLTR_TYPE = 138;
pub const _DPFLTR_TYPE_DPFLTR_SSPICLI_ID: _DPFLTR_TYPE = 139;
pub const _DPFLTR_TYPE_DPFLTR_CNG_ID: _DPFLTR_TYPE = 140;
pub const _DPFLTR_TYPE_DPFLTR_EXFAT_ID: _DPFLTR_TYPE = 141;
pub const _DPFLTR_TYPE_DPFLTR_FILETRACE_ID: _DPFLTR_TYPE = 142;
pub const _DPFLTR_TYPE_DPFLTR_XSAVE_ID: _DPFLTR_TYPE = 143;
pub const _DPFLTR_TYPE_DPFLTR_SE_ID: _DPFLTR_TYPE = 144;
pub const _DPFLTR_TYPE_DPFLTR_DRIVEEXTENDER_ID: _DPFLTR_TYPE = 145;
pub const _DPFLTR_TYPE_DPFLTR_POWER_ID: _DPFLTR_TYPE = 146;
pub const _DPFLTR_TYPE_DPFLTR_CRASHDUMPXHCI_ID: _DPFLTR_TYPE = 147;
pub const _DPFLTR_TYPE_DPFLTR_GPIO_ID: _DPFLTR_TYPE = 148;
pub const _DPFLTR_TYPE_DPFLTR_REFS_ID: _DPFLTR_TYPE = 149;
pub const _DPFLTR_TYPE_DPFLTR_WER_ID: _DPFLTR_TYPE = 150;
pub const _DPFLTR_TYPE_DPFLTR_CAPIMG_ID: _DPFLTR_TYPE = 151;
pub const _DPFLTR_TYPE_DPFLTR_VPCI_ID: _DPFLTR_TYPE = 152;
pub const _DPFLTR_TYPE_DPFLTR_STORAGECLASSMEMORY_ID: _DPFLTR_TYPE = 153;
pub const _DPFLTR_TYPE_DPFLTR_FSLIB_ID: _DPFLTR_TYPE = 154;
pub const _DPFLTR_TYPE_DPFLTR_ENDOFTABLE_ID: _DPFLTR_TYPE = 155;
pub type _DPFLTR_TYPE = core::ffi::c_int;
pub use self::_DPFLTR_TYPE as DPFLTR_TYPE;
unsafe extern "C" {
    pub fn RtlIoEncodeMemIoResource(
        Descriptor: PIO_RESOURCE_DESCRIPTOR,
        Type: UCHAR,
        Length: ULONGLONG,
        Alignment: ULONGLONG,
        MinimumAddress: ULONGLONG,
        MaximumAddress: ULONGLONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlCmEncodeMemIoResource(
        Descriptor: PCM_PARTIAL_RESOURCE_DESCRIPTOR,
        Type: UCHAR,
        Length: ULONGLONG,
        Start: ULONGLONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlIoDecodeMemIoResource(
        Descriptor: PIO_RESOURCE_DESCRIPTOR,
        Alignment: PULONGLONG,
        MinimumAddress: PULONGLONG,
        MaximumAddress: PULONGLONG,
    ) -> ULONGLONG;
}
unsafe extern "C" {
    pub fn RtlCmDecodeMemIoResource(
        Descriptor: PCM_PARTIAL_RESOURCE_DESCRIPTOR,
        Start: PULONGLONG,
    ) -> ULONGLONG;
}
unsafe extern "C" {
    pub fn RtlFindClosestEncodableLength(
        SourceLength: ULONGLONG,
        TargetLength: PULONGLONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlIsUntrustedObject(
        Handle: HANDLE,
        Object: PVOID,
        UntrustedObject: PBOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlQueryValidationRunlevel(ComponentName: PCUNICODE_STRING) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlCrc32(Buffer: *const core::ffi::c_void, Size: usize, InitialCrc: ULONG) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlCrc64(
        Buffer: *const core::ffi::c_void,
        Size: usize,
        InitialCrc: ULONGLONG,
    ) -> ULONGLONG;
}
pub const _OS_DEPLOYEMENT_STATE_VALUES_OS_DEPLOYMENT_STANDARD: _OS_DEPLOYEMENT_STATE_VALUES = 1;
pub const _OS_DEPLOYEMENT_STATE_VALUES_OS_DEPLOYMENT_COMPACT: _OS_DEPLOYEMENT_STATE_VALUES = 2;
pub type _OS_DEPLOYEMENT_STATE_VALUES = core::ffi::c_int;
pub use self::_OS_DEPLOYEMENT_STATE_VALUES as OS_DEPLOYEMENT_STATE_VALUES;
unsafe extern "C" {
    pub fn RtlOsDeploymentState(Flags: ULONG) -> OS_DEPLOYEMENT_STATE_VALUES;
}
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeNone: _IMAGE_POLICY_ENTRY_TYPE = 0;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeBool: _IMAGE_POLICY_ENTRY_TYPE = 1;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeInt8: _IMAGE_POLICY_ENTRY_TYPE = 2;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeUInt8: _IMAGE_POLICY_ENTRY_TYPE = 3;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeInt16: _IMAGE_POLICY_ENTRY_TYPE = 4;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeUInt16: _IMAGE_POLICY_ENTRY_TYPE = 5;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeInt32: _IMAGE_POLICY_ENTRY_TYPE = 6;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeUInt32: _IMAGE_POLICY_ENTRY_TYPE = 7;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeInt64: _IMAGE_POLICY_ENTRY_TYPE = 8;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeUInt64: _IMAGE_POLICY_ENTRY_TYPE = 9;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeAnsiString: _IMAGE_POLICY_ENTRY_TYPE = 10;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeUnicodeString: _IMAGE_POLICY_ENTRY_TYPE = 11;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeOverride: _IMAGE_POLICY_ENTRY_TYPE = 12;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeMaximum: _IMAGE_POLICY_ENTRY_TYPE = 13;
pub type _IMAGE_POLICY_ENTRY_TYPE = core::ffi::c_int;
pub use self::_IMAGE_POLICY_ENTRY_TYPE as IMAGE_POLICY_ENTRY_TYPE;
pub const _IMAGE_POLICY_ID_ImagePolicyIdNone: _IMAGE_POLICY_ID = 0;
pub const _IMAGE_POLICY_ID_ImagePolicyIdEtw: _IMAGE_POLICY_ID = 1;
pub const _IMAGE_POLICY_ID_ImagePolicyIdDebug: _IMAGE_POLICY_ID = 2;
pub const _IMAGE_POLICY_ID_ImagePolicyIdCrashDump: _IMAGE_POLICY_ID = 3;
pub const _IMAGE_POLICY_ID_ImagePolicyIdCrashDumpKey: _IMAGE_POLICY_ID = 4;
pub const _IMAGE_POLICY_ID_ImagePolicyIdCrashDumpKeyGuid: _IMAGE_POLICY_ID = 5;
pub const _IMAGE_POLICY_ID_ImagePolicyIdParentSd: _IMAGE_POLICY_ID = 6;
pub const _IMAGE_POLICY_ID_ImagePolicyIdParentSdRev: _IMAGE_POLICY_ID = 7;
pub const _IMAGE_POLICY_ID_ImagePolicyIdSvn: _IMAGE_POLICY_ID = 8;
pub const _IMAGE_POLICY_ID_ImagePolicyIdDeviceId: _IMAGE_POLICY_ID = 9;
pub const _IMAGE_POLICY_ID_ImagePolicyIdCapability: _IMAGE_POLICY_ID = 10;
pub const _IMAGE_POLICY_ID_ImagePolicyIdScenarioId: _IMAGE_POLICY_ID = 11;
pub const _IMAGE_POLICY_ID_ImagePolicyIdMaximum: _IMAGE_POLICY_ID = 12;
pub type _IMAGE_POLICY_ID = core::ffi::c_int;
pub use self::_IMAGE_POLICY_ID as IMAGE_POLICY_ID;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_POLICY_ENTRY {
    pub Type: IMAGE_POLICY_ENTRY_TYPE,
    pub PolicyId: IMAGE_POLICY_ID,
    pub u: _IMAGE_POLICY_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_POLICY_ENTRY__bindgen_ty_1 {
    pub None: *const core::ffi::c_void,
    pub BoolValue: BOOLEAN,
    pub Int8Value: INT8,
    pub UInt8Value: UINT8,
    pub Int16Value: INT16,
    pub UInt16Value: UINT16,
    pub Int32Value: INT32,
    pub UInt32Value: UINT32,
    pub Int64Value: INT64,
    pub UInt64Value: UINT64,
    pub AnsiStringValue: PCSTR,
    pub UnicodeStringValue: PCWSTR,
}
pub type IMAGE_POLICY_ENTRY = _IMAGE_POLICY_ENTRY;
pub type PCIMAGE_POLICY_ENTRY = *const IMAGE_POLICY_ENTRY;
#[repr(C)]
pub struct _IMAGE_POLICY_METADATA {
    pub Version: UCHAR,
    pub Reserved0: [UCHAR; 7usize],
    pub ApplicationId: ULONGLONG,
    pub Policies: __IncompleteArrayField<IMAGE_POLICY_ENTRY>,
}
pub type IMAGE_POLICY_METADATA = _IMAGE_POLICY_METADATA;
pub type PCIMAGE_POLICY_METADATA = *const IMAGE_POLICY_METADATA;
unsafe extern "C" {
    pub fn RtlCompareMemory(
        Source1: *const core::ffi::c_void,
        Source2: *const core::ffi::c_void,
        Length: SIZE_T,
    ) -> SIZE_T;
}
pub type UOW = GUID;
pub type PUOW = *mut GUID;
pub type CRM_PROTOCOL_ID = GUID;
pub type PCRM_PROTOCOL_ID = *mut GUID;
pub type NOTIFICATION_MASK = ULONG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION {
    pub TransactionKey: PVOID,
    pub TransactionNotification: ULONG,
    pub TmVirtualClock: LARGE_INTEGER,
    pub ArgumentLength: ULONG,
}
pub type TRANSACTION_NOTIFICATION = _TRANSACTION_NOTIFICATION;
pub type PTRANSACTION_NOTIFICATION = *mut _TRANSACTION_NOTIFICATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT {
    pub EnlistmentId: GUID,
    pub UOW: UOW,
}
pub type TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT = _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT =
*mut _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT {
    pub TmIdentity: GUID,
    pub Flags: ULONG,
}
pub type TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT = _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT =
*mut _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT;
pub type SAVEPOINT_ID = ULONG;
pub type PSAVEPOINT_ID = *mut ULONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT {
    pub SavepointId: SAVEPOINT_ID,
}
pub type TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT = _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT =
*mut _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT {
    pub PropagationCookie: ULONG,
    pub UOW: GUID,
    pub TmIdentity: GUID,
    pub BufferLength: ULONG,
}
pub type TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT = _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT =
*mut _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT {
    pub MarshalCookie: ULONG,
    pub UOW: GUID,
}
pub type TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT = _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT =
*mut _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT;
pub type TRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT = TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT =
*mut TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KCRM_MARSHAL_HEADER {
    pub VersionMajor: ULONG,
    pub VersionMinor: ULONG,
    pub NumProtocols: ULONG,
    pub Unused: ULONG,
}
pub type KCRM_MARSHAL_HEADER = _KCRM_MARSHAL_HEADER;
pub type PKCRM_MARSHAL_HEADER = *mut _KCRM_MARSHAL_HEADER;
pub type PRKCRM_MARSHAL_HEADER = *mut _KCRM_MARSHAL_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KCRM_TRANSACTION_BLOB {
    pub UOW: UOW,
    pub TmIdentity: GUID,
    pub IsolationLevel: ULONG,
    pub IsolationFlags: ULONG,
    pub Timeout: ULONG,
    pub Description: [WCHAR; 64usize],
}
pub type KCRM_TRANSACTION_BLOB = _KCRM_TRANSACTION_BLOB;
pub type PKCRM_TRANSACTION_BLOB = *mut _KCRM_TRANSACTION_BLOB;
pub type PRKCRM_TRANSACTION_BLOB = *mut _KCRM_TRANSACTION_BLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KCRM_PROTOCOL_BLOB {
    pub ProtocolId: CRM_PROTOCOL_ID,
    pub StaticInfoLength: ULONG,
    pub TransactionIdInfoLength: ULONG,
    pub Unused1: ULONG,
    pub Unused2: ULONG,
}
pub type KCRM_PROTOCOL_BLOB = _KCRM_PROTOCOL_BLOB;
pub type PKCRM_PROTOCOL_BLOB = *mut _KCRM_PROTOCOL_BLOB;
pub type PRKCRM_PROTOCOL_BLOB = *mut _KCRM_PROTOCOL_BLOB;
pub const _TRANSACTION_OUTCOME_TransactionOutcomeUndetermined: _TRANSACTION_OUTCOME = 1;
pub const _TRANSACTION_OUTCOME_TransactionOutcomeCommitted: _TRANSACTION_OUTCOME = 2;
pub const _TRANSACTION_OUTCOME_TransactionOutcomeAborted: _TRANSACTION_OUTCOME = 3;
pub type _TRANSACTION_OUTCOME = core::ffi::c_int;
pub use self::_TRANSACTION_OUTCOME as TRANSACTION_OUTCOME;
pub const _TRANSACTION_STATE_TransactionStateNormal: _TRANSACTION_STATE = 1;
pub const _TRANSACTION_STATE_TransactionStateIndoubt: _TRANSACTION_STATE = 2;
pub const _TRANSACTION_STATE_TransactionStateCommittedNotify: _TRANSACTION_STATE = 3;
pub type _TRANSACTION_STATE = core::ffi::c_int;
pub use self::_TRANSACTION_STATE as TRANSACTION_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_BASIC_INFORMATION {
    pub TransactionId: GUID,
    pub State: ULONG,
    pub Outcome: ULONG,
}
pub type TRANSACTION_BASIC_INFORMATION = _TRANSACTION_BASIC_INFORMATION;
pub type PTRANSACTION_BASIC_INFORMATION = *mut _TRANSACTION_BASIC_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TRANSACTIONMANAGER_BASIC_INFORMATION {
    pub TmIdentity: GUID,
    pub VirtualClock: LARGE_INTEGER,
}
pub type TRANSACTIONMANAGER_BASIC_INFORMATION = _TRANSACTIONMANAGER_BASIC_INFORMATION;
pub type PTRANSACTIONMANAGER_BASIC_INFORMATION = *mut _TRANSACTIONMANAGER_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTIONMANAGER_LOG_INFORMATION {
    pub LogIdentity: GUID,
}
pub type TRANSACTIONMANAGER_LOG_INFORMATION = _TRANSACTIONMANAGER_LOG_INFORMATION;
pub type PTRANSACTIONMANAGER_LOG_INFORMATION = *mut _TRANSACTIONMANAGER_LOG_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTIONMANAGER_LOGPATH_INFORMATION {
    pub LogPathLength: ULONG,
    pub LogPath: [WCHAR; 1usize],
}
pub type TRANSACTIONMANAGER_LOGPATH_INFORMATION = _TRANSACTIONMANAGER_LOGPATH_INFORMATION;
pub type PTRANSACTIONMANAGER_LOGPATH_INFORMATION = *mut _TRANSACTIONMANAGER_LOGPATH_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTIONMANAGER_RECOVERY_INFORMATION {
    pub LastRecoveredLsn: ULONGLONG,
}
pub type TRANSACTIONMANAGER_RECOVERY_INFORMATION = _TRANSACTIONMANAGER_RECOVERY_INFORMATION;
pub type PTRANSACTIONMANAGER_RECOVERY_INFORMATION = *mut _TRANSACTIONMANAGER_RECOVERY_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TRANSACTION_PROPERTIES_INFORMATION {
    pub IsolationLevel: ULONG,
    pub IsolationFlags: ULONG,
    pub Timeout: LARGE_INTEGER,
    pub Outcome: ULONG,
    pub DescriptionLength: ULONG,
    pub Description: [WCHAR; 1usize],
}
pub type TRANSACTION_PROPERTIES_INFORMATION = _TRANSACTION_PROPERTIES_INFORMATION;
pub type PTRANSACTION_PROPERTIES_INFORMATION = *mut _TRANSACTION_PROPERTIES_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_BIND_INFORMATION {
    pub TmHandle: HANDLE,
}
pub type TRANSACTION_BIND_INFORMATION = _TRANSACTION_BIND_INFORMATION;
pub type PTRANSACTION_BIND_INFORMATION = *mut _TRANSACTION_BIND_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_ENLISTMENT_PAIR {
    pub EnlistmentId: GUID,
    pub ResourceManagerId: GUID,
}
pub type TRANSACTION_ENLISTMENT_PAIR = _TRANSACTION_ENLISTMENT_PAIR;
pub type PTRANSACTION_ENLISTMENT_PAIR = *mut _TRANSACTION_ENLISTMENT_PAIR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_ENLISTMENTS_INFORMATION {
    pub NumberOfEnlistments: ULONG,
    pub EnlistmentPair: [TRANSACTION_ENLISTMENT_PAIR; 1usize],
}
pub type TRANSACTION_ENLISTMENTS_INFORMATION = _TRANSACTION_ENLISTMENTS_INFORMATION;
pub type PTRANSACTION_ENLISTMENTS_INFORMATION = *mut _TRANSACTION_ENLISTMENTS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION {
    pub SuperiorEnlistmentPair: TRANSACTION_ENLISTMENT_PAIR,
}
pub type TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION = _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION;
pub type PTRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION =
*mut _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RESOURCEMANAGER_BASIC_INFORMATION {
    pub ResourceManagerId: GUID,
    pub DescriptionLength: ULONG,
    pub Description: [WCHAR; 1usize],
}
pub type RESOURCEMANAGER_BASIC_INFORMATION = _RESOURCEMANAGER_BASIC_INFORMATION;
pub type PRESOURCEMANAGER_BASIC_INFORMATION = *mut _RESOURCEMANAGER_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RESOURCEMANAGER_COMPLETION_INFORMATION {
    pub IoCompletionPortHandle: HANDLE,
    pub CompletionKey: ULONG_PTR,
}
pub type RESOURCEMANAGER_COMPLETION_INFORMATION = _RESOURCEMANAGER_COMPLETION_INFORMATION;
pub type PRESOURCEMANAGER_COMPLETION_INFORMATION = *mut _RESOURCEMANAGER_COMPLETION_INFORMATION;
pub const _TRANSACTION_INFORMATION_CLASS_TransactionBasicInformation:
_TRANSACTION_INFORMATION_CLASS = 0;
pub const _TRANSACTION_INFORMATION_CLASS_TransactionPropertiesInformation:
_TRANSACTION_INFORMATION_CLASS = 1;
pub const _TRANSACTION_INFORMATION_CLASS_TransactionEnlistmentInformation:
_TRANSACTION_INFORMATION_CLASS = 2;
pub const _TRANSACTION_INFORMATION_CLASS_TransactionSuperiorEnlistmentInformation:
_TRANSACTION_INFORMATION_CLASS = 3;
pub type _TRANSACTION_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_TRANSACTION_INFORMATION_CLASS as TRANSACTION_INFORMATION_CLASS;
pub const _TRANSACTIONMANAGER_INFORMATION_CLASS_TransactionManagerBasicInformation:
_TRANSACTIONMANAGER_INFORMATION_CLASS = 0;
pub const _TRANSACTIONMANAGER_INFORMATION_CLASS_TransactionManagerLogInformation:
_TRANSACTIONMANAGER_INFORMATION_CLASS = 1;
pub const _TRANSACTIONMANAGER_INFORMATION_CLASS_TransactionManagerLogPathInformation:
_TRANSACTIONMANAGER_INFORMATION_CLASS = 2;
pub const _TRANSACTIONMANAGER_INFORMATION_CLASS_TransactionManagerRecoveryInformation:
_TRANSACTIONMANAGER_INFORMATION_CLASS = 4;
pub type _TRANSACTIONMANAGER_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_TRANSACTIONMANAGER_INFORMATION_CLASS as TRANSACTIONMANAGER_INFORMATION_CLASS;
pub const _RESOURCEMANAGER_INFORMATION_CLASS_ResourceManagerBasicInformation:
_RESOURCEMANAGER_INFORMATION_CLASS = 0;
pub const _RESOURCEMANAGER_INFORMATION_CLASS_ResourceManagerCompletionInformation:
_RESOURCEMANAGER_INFORMATION_CLASS = 1;
pub type _RESOURCEMANAGER_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_RESOURCEMANAGER_INFORMATION_CLASS as RESOURCEMANAGER_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENLISTMENT_BASIC_INFORMATION {
    pub EnlistmentId: GUID,
    pub TransactionId: GUID,
    pub ResourceManagerId: GUID,
}
pub type ENLISTMENT_BASIC_INFORMATION = _ENLISTMENT_BASIC_INFORMATION;
pub type PENLISTMENT_BASIC_INFORMATION = *mut _ENLISTMENT_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENLISTMENT_CRM_INFORMATION {
    pub CrmTransactionManagerId: GUID,
    pub CrmResourceManagerId: GUID,
    pub CrmEnlistmentId: GUID,
}
pub type ENLISTMENT_CRM_INFORMATION = _ENLISTMENT_CRM_INFORMATION;
pub type PENLISTMENT_CRM_INFORMATION = *mut _ENLISTMENT_CRM_INFORMATION;
pub const _ENLISTMENT_INFORMATION_CLASS_EnlistmentBasicInformation: _ENLISTMENT_INFORMATION_CLASS =
    0;
pub const _ENLISTMENT_INFORMATION_CLASS_EnlistmentRecoveryInformation:
_ENLISTMENT_INFORMATION_CLASS = 1;
pub const _ENLISTMENT_INFORMATION_CLASS_EnlistmentCrmInformation: _ENLISTMENT_INFORMATION_CLASS = 2;
pub type _ENLISTMENT_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_ENLISTMENT_INFORMATION_CLASS as ENLISTMENT_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_LIST_ENTRY {
    pub UOW: UOW,
}
pub type TRANSACTION_LIST_ENTRY = _TRANSACTION_LIST_ENTRY;
pub type PTRANSACTION_LIST_ENTRY = *mut _TRANSACTION_LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_LIST_INFORMATION {
    pub NumberOfTransactions: ULONG,
    pub TransactionInformation: [TRANSACTION_LIST_ENTRY; 1usize],
}
pub type TRANSACTION_LIST_INFORMATION = _TRANSACTION_LIST_INFORMATION;
pub type PTRANSACTION_LIST_INFORMATION = *mut _TRANSACTION_LIST_INFORMATION;
pub const _KTMOBJECT_TYPE_KTMOBJECT_TRANSACTION: _KTMOBJECT_TYPE = 0;
pub const _KTMOBJECT_TYPE_KTMOBJECT_TRANSACTION_MANAGER: _KTMOBJECT_TYPE = 1;
pub const _KTMOBJECT_TYPE_KTMOBJECT_RESOURCE_MANAGER: _KTMOBJECT_TYPE = 2;
pub const _KTMOBJECT_TYPE_KTMOBJECT_ENLISTMENT: _KTMOBJECT_TYPE = 3;
pub const _KTMOBJECT_TYPE_KTMOBJECT_INVALID: _KTMOBJECT_TYPE = 4;
pub type _KTMOBJECT_TYPE = core::ffi::c_int;
pub use self::_KTMOBJECT_TYPE as KTMOBJECT_TYPE;
pub type PKTMOBJECT_TYPE = *mut _KTMOBJECT_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTMOBJECT_CURSOR {
    pub LastQuery: GUID,
    pub ObjectIdCount: ULONG,
    pub ObjectIds: [GUID; 1usize],
}
pub type KTMOBJECT_CURSOR = _KTMOBJECT_CURSOR;
pub type PKTMOBJECT_CURSOR = *mut _KTMOBJECT_CURSOR;
unsafe extern "C" {
    pub fn NtCreateTransactionManager(
        TmHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        LogFileName: PUNICODE_STRING,
        CreateOptions: ULONG,
        CommitStrength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtOpenTransactionManager(
        TmHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        LogFileName: PUNICODE_STRING,
        TmIdentity: LPGUID,
        OpenOptions: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtRenameTransactionManager(
        LogFileName: PUNICODE_STRING,
        ExistingTransactionManagerGuid: LPGUID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtRollforwardTransactionManager(
        TransactionManagerHandle: HANDLE,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtRecoverTransactionManager(TransactionManagerHandle: HANDLE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtQueryInformationTransactionManager(
        TransactionManagerHandle: HANDLE,
        TransactionManagerInformationClass: TRANSACTIONMANAGER_INFORMATION_CLASS,
        TransactionManagerInformation: PVOID,
        TransactionManagerInformationLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtSetInformationTransactionManager(
        TmHandle: HANDLE,
        TransactionManagerInformationClass: TRANSACTIONMANAGER_INFORMATION_CLASS,
        TransactionManagerInformation: PVOID,
        TransactionManagerInformationLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtEnumerateTransactionObject(
        RootObjectHandle: HANDLE,
        QueryType: KTMOBJECT_TYPE,
        ObjectCursor: PKTMOBJECT_CURSOR,
        ObjectCursorLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
pub type PFN_NT_CREATE_TRANSACTION = ::core::option::Option<
    unsafe extern "C" fn(
        TransactionHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        Uow: LPGUID,
        TmHandle: HANDLE,
        CreateOptions: ULONG,
        IsolationLevel: ULONG,
        IsolationFlags: ULONG,
        Timeout: PLARGE_INTEGER,
        Description: PUNICODE_STRING,
    ) -> NTSTATUS,
>;
unsafe extern "C" {
    pub fn NtCreateTransaction(
        TransactionHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        Uow: LPGUID,
        TmHandle: HANDLE,
        CreateOptions: ULONG,
        IsolationLevel: ULONG,
        IsolationFlags: ULONG,
        Timeout: PLARGE_INTEGER,
        Description: PUNICODE_STRING,
    ) -> NTSTATUS;
}
pub type PFN_NT_OPEN_TRANSACTION = ::core::option::Option<
    unsafe extern "C" fn(
        TransactionHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        Uow: LPGUID,
        TmHandle: HANDLE,
    ) -> NTSTATUS,
>;
unsafe extern "C" {
    pub fn NtOpenTransaction(
        TransactionHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        Uow: LPGUID,
        TmHandle: HANDLE,
    ) -> NTSTATUS;
}
pub type PFN_NT_QUERY_INFORMATION_TRANSACTION = ::core::option::Option<
    unsafe extern "C" fn(
        TransactionHandle: HANDLE,
        TransactionInformationClass: TRANSACTION_INFORMATION_CLASS,
        TransactionInformation: PVOID,
        TransactionInformationLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS,
>;
unsafe extern "C" {
    pub fn NtQueryInformationTransaction(
        TransactionHandle: HANDLE,
        TransactionInformationClass: TRANSACTION_INFORMATION_CLASS,
        TransactionInformation: PVOID,
        TransactionInformationLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
pub type PFN_NT_SET_INFORMATION_TRANSACTION = ::core::option::Option<
    unsafe extern "C" fn(
        TransactionHandle: HANDLE,
        TransactionInformationClass: TRANSACTION_INFORMATION_CLASS,
        TransactionInformation: PVOID,
        TransactionInformationLength: ULONG,
    ) -> NTSTATUS,
>;
unsafe extern "C" {
    pub fn NtSetInformationTransaction(
        TransactionHandle: HANDLE,
        TransactionInformationClass: TRANSACTION_INFORMATION_CLASS,
        TransactionInformation: PVOID,
        TransactionInformationLength: ULONG,
    ) -> NTSTATUS;
}
pub type PFN_NT_COMMIT_TRANSACTION = ::core::option::Option<
    unsafe extern "C" fn(TransactionHandle: HANDLE, Wait: BOOLEAN) -> NTSTATUS,
>;
unsafe extern "C" {
    pub fn NtCommitTransaction(TransactionHandle: HANDLE, Wait: BOOLEAN) -> NTSTATUS;
}
pub type PFN_NT_ROLLBACK_TRANSACTION = ::core::option::Option<
    unsafe extern "C" fn(TransactionHandle: HANDLE, Wait: BOOLEAN) -> NTSTATUS,
>;
unsafe extern "C" {
    pub fn NtRollbackTransaction(TransactionHandle: HANDLE, Wait: BOOLEAN) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtCreateEnlistment(
        EnlistmentHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ResourceManagerHandle: HANDLE,
        TransactionHandle: HANDLE,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        CreateOptions: ULONG,
        NotificationMask: NOTIFICATION_MASK,
        EnlistmentKey: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtOpenEnlistment(
        EnlistmentHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ResourceManagerHandle: HANDLE,
        EnlistmentGuid: LPGUID,
        ObjectAttributes: POBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtQueryInformationEnlistment(
        EnlistmentHandle: HANDLE,
        EnlistmentInformationClass: ENLISTMENT_INFORMATION_CLASS,
        EnlistmentInformation: PVOID,
        EnlistmentInformationLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtSetInformationEnlistment(
        EnlistmentHandle: HANDLE,
        EnlistmentInformationClass: ENLISTMENT_INFORMATION_CLASS,
        EnlistmentInformation: PVOID,
        EnlistmentInformationLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtRecoverEnlistment(EnlistmentHandle: HANDLE, EnlistmentKey: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtPrePrepareEnlistment(
        EnlistmentHandle: HANDLE,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtPrepareEnlistment(
        EnlistmentHandle: HANDLE,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtCommitEnlistment(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER)
                              -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtRollbackEnlistment(
        EnlistmentHandle: HANDLE,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtPrePrepareComplete(
        EnlistmentHandle: HANDLE,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtPrepareComplete(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtCommitComplete(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtReadOnlyEnlistment(
        EnlistmentHandle: HANDLE,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtRollbackComplete(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER)
                              -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtSinglePhaseReject(
        EnlistmentHandle: HANDLE,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtCreateResourceManager(
        ResourceManagerHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        TmHandle: HANDLE,
        RmGuid: LPGUID,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        CreateOptions: ULONG,
        Description: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtOpenResourceManager(
        ResourceManagerHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        TmHandle: HANDLE,
        ResourceManagerGuid: LPGUID,
        ObjectAttributes: POBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtRecoverResourceManager(ResourceManagerHandle: HANDLE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtGetNotificationResourceManager(
        ResourceManagerHandle: HANDLE,
        TransactionNotification: PTRANSACTION_NOTIFICATION,
        NotificationLength: ULONG,
        Timeout: PLARGE_INTEGER,
        ReturnLength: PULONG,
        Asynchronous: ULONG,
        AsynchronousContext: ULONG_PTR,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtQueryInformationResourceManager(
        ResourceManagerHandle: HANDLE,
        ResourceManagerInformationClass: RESOURCEMANAGER_INFORMATION_CLASS,
        ResourceManagerInformation: PVOID,
        ResourceManagerInformationLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtSetInformationResourceManager(
        ResourceManagerHandle: HANDLE,
        ResourceManagerInformationClass: RESOURCEMANAGER_INFORMATION_CLASS,
        ResourceManagerInformation: PVOID,
        ResourceManagerInformationLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtRegisterProtocolAddressInformation(
        ResourceManager: HANDLE,
        ProtocolId: PCRM_PROTOCOL_ID,
        ProtocolInformationSize: ULONG,
        ProtocolInformation: PVOID,
        CreateOptions: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtPropagationComplete(
        ResourceManagerHandle: HANDLE,
        RequestCookie: ULONG,
        BufferLength: ULONG,
        Buffer: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtPropagationFailed(
        ResourceManagerHandle: HANDLE,
        RequestCookie: ULONG,
        PropStatus: NTSTATUS,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub static mut NtGlobalFlag: ULONG;
}
unsafe extern "C" {
    pub static mut NtGlobalFlag2: ULONG;
}
pub use self::_POOL_TYPE as POOL_TYPE;
pub type POOL_FLAGS = ULONG64;
pub type ALLOCATE_FUNCTION = ::core::option::Option<
    unsafe extern "C" fn(PoolType: POOL_TYPE, NumberOfBytes: SIZE_T, Tag: ULONG) -> PVOID,
>;
pub type PALLOCATE_FUNCTION = ALLOCATE_FUNCTION;
pub type FREE_FUNCTION = ::core::option::Option<unsafe extern "C" fn(Buffer: PVOID)>;
pub type PFREE_FUNCTION = FREE_FUNCTION;
pub type PLOOKASIDE_LIST_EX = *mut _LOOKASIDE_LIST_EX;
pub type ALLOCATE_FUNCTION_EX = ::core::option::Option<
    unsafe extern "C" fn(
        PoolType: POOL_TYPE,
        NumberOfBytes: SIZE_T,
        Tag: ULONG,
        Lookaside: PLOOKASIDE_LIST_EX,
    ) -> PVOID,
>;
pub type PALLOCATE_FUNCTION_EX = ALLOCATE_FUNCTION_EX;
pub type FREE_FUNCTION_EX =
::core::option::Option<unsafe extern "C" fn(Buffer: PVOID, Lookaside: PLOOKASIDE_LIST_EX)>;
pub type PFREE_FUNCTION_EX = FREE_FUNCTION_EX;
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct _GENERAL_LOOKASIDE {
    pub __bindgen_anon_1: _GENERAL_LOOKASIDE__bindgen_ty_1,
    pub Depth: USHORT,
    pub MaximumDepth: USHORT,
    pub TotalAllocates: ULONG,
    pub __bindgen_anon_2: _GENERAL_LOOKASIDE__bindgen_ty_2,
    pub TotalFrees: ULONG,
    pub __bindgen_anon_3: _GENERAL_LOOKASIDE__bindgen_ty_3,
    pub Type: POOL_TYPE,
    pub Tag: ULONG,
    pub Size: ULONG,
    pub __bindgen_anon_4: _GENERAL_LOOKASIDE__bindgen_ty_4,
    pub __bindgen_anon_5: _GENERAL_LOOKASIDE__bindgen_ty_5,
    pub ListEntry: LIST_ENTRY,
    pub LastTotalAllocates: ULONG,
    pub __bindgen_anon_6: _GENERAL_LOOKASIDE__bindgen_ty_6,
    pub Future: [ULONG; 2usize],
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE__bindgen_ty_1 {
    pub ListHead: SLIST_HEADER,
    pub SingleListHead: SINGLE_LIST_ENTRY,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE__bindgen_ty_2 {
    pub AllocateMisses: ULONG,
    pub AllocateHits: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE__bindgen_ty_3 {
    pub FreeMisses: ULONG,
    pub FreeHits: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE__bindgen_ty_4 {
    pub AllocateEx: PALLOCATE_FUNCTION_EX,
    pub Allocate: PALLOCATE_FUNCTION,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE__bindgen_ty_5 {
    pub FreeEx: PFREE_FUNCTION_EX,
    pub Free: PFREE_FUNCTION,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE__bindgen_ty_6 {
    pub LastAllocateMisses: ULONG,
    pub LastAllocateHits: ULONG,
}
pub type GENERAL_LOOKASIDE = _GENERAL_LOOKASIDE;
pub type PGENERAL_LOOKASIDE = *mut GENERAL_LOOKASIDE;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _GENERAL_LOOKASIDE_POOL {
    pub __bindgen_anon_1: _GENERAL_LOOKASIDE_POOL__bindgen_ty_1,
    pub Depth: USHORT,
    pub MaximumDepth: USHORT,
    pub TotalAllocates: ULONG,
    pub __bindgen_anon_2: _GENERAL_LOOKASIDE_POOL__bindgen_ty_2,
    pub TotalFrees: ULONG,
    pub __bindgen_anon_3: _GENERAL_LOOKASIDE_POOL__bindgen_ty_3,
    pub Type: POOL_TYPE,
    pub Tag: ULONG,
    pub Size: ULONG,
    pub __bindgen_anon_4: _GENERAL_LOOKASIDE_POOL__bindgen_ty_4,
    pub __bindgen_anon_5: _GENERAL_LOOKASIDE_POOL__bindgen_ty_5,
    pub ListEntry: LIST_ENTRY,
    pub LastTotalAllocates: ULONG,
    pub __bindgen_anon_6: _GENERAL_LOOKASIDE_POOL__bindgen_ty_6,
    pub Future: [ULONG; 2usize],
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE_POOL__bindgen_ty_1 {
    pub ListHead: SLIST_HEADER,
    pub SingleListHead: SINGLE_LIST_ENTRY,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE_POOL__bindgen_ty_2 {
    pub AllocateMisses: ULONG,
    pub AllocateHits: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE_POOL__bindgen_ty_3 {
    pub FreeMisses: ULONG,
    pub FreeHits: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE_POOL__bindgen_ty_4 {
    pub AllocateEx: PALLOCATE_FUNCTION_EX,
    pub Allocate: PALLOCATE_FUNCTION,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE_POOL__bindgen_ty_5 {
    pub FreeEx: PFREE_FUNCTION_EX,
    pub Free: PFREE_FUNCTION,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GENERAL_LOOKASIDE_POOL__bindgen_ty_6 {
    pub LastAllocateMisses: ULONG,
    pub LastAllocateHits: ULONG,
}
pub type GENERAL_LOOKASIDE_POOL = _GENERAL_LOOKASIDE_POOL;
pub type PGENERAL_LOOKASIDE_POOL = *mut _GENERAL_LOOKASIDE_POOL;
pub type KPROCESSOR_MODE = CCHAR;
pub const _MODE_KernelMode: _MODE = 0;
pub const _MODE_UserMode: _MODE = 1;
pub const _MODE_MaximumMode: _MODE = 2;
pub type _MODE = core::ffi::c_int;
pub use self::_MODE as MODE;
pub type KSYNCHRONIZE_ROUTINE =
::core::option::Option<unsafe extern "C" fn(SynchronizeContext: PVOID) -> BOOLEAN>;
pub type PKSYNCHRONIZE_ROUTINE = KSYNCHRONIZE_ROUTINE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KAPC {
    pub Type: UCHAR,
    pub AllFlags: UCHAR,
    pub Size: UCHAR,
    pub SpareByte1: UCHAR,
    pub SpareLong0: ULONG,
    pub Thread: *mut _KTHREAD,
    pub ApcListEntry: LIST_ENTRY,
    pub Reserved: [PVOID; 3usize],
    pub NormalContext: PVOID,
    pub SystemArgument1: PVOID,
    pub SystemArgument2: PVOID,
    pub ApcStateIndex: CCHAR,
    pub ApcMode: KPROCESSOR_MODE,
    pub Inserted: BOOLEAN,
}
pub type KAPC = _KAPC;
pub type PKAPC = *mut _KAPC;
pub type PRKAPC = *mut _KAPC;
pub type KDEFERRED_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(
        Dpc: *mut _KDPC,
        DeferredContext: PVOID,
        SystemArgument1: PVOID,
        SystemArgument2: PVOID,
    ),
>;
pub type PKDEFERRED_ROUTINE = KDEFERRED_ROUTINE;
pub const _KDPC_IMPORTANCE_LowImportance: _KDPC_IMPORTANCE = 0;
pub const _KDPC_IMPORTANCE_MediumImportance: _KDPC_IMPORTANCE = 1;
pub const _KDPC_IMPORTANCE_HighImportance: _KDPC_IMPORTANCE = 2;
pub const _KDPC_IMPORTANCE_MediumHighImportance: _KDPC_IMPORTANCE = 3;
pub type _KDPC_IMPORTANCE = core::ffi::c_int;
pub use self::_KDPC_IMPORTANCE as KDPC_IMPORTANCE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KDPC {
    pub __bindgen_anon_1: _KDPC__bindgen_ty_1,
    pub DpcListEntry: SINGLE_LIST_ENTRY,
    pub ProcessorHistory: KAFFINITY,
    pub DeferredRoutine: PKDEFERRED_ROUTINE,
    pub DeferredContext: PVOID,
    pub SystemArgument1: PVOID,
    pub SystemArgument2: PVOID,
    pub DpcData: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KDPC__bindgen_ty_1 {
    pub TargetInfoAsUlong: ULONG,
    pub __bindgen_anon_1: _KDPC__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KDPC__bindgen_ty_1__bindgen_ty_1 {
    pub Type: UCHAR,
    pub Importance: UCHAR,
    pub Number: USHORT,
}
pub type KDPC = _KDPC;
pub type PKDPC = *mut _KDPC;
pub type PRKDPC = *mut _KDPC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MDL {
    pub Next: *mut _MDL,
    pub Size: CSHORT,
    pub MdlFlags: CSHORT,
    pub Process: *mut _EPROCESS,
    pub MappedSystemVa: PVOID,
    pub StartVa: PVOID,
    pub ByteCount: ULONG,
    pub ByteOffset: ULONG,
}
pub type MDL = _MDL;
pub type PMDL = *mut _MDL;
pub type PMDLX = *mut MDL;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPATCHER_HEADER {
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1,
    pub SignalState: LONG,
    pub WaitListHead: LIST_ENTRY,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1 {
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3,
    pub __bindgen_anon_4: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4,
    pub __bindgen_anon_5: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5,
    pub __bindgen_anon_6: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6,
    pub __bindgen_anon_7: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1 {
    pub Lock: LONG,
    pub LockNV: LONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2 {
    pub Type: UCHAR,
    pub Signalling: UCHAR,
    pub Size: UCHAR,
    pub Reserved1: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3 {
    pub TimerType: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1,
    pub Hand: UCHAR,
    pub __bindgen_anon_2: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    pub TimerControlFlags: UCHAR,
    pub __bindgen_anon_1:
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Absolute(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Absolute(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Absolute_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Absolute_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Wake(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Wake(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Wake_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Wake_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EncodedTolerableDelay(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_EncodedTolerableDelay(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EncodedTolerableDelay_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                6u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_EncodedTolerableDelay_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Absolute: UCHAR,
        Wake: UCHAR,
        EncodedTolerableDelay: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Absolute: u8 = unsafe { ::core::mem::transmute(Absolute) };
            Absolute as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Wake: u8 = unsafe { ::core::mem::transmute(Wake) };
            Wake as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let EncodedTolerableDelay: u8 =
                unsafe { ::core::mem::transmute(EncodedTolerableDelay) };
            EncodedTolerableDelay as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2 {
    pub TimerMiscFlags: UCHAR,
    pub __bindgen_anon_1:
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn Index(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_Index(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Index_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                6u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Index_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Inserted(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Inserted(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Inserted_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Inserted_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Expired(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Expired(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Expired_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Expired_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Index: UCHAR,
        Inserted: UCHAR,
        Expired: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let Index: u8 = unsafe { ::core::mem::transmute(Index) };
            Index as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Inserted: u8 = unsafe { ::core::mem::transmute(Inserted) };
            Inserted as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Expired: u8 = unsafe { ::core::mem::transmute(Expired) };
            Expired as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4 {
    pub Timer2Type: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
    pub Timer2ComponentId: UCHAR,
    pub Timer2RelativeId: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    pub Timer2Flags: UCHAR,
    pub __bindgen_anon_1:
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Timer2Inserted(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2Inserted(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Timer2Inserted_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Timer2Inserted_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Timer2Expiring(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2Expiring(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Timer2Expiring_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Timer2Expiring_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Timer2CancelPending(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2CancelPending(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Timer2CancelPending_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Timer2CancelPending_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Timer2SetPending(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2SetPending(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Timer2SetPending_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Timer2SetPending_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Timer2Running(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2Running(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Timer2Running_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Timer2Running_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Timer2Disabled(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2Disabled(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Timer2Disabled_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Timer2Disabled_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Timer2ReservedFlags(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2ReservedFlags(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Timer2ReservedFlags_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Timer2ReservedFlags_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Timer2Inserted: UCHAR,
        Timer2Expiring: UCHAR,
        Timer2CancelPending: UCHAR,
        Timer2SetPending: UCHAR,
        Timer2Running: UCHAR,
        Timer2Disabled: UCHAR,
        Timer2ReservedFlags: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Timer2Inserted: u8 = unsafe { ::core::mem::transmute(Timer2Inserted) };
            Timer2Inserted as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Timer2Expiring: u8 = unsafe { ::core::mem::transmute(Timer2Expiring) };
            Timer2Expiring as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Timer2CancelPending: u8 = unsafe { ::core::mem::transmute(Timer2CancelPending) };
            Timer2CancelPending as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Timer2SetPending: u8 = unsafe { ::core::mem::transmute(Timer2SetPending) };
            Timer2SetPending as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Timer2Running: u8 = unsafe { ::core::mem::transmute(Timer2Running) };
            Timer2Running as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Timer2Disabled: u8 = unsafe { ::core::mem::transmute(Timer2Disabled) };
            Timer2Disabled as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let Timer2ReservedFlags: u8 = unsafe { ::core::mem::transmute(Timer2ReservedFlags) };
            Timer2ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5 {
    pub QueueType: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
    pub QueueSize: UCHAR,
    pub QueueReserved: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub QueueControlFlags: UCHAR,
    pub __bindgen_anon_1:
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Abandoned(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Abandoned(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Abandoned_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Abandoned_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DisableIncrement(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DisableIncrement(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DisableIncrement_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_DisableIncrement_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn QueueReservedControlFlags(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_QueueReservedControlFlags(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn QueueReservedControlFlags_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                6u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_QueueReservedControlFlags_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Abandoned: UCHAR,
        DisableIncrement: UCHAR,
        QueueReservedControlFlags: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Abandoned: u8 = unsafe { ::core::mem::transmute(Abandoned) };
            Abandoned as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DisableIncrement: u8 = unsafe { ::core::mem::transmute(DisableIncrement) };
            DisableIncrement as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let QueueReservedControlFlags: u8 =
                unsafe { ::core::mem::transmute(QueueReservedControlFlags) };
            QueueReservedControlFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6 {
    pub ThreadType: UCHAR,
    pub ThreadReserved: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1,
    pub __bindgen_anon_2: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1 {
    pub ThreadControlFlags: UCHAR,
    pub __bindgen_anon_1:
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn CycleProfiling(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CycleProfiling(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CycleProfiling_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_CycleProfiling_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CounterProfiling(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CounterProfiling(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CounterProfiling_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_CounterProfiling_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn GroupScheduling(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_GroupScheduling(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn GroupScheduling_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_GroupScheduling_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AffinitySet(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AffinitySet(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AffinitySet_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_AffinitySet_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Tagged(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Tagged(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Tagged_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Tagged_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EnergyProfiling(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_EnergyProfiling(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EnergyProfiling_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_EnergyProfiling_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SchedulerAssist(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SchedulerAssist(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SchedulerAssist_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_SchedulerAssist_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ThreadReservedControlFlags(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ThreadReservedControlFlags(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ThreadReservedControlFlags_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ThreadReservedControlFlags_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CycleProfiling: UCHAR,
        CounterProfiling: UCHAR,
        GroupScheduling: UCHAR,
        AffinitySet: UCHAR,
        Tagged: UCHAR,
        EnergyProfiling: UCHAR,
        SchedulerAssist: UCHAR,
        ThreadReservedControlFlags: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CycleProfiling: u8 = unsafe { ::core::mem::transmute(CycleProfiling) };
            CycleProfiling as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CounterProfiling: u8 = unsafe { ::core::mem::transmute(CounterProfiling) };
            CounterProfiling as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let GroupScheduling: u8 = unsafe { ::core::mem::transmute(GroupScheduling) };
            GroupScheduling as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AffinitySet: u8 = unsafe { ::core::mem::transmute(AffinitySet) };
            AffinitySet as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Tagged: u8 = unsafe { ::core::mem::transmute(Tagged) };
            Tagged as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let EnergyProfiling: u8 = unsafe { ::core::mem::transmute(EnergyProfiling) };
            EnergyProfiling as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SchedulerAssist: u8 = unsafe { ::core::mem::transmute(SchedulerAssist) };
            SchedulerAssist as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ThreadReservedControlFlags: u8 =
                unsafe { ::core::mem::transmute(ThreadReservedControlFlags) };
            ThreadReservedControlFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2 {
    pub DebugActive: UCHAR,
    pub __bindgen_anon_1:
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn ActiveDR7(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ActiveDR7(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ActiveDR7_raw(this: *const Self) -> BOOLEAN {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ActiveDR7_raw(this: *mut Self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Instrumented(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Instrumented(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Instrumented_raw(this: *const Self) -> BOOLEAN {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Instrumented_raw(this: *mut Self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Minimal(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Minimal(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Minimal_raw(this: *const Self) -> BOOLEAN {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Minimal_raw(this: *mut Self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved4(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved4(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved4_raw(this: *const Self) -> BOOLEAN {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved4_raw(this: *mut Self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AltSyscall(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AltSyscall(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AltSyscall_raw(this: *const Self) -> BOOLEAN {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_AltSyscall_raw(this: *mut Self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Emulation(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Emulation(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Emulation_raw(this: *const Self) -> BOOLEAN {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Emulation_raw(this: *mut Self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved5(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved5(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved5_raw(this: *const Self) -> BOOLEAN {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved5_raw(this: *mut Self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ActiveDR7: BOOLEAN,
        Instrumented: BOOLEAN,
        Minimal: BOOLEAN,
        Reserved4: BOOLEAN,
        AltSyscall: BOOLEAN,
        Emulation: BOOLEAN,
        Reserved5: BOOLEAN,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ActiveDR7: u8 = unsafe { ::core::mem::transmute(ActiveDR7) };
            ActiveDR7 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Instrumented: u8 = unsafe { ::core::mem::transmute(Instrumented) };
            Instrumented as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Minimal: u8 = unsafe { ::core::mem::transmute(Minimal) };
            Minimal as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let Reserved4: u8 = unsafe { ::core::mem::transmute(Reserved4) };
            Reserved4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let AltSyscall: u8 = unsafe { ::core::mem::transmute(AltSyscall) };
            AltSyscall as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Emulation: u8 = unsafe { ::core::mem::transmute(Emulation) };
            Emulation as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Reserved5: u8 = unsafe { ::core::mem::transmute(Reserved5) };
            Reserved5 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7 {
    pub MutantType: UCHAR,
    pub MutantSize: UCHAR,
    pub DpcActive: BOOLEAN,
    pub MutantReserved: UCHAR,
}
pub type DISPATCHER_HEADER = _DISPATCHER_HEADER;
pub type PDISPATCHER_HEADER = *mut _DISPATCHER_HEADER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KEVENT {
    pub Header: DISPATCHER_HEADER,
}
pub type KEVENT = _KEVENT;
pub type PKEVENT = *mut _KEVENT;
pub type PRKEVENT = *mut _KEVENT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KGATE {
    pub Header: DISPATCHER_HEADER,
}
pub type KGATE = _KGATE;
pub type PKGATE = *mut _KGATE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KTIMER {
    pub Header: DISPATCHER_HEADER,
    pub DueTime: ULARGE_INTEGER,
    pub TimerListEntry: LIST_ENTRY,
    pub Dpc: *mut _KDPC,
    pub Processor: USHORT,
    pub TimerType: USHORT,
    pub Period: ULONG,
}
pub type KTIMER = _KTIMER;
pub type PKTIMER = *mut _KTIMER;
pub type PRKTIMER = *mut _KTIMER;
pub const _LOCK_OPERATION_IoReadAccess: _LOCK_OPERATION = 0;
pub const _LOCK_OPERATION_IoWriteAccess: _LOCK_OPERATION = 1;
pub const _LOCK_OPERATION_IoModifyAccess: _LOCK_OPERATION = 2;
pub type _LOCK_OPERATION = core::ffi::c_int;
pub use self::_LOCK_OPERATION as LOCK_OPERATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FAST_MUTEX {
    pub Count: LONG,
    pub Owner: PVOID,
    pub Contention: ULONG,
    pub Event: KEVENT,
    pub OldIrql: ULONG,
}
pub type FAST_MUTEX = _FAST_MUTEX;
pub type PFAST_MUTEX = *mut _FAST_MUTEX;
pub type KGUARDED_MUTEX = _FAST_MUTEX;
pub type PKGUARDED_MUTEX = *mut _FAST_MUTEX;
unsafe extern "C" {
    pub fn __inbyte(Port: USHORT) -> UCHAR;
}
unsafe extern "C" {
    pub fn __inword(Port: USHORT) -> USHORT;
}
unsafe extern "C" {
    pub fn __indword(Port: USHORT) -> ULONG;
}
unsafe extern "C" {
    pub fn __outbyte(Port: USHORT, Data: UCHAR);
}
unsafe extern "C" {
    pub fn __outword(Port: USHORT, Data: USHORT);
}
unsafe extern "C" {
    pub fn __outdword(Port: USHORT, Data: ULONG);
}
unsafe extern "C" {
    pub fn __inbytestring(Port: USHORT, Buffer: PUCHAR, Count: ULONG);
}
unsafe extern "C" {
    pub fn __inwordstring(Port: USHORT, Buffer: PUSHORT, Count: ULONG);
}
unsafe extern "C" {
    pub fn __indwordstring(Port: USHORT, Buffer: PULONG, Count: ULONG);
}
unsafe extern "C" {
    pub fn __outbytestring(Port: USHORT, Buffer: PUCHAR, Count: ULONG);
}
unsafe extern "C" {
    pub fn __outwordstring(Port: USHORT, Buffer: PUSHORT, Count: ULONG);
}
unsafe extern "C" {
    pub fn __outdwordstring(Port: USHORT, Buffer: PULONG, Count: ULONG);
}
pub type PFN_COUNT = ULONG;
pub type SPFN_NUMBER = LONG64;
pub type PSPFN_NUMBER = *mut LONG64;
pub type PFN_NUMBER = ULONG64;
pub type PPFN_NUMBER = *mut ULONG64;
unsafe extern "C" {
    pub fn __readcr8() -> ULONG64;
}
unsafe extern "C" {
    pub fn __writecr8(Data: ULONG64);
}
unsafe extern "C" {
    pub fn KeFlushIoBuffers(Mdl: PMDL, ReadOperation: BOOLEAN, DmaOperation: BOOLEAN);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KFLOATING_SAVE {
    pub Dummy: ULONG,
}
pub type KFLOATING_SAVE = _KFLOATING_SAVE;
pub type PKFLOATING_SAVE = *mut _KFLOATING_SAVE;
unsafe extern "C" {
    pub fn KeGetCurrentIrql() -> KIRQL;
}
unsafe extern "C" {
    pub fn KeLowerIrql(NewIrql: KIRQL);
}
unsafe extern "C" {
    pub fn KfRaiseIrql(NewIrql: KIRQL) -> KIRQL;
}
pub const _FIRMWARE_TYPE_FirmwareTypeUnknown: _FIRMWARE_TYPE = 0;
pub const _FIRMWARE_TYPE_FirmwareTypeBios: _FIRMWARE_TYPE = 1;
pub const _FIRMWARE_TYPE_FirmwareTypeUefi: _FIRMWARE_TYPE = 2;
pub const _FIRMWARE_TYPE_FirmwareTypeMax: _FIRMWARE_TYPE = 3;
pub type _FIRMWARE_TYPE = core::ffi::c_int;
pub use self::_FIRMWARE_TYPE as FIRMWARE_TYPE;
pub type PFIRMWARE_TYPE = *mut _FIRMWARE_TYPE;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationProcessorCore: _LOGICAL_PROCESSOR_RELATIONSHIP =
    0;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationNumaNode: _LOGICAL_PROCESSOR_RELATIONSHIP = 1;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationCache: _LOGICAL_PROCESSOR_RELATIONSHIP = 2;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationProcessorPackage:
_LOGICAL_PROCESSOR_RELATIONSHIP = 3;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationGroup: _LOGICAL_PROCESSOR_RELATIONSHIP = 4;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationProcessorDie: _LOGICAL_PROCESSOR_RELATIONSHIP = 5;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationNumaNodeEx: _LOGICAL_PROCESSOR_RELATIONSHIP = 6;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationProcessorModule: _LOGICAL_PROCESSOR_RELATIONSHIP =
    7;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationAll: _LOGICAL_PROCESSOR_RELATIONSHIP = 65535;
pub type _LOGICAL_PROCESSOR_RELATIONSHIP = core::ffi::c_int;
pub use self::_LOGICAL_PROCESSOR_RELATIONSHIP as LOGICAL_PROCESSOR_RELATIONSHIP;
pub const _PROCESSOR_CACHE_TYPE_CacheUnified: _PROCESSOR_CACHE_TYPE = 0;
pub const _PROCESSOR_CACHE_TYPE_CacheInstruction: _PROCESSOR_CACHE_TYPE = 1;
pub const _PROCESSOR_CACHE_TYPE_CacheData: _PROCESSOR_CACHE_TYPE = 2;
pub const _PROCESSOR_CACHE_TYPE_CacheTrace: _PROCESSOR_CACHE_TYPE = 3;
pub type _PROCESSOR_CACHE_TYPE = core::ffi::c_int;
pub use self::_PROCESSOR_CACHE_TYPE as PROCESSOR_CACHE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CACHE_DESCRIPTOR {
    pub Level: UCHAR,
    pub Associativity: UCHAR,
    pub LineSize: USHORT,
    pub Size: ULONG,
    pub Type: PROCESSOR_CACHE_TYPE,
}
pub type CACHE_DESCRIPTOR = _CACHE_DESCRIPTOR;
pub type PCACHE_DESCRIPTOR = *mut _CACHE_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION {
    pub ProcessorMask: ULONG_PTR,
    pub Relationship: LOGICAL_PROCESSOR_RELATIONSHIP,
    pub __bindgen_anon_1: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1 {
    pub ProcessorCore: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1,
    pub NumaNode: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2,
    pub Cache: CACHE_DESCRIPTOR,
    pub Reserved: [ULONGLONG; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub Flags: UCHAR,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2 {
    pub NodeNumber: ULONG,
}
pub type SYSTEM_LOGICAL_PROCESSOR_INFORMATION = _SYSTEM_LOGICAL_PROCESSOR_INFORMATION;
pub type PSYSTEM_LOGICAL_PROCESSOR_INFORMATION = *mut _SYSTEM_LOGICAL_PROCESSOR_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESSOR_RELATIONSHIP {
    pub Flags: UCHAR,
    pub EfficiencyClass: UCHAR,
    pub Reserved: [UCHAR; 20usize],
    pub GroupCount: USHORT,
    pub GroupMask: [GROUP_AFFINITY; 1usize],
}
pub type PROCESSOR_RELATIONSHIP = _PROCESSOR_RELATIONSHIP;
pub type PPROCESSOR_RELATIONSHIP = *mut _PROCESSOR_RELATIONSHIP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NUMA_NODE_RELATIONSHIP {
    pub NodeNumber: ULONG,
    pub Reserved: [UCHAR; 18usize],
    pub GroupCount: USHORT,
    pub __bindgen_anon_1: _NUMA_NODE_RELATIONSHIP__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NUMA_NODE_RELATIONSHIP__bindgen_ty_1 {
    pub GroupMask: GROUP_AFFINITY,
    pub GroupMasks: [GROUP_AFFINITY; 1usize],
}
pub type NUMA_NODE_RELATIONSHIP = _NUMA_NODE_RELATIONSHIP;
pub type PNUMA_NODE_RELATIONSHIP = *mut _NUMA_NODE_RELATIONSHIP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CACHE_RELATIONSHIP {
    pub Level: UCHAR,
    pub Associativity: UCHAR,
    pub LineSize: USHORT,
    pub CacheSize: ULONG,
    pub Type: PROCESSOR_CACHE_TYPE,
    pub Reserved: [UCHAR; 18usize],
    pub GroupCount: USHORT,
    pub __bindgen_anon_1: _CACHE_RELATIONSHIP__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CACHE_RELATIONSHIP__bindgen_ty_1 {
    pub GroupMask: GROUP_AFFINITY,
    pub GroupMasks: [GROUP_AFFINITY; 1usize],
}
pub type CACHE_RELATIONSHIP = _CACHE_RELATIONSHIP;
pub type PCACHE_RELATIONSHIP = *mut _CACHE_RELATIONSHIP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESSOR_GROUP_INFO {
    pub MaximumProcessorCount: UCHAR,
    pub ActiveProcessorCount: UCHAR,
    pub Reserved: [UCHAR; 38usize],
    pub ActiveProcessorMask: KAFFINITY,
}
pub type PROCESSOR_GROUP_INFO = _PROCESSOR_GROUP_INFO;
pub type PPROCESSOR_GROUP_INFO = *mut _PROCESSOR_GROUP_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GROUP_RELATIONSHIP {
    pub MaximumGroupCount: USHORT,
    pub ActiveGroupCount: USHORT,
    pub Reserved: [UCHAR; 20usize],
    pub GroupInfo: [PROCESSOR_GROUP_INFO; 1usize],
}
pub type GROUP_RELATIONSHIP = _GROUP_RELATIONSHIP;
pub type PGROUP_RELATIONSHIP = *mut _GROUP_RELATIONSHIP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
    pub Relationship: LOGICAL_PROCESSOR_RELATIONSHIP,
    pub Size: ULONG,
    pub __bindgen_anon_1: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1 {
    pub Processor: PROCESSOR_RELATIONSHIP,
    pub NumaNode: NUMA_NODE_RELATIONSHIP,
    pub Cache: CACHE_RELATIONSHIP,
    pub Group: GROUP_RELATIONSHIP,
}
pub type SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX = _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;
pub type PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX = *mut _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;
pub const _CPU_SET_INFORMATION_TYPE_CpuSetInformation: _CPU_SET_INFORMATION_TYPE = 0;
pub type _CPU_SET_INFORMATION_TYPE = core::ffi::c_int;
pub use self::_CPU_SET_INFORMATION_TYPE as CPU_SET_INFORMATION_TYPE;
pub type PCPU_SET_INFORMATION_TYPE = *mut _CPU_SET_INFORMATION_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_CPU_SET_INFORMATION {
    pub Size: ULONG,
    pub Type: CPU_SET_INFORMATION_TYPE,
    pub __bindgen_anon_1: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1 {
    pub CpuSet: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub Id: ULONG,
    pub Group: USHORT,
    pub LogicalProcessorIndex: UCHAR,
    pub CoreIndex: UCHAR,
    pub LastLevelCacheIndex: UCHAR,
    pub NumaNodeIndex: UCHAR,
    pub EfficiencyClass: UCHAR,
    pub __bindgen_anon_1: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
    pub AllocationTag: ULONG64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub AllFlags: UCHAR,
    pub __bindgen_anon_1:
        _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Parked(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Parked(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Parked_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Parked_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Allocated(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Allocated(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Allocated_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Allocated_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AllocatedToTargetProcess(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AllocatedToTargetProcess(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AllocatedToTargetProcess_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_AllocatedToTargetProcess_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RealTime(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RealTime(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RealTime_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_RealTime_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReservedFlags_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Parked: UCHAR,
        Allocated: UCHAR,
        AllocatedToTargetProcess: UCHAR,
        RealTime: UCHAR,
        ReservedFlags: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Parked: u8 = unsafe { ::core::mem::transmute(Parked) };
            Parked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Allocated: u8 = unsafe { ::core::mem::transmute(Allocated) };
            Allocated as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let AllocatedToTargetProcess: u8 =
                unsafe { ::core::mem::transmute(AllocatedToTargetProcess) };
            AllocatedToTargetProcess as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let RealTime: u8 = unsafe { ::core::mem::transmute(RealTime) };
            RealTime as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let ReservedFlags: u8 = unsafe { ::core::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub Reserved: ULONG,
    pub SchedulingClass: UCHAR,
}
pub type SYSTEM_CPU_SET_INFORMATION = _SYSTEM_CPU_SET_INFORMATION;
pub type PSYSTEM_CPU_SET_INFORMATION = *mut _SYSTEM_CPU_SET_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_POOL_ZEROING_INFORMATION {
    pub PoolZeroingSupportPresent: BOOLEAN,
}
pub type SYSTEM_POOL_ZEROING_INFORMATION = _SYSTEM_POOL_ZEROING_INFORMATION;
pub type PSYSTEM_POOL_ZEROING_INFORMATION = *mut _SYSTEM_POOL_ZEROING_INFORMATION;
pub const _ALTERNATIVE_ARCHITECTURE_TYPE_StandardDesign: _ALTERNATIVE_ARCHITECTURE_TYPE = 0;
pub const _ALTERNATIVE_ARCHITECTURE_TYPE_NEC98x86: _ALTERNATIVE_ARCHITECTURE_TYPE = 1;
pub const _ALTERNATIVE_ARCHITECTURE_TYPE_EndAlternatives: _ALTERNATIVE_ARCHITECTURE_TYPE = 2;
pub type _ALTERNATIVE_ARCHITECTURE_TYPE = core::ffi::c_int;
pub use self::_ALTERNATIVE_ARCHITECTURE_TYPE as ALTERNATIVE_ARCHITECTURE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_RECORD {
    pub ExceptionCode: NTSTATUS,
    pub ExceptionFlags: ULONG,
    pub ExceptionRecord: *mut _EXCEPTION_RECORD,
    pub ExceptionAddress: PVOID,
    pub NumberParameters: ULONG,
    pub ExceptionInformation: [ULONG_PTR; 15usize],
}
pub type EXCEPTION_RECORD = _EXCEPTION_RECORD;
pub type PEXCEPTION_RECORD = *mut EXCEPTION_RECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_RECORD32 {
    pub ExceptionCode: NTSTATUS,
    pub ExceptionFlags: ULONG,
    pub ExceptionRecord: ULONG,
    pub ExceptionAddress: ULONG,
    pub NumberParameters: ULONG,
    pub ExceptionInformation: [ULONG; 15usize],
}
pub type EXCEPTION_RECORD32 = _EXCEPTION_RECORD32;
pub type PEXCEPTION_RECORD32 = *mut _EXCEPTION_RECORD32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_RECORD64 {
    pub ExceptionCode: NTSTATUS,
    pub ExceptionFlags: ULONG,
    pub ExceptionRecord: ULONG64,
    pub ExceptionAddress: ULONG64,
    pub NumberParameters: ULONG,
    pub __unusedAlignment: ULONG,
    pub ExceptionInformation: [ULONG64; 15usize],
}
pub type EXCEPTION_RECORD64 = _EXCEPTION_RECORD64;
pub type PEXCEPTION_RECORD64 = *mut _EXCEPTION_RECORD64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_POINTERS {
    pub ExceptionRecord: PEXCEPTION_RECORD,
    pub ContextRecord: PCONTEXT,
}
pub type EXCEPTION_POINTERS = _EXCEPTION_POINTERS;
pub type PEXCEPTION_POINTERS = *mut _EXCEPTION_POINTERS;
pub const _KINTERRUPT_MODE_LevelSensitive: _KINTERRUPT_MODE = 0;
pub const _KINTERRUPT_MODE_Latched: _KINTERRUPT_MODE = 1;
pub type _KINTERRUPT_MODE = core::ffi::c_int;
pub use self::_KINTERRUPT_MODE as KINTERRUPT_MODE;
pub const _KINTERRUPT_POLARITY_InterruptPolarityUnknown: _KINTERRUPT_POLARITY = 0;
pub const _KINTERRUPT_POLARITY_InterruptActiveHigh: _KINTERRUPT_POLARITY = 1;
pub const _KINTERRUPT_POLARITY_InterruptRisingEdge: _KINTERRUPT_POLARITY = 1;
pub const _KINTERRUPT_POLARITY_InterruptActiveLow: _KINTERRUPT_POLARITY = 2;
pub const _KINTERRUPT_POLARITY_InterruptFallingEdge: _KINTERRUPT_POLARITY = 2;
pub const _KINTERRUPT_POLARITY_InterruptActiveBoth: _KINTERRUPT_POLARITY = 3;
pub const _KINTERRUPT_POLARITY_InterruptActiveBothTriggerLow: _KINTERRUPT_POLARITY = 3;
pub const _KINTERRUPT_POLARITY_InterruptActiveBothTriggerHigh: _KINTERRUPT_POLARITY = 4;
pub type _KINTERRUPT_POLARITY = core::ffi::c_int;
pub use self::_KINTERRUPT_POLARITY as KINTERRUPT_POLARITY;
pub type PKINTERRUPT_POLARITY = *mut _KINTERRUPT_POLARITY;
pub const _KWAIT_REASON_Executive: _KWAIT_REASON = 0;
pub const _KWAIT_REASON_FreePage: _KWAIT_REASON = 1;
pub const _KWAIT_REASON_PageIn: _KWAIT_REASON = 2;
pub const _KWAIT_REASON_PoolAllocation: _KWAIT_REASON = 3;
pub const _KWAIT_REASON_DelayExecution: _KWAIT_REASON = 4;
pub const _KWAIT_REASON_Suspended: _KWAIT_REASON = 5;
pub const _KWAIT_REASON_UserRequest: _KWAIT_REASON = 6;
pub const _KWAIT_REASON_WrExecutive: _KWAIT_REASON = 7;
pub const _KWAIT_REASON_WrFreePage: _KWAIT_REASON = 8;
pub const _KWAIT_REASON_WrPageIn: _KWAIT_REASON = 9;
pub const _KWAIT_REASON_WrPoolAllocation: _KWAIT_REASON = 10;
pub const _KWAIT_REASON_WrDelayExecution: _KWAIT_REASON = 11;
pub const _KWAIT_REASON_WrSuspended: _KWAIT_REASON = 12;
pub const _KWAIT_REASON_WrUserRequest: _KWAIT_REASON = 13;
pub const _KWAIT_REASON_WrSpare0: _KWAIT_REASON = 14;
pub const _KWAIT_REASON_WrQueue: _KWAIT_REASON = 15;
pub const _KWAIT_REASON_WrLpcReceive: _KWAIT_REASON = 16;
pub const _KWAIT_REASON_WrLpcReply: _KWAIT_REASON = 17;
pub const _KWAIT_REASON_WrVirtualMemory: _KWAIT_REASON = 18;
pub const _KWAIT_REASON_WrPageOut: _KWAIT_REASON = 19;
pub const _KWAIT_REASON_WrRendezvous: _KWAIT_REASON = 20;
pub const _KWAIT_REASON_WrKeyedEvent: _KWAIT_REASON = 21;
pub const _KWAIT_REASON_WrTerminated: _KWAIT_REASON = 22;
pub const _KWAIT_REASON_WrProcessInSwap: _KWAIT_REASON = 23;
pub const _KWAIT_REASON_WrCpuRateControl: _KWAIT_REASON = 24;
pub const _KWAIT_REASON_WrCalloutStack: _KWAIT_REASON = 25;
pub const _KWAIT_REASON_WrKernel: _KWAIT_REASON = 26;
pub const _KWAIT_REASON_WrResource: _KWAIT_REASON = 27;
pub const _KWAIT_REASON_WrPushLock: _KWAIT_REASON = 28;
pub const _KWAIT_REASON_WrMutex: _KWAIT_REASON = 29;
pub const _KWAIT_REASON_WrQuantumEnd: _KWAIT_REASON = 30;
pub const _KWAIT_REASON_WrDispatchInt: _KWAIT_REASON = 31;
pub const _KWAIT_REASON_WrPreempted: _KWAIT_REASON = 32;
pub const _KWAIT_REASON_WrYieldExecution: _KWAIT_REASON = 33;
pub const _KWAIT_REASON_WrFastMutex: _KWAIT_REASON = 34;
pub const _KWAIT_REASON_WrGuardedMutex: _KWAIT_REASON = 35;
pub const _KWAIT_REASON_WrRundown: _KWAIT_REASON = 36;
pub const _KWAIT_REASON_WrAlertByThreadId: _KWAIT_REASON = 37;
pub const _KWAIT_REASON_WrDeferredPreempt: _KWAIT_REASON = 38;
pub const _KWAIT_REASON_WrPhysicalFault: _KWAIT_REASON = 39;
pub const _KWAIT_REASON_WrIoRing: _KWAIT_REASON = 40;
pub const _KWAIT_REASON_WrMdlCache: _KWAIT_REASON = 41;
pub const _KWAIT_REASON_MaximumWaitReason: _KWAIT_REASON = 42;
pub type _KWAIT_REASON = core::ffi::c_int;
pub use self::_KWAIT_REASON as KWAIT_REASON;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KWAIT_BLOCK {
    pub WaitListEntry: LIST_ENTRY,
    pub WaitType: UCHAR,
    pub BlockState: UCHAR,
    pub WaitKey: USHORT,
    pub SpareLong: LONG,
    pub __bindgen_anon_1: _KWAIT_BLOCK__bindgen_ty_1,
    pub Object: PVOID,
    pub SparePtr: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KWAIT_BLOCK__bindgen_ty_1 {
    pub Thread: *mut _KTHREAD,
    pub NotificationQueue: *mut _KQUEUE,
    pub Dpc: *mut _KDPC,
}
pub type KWAIT_BLOCK = _KWAIT_BLOCK;
pub type PKWAIT_BLOCK = *mut _KWAIT_BLOCK;
pub type PRKWAIT_BLOCK = *mut _KWAIT_BLOCK;
pub type KSTART_ROUTINE = ::core::option::Option<unsafe extern "C" fn(StartContext: PVOID)>;
pub type PKSTART_ROUTINE = KSTART_ROUTINE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KDEVICE_QUEUE {
    pub Type: CSHORT,
    pub Size: CSHORT,
    pub DeviceListHead: LIST_ENTRY,
    pub Lock: KSPIN_LOCK,
    pub __bindgen_anon_1: _KDEVICE_QUEUE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KDEVICE_QUEUE__bindgen_ty_1 {
    pub Busy: BOOLEAN,
    pub __bindgen_anon_1: _KDEVICE_QUEUE__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KDEVICE_QUEUE__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _KDEVICE_QUEUE__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Reserved(&self) -> LONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: LONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> LONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: LONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Hint(&self) -> LONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 56u8) as u64) }
    }
    #[inline]
    pub fn set_Hint(&mut self, val: LONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 56u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Hint_raw(this: *const Self) -> LONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                56u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Hint_raw(this: *mut Self, val: LONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                56u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(Reserved: LONG64, Hint: LONG64) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(8usize, 56u8, {
            let Hint: u64 = unsafe { ::core::mem::transmute(Hint) };
            Hint as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type KDEVICE_QUEUE = _KDEVICE_QUEUE;
pub type PKDEVICE_QUEUE = *mut _KDEVICE_QUEUE;
pub type PRKDEVICE_QUEUE = *mut _KDEVICE_QUEUE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KDEVICE_QUEUE_ENTRY {
    pub DeviceListEntry: LIST_ENTRY,
    pub SortKey: ULONG,
    pub Inserted: BOOLEAN,
}
pub type KDEVICE_QUEUE_ENTRY = _KDEVICE_QUEUE_ENTRY;
pub type PKDEVICE_QUEUE_ENTRY = *mut _KDEVICE_QUEUE_ENTRY;
pub type PRKDEVICE_QUEUE_ENTRY = *mut _KDEVICE_QUEUE_ENTRY;
pub type KSERVICE_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(Interrupt: *mut _KINTERRUPT, ServiceContext: PVOID) -> BOOLEAN,
>;
pub type PKSERVICE_ROUTINE = KSERVICE_ROUTINE;
pub type KMESSAGE_SERVICE_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(
        Interrupt: *mut _KINTERRUPT,
        ServiceContext: PVOID,
        MessageID: ULONG,
    ) -> BOOLEAN,
>;
pub type PKMESSAGE_SERVICE_ROUTINE = KMESSAGE_SERVICE_ROUTINE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KMUTANT {
    pub Header: DISPATCHER_HEADER,
    pub MutantListEntry: LIST_ENTRY,
    pub OwnerThread: *mut _KTHREAD,
    pub __bindgen_anon_1: _KMUTANT__bindgen_ty_1,
    pub ApcDisable: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KMUTANT__bindgen_ty_1 {
    pub MutantFlags: UCHAR,
    pub __bindgen_anon_1: _KMUTANT__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KMUTANT__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _KMUTANT__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Abandoned(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Abandoned(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Abandoned_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Abandoned_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Spare1(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_Spare1(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Spare1_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                7u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Spare1_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(Abandoned: UCHAR, Spare1: UCHAR) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Abandoned: u8 = unsafe { ::core::mem::transmute(Abandoned) };
            Abandoned as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let Spare1: u8 = unsafe { ::core::mem::transmute(Spare1) };
            Spare1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type KMUTANT = _KMUTANT;
pub type PKMUTANT = *mut _KMUTANT;
pub type PRKMUTANT = *mut _KMUTANT;
pub type KMUTEX = _KMUTANT;
pub type PKMUTEX = *mut _KMUTANT;
pub type PRKMUTEX = *mut _KMUTANT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KSEMAPHORE {
    pub Header: DISPATCHER_HEADER,
    pub Limit: LONG,
}
pub type KSEMAPHORE = _KSEMAPHORE;
pub type PKSEMAPHORE = *mut _KSEMAPHORE;
pub type PRKSEMAPHORE = *mut _KSEMAPHORE;
unsafe extern "C" {
    pub fn KeInitializeDpc(
        Dpc: PRKDPC,
        DeferredRoutine: PKDEFERRED_ROUTINE,
        DeferredContext: PVOID,
    );
}
unsafe extern "C" {
    pub fn KeInitializeThreadedDpc(
        Dpc: PRKDPC,
        DeferredRoutine: PKDEFERRED_ROUTINE,
        DeferredContext: PVOID,
    );
}
unsafe extern "C" {
    pub fn KeInsertQueueDpc(Dpc: PRKDPC, SystemArgument1: PVOID, SystemArgument2: PVOID)
                            -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeRemoveQueueDpc(Dpc: PRKDPC) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeRemoveQueueDpcEx(Dpc: PRKDPC, WaitIfActive: BOOLEAN) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeInitializeCrashDumpHeader(
        DumpType: ULONG,
        Flags: ULONG,
        Buffer: PVOID,
        BufferSize: ULONG,
        BufferNeeded: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KeSetImportanceDpc(Dpc: PRKDPC, Importance: KDPC_IMPORTANCE);
}
unsafe extern "C" {
    pub fn KeSetTargetProcessorDpc(Dpc: PRKDPC, Number: CCHAR);
}
unsafe extern "C" {
    pub fn KeFlushQueuedDpcs();
}
unsafe extern "C" {
    pub fn KeInitializeDeviceQueue(DeviceQueue: PKDEVICE_QUEUE);
}
unsafe extern "C" {
    pub fn KeInsertDeviceQueue(
        DeviceQueue: PKDEVICE_QUEUE,
        DeviceQueueEntry: PKDEVICE_QUEUE_ENTRY,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeInsertByKeyDeviceQueue(
        DeviceQueue: PKDEVICE_QUEUE,
        DeviceQueueEntry: PKDEVICE_QUEUE_ENTRY,
        SortKey: ULONG,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeRemoveDeviceQueue(DeviceQueue: PKDEVICE_QUEUE) -> PKDEVICE_QUEUE_ENTRY;
}
unsafe extern "C" {
    pub fn KeRemoveByKeyDeviceQueue(
        DeviceQueue: PKDEVICE_QUEUE,
        SortKey: ULONG,
    ) -> PKDEVICE_QUEUE_ENTRY;
}
unsafe extern "C" {
    pub fn KeRemoveByKeyDeviceQueueIfBusy(
        DeviceQueue: PKDEVICE_QUEUE,
        SortKey: ULONG,
    ) -> PKDEVICE_QUEUE_ENTRY;
}
unsafe extern "C" {
    pub fn KeRemoveEntryDeviceQueue(
        DeviceQueue: PKDEVICE_QUEUE,
        DeviceQueueEntry: PKDEVICE_QUEUE_ENTRY,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeSynchronizeExecution(
        Interrupt: PKINTERRUPT,
        SynchronizeRoutine: PKSYNCHRONIZE_ROUTINE,
        SynchronizeContext: PVOID,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeAcquireInterruptSpinLock(Interrupt: PKINTERRUPT) -> KIRQL;
}
unsafe extern "C" {
    pub fn KeReleaseInterruptSpinLock(Interrupt: PKINTERRUPT, OldIrql: KIRQL);
}
unsafe extern "C" {
    pub fn KeInitializeEvent(Event: PRKEVENT, Type: EVENT_TYPE, State: BOOLEAN);
}
unsafe extern "C" {
    pub fn KeClearEvent(Event: PRKEVENT);
}
unsafe extern "C" {
    pub fn KeReadStateEvent(Event: PRKEVENT) -> LONG;
}
unsafe extern "C" {
    pub fn KeResetEvent(Event: PRKEVENT) -> LONG;
}
unsafe extern "C" {
    pub fn KeSetEvent(Event: PRKEVENT, Increment: KPRIORITY, Wait: BOOLEAN) -> LONG;
}
unsafe extern "C" {
    pub fn KeInitializeMutex(Mutex: PRKMUTEX, Level: ULONG);
}
unsafe extern "C" {
    pub fn KeReadStateMutex(Mutex: PRKMUTEX) -> LONG;
}
unsafe extern "C" {
    pub fn KeReleaseMutex(Mutex: PRKMUTEX, Wait: BOOLEAN) -> LONG;
}
unsafe extern "C" {
    pub fn KeInitializeSemaphore(Semaphore: PRKSEMAPHORE, Count: LONG, Limit: LONG);
}
unsafe extern "C" {
    pub fn KeReadStateSemaphore(Semaphore: PRKSEMAPHORE) -> LONG;
}
unsafe extern "C" {
    pub fn KeReleaseSemaphore(
        Semaphore: PRKSEMAPHORE,
        Increment: KPRIORITY,
        Adjustment: LONG,
        Wait: BOOLEAN,
    ) -> LONG;
}
unsafe extern "C" {
    pub fn KeDelayExecutionThread(
        WaitMode: KPROCESSOR_MODE,
        Alertable: BOOLEAN,
        Interval: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KeQueryPriorityThread(Thread: PKTHREAD) -> KPRIORITY;
}
unsafe extern "C" {
    pub fn KeQueryRuntimeThread(Thread: PKTHREAD, UserTime: PULONG) -> ULONG;
}
unsafe extern "C" {
    pub fn KeQueryTotalCycleTimeThread(Thread: PKTHREAD, CycleTimeStamp: PULONG64) -> ULONG64;
}
unsafe extern "C" {
    pub fn KeSetTargetProcessorDpcEx(Dpc: PKDPC, ProcNumber: PPROCESSOR_NUMBER) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KeRevertToUserAffinityThread();
}
unsafe extern "C" {
    pub fn KeSetSystemAffinityThread(Affinity: KAFFINITY);
}
unsafe extern "C" {
    pub fn KeRevertToUserAffinityThreadEx(Affinity: KAFFINITY);
}
unsafe extern "C" {
    pub fn KeSetSystemGroupAffinityThread(
        Affinity: PGROUP_AFFINITY,
        PreviousAffinity: PGROUP_AFFINITY,
    );
}
unsafe extern "C" {
    pub fn KeRevertToUserGroupAffinityThread(PreviousAffinity: PGROUP_AFFINITY);
}
unsafe extern "C" {
    pub fn KeSetSystemAffinityThreadEx(Affinity: KAFFINITY) -> KAFFINITY;
}
unsafe extern "C" {
    pub fn KeSetPriorityThread(Thread: PKTHREAD, Priority: KPRIORITY) -> KPRIORITY;
}
unsafe extern "C" {
    pub fn KeEnterCriticalRegion();
}
unsafe extern "C" {
    pub fn KeLeaveCriticalRegion();
}
unsafe extern "C" {
    pub fn KeEnterGuardedRegion();
}
unsafe extern "C" {
    pub fn KeLeaveGuardedRegion();
}
unsafe extern "C" {
    pub fn KeAreApcsDisabled() -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeInitializeTimer(Timer: PKTIMER);
}
unsafe extern "C" {
    pub fn KeInitializeTimerEx(Timer: PKTIMER, Type: TIMER_TYPE);
}
unsafe extern "C" {
    pub fn KeCancelTimer(arg1: PKTIMER) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeReadStateTimer(Timer: PKTIMER) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeSetTimer(Timer: PKTIMER, DueTime: LARGE_INTEGER, Dpc: PKDPC) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeSetTimerEx(
        Timer: PKTIMER,
        DueTime: LARGE_INTEGER,
        Period: LONG,
        Dpc: PKDPC,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeSetCoalescableTimer(
        Timer: PKTIMER,
        DueTime: LARGE_INTEGER,
        Period: ULONG,
        TolerableDelay: ULONG,
        Dpc: PKDPC,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeWaitForMultipleObjects(
        Count: ULONG,
        Object: *mut PVOID,
        WaitType: WAIT_TYPE,
        WaitReason: KWAIT_REASON,
        WaitMode: KPROCESSOR_MODE,
        Alertable: BOOLEAN,
        Timeout: PLARGE_INTEGER,
        WaitBlockArray: PKWAIT_BLOCK,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KeWaitForSingleObject(
        Object: PVOID,
        WaitReason: KWAIT_REASON,
        WaitMode: KPROCESSOR_MODE,
        Alertable: BOOLEAN,
        Timeout: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
pub type KIPI_BROADCAST_WORKER =
::core::option::Option<unsafe extern "C" fn(Argument: ULONG_PTR) -> ULONG_PTR>;
pub type PKIPI_BROADCAST_WORKER = KIPI_BROADCAST_WORKER;
unsafe extern "C" {
    pub fn KeIpiGenericCall(
        BroadcastFunction: PKIPI_BROADCAST_WORKER,
        Context: ULONG_PTR,
    ) -> ULONG_PTR;
}
unsafe extern "C" {
    pub fn KeInitializeSpinLock(SpinLock: PKSPIN_LOCK);
}
unsafe extern "C" {
    pub fn KeTestSpinLock(SpinLock: PKSPIN_LOCK) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeTryToAcquireSpinLockAtDpcLevel(SpinLock: PKSPIN_LOCK) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeAcquireSpinLockAtDpcLevel(SpinLock: PKSPIN_LOCK);
}
unsafe extern "C" {
    pub fn KeAcquireSpinLockRaiseToDpc(SpinLock: PKSPIN_LOCK) -> KIRQL;
}
unsafe extern "C" {
    pub fn KeReleaseSpinLock(SpinLock: PKSPIN_LOCK, NewIrql: KIRQL);
}
unsafe extern "C" {
    pub fn KeReleaseSpinLockFromDpcLevel(SpinLock: PKSPIN_LOCK);
}
unsafe extern "C" {
    pub fn KeAcquireSpinLockForDpc(SpinLock: PKSPIN_LOCK) -> KIRQL;
}
unsafe extern "C" {
    pub fn KeReleaseSpinLockForDpc(SpinLock: PKSPIN_LOCK, OldIrql: KIRQL);
}
unsafe extern "C" {
    pub fn KeAcquireInStackQueuedSpinLock(SpinLock: PKSPIN_LOCK, LockHandle: PKLOCK_QUEUE_HANDLE);
}
unsafe extern "C" {
    pub fn KeReleaseInStackQueuedSpinLock(LockHandle: PKLOCK_QUEUE_HANDLE);
}
unsafe extern "C" {
    pub fn KeAcquireInStackQueuedSpinLockAtDpcLevel(
        SpinLock: PKSPIN_LOCK,
        LockHandle: PKLOCK_QUEUE_HANDLE,
    );
}
unsafe extern "C" {
    pub fn KeReleaseInStackQueuedSpinLockFromDpcLevel(LockHandle: PKLOCK_QUEUE_HANDLE);
}
unsafe extern "C" {
    pub fn KeAcquireInStackQueuedSpinLockForDpc(
        SpinLock: PKSPIN_LOCK,
        LockHandle: PKLOCK_QUEUE_HANDLE,
    );
}
unsafe extern "C" {
    pub fn KeReleaseInStackQueuedSpinLockForDpc(LockHandle: PKLOCK_QUEUE_HANDLE);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KDPC_WATCHDOG_INFORMATION {
    pub DpcTimeLimit: ULONG,
    pub DpcTimeCount: ULONG,
    pub DpcWatchdogLimit: ULONG,
    pub DpcWatchdogCount: ULONG,
    pub Reserved: ULONG,
}
pub type KDPC_WATCHDOG_INFORMATION = _KDPC_WATCHDOG_INFORMATION;
pub type PKDPC_WATCHDOG_INFORMATION = *mut _KDPC_WATCHDOG_INFORMATION;
unsafe extern "C" {
    pub fn KeQueryDpcWatchdogInformation(
        WatchdogInformation: PKDPC_WATCHDOG_INFORMATION,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KeIsExecutingDpc() -> LOGICAL;
}
pub const _KBUGCHECK_BUFFER_DUMP_STATE_BufferEmpty: _KBUGCHECK_BUFFER_DUMP_STATE = 0;
pub const _KBUGCHECK_BUFFER_DUMP_STATE_BufferInserted: _KBUGCHECK_BUFFER_DUMP_STATE = 1;
pub const _KBUGCHECK_BUFFER_DUMP_STATE_BufferStarted: _KBUGCHECK_BUFFER_DUMP_STATE = 2;
pub const _KBUGCHECK_BUFFER_DUMP_STATE_BufferFinished: _KBUGCHECK_BUFFER_DUMP_STATE = 3;
pub const _KBUGCHECK_BUFFER_DUMP_STATE_BufferIncomplete: _KBUGCHECK_BUFFER_DUMP_STATE = 4;
pub type _KBUGCHECK_BUFFER_DUMP_STATE = core::ffi::c_int;
pub use self::_KBUGCHECK_BUFFER_DUMP_STATE as KBUGCHECK_BUFFER_DUMP_STATE;
pub type KBUGCHECK_CALLBACK_ROUTINE =
::core::option::Option<unsafe extern "C" fn(Buffer: PVOID, Length: ULONG)>;
pub type PKBUGCHECK_CALLBACK_ROUTINE = KBUGCHECK_CALLBACK_ROUTINE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KBUGCHECK_CALLBACK_RECORD {
    pub Entry: LIST_ENTRY,
    pub CallbackRoutine: PKBUGCHECK_CALLBACK_ROUTINE,
    pub Buffer: PVOID,
    pub Length: ULONG,
    pub Component: PUCHAR,
    pub Checksum: ULONG_PTR,
    pub State: UCHAR,
}
pub type KBUGCHECK_CALLBACK_RECORD = _KBUGCHECK_CALLBACK_RECORD;
pub type PKBUGCHECK_CALLBACK_RECORD = *mut _KBUGCHECK_CALLBACK_RECORD;
unsafe extern "C" {
    pub fn KeDeregisterBugCheckCallback(CallbackRecord: PKBUGCHECK_CALLBACK_RECORD) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeRegisterBugCheckCallback(
        CallbackRecord: PKBUGCHECK_CALLBACK_RECORD,
        CallbackRoutine: PKBUGCHECK_CALLBACK_ROUTINE,
        Buffer: PVOID,
        Length: ULONG,
        Component: PUCHAR,
    ) -> BOOLEAN;
}
pub const _KBUGCHECK_CALLBACK_REASON_KbCallbackInvalid: _KBUGCHECK_CALLBACK_REASON = 0;
pub const _KBUGCHECK_CALLBACK_REASON_KbCallbackReserved1: _KBUGCHECK_CALLBACK_REASON = 1;
pub const _KBUGCHECK_CALLBACK_REASON_KbCallbackSecondaryDumpData: _KBUGCHECK_CALLBACK_REASON = 2;
pub const _KBUGCHECK_CALLBACK_REASON_KbCallbackDumpIo: _KBUGCHECK_CALLBACK_REASON = 3;
pub const _KBUGCHECK_CALLBACK_REASON_KbCallbackAddPages: _KBUGCHECK_CALLBACK_REASON = 4;
pub const _KBUGCHECK_CALLBACK_REASON_KbCallbackSecondaryMultiPartDumpData:
_KBUGCHECK_CALLBACK_REASON = 5;
pub const _KBUGCHECK_CALLBACK_REASON_KbCallbackRemovePages: _KBUGCHECK_CALLBACK_REASON = 6;
pub const _KBUGCHECK_CALLBACK_REASON_KbCallbackTriageDumpData: _KBUGCHECK_CALLBACK_REASON = 7;
pub const _KBUGCHECK_CALLBACK_REASON_KbCallbackReserved2: _KBUGCHECK_CALLBACK_REASON = 8;
pub type _KBUGCHECK_CALLBACK_REASON = core::ffi::c_int;
pub use self::_KBUGCHECK_CALLBACK_REASON as KBUGCHECK_CALLBACK_REASON;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KBUGCHECK_REASON_CALLBACK_RECORD {
    _unused: [u8; 0],
}
pub type KBUGCHECK_REASON_CALLBACK_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(
        Reason: KBUGCHECK_CALLBACK_REASON,
        Record: *mut _KBUGCHECK_REASON_CALLBACK_RECORD,
        ReasonSpecificData: PVOID,
        ReasonSpecificDataLength: ULONG,
    ),
>;
pub type PKBUGCHECK_REASON_CALLBACK_ROUTINE = KBUGCHECK_REASON_CALLBACK_ROUTINE;
unsafe extern "C" {
    pub fn BugCheckSecondaryMultiPartDumpDataCallback(
        Reason: KBUGCHECK_CALLBACK_REASON,
        Record: *mut _KBUGCHECK_REASON_CALLBACK_RECORD,
        ReasonSpecificData: PVOID,
        ReasonSpecificDataLength: ULONG,
    );
}
pub type KBUGCHECK_REASON_CALLBACK_RECORD = _KBUGCHECK_REASON_CALLBACK_RECORD;
pub type PKBUGCHECK_REASON_CALLBACK_RECORD = *mut _KBUGCHECK_REASON_CALLBACK_RECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KBUGCHECK_SECONDARY_DUMP_DATA {
    pub InBuffer: PVOID,
    pub InBufferLength: ULONG,
    pub MaximumAllowed: ULONG,
    pub Guid: GUID,
    pub OutBuffer: PVOID,
    pub OutBufferLength: ULONG,
}
pub type KBUGCHECK_SECONDARY_DUMP_DATA = _KBUGCHECK_SECONDARY_DUMP_DATA;
pub type PKBUGCHECK_SECONDARY_DUMP_DATA = *mut _KBUGCHECK_SECONDARY_DUMP_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KBUGCHECK_SECONDARY_DUMP_DATA_EX {
    pub InBuffer: PVOID,
    pub InBufferLength: ULONG,
    pub MaximumAllowed: ULONG,
    pub Guid: GUID,
    pub OutBuffer: PVOID,
    pub OutBufferLength: ULONG,
    pub Context: PVOID,
    pub Flags: ULONG,
    pub DumpType: ULONG,
    pub BugCheckCode: ULONG,
    pub BugCheckParameter1: ULONG_PTR,
    pub BugCheckParameter2: ULONG_PTR,
    pub BugCheckParameter3: ULONG_PTR,
    pub BugCheckParameter4: ULONG_PTR,
}
pub type KBUGCHECK_SECONDARY_DUMP_DATA_EX = _KBUGCHECK_SECONDARY_DUMP_DATA_EX;
pub type PKBUGCHECK_SECONDARY_DUMP_DATA_EX = *mut _KBUGCHECK_SECONDARY_DUMP_DATA_EX;
pub const _KBUGCHECK_DUMP_IO_TYPE_KbDumpIoInvalid: _KBUGCHECK_DUMP_IO_TYPE = 0;
pub const _KBUGCHECK_DUMP_IO_TYPE_KbDumpIoHeader: _KBUGCHECK_DUMP_IO_TYPE = 1;
pub const _KBUGCHECK_DUMP_IO_TYPE_KbDumpIoBody: _KBUGCHECK_DUMP_IO_TYPE = 2;
pub const _KBUGCHECK_DUMP_IO_TYPE_KbDumpIoSecondaryData: _KBUGCHECK_DUMP_IO_TYPE = 3;
pub const _KBUGCHECK_DUMP_IO_TYPE_KbDumpIoComplete: _KBUGCHECK_DUMP_IO_TYPE = 4;
pub type _KBUGCHECK_DUMP_IO_TYPE = core::ffi::c_int;
pub use self::_KBUGCHECK_DUMP_IO_TYPE as KBUGCHECK_DUMP_IO_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KBUGCHECK_DUMP_IO {
    pub Offset: ULONG64,
    pub Buffer: PVOID,
    pub BufferLength: ULONG,
    pub Type: KBUGCHECK_DUMP_IO_TYPE,
}
pub type KBUGCHECK_DUMP_IO = _KBUGCHECK_DUMP_IO;
pub type PKBUGCHECK_DUMP_IO = *mut _KBUGCHECK_DUMP_IO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KBUGCHECK_ADD_PAGES {
    pub Context: PVOID,
    pub Flags: ULONG,
    pub BugCheckCode: ULONG,
    pub Address: ULONG_PTR,
    pub Count: ULONG_PTR,
}
pub type KBUGCHECK_ADD_PAGES = _KBUGCHECK_ADD_PAGES;
pub type PKBUGCHECK_ADD_PAGES = *mut _KBUGCHECK_ADD_PAGES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KBUGCHECK_REMOVE_PAGES {
    pub Context: PVOID,
    pub Flags: ULONG,
    pub BugCheckCode: ULONG,
    pub Address: ULONG_PTR,
    pub Count: ULONG_PTR,
}
pub type KBUGCHECK_REMOVE_PAGES = _KBUGCHECK_REMOVE_PAGES;
pub type PKBUGCHECK_REMOVE_PAGES = *mut _KBUGCHECK_REMOVE_PAGES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KADDRESS_RANGE {
    pub Address: PVOID,
    pub Size: SIZE_T,
}
pub type KADDRESS_RANGE = _KADDRESS_RANGE;
pub type PKADDRESS_RANGE = *mut _KADDRESS_RANGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KADDRESS_RANGE_DESCRIPTOR {
    pub AddressRanges: *const KADDRESS_RANGE,
    pub AddressRangeCount: SIZE_T,
}
pub type KADDRESS_RANGE_DESCRIPTOR = _KADDRESS_RANGE_DESCRIPTOR;
pub type PKADDRESS_RANGE_DESCRIPTOR = *mut _KADDRESS_RANGE_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTRIAGE_DUMP_DATA_ARRAY {
    pub List: LIST_ENTRY,
    pub NumBlocksUsed: ULONG,
    pub NumBlocksTotal: ULONG,
    pub DataSize: ULONG,
    pub MaxDataSize: ULONG,
    pub ComponentNameBufferLength: ULONG,
    pub ComponentName: PUCHAR,
    pub Blocks: [KADDRESS_RANGE; 1usize],
}
pub type KTRIAGE_DUMP_DATA_ARRAY = _KTRIAGE_DUMP_DATA_ARRAY;
pub type PKTRIAGE_DUMP_DATA_ARRAY = *mut _KTRIAGE_DUMP_DATA_ARRAY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KBUGCHECK_TRIAGE_DUMP_DATA {
    pub DataArray: PKTRIAGE_DUMP_DATA_ARRAY,
    pub Flags: ULONG,
    pub MaxVirtMemSize: ULONG,
    pub BugCheckCode: ULONG,
    pub BugCheckParameter1: ULONG_PTR,
    pub BugCheckParameter2: ULONG_PTR,
    pub BugCheckParameter3: ULONG_PTR,
    pub BugCheckParameter4: ULONG_PTR,
}
pub type KBUGCHECK_TRIAGE_DUMP_DATA = _KBUGCHECK_TRIAGE_DUMP_DATA;
pub type PKBUGCHECK_TRIAGE_DUMP_DATA = *mut _KBUGCHECK_TRIAGE_DUMP_DATA;
unsafe extern "C" {
    pub fn KeInitializeTriageDumpDataArray(
        KtriageDumpDataArray: PKTRIAGE_DUMP_DATA_ARRAY,
        Size: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KeAddTriageDumpDataBlock(
        KtriageDumpDataArray: PKTRIAGE_DUMP_DATA_ARRAY,
        Address: PVOID,
        Size: SIZE_T,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KeDeregisterBugCheckReasonCallback(
        CallbackRecord: PKBUGCHECK_REASON_CALLBACK_RECORD,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeRegisterBugCheckReasonCallback(
        CallbackRecord: PKBUGCHECK_REASON_CALLBACK_RECORD,
        CallbackRoutine: PKBUGCHECK_REASON_CALLBACK_ROUTINE,
        Reason: KBUGCHECK_CALLBACK_REASON,
        Component: PUCHAR,
    ) -> BOOLEAN;
}
pub type NMI_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, Handled: BOOLEAN) -> BOOLEAN>;
pub type PNMI_CALLBACK = NMI_CALLBACK;
unsafe extern "C" {
    pub fn KeRegisterNmiCallback(CallbackRoutine: PNMI_CALLBACK, Context: PVOID) -> PVOID;
}
unsafe extern "C" {
    pub fn KeDeregisterNmiCallback(Handle: PVOID) -> NTSTATUS;
}
pub const _BOUND_CALLBACK_STATUS_BoundExceptionContinueSearch: _BOUND_CALLBACK_STATUS = 0;
pub const _BOUND_CALLBACK_STATUS_BoundExceptionHandled: _BOUND_CALLBACK_STATUS = 1;
pub const _BOUND_CALLBACK_STATUS_BoundExceptionError: _BOUND_CALLBACK_STATUS = 2;
pub const _BOUND_CALLBACK_STATUS_BoundExceptionMaximum: _BOUND_CALLBACK_STATUS = 3;
pub type _BOUND_CALLBACK_STATUS = core::ffi::c_int;
pub use self::_BOUND_CALLBACK_STATUS as BOUND_CALLBACK_STATUS;
pub type PBOUND_CALLBACK_STATUS = *mut _BOUND_CALLBACK_STATUS;
pub type BOUND_CALLBACK = ::core::option::Option<unsafe extern "C" fn() -> BOUND_CALLBACK_STATUS>;
pub type PBOUND_CALLBACK = BOUND_CALLBACK;
unsafe extern "C" {
    pub fn KeRegisterBoundCallback(CallbackRoutine: PBOUND_CALLBACK) -> PVOID;
}
unsafe extern "C" {
    pub fn KeDeregisterBoundCallback(Handle: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KeBugCheckEx(
        BugCheckCode: ULONG,
        BugCheckParameter1: ULONG_PTR,
        BugCheckParameter2: ULONG_PTR,
        BugCheckParameter3: ULONG_PTR,
        BugCheckParameter4: ULONG_PTR,
    ) -> !;
}
unsafe extern "C" {
    pub fn KeQuerySystemTimePrecise(CurrentTime: PLARGE_INTEGER);
}
unsafe extern "C" {
    pub fn KeQueryInterruptTimePrecise(QpcTimeStamp: PULONG64) -> ULONG64;
}
unsafe extern "C" {
    pub fn KeQueryUnbiasedInterruptTimePrecise(QpcTimeStamp: PULONG64) -> ULONG64;
}
unsafe extern "C" {
    pub fn KeQueryTimeIncrement() -> ULONG;
}
unsafe extern "C" {
    pub fn KeQueryUnbiasedInterruptTime() -> ULONGLONG;
}
unsafe extern "C" {
    pub fn KeGetRecommendedSharedDataAlignment() -> ULONG;
}
unsafe extern "C" {
    pub fn KeQueryActiveProcessors() -> KAFFINITY;
}
unsafe extern "C" {
    pub fn KeQueryActiveProcessorCount(ActiveProcessors: PKAFFINITY) -> ULONG;
}
unsafe extern "C" {
    pub fn KeQueryActiveProcessorCountEx(GroupNumber: USHORT) -> ULONG;
}
unsafe extern "C" {
    pub fn KeQueryMaximumProcessorCount() -> ULONG;
}
unsafe extern "C" {
    pub fn KeQueryMaximumProcessorCountEx(GroupNumber: USHORT) -> ULONG;
}
unsafe extern "C" {
    pub fn KeQueryActiveGroupCount() -> USHORT;
}
unsafe extern "C" {
    pub fn KeQueryMaximumGroupCount() -> USHORT;
}
unsafe extern "C" {
    pub fn KeQueryGroupAffinity(GroupNumber: USHORT) -> KAFFINITY;
}
unsafe extern "C" {
    pub fn KeGetCurrentProcessorNumberEx(ProcNumber: PPROCESSOR_NUMBER) -> ULONG;
}
unsafe extern "C" {
    pub fn KeQueryNodeActiveAffinity(NodeNumber: USHORT, Affinity: PGROUP_AFFINITY, Count: PUSHORT);
}
unsafe extern "C" {
    pub fn KeQueryNodeMaximumProcessorCount(NodeNumber: USHORT) -> USHORT;
}
unsafe extern "C" {
    pub fn KeQueryHighestNodeNumber() -> USHORT;
}
unsafe extern "C" {
    pub fn KeGetCurrentNodeNumber() -> USHORT;
}
unsafe extern "C" {
    pub fn KeQueryLogicalProcessorRelationship(
        ProcessorNumber: PPROCESSOR_NUMBER,
        RelationshipType: LOGICAL_PROCESSOR_RELATIONSHIP,
        Information: PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX,
        Length: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KeShouldYieldProcessor() -> LOGICAL;
}
unsafe extern "C" {
    pub fn KeQueryNodeActiveAffinity2(
        NodeNumber: USHORT,
        GroupAffinities: PGROUP_AFFINITY,
        GroupAffinitiesCount: USHORT,
        GroupAffinitiesRequired: PUSHORT,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KeQueryNodeActiveProcessorCount(NodeNumber: USHORT) -> ULONG;
}
pub const _MEMORY_CACHING_TYPE_ORIG_MmFrameBufferCached: _MEMORY_CACHING_TYPE_ORIG = 2;
pub type _MEMORY_CACHING_TYPE_ORIG = core::ffi::c_int;
pub use self::_MEMORY_CACHING_TYPE_ORIG as MEMORY_CACHING_TYPE_ORIG;
pub const _MEMORY_CACHING_TYPE_MmNonCached: _MEMORY_CACHING_TYPE = 0;
pub const _MEMORY_CACHING_TYPE_MmCached: _MEMORY_CACHING_TYPE = 1;
pub const _MEMORY_CACHING_TYPE_MmWriteCombined: _MEMORY_CACHING_TYPE = 2;
pub const _MEMORY_CACHING_TYPE_MmHardwareCoherentCached: _MEMORY_CACHING_TYPE = 3;
pub const _MEMORY_CACHING_TYPE_MmNonCachedUnordered: _MEMORY_CACHING_TYPE = 4;
pub const _MEMORY_CACHING_TYPE_MmUSWCCached: _MEMORY_CACHING_TYPE = 5;
pub const _MEMORY_CACHING_TYPE_MmMaximumCacheType: _MEMORY_CACHING_TYPE = 6;
pub const _MEMORY_CACHING_TYPE_MmNotMapped: _MEMORY_CACHING_TYPE = -1;
pub type _MEMORY_CACHING_TYPE = core::ffi::c_int;
pub use self::_MEMORY_CACHING_TYPE as MEMORY_CACHING_TYPE;
unsafe extern "C" {
    pub fn KeAreAllApcsDisabled() -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeInitializeGuardedMutex(Mutex: PKGUARDED_MUTEX);
}
unsafe extern "C" {
    pub fn KeAcquireGuardedMutex(Mutex: PKGUARDED_MUTEX);
}
unsafe extern "C" {
    pub fn KeReleaseGuardedMutex(Mutex: PKGUARDED_MUTEX);
}
unsafe extern "C" {
    pub fn KeTryToAcquireGuardedMutex(Mutex: PKGUARDED_MUTEX) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeAcquireGuardedMutexUnsafe(FastMutex: PKGUARDED_MUTEX);
}
unsafe extern "C" {
    pub fn KeReleaseGuardedMutexUnsafe(FastMutex: PKGUARDED_MUTEX);
}
pub const KE_PROCESSOR_CHANGE_NOTIFY_STATE_KeProcessorAddStartNotify:
KE_PROCESSOR_CHANGE_NOTIFY_STATE = 0;
pub const KE_PROCESSOR_CHANGE_NOTIFY_STATE_KeProcessorAddCompleteNotify:
KE_PROCESSOR_CHANGE_NOTIFY_STATE = 1;
pub const KE_PROCESSOR_CHANGE_NOTIFY_STATE_KeProcessorAddFailureNotify:
KE_PROCESSOR_CHANGE_NOTIFY_STATE = 2;
pub type KE_PROCESSOR_CHANGE_NOTIFY_STATE = core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KE_PROCESSOR_CHANGE_NOTIFY_CONTEXT {
    pub State: KE_PROCESSOR_CHANGE_NOTIFY_STATE,
    pub NtNumber: ULONG,
    pub Status: NTSTATUS,
    pub ProcNumber: PROCESSOR_NUMBER,
}
pub type KE_PROCESSOR_CHANGE_NOTIFY_CONTEXT = _KE_PROCESSOR_CHANGE_NOTIFY_CONTEXT;
pub type PKE_PROCESSOR_CHANGE_NOTIFY_CONTEXT = *mut _KE_PROCESSOR_CHANGE_NOTIFY_CONTEXT;
pub type PROCESSOR_CALLBACK_FUNCTION = ::core::option::Option<
    unsafe extern "C" fn(
        CallbackContext: PVOID,
        ChangeContext: PKE_PROCESSOR_CHANGE_NOTIFY_CONTEXT,
        OperationStatus: PNTSTATUS,
    ),
>;
pub type PPROCESSOR_CALLBACK_FUNCTION = PROCESSOR_CALLBACK_FUNCTION;
unsafe extern "C" {
    pub fn KeRegisterProcessorChangeCallback(
        CallbackFunction: PPROCESSOR_CALLBACK_FUNCTION,
        CallbackContext: PVOID,
        Flags: ULONG,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn KeDeregisterProcessorChangeCallback(CallbackHandle: PVOID);
}
unsafe extern "C" {
    pub fn KeGetProcessorNumberFromIndex(
        ProcIndex: ULONG,
        ProcNumber: PPROCESSOR_NUMBER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KeGetProcessorIndexFromNumber(ProcNumber: PPROCESSOR_NUMBER) -> ULONG;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XSTATE_SAVE {
    pub Prev: *mut _XSTATE_SAVE,
    pub Thread: *mut _KTHREAD,
    pub Level: UCHAR,
    pub XStateContext: XSTATE_CONTEXT,
}
pub type XSTATE_SAVE = _XSTATE_SAVE;
pub type PXSTATE_SAVE = *mut _XSTATE_SAVE;
unsafe extern "C" {
    pub fn KeSaveExtendedProcessorState(Mask: ULONG64, XStateSave: PXSTATE_SAVE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KeRestoreExtendedProcessorState(XStateSave: PXSTATE_SAVE);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXT_SET_PARAMETERS_V0 {
    pub Version: ULONG,
    pub Reserved: ULONG,
    pub NoWakeTolerance: LONGLONG,
}
pub type EXT_SET_PARAMETERS = _EXT_SET_PARAMETERS_V0;
pub type PEXT_SET_PARAMETERS = *mut _EXT_SET_PARAMETERS_V0;
pub type KT2_SET_PARAMETERS = EXT_SET_PARAMETERS;
pub type PKT2_SET_PARAMETERS = *mut EXT_SET_PARAMETERS;
unsafe extern "C" {
    pub fn KeConvertAuxiliaryCounterToPerformanceCounter(
        AuxiliaryCounterValue: ULONG64,
        PerformanceCounterValue: PULONG64,
        ConversionError: PULONG64,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KeConvertPerformanceCounterToAuxiliaryCounter(
        PerformanceCounterValue: ULONG64,
        AuxiliaryCounterValue: PULONG64,
        ConversionError: PULONG64,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KeQueryAuxiliaryCounterFrequency(AuxiliaryCounterFrequency: PULONG64) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KWAIT_CHAIN {
    pub Head: PVOID,
}
pub type KWAIT_CHAIN = _KWAIT_CHAIN;
pub type PKWAIT_CHAIN = *mut _KWAIT_CHAIN;
unsafe extern "C" {
    pub static mut KdDebuggerNotPresent: PBOOLEAN;
}
unsafe extern "C" {
    pub static mut KdDebuggerEnabled: PBOOLEAN;
}
unsafe extern "C" {
    pub fn KdDisableDebugger() -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KdEnableDebugger() -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KdRefreshDebuggerNotPresent() -> BOOLEAN;
}
pub const _KD_OPTION_KD_OPTION_SET_BLOCK_ENABLE: _KD_OPTION = 0;
pub type _KD_OPTION = core::ffi::c_int;
pub use self::_KD_OPTION as KD_OPTION;
unsafe extern "C" {
    pub fn KdChangeOption(
        Option: KD_OPTION,
        InBufferBytes: ULONG,
        InBuffer: PVOID,
        OutBufferBytes: ULONG,
        OutBuffer: PVOID,
        OutBufferNeeded: PULONG,
    ) -> NTSTATUS;
}
pub const _POOL_TYPE_NonPagedPool: _POOL_TYPE = 0;
pub const _POOL_TYPE_NonPagedPoolExecute: _POOL_TYPE = 0;
pub const _POOL_TYPE_PagedPool: _POOL_TYPE = 1;
pub const _POOL_TYPE_NonPagedPoolMustSucceed: _POOL_TYPE = 2;
pub const _POOL_TYPE_DontUseThisType: _POOL_TYPE = 3;
pub const _POOL_TYPE_NonPagedPoolCacheAligned: _POOL_TYPE = 4;
pub const _POOL_TYPE_PagedPoolCacheAligned: _POOL_TYPE = 5;
pub const _POOL_TYPE_NonPagedPoolCacheAlignedMustS: _POOL_TYPE = 6;
pub const _POOL_TYPE_MaxPoolType: _POOL_TYPE = 7;
pub const _POOL_TYPE_NonPagedPoolBase: _POOL_TYPE = 0;
pub const _POOL_TYPE_NonPagedPoolBaseMustSucceed: _POOL_TYPE = 2;
pub const _POOL_TYPE_NonPagedPoolBaseCacheAligned: _POOL_TYPE = 4;
pub const _POOL_TYPE_NonPagedPoolBaseCacheAlignedMustS: _POOL_TYPE = 6;
pub const _POOL_TYPE_NonPagedPoolSession: _POOL_TYPE = 32;
pub const _POOL_TYPE_PagedPoolSession: _POOL_TYPE = 33;
pub const _POOL_TYPE_NonPagedPoolMustSucceedSession: _POOL_TYPE = 34;
pub const _POOL_TYPE_DontUseThisTypeSession: _POOL_TYPE = 35;
pub const _POOL_TYPE_NonPagedPoolCacheAlignedSession: _POOL_TYPE = 36;
pub const _POOL_TYPE_PagedPoolCacheAlignedSession: _POOL_TYPE = 37;
pub const _POOL_TYPE_NonPagedPoolCacheAlignedMustSSession: _POOL_TYPE = 38;
pub const _POOL_TYPE_NonPagedPoolNx: _POOL_TYPE = 512;
pub const _POOL_TYPE_NonPagedPoolNxCacheAligned: _POOL_TYPE = 516;
pub const _POOL_TYPE_NonPagedPoolSessionNx: _POOL_TYPE = 544;
pub type _POOL_TYPE = core::ffi::c_int;
unsafe extern "C" {
    pub fn ExAllocatePool(PoolType: POOL_TYPE, NumberOfBytes: SIZE_T) -> PVOID;
}
unsafe extern "C" {
    pub fn ExAllocatePoolWithQuota(PoolType: POOL_TYPE, NumberOfBytes: SIZE_T) -> PVOID;
}
unsafe extern "C" {
    pub fn ExAllocatePoolWithTag(PoolType: POOL_TYPE, NumberOfBytes: SIZE_T, Tag: ULONG) -> PVOID;
}
pub const _EX_POOL_PRIORITY_LowPoolPriority: _EX_POOL_PRIORITY = 0;
pub const _EX_POOL_PRIORITY_LowPoolPrioritySpecialPoolOverrun: _EX_POOL_PRIORITY = 8;
pub const _EX_POOL_PRIORITY_LowPoolPrioritySpecialPoolUnderrun: _EX_POOL_PRIORITY = 9;
pub const _EX_POOL_PRIORITY_NormalPoolPriority: _EX_POOL_PRIORITY = 16;
pub const _EX_POOL_PRIORITY_NormalPoolPrioritySpecialPoolOverrun: _EX_POOL_PRIORITY = 24;
pub const _EX_POOL_PRIORITY_NormalPoolPrioritySpecialPoolUnderrun: _EX_POOL_PRIORITY = 25;
pub const _EX_POOL_PRIORITY_HighPoolPriority: _EX_POOL_PRIORITY = 32;
pub const _EX_POOL_PRIORITY_HighPoolPrioritySpecialPoolOverrun: _EX_POOL_PRIORITY = 40;
pub const _EX_POOL_PRIORITY_HighPoolPrioritySpecialPoolUnderrun: _EX_POOL_PRIORITY = 41;
pub type _EX_POOL_PRIORITY = core::ffi::c_int;
pub use self::_EX_POOL_PRIORITY as EX_POOL_PRIORITY;
unsafe extern "C" {
    pub fn ExAllocatePoolWithTagPriority(
        PoolType: POOL_TYPE,
        NumberOfBytes: SIZE_T,
        Tag: ULONG,
        Priority: EX_POOL_PRIORITY,
    ) -> PVOID;
}
pub const POOL_EXTENDED_PARAMETER_TYPE_PoolExtendedParameterInvalidType:
POOL_EXTENDED_PARAMETER_TYPE = 0;
pub const POOL_EXTENDED_PARAMETER_TYPE_PoolExtendedParameterPriority: POOL_EXTENDED_PARAMETER_TYPE =
    1;
pub const POOL_EXTENDED_PARAMETER_TYPE_PoolExtendedParameterSecurePool:
POOL_EXTENDED_PARAMETER_TYPE = 2;
pub const POOL_EXTENDED_PARAMETER_TYPE_PoolExtendedParameterNumaNode: POOL_EXTENDED_PARAMETER_TYPE =
    3;
pub const POOL_EXTENDED_PARAMETER_TYPE_PoolExtendedParameterMax: POOL_EXTENDED_PARAMETER_TYPE = 4;
pub type POOL_EXTENDED_PARAMETER_TYPE = core::ffi::c_int;
pub type PPOOL_EXTENDED_PARAMETER_TYPE = *mut POOL_EXTENDED_PARAMETER_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POOL_EXTENDED_PARAMS_SECURE_POOL {
    pub SecurePoolHandle: HANDLE,
    pub Buffer: PVOID,
    pub Cookie: ULONG_PTR,
    pub SecurePoolFlags: ULONG,
}
pub type POOL_EXTENDED_PARAMS_SECURE_POOL = _POOL_EXTENDED_PARAMS_SECURE_POOL;
pub type POOL_NODE_REQUIREMENT = ULONG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POOL_EXTENDED_PARAMETER {
    pub __bindgen_anon_1: _POOL_EXTENDED_PARAMETER__bindgen_ty_1,
    pub __bindgen_anon_2: _POOL_EXTENDED_PARAMETER__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POOL_EXTENDED_PARAMETER__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _POOL_EXTENDED_PARAMETER__bindgen_ty_1 {
    #[inline]
    pub fn Type(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Type(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Type_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Type_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Optional(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Optional(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Optional_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Optional_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 55u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 55u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                55u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                55u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Type: ULONG64,
        Optional: ULONG64,
        Reserved: ULONG64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let Type: u64 = unsafe { ::core::mem::transmute(Type) };
            Type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Optional: u64 = unsafe { ::core::mem::transmute(Optional) };
            Optional as u64
        });
        __bindgen_bitfield_unit.set(9usize, 55u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _POOL_EXTENDED_PARAMETER__bindgen_ty_2 {
    pub Reserved2: ULONG64,
    pub Reserved3: PVOID,
    pub Priority: EX_POOL_PRIORITY,
    pub SecurePoolParams: *mut POOL_EXTENDED_PARAMS_SECURE_POOL,
    pub PreferredNode: POOL_NODE_REQUIREMENT,
}
pub type POOL_EXTENDED_PARAMETER = _POOL_EXTENDED_PARAMETER;
pub type PPOOL_EXTENDED_PARAMETER = *mut _POOL_EXTENDED_PARAMETER;
pub type PCPOOL_EXTENDED_PARAMETER = *const POOL_EXTENDED_PARAMETER;
unsafe extern "C" {
    pub fn ExAllocatePool2(Flags: POOL_FLAGS, NumberOfBytes: SIZE_T, Tag: ULONG) -> PVOID;
}
unsafe extern "C" {
    pub fn ExAllocatePool3(
        Flags: POOL_FLAGS,
        NumberOfBytes: SIZE_T,
        Tag: ULONG,
        ExtendedParameters: PCPOOL_EXTENDED_PARAMETER,
        ExtendedParametersCount: ULONG,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn ExFreePool2(
        P: PVOID,
        Tag: ULONG,
        ExtendedParameters: PCPOOL_EXTENDED_PARAMETER,
        ExtendedParametersCount: ULONG,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POOL_CREATE_EXTENDED_PARAMS {
    pub Version: ULONG,
}
pub type POOL_CREATE_EXTENDED_PARAMS = _POOL_CREATE_EXTENDED_PARAMS;
pub type PPOOL_CREATE_EXTENDED_PARAMS = *mut _POOL_CREATE_EXTENDED_PARAMS;
unsafe extern "C" {
    pub fn ExCreatePool(
        Flags: ULONG,
        Tag: ULONG_PTR,
        Params: *mut POOL_CREATE_EXTENDED_PARAMS,
        PoolHandle: *mut HANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ExDestroyPool(PoolHandle: HANDLE);
}
unsafe extern "C" {
    pub fn ExSecurePoolUpdate(
        SecurePoolHandle: HANDLE,
        Tag: ULONG,
        Allocation: PVOID,
        Cookie: ULONG_PTR,
        Offset: SIZE_T,
        Size: SIZE_T,
        Buffer: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ExSecurePoolValidate(
        SecurePoolHandle: HANDLE,
        Tag: ULONG,
        Allocation: PVOID,
        Cookie: ULONG_PTR,
    ) -> LOGICAL;
}
unsafe extern "C" {
    pub fn ExAllocatePoolWithQuotaTag(
        PoolType: POOL_TYPE,
        NumberOfBytes: SIZE_T,
        Tag: ULONG,
    ) -> PVOID;
}
pub const ExPoolZeroingNativelySupported: BOOLEAN = 0;
unsafe extern "C" {
    pub fn ExFreePool(P: PVOID);
}
unsafe extern "C" {
    pub fn ExFreePoolWithTag(P: PVOID, Tag: ULONG);
}
unsafe extern "C" {
    pub fn ExAcquireFastMutexUnsafe(FastMutex: PFAST_MUTEX);
}
unsafe extern "C" {
    pub fn ExReleaseFastMutexUnsafe(FastMutex: PFAST_MUTEX);
}
unsafe extern "C" {
    pub fn ExAcquireFastMutex(FastMutex: PFAST_MUTEX);
}
unsafe extern "C" {
    pub fn ExReleaseFastMutex(FastMutex: PFAST_MUTEX);
}
unsafe extern "C" {
    pub fn ExTryToAcquireFastMutex(FastMutex: PFAST_MUTEX) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ExInterlockedAddLargeInteger(
        Addend: PLARGE_INTEGER,
        Increment: LARGE_INTEGER,
        Lock: PKSPIN_LOCK,
    ) -> LARGE_INTEGER;
}
unsafe extern "C" {
    pub fn ExInterlockedAddUlong(Addend: PULONG, Increment: ULONG, Lock: PKSPIN_LOCK) -> ULONG;
}
unsafe extern "C" {
    pub fn ExInterlockedInsertHeadList(
        ListHead: PLIST_ENTRY,
        ListEntry: PLIST_ENTRY,
        Lock: PKSPIN_LOCK,
    ) -> PLIST_ENTRY;
}
unsafe extern "C" {
    pub fn ExInterlockedInsertTailList(
        ListHead: PLIST_ENTRY,
        ListEntry: PLIST_ENTRY,
        Lock: PKSPIN_LOCK,
    ) -> PLIST_ENTRY;
}
unsafe extern "C" {
    pub fn ExInterlockedRemoveHeadList(ListHead: PLIST_ENTRY, Lock: PKSPIN_LOCK) -> PLIST_ENTRY;
}
unsafe extern "C" {
    pub fn ExInterlockedPopEntryList(
        ListHead: PSINGLE_LIST_ENTRY,
        Lock: PKSPIN_LOCK,
    ) -> PSINGLE_LIST_ENTRY;
}
unsafe extern "C" {
    pub fn ExInterlockedPushEntryList(
        ListHead: PSINGLE_LIST_ENTRY,
        ListEntry: PSINGLE_LIST_ENTRY,
        Lock: PKSPIN_LOCK,
    ) -> PSINGLE_LIST_ENTRY;
}
unsafe extern "C" {
    pub fn InitializeSListHead(SListHead: PSLIST_HEADER);
}
unsafe extern "C" {
    pub fn FirstEntrySList(SListHead: PSLIST_HEADER) -> PSLIST_ENTRY;
}
unsafe extern "C" {
    pub fn ExQueryDepthSList(SListHead: PSLIST_HEADER) -> USHORT;
}
unsafe extern "C" {
    pub fn ExpInterlockedPopEntrySList(ListHead: PSLIST_HEADER) -> PSLIST_ENTRY;
}
unsafe extern "C" {
    pub fn ExpInterlockedPushEntrySList(
        ListHead: PSLIST_HEADER,
        ListEntry: PSLIST_ENTRY,
    ) -> PSLIST_ENTRY;
}
unsafe extern "C" {
    pub fn ExpInterlockedFlushSList(ListHead: PSLIST_HEADER) -> PSLIST_ENTRY;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _LOOKASIDE_LIST_EX {
    pub L: GENERAL_LOOKASIDE_POOL,
}
pub type LOOKASIDE_LIST_EX = _LOOKASIDE_LIST_EX;
unsafe extern "C" {
    pub fn ExInitializeLookasideListEx(
        Lookaside: PLOOKASIDE_LIST_EX,
        Allocate: PALLOCATE_FUNCTION_EX,
        Free: PFREE_FUNCTION_EX,
        PoolType: POOL_TYPE,
        Flags: ULONG,
        Size: SIZE_T,
        Tag: ULONG,
        Depth: USHORT,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ExDeleteLookasideListEx(Lookaside: PLOOKASIDE_LIST_EX);
}
unsafe extern "C" {
    pub fn ExFlushLookasideListEx(Lookaside: PLOOKASIDE_LIST_EX);
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct _NPAGED_LOOKASIDE_LIST {
    pub L: GENERAL_LOOKASIDE,
}
pub type NPAGED_LOOKASIDE_LIST = _NPAGED_LOOKASIDE_LIST;
pub type PNPAGED_LOOKASIDE_LIST = *mut _NPAGED_LOOKASIDE_LIST;
unsafe extern "C" {
    pub fn ExInitializeNPagedLookasideList(
        Lookaside: PNPAGED_LOOKASIDE_LIST,
        Allocate: PALLOCATE_FUNCTION,
        Free: PFREE_FUNCTION,
        Flags: ULONG,
        Size: SIZE_T,
        Tag: ULONG,
        Depth: USHORT,
    );
}
unsafe extern "C" {
    pub fn ExDeleteNPagedLookasideList(Lookaside: PNPAGED_LOOKASIDE_LIST);
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct _PAGED_LOOKASIDE_LIST {
    pub L: GENERAL_LOOKASIDE,
}
pub type PAGED_LOOKASIDE_LIST = _PAGED_LOOKASIDE_LIST;
pub type PPAGED_LOOKASIDE_LIST = *mut _PAGED_LOOKASIDE_LIST;
unsafe extern "C" {
    pub fn ExInitializePagedLookasideList(
        Lookaside: PPAGED_LOOKASIDE_LIST,
        Allocate: PALLOCATE_FUNCTION,
        Free: PFREE_FUNCTION,
        Flags: ULONG,
        Size: SIZE_T,
        Tag: ULONG,
        Depth: USHORT,
    );
}
unsafe extern "C" {
    pub fn ExDeletePagedLookasideList(Lookaside: PPAGED_LOOKASIDE_LIST);
}
unsafe extern "C" {
    pub fn ProbeForRead(Address: *mut core::ffi::c_void, Length: SIZE_T, Alignment: ULONG);
}
unsafe extern "C" {
    pub fn ExRaiseStatus(Status: NTSTATUS) -> !;
}
unsafe extern "C" {
    pub fn ProbeForWrite(Address: *mut core::ffi::c_void, Length: SIZE_T, Alignment: ULONG);
}
pub const _WORK_QUEUE_TYPE_CriticalWorkQueue: _WORK_QUEUE_TYPE = 0;
pub const _WORK_QUEUE_TYPE_DelayedWorkQueue: _WORK_QUEUE_TYPE = 1;
pub const _WORK_QUEUE_TYPE_HyperCriticalWorkQueue: _WORK_QUEUE_TYPE = 2;
pub const _WORK_QUEUE_TYPE_NormalWorkQueue: _WORK_QUEUE_TYPE = 3;
pub const _WORK_QUEUE_TYPE_BackgroundWorkQueue: _WORK_QUEUE_TYPE = 4;
pub const _WORK_QUEUE_TYPE_RealTimeWorkQueue: _WORK_QUEUE_TYPE = 5;
pub const _WORK_QUEUE_TYPE_SuperCriticalWorkQueue: _WORK_QUEUE_TYPE = 6;
pub const _WORK_QUEUE_TYPE_MaximumWorkQueue: _WORK_QUEUE_TYPE = 7;
pub const _WORK_QUEUE_TYPE_CustomPriorityWorkQueue: _WORK_QUEUE_TYPE = 32;
pub type _WORK_QUEUE_TYPE = core::ffi::c_int;
pub use self::_WORK_QUEUE_TYPE as WORK_QUEUE_TYPE;
pub type WORKER_THREAD_ROUTINE = ::core::option::Option<unsafe extern "C" fn(Parameter: PVOID)>;
pub type PWORKER_THREAD_ROUTINE = WORKER_THREAD_ROUTINE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WORK_QUEUE_ITEM {
    pub List: LIST_ENTRY,
    pub WorkerRoutine: PWORKER_THREAD_ROUTINE,
    pub Parameter: PVOID,
}
pub type WORK_QUEUE_ITEM = _WORK_QUEUE_ITEM;
pub type PWORK_QUEUE_ITEM = *mut _WORK_QUEUE_ITEM;
unsafe extern "C" {
    pub fn ExQueueWorkItem(WorkItem: PWORK_QUEUE_ITEM, QueueType: WORK_QUEUE_TYPE);
}
unsafe extern "C" {
    pub fn ExIsProcessorFeaturePresent(ProcessorFeature: ULONG) -> BOOLEAN;
}
pub type ERESOURCE_THREAD = ULONG_PTR;
pub type PERESOURCE_THREAD = *mut ERESOURCE_THREAD;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OWNER_ENTRY {
    pub OwnerThread: ERESOURCE_THREAD,
    pub __bindgen_anon_1: _OWNER_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OWNER_ENTRY__bindgen_ty_1 {
    pub __bindgen_anon_1: _OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1,
    pub TableSize: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn IoPriorityBoosted(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoPriorityBoosted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IoPriorityBoosted_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IoPriorityBoosted_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn OwnerReferenced(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OwnerReferenced(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn OwnerReferenced_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_OwnerReferenced_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IoQoSPriorityBoosted(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoQoSPriorityBoosted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IoQoSPriorityBoosted_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IoQoSPriorityBoosted_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn OwnerCount(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_OwnerCount(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn OwnerCount_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                29u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_OwnerCount_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                29u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        IoPriorityBoosted: ULONG,
        OwnerReferenced: ULONG,
        IoQoSPriorityBoosted: ULONG,
        OwnerCount: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let IoPriorityBoosted: u32 = unsafe { ::core::mem::transmute(IoPriorityBoosted) };
            IoPriorityBoosted as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let OwnerReferenced: u32 = unsafe { ::core::mem::transmute(OwnerReferenced) };
            OwnerReferenced as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let IoQoSPriorityBoosted: u32 = unsafe { ::core::mem::transmute(IoQoSPriorityBoosted) };
            IoQoSPriorityBoosted as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let OwnerCount: u32 = unsafe { ::core::mem::transmute(OwnerCount) };
            OwnerCount as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type OWNER_ENTRY = _OWNER_ENTRY;
pub type POWNER_ENTRY = *mut _OWNER_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ERESOURCE {
    pub SystemResourcesList: LIST_ENTRY,
    pub OwnerTable: POWNER_ENTRY,
    pub ActiveCount: SHORT,
    pub __bindgen_anon_1: _ERESOURCE__bindgen_ty_1,
    pub SharedWaiters: PVOID,
    pub ExclusiveWaiters: PVOID,
    pub OwnerEntry: OWNER_ENTRY,
    pub ActiveEntries: ULONG,
    pub ContentionCount: ULONG,
    pub NumberOfSharedWaiters: ULONG,
    pub NumberOfExclusiveWaiters: ULONG,
    pub Reserved2: PVOID,
    pub __bindgen_anon_2: _ERESOURCE__bindgen_ty_2,
    pub SpinLock: KSPIN_LOCK,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ERESOURCE__bindgen_ty_1 {
    pub Flag: USHORT,
    pub __bindgen_anon_1: _ERESOURCE__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ERESOURCE__bindgen_ty_1__bindgen_ty_1 {
    pub ReservedLowFlags: UCHAR,
    pub WaiterPriority: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ERESOURCE__bindgen_ty_2 {
    pub Address: PVOID,
    pub CreatorBackTraceIndex: ULONG_PTR,
}
pub type ERESOURCE = _ERESOURCE;
pub type PERESOURCE = *mut _ERESOURCE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RESOURCE_HASH_ENTRY {
    pub ListEntry: LIST_ENTRY,
    pub Address: PVOID,
    pub ContentionCount: ULONG,
    pub Number: ULONG,
}
pub type RESOURCE_HASH_ENTRY = _RESOURCE_HASH_ENTRY;
pub type PRESOURCE_HASH_ENTRY = *mut _RESOURCE_HASH_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RESOURCE_PERFORMANCE_DATA {
    pub ActiveResourceCount: ULONG,
    pub TotalResourceCount: ULONG,
    pub ExclusiveAcquire: ULONG,
    pub SharedFirstLevel: ULONG,
    pub SharedSecondLevel: ULONG,
    pub StarveFirstLevel: ULONG,
    pub StarveSecondLevel: ULONG,
    pub WaitForExclusive: ULONG,
    pub OwnerTableExpands: ULONG,
    pub MaximumTableExpand: ULONG,
    pub HashTable: [LIST_ENTRY; 64usize],
}
pub type RESOURCE_PERFORMANCE_DATA = _RESOURCE_PERFORMANCE_DATA;
pub type PRESOURCE_PERFORMANCE_DATA = *mut _RESOURCE_PERFORMANCE_DATA;
unsafe extern "C" {
    pub fn ExInitializeResourceLite(Resource: PERESOURCE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ExReinitializeResourceLite(Resource: PERESOURCE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ExAcquireResourceSharedLite(Resource: PERESOURCE, Wait: BOOLEAN) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ExEnterCriticalRegionAndAcquireResourceShared(Resource: PERESOURCE) -> PVOID;
}
unsafe extern "C" {
    pub fn ExAcquireResourceExclusiveLite(Resource: PERESOURCE, Wait: BOOLEAN) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ExEnterCriticalRegionAndAcquireResourceExclusive(Resource: PERESOURCE) -> PVOID;
}
unsafe extern "C" {
    pub fn ExAcquireSharedStarveExclusive(Resource: PERESOURCE, Wait: BOOLEAN) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ExAcquireSharedWaitForExclusive(Resource: PERESOURCE, Wait: BOOLEAN) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ExEnterCriticalRegionAndAcquireSharedWaitForExclusive(Resource: PERESOURCE) -> PVOID;
}
unsafe extern "C" {
    pub fn ExReleaseResourceLite(Resource: PERESOURCE);
}
unsafe extern "C" {
    pub fn ExReleaseResourceAndLeaveCriticalRegion(Resource: PERESOURCE);
}
unsafe extern "C" {
    pub fn ExReleaseResourceForThreadLite(Resource: PERESOURCE, ResourceThreadId: ERESOURCE_THREAD);
}
unsafe extern "C" {
    pub fn ExSetResourceOwnerPointer(Resource: PERESOURCE, OwnerPointer: PVOID);
}
unsafe extern "C" {
    pub fn ExSetResourceOwnerPointerEx(Resource: PERESOURCE, OwnerPointer: PVOID, Flags: ULONG);
}
unsafe extern "C" {
    pub fn ExConvertExclusiveToSharedLite(Resource: PERESOURCE);
}
unsafe extern "C" {
    pub fn ExDeleteResourceLite(Resource: PERESOURCE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ExGetExclusiveWaiterCount(Resource: PERESOURCE) -> ULONG;
}
unsafe extern "C" {
    pub fn ExGetSharedWaiterCount(Resource: PERESOURCE) -> ULONG;
}
unsafe extern "C" {
    pub fn ExIsResourceAcquiredExclusiveLite(Resource: PERESOURCE) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ExIsResourceAcquiredSharedLite(Resource: PERESOURCE) -> ULONG;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EX_RUNDOWN_REF {
    pub __bindgen_anon_1: _EX_RUNDOWN_REF__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EX_RUNDOWN_REF__bindgen_ty_1 {
    pub Count: ULONG_PTR,
    pub Ptr: PVOID,
}
pub type EX_RUNDOWN_REF = _EX_RUNDOWN_REF;
pub type PEX_RUNDOWN_REF = *mut _EX_RUNDOWN_REF;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EX_RUNDOWN_REF_CACHE_AWARE {
    _unused: [u8; 0],
}
pub type PEX_RUNDOWN_REF_CACHE_AWARE = *mut _EX_RUNDOWN_REF_CACHE_AWARE;
unsafe extern "C" {
    pub fn ExGetPreviousMode() -> KPROCESSOR_MODE;
}
unsafe extern "C" {
    pub fn ExSetTimerResolution(DesiredTime: ULONG, SetResolution: BOOLEAN) -> ULONG;
}
unsafe extern "C" {
    pub fn ExQueryTimerResolution(MaximumTime: PULONG, MinimumTime: PULONG, CurrentTime: PULONG);
}
unsafe extern "C" {
    pub fn ExSystemTimeToLocalTime(SystemTime: PLARGE_INTEGER, LocalTime: PLARGE_INTEGER);
}
unsafe extern "C" {
    pub fn ExLocalTimeToSystemTime(LocalTime: PLARGE_INTEGER, SystemTime: PLARGE_INTEGER);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EX_TIMER {
    _unused: [u8; 0],
}
pub type PEX_TIMER = *mut _EX_TIMER;
pub type EXT_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Timer: PEX_TIMER, Context: PVOID)>;
pub type PEXT_CALLBACK = EXT_CALLBACK;
pub type EXT_DELETE_CALLBACK = ::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
pub type PEXT_DELETE_CALLBACK = EXT_DELETE_CALLBACK;
pub type PEXT_CANCEL_PARAMETERS = PVOID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXT_DELETE_PARAMETERS {
    pub Version: ULONG,
    pub Reserved: ULONG,
    pub DeleteCallback: PEXT_DELETE_CALLBACK,
    pub DeleteContext: PVOID,
}
pub type EXT_DELETE_PARAMETERS = _EXT_DELETE_PARAMETERS;
pub type PEXT_DELETE_PARAMETERS = *mut _EXT_DELETE_PARAMETERS;
unsafe extern "C" {
    pub fn ExAllocateTimer(
        Callback: PEXT_CALLBACK,
        CallbackContext: PVOID,
        Attributes: ULONG,
    ) -> PEX_TIMER;
}
unsafe extern "C" {
    pub fn ExSetTimer(
        Timer: PEX_TIMER,
        DueTime: LONGLONG,
        Period: LONGLONG,
        Parameters: PEXT_SET_PARAMETERS,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ExCancelTimer(Timer: PEX_TIMER, Parameters: PEXT_CANCEL_PARAMETERS) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ExDeleteTimer(
        Timer: PEX_TIMER,
        Cancel: BOOLEAN,
        Wait: BOOLEAN,
        Parameters: PEXT_DELETE_PARAMETERS,
    ) -> BOOLEAN;
}
pub type CALLBACK_FUNCTION = ::core::option::Option<
    unsafe extern "C" fn(CallbackContext: PVOID, Argument1: PVOID, Argument2: PVOID),
>;
pub type PCALLBACK_FUNCTION = CALLBACK_FUNCTION;
unsafe extern "C" {
    pub fn ExCreateCallback(
        CallbackObject: *mut PCALLBACK_OBJECT,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        Create: BOOLEAN,
        AllowMultipleCallbacks: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ExRegisterCallback(
        CallbackObject: PCALLBACK_OBJECT,
        CallbackFunction: PCALLBACK_FUNCTION,
        CallbackContext: PVOID,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn ExUnregisterCallback(CallbackRegistration: PVOID);
}
unsafe extern "C" {
    pub fn ExNotifyCallback(CallbackObject: PVOID, Argument1: PVOID, Argument2: PVOID);
}
unsafe extern "C" {
    pub fn ExVerifySuite(SuiteType: SUITE_TYPE) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ExInitializeRundownProtection(RunRef: PEX_RUNDOWN_REF);
}
unsafe extern "C" {
    pub fn ExReInitializeRundownProtection(RunRef: PEX_RUNDOWN_REF);
}
unsafe extern "C" {
    pub fn ExAcquireRundownProtection(RunRef: PEX_RUNDOWN_REF) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ExAcquireRundownProtectionEx(RunRef: PEX_RUNDOWN_REF, Count: ULONG) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ExReleaseRundownProtection(RunRef: PEX_RUNDOWN_REF);
}
unsafe extern "C" {
    pub fn ExReleaseRundownProtectionEx(RunRef: PEX_RUNDOWN_REF, Count: ULONG);
}
unsafe extern "C" {
    pub fn ExRundownCompleted(RunRef: PEX_RUNDOWN_REF);
}
unsafe extern "C" {
    pub fn ExWaitForRundownProtectionRelease(RunRef: PEX_RUNDOWN_REF);
}
unsafe extern "C" {
    pub fn ExAllocateCacheAwareRundownProtection(
        PoolType: POOL_TYPE,
        PoolTag: ULONG,
    ) -> PEX_RUNDOWN_REF_CACHE_AWARE;
}
unsafe extern "C" {
    pub fn ExSizeOfRundownProtectionCacheAware() -> SIZE_T;
}
unsafe extern "C" {
    pub fn ExInitializeRundownProtectionCacheAware(
        RunRefCacheAware: PEX_RUNDOWN_REF_CACHE_AWARE,
        RunRefSize: SIZE_T,
    );
}
unsafe extern "C" {
    pub fn ExFreeCacheAwareRundownProtection(RunRefCacheAware: PEX_RUNDOWN_REF_CACHE_AWARE);
}
unsafe extern "C" {
    pub fn ExAcquireRundownProtectionCacheAware(
        RunRefCacheAware: PEX_RUNDOWN_REF_CACHE_AWARE,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ExReleaseRundownProtectionCacheAware(RunRefCacheAware: PEX_RUNDOWN_REF_CACHE_AWARE);
}
unsafe extern "C" {
    pub fn ExAcquireRundownProtectionCacheAwareEx(
        RunRefCacheAware: PEX_RUNDOWN_REF_CACHE_AWARE,
        Count: ULONG,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ExReleaseRundownProtectionCacheAwareEx(
        RunRef: PEX_RUNDOWN_REF_CACHE_AWARE,
        Count: ULONG,
    );
}
unsafe extern "C" {
    pub fn ExWaitForRundownProtectionReleaseCacheAware(RunRef: PEX_RUNDOWN_REF_CACHE_AWARE);
}
unsafe extern "C" {
    pub fn ExReInitializeRundownProtectionCacheAware(RunRefCacheAware: PEX_RUNDOWN_REF_CACHE_AWARE);
}
unsafe extern "C" {
    pub fn ExRundownCompletedCacheAware(RunRefCacheAware: PEX_RUNDOWN_REF_CACHE_AWARE);
}
unsafe extern "C" {
    pub fn ExInitializeRundownProtectionCacheAwareEx(
        RunRefCacheAware: PEX_RUNDOWN_REF_CACHE_AWARE,
        Flags: ULONG,
    );
}
unsafe extern "C" {
    pub fn ExCleanupRundownProtectionCacheAware(RunRefCacheAware: PEX_RUNDOWN_REF_CACHE_AWARE);
}
unsafe extern "C" {
    pub fn ExInitializePushLock(PushLock: PULONG_PTR);
}
unsafe extern "C" {
    pub fn ExAcquirePushLockExclusiveEx(PushLock: PULONG_PTR, Flags: ULONG);
}
unsafe extern "C" {
    pub fn ExAcquirePushLockSharedEx(PushLock: PULONG_PTR, Flags: ULONG);
}
unsafe extern "C" {
    pub fn ExReleasePushLockExclusiveEx(PushLock: PULONG_PTR, Flags: ULONG);
}
unsafe extern "C" {
    pub fn ExReleasePushLockSharedEx(PushLock: PULONG_PTR, Flags: ULONG);
}
unsafe extern "C" {
    pub fn ExInitializeDeviceAts(
        PhysicalDeviceObject: *mut __BindgenOpaqueArray<u8, 0usize>,
        Flags: ULONG,
    ) -> NTSTATUS;
}
pub type EX_SPIN_LOCK = LONG;
pub type PEX_SPIN_LOCK = *mut LONG;
unsafe extern "C" {
    pub fn ExAcquireSpinLockSharedAtDpcLevel(SpinLock: PEX_SPIN_LOCK);
}
unsafe extern "C" {
    pub fn ExAcquireSpinLockShared(SpinLock: PEX_SPIN_LOCK) -> KIRQL;
}
unsafe extern "C" {
    pub fn ExReleaseSpinLockSharedFromDpcLevel(SpinLock: PEX_SPIN_LOCK);
}
unsafe extern "C" {
    pub fn ExReleaseSpinLockShared(SpinLock: PEX_SPIN_LOCK, OldIrql: KIRQL);
}
unsafe extern "C" {
    pub fn ExTryConvertSharedSpinLockExclusive(SpinLock: PEX_SPIN_LOCK) -> LOGICAL;
}
unsafe extern "C" {
    pub fn ExAcquireSpinLockExclusiveAtDpcLevel(SpinLock: PEX_SPIN_LOCK);
}
unsafe extern "C" {
    pub fn ExAcquireSpinLockExclusive(SpinLock: PEX_SPIN_LOCK) -> KIRQL;
}
unsafe extern "C" {
    pub fn ExReleaseSpinLockExclusiveFromDpcLevel(SpinLock: PEX_SPIN_LOCK);
}
unsafe extern "C" {
    pub fn ExReleaseSpinLockExclusive(SpinLock: PEX_SPIN_LOCK, OldIrql: KIRQL);
}
unsafe extern "C" {
    pub fn ExTryAcquireSpinLockSharedAtDpcLevel(SpinLock: PEX_SPIN_LOCK) -> LOGICAL;
}
unsafe extern "C" {
    pub fn ExTryAcquireSpinLockExclusiveAtDpcLevel(SpinLock: PEX_SPIN_LOCK) -> LOGICAL;
}
pub type EX_CALLBACK_FUNCTION = ::core::option::Option<
    unsafe extern "C" fn(CallbackContext: PVOID, Argument1: PVOID, Argument2: PVOID) -> NTSTATUS,
>;
pub type PEX_CALLBACK_FUNCTION = EX_CALLBACK_FUNCTION;
unsafe extern "C" {
    pub fn ExGetFirmwareEnvironmentVariable(
        VariableName: PUNICODE_STRING,
        VendorGuid: LPGUID,
        Value: PVOID,
        ValueLength: PULONG,
        Attributes: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ExSetFirmwareEnvironmentVariable(
        VariableName: PUNICODE_STRING,
        VendorGuid: LPGUID,
        Value: PVOID,
        ValueLength: ULONG,
        Attributes: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ExIsManufacturingModeEnabled() -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ExIsSoftBoot() -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ExGetFirmwareType() -> FIRMWARE_TYPE;
}
unsafe extern "C" {
    pub fn ExEnumerateSystemFirmwareTables(
        FirmwareTableProviderSignature: ULONG,
        FirmwareTableBuffer: PVOID,
        BufferLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ExGetSystemFirmwareTable(
        FirmwareTableProviderSignature: ULONG,
        FirmwareTableID: ULONG,
        FirmwareTableBuffer: PVOID,
        BufferLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
pub const _REG_NOTIFY_CLASS_RegNtDeleteKey: _REG_NOTIFY_CLASS = 0;
pub const _REG_NOTIFY_CLASS_RegNtPreDeleteKey: _REG_NOTIFY_CLASS = 0;
pub const _REG_NOTIFY_CLASS_RegNtSetValueKey: _REG_NOTIFY_CLASS = 1;
pub const _REG_NOTIFY_CLASS_RegNtPreSetValueKey: _REG_NOTIFY_CLASS = 1;
pub const _REG_NOTIFY_CLASS_RegNtDeleteValueKey: _REG_NOTIFY_CLASS = 2;
pub const _REG_NOTIFY_CLASS_RegNtPreDeleteValueKey: _REG_NOTIFY_CLASS = 2;
pub const _REG_NOTIFY_CLASS_RegNtSetInformationKey: _REG_NOTIFY_CLASS = 3;
pub const _REG_NOTIFY_CLASS_RegNtPreSetInformationKey: _REG_NOTIFY_CLASS = 3;
pub const _REG_NOTIFY_CLASS_RegNtRenameKey: _REG_NOTIFY_CLASS = 4;
pub const _REG_NOTIFY_CLASS_RegNtPreRenameKey: _REG_NOTIFY_CLASS = 4;
pub const _REG_NOTIFY_CLASS_RegNtEnumerateKey: _REG_NOTIFY_CLASS = 5;
pub const _REG_NOTIFY_CLASS_RegNtPreEnumerateKey: _REG_NOTIFY_CLASS = 5;
pub const _REG_NOTIFY_CLASS_RegNtEnumerateValueKey: _REG_NOTIFY_CLASS = 6;
pub const _REG_NOTIFY_CLASS_RegNtPreEnumerateValueKey: _REG_NOTIFY_CLASS = 6;
pub const _REG_NOTIFY_CLASS_RegNtQueryKey: _REG_NOTIFY_CLASS = 7;
pub const _REG_NOTIFY_CLASS_RegNtPreQueryKey: _REG_NOTIFY_CLASS = 7;
pub const _REG_NOTIFY_CLASS_RegNtQueryValueKey: _REG_NOTIFY_CLASS = 8;
pub const _REG_NOTIFY_CLASS_RegNtPreQueryValueKey: _REG_NOTIFY_CLASS = 8;
pub const _REG_NOTIFY_CLASS_RegNtQueryMultipleValueKey: _REG_NOTIFY_CLASS = 9;
pub const _REG_NOTIFY_CLASS_RegNtPreQueryMultipleValueKey: _REG_NOTIFY_CLASS = 9;
pub const _REG_NOTIFY_CLASS_RegNtPreCreateKey: _REG_NOTIFY_CLASS = 10;
pub const _REG_NOTIFY_CLASS_RegNtPostCreateKey: _REG_NOTIFY_CLASS = 11;
pub const _REG_NOTIFY_CLASS_RegNtPreOpenKey: _REG_NOTIFY_CLASS = 12;
pub const _REG_NOTIFY_CLASS_RegNtPostOpenKey: _REG_NOTIFY_CLASS = 13;
pub const _REG_NOTIFY_CLASS_RegNtKeyHandleClose: _REG_NOTIFY_CLASS = 14;
pub const _REG_NOTIFY_CLASS_RegNtPreKeyHandleClose: _REG_NOTIFY_CLASS = 14;
pub const _REG_NOTIFY_CLASS_RegNtPostDeleteKey: _REG_NOTIFY_CLASS = 15;
pub const _REG_NOTIFY_CLASS_RegNtPostSetValueKey: _REG_NOTIFY_CLASS = 16;
pub const _REG_NOTIFY_CLASS_RegNtPostDeleteValueKey: _REG_NOTIFY_CLASS = 17;
pub const _REG_NOTIFY_CLASS_RegNtPostSetInformationKey: _REG_NOTIFY_CLASS = 18;
pub const _REG_NOTIFY_CLASS_RegNtPostRenameKey: _REG_NOTIFY_CLASS = 19;
pub const _REG_NOTIFY_CLASS_RegNtPostEnumerateKey: _REG_NOTIFY_CLASS = 20;
pub const _REG_NOTIFY_CLASS_RegNtPostEnumerateValueKey: _REG_NOTIFY_CLASS = 21;
pub const _REG_NOTIFY_CLASS_RegNtPostQueryKey: _REG_NOTIFY_CLASS = 22;
pub const _REG_NOTIFY_CLASS_RegNtPostQueryValueKey: _REG_NOTIFY_CLASS = 23;
pub const _REG_NOTIFY_CLASS_RegNtPostQueryMultipleValueKey: _REG_NOTIFY_CLASS = 24;
pub const _REG_NOTIFY_CLASS_RegNtPostKeyHandleClose: _REG_NOTIFY_CLASS = 25;
pub const _REG_NOTIFY_CLASS_RegNtPreCreateKeyEx: _REG_NOTIFY_CLASS = 26;
pub const _REG_NOTIFY_CLASS_RegNtPostCreateKeyEx: _REG_NOTIFY_CLASS = 27;
pub const _REG_NOTIFY_CLASS_RegNtPreOpenKeyEx: _REG_NOTIFY_CLASS = 28;
pub const _REG_NOTIFY_CLASS_RegNtPostOpenKeyEx: _REG_NOTIFY_CLASS = 29;
pub const _REG_NOTIFY_CLASS_RegNtPreFlushKey: _REG_NOTIFY_CLASS = 30;
pub const _REG_NOTIFY_CLASS_RegNtPostFlushKey: _REG_NOTIFY_CLASS = 31;
pub const _REG_NOTIFY_CLASS_RegNtPreLoadKey: _REG_NOTIFY_CLASS = 32;
pub const _REG_NOTIFY_CLASS_RegNtPostLoadKey: _REG_NOTIFY_CLASS = 33;
pub const _REG_NOTIFY_CLASS_RegNtPreUnLoadKey: _REG_NOTIFY_CLASS = 34;
pub const _REG_NOTIFY_CLASS_RegNtPostUnLoadKey: _REG_NOTIFY_CLASS = 35;
pub const _REG_NOTIFY_CLASS_RegNtPreQueryKeySecurity: _REG_NOTIFY_CLASS = 36;
pub const _REG_NOTIFY_CLASS_RegNtPostQueryKeySecurity: _REG_NOTIFY_CLASS = 37;
pub const _REG_NOTIFY_CLASS_RegNtPreSetKeySecurity: _REG_NOTIFY_CLASS = 38;
pub const _REG_NOTIFY_CLASS_RegNtPostSetKeySecurity: _REG_NOTIFY_CLASS = 39;
pub const _REG_NOTIFY_CLASS_RegNtCallbackObjectContextCleanup: _REG_NOTIFY_CLASS = 40;
pub const _REG_NOTIFY_CLASS_RegNtPreRestoreKey: _REG_NOTIFY_CLASS = 41;
pub const _REG_NOTIFY_CLASS_RegNtPostRestoreKey: _REG_NOTIFY_CLASS = 42;
pub const _REG_NOTIFY_CLASS_RegNtPreSaveKey: _REG_NOTIFY_CLASS = 43;
pub const _REG_NOTIFY_CLASS_RegNtPostSaveKey: _REG_NOTIFY_CLASS = 44;
pub const _REG_NOTIFY_CLASS_RegNtPreReplaceKey: _REG_NOTIFY_CLASS = 45;
pub const _REG_NOTIFY_CLASS_RegNtPostReplaceKey: _REG_NOTIFY_CLASS = 46;
pub const _REG_NOTIFY_CLASS_RegNtPreQueryKeyName: _REG_NOTIFY_CLASS = 47;
pub const _REG_NOTIFY_CLASS_RegNtPostQueryKeyName: _REG_NOTIFY_CLASS = 48;
pub const _REG_NOTIFY_CLASS_RegNtPreSaveMergedKey: _REG_NOTIFY_CLASS = 49;
pub const _REG_NOTIFY_CLASS_RegNtPostSaveMergedKey: _REG_NOTIFY_CLASS = 50;
pub const _REG_NOTIFY_CLASS_MaxRegNtNotifyClass: _REG_NOTIFY_CLASS = 51;
pub type _REG_NOTIFY_CLASS = core::ffi::c_int;
pub use self::_REG_NOTIFY_CLASS as REG_NOTIFY_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_DELETE_KEY_INFORMATION {
    pub Object: PVOID,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_DELETE_KEY_INFORMATION = _REG_DELETE_KEY_INFORMATION;
pub type PREG_DELETE_KEY_INFORMATION = *mut _REG_DELETE_KEY_INFORMATION;
pub type REG_FLUSH_KEY_INFORMATION = _REG_DELETE_KEY_INFORMATION;
pub type PREG_FLUSH_KEY_INFORMATION = *mut _REG_DELETE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_SET_VALUE_KEY_INFORMATION {
    pub Object: PVOID,
    pub ValueName: PUNICODE_STRING,
    pub TitleIndex: ULONG,
    pub Type: ULONG,
    pub Data: PVOID,
    pub DataSize: ULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_SET_VALUE_KEY_INFORMATION = _REG_SET_VALUE_KEY_INFORMATION;
pub type PREG_SET_VALUE_KEY_INFORMATION = *mut _REG_SET_VALUE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_DELETE_VALUE_KEY_INFORMATION {
    pub Object: PVOID,
    pub ValueName: PUNICODE_STRING,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_DELETE_VALUE_KEY_INFORMATION = _REG_DELETE_VALUE_KEY_INFORMATION;
pub type PREG_DELETE_VALUE_KEY_INFORMATION = *mut _REG_DELETE_VALUE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_SET_INFORMATION_KEY_INFORMATION {
    pub Object: PVOID,
    pub KeySetInformationClass: KEY_SET_INFORMATION_CLASS,
    pub KeySetInformation: PVOID,
    pub KeySetInformationLength: ULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_SET_INFORMATION_KEY_INFORMATION = _REG_SET_INFORMATION_KEY_INFORMATION;
pub type PREG_SET_INFORMATION_KEY_INFORMATION = *mut _REG_SET_INFORMATION_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_ENUMERATE_KEY_INFORMATION {
    pub Object: PVOID,
    pub Index: ULONG,
    pub KeyInformationClass: KEY_INFORMATION_CLASS,
    pub KeyInformation: PVOID,
    pub Length: ULONG,
    pub ResultLength: PULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_ENUMERATE_KEY_INFORMATION = _REG_ENUMERATE_KEY_INFORMATION;
pub type PREG_ENUMERATE_KEY_INFORMATION = *mut _REG_ENUMERATE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_ENUMERATE_VALUE_KEY_INFORMATION {
    pub Object: PVOID,
    pub Index: ULONG,
    pub KeyValueInformationClass: KEY_VALUE_INFORMATION_CLASS,
    pub KeyValueInformation: PVOID,
    pub Length: ULONG,
    pub ResultLength: PULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_ENUMERATE_VALUE_KEY_INFORMATION = _REG_ENUMERATE_VALUE_KEY_INFORMATION;
pub type PREG_ENUMERATE_VALUE_KEY_INFORMATION = *mut _REG_ENUMERATE_VALUE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_QUERY_KEY_INFORMATION {
    pub Object: PVOID,
    pub KeyInformationClass: KEY_INFORMATION_CLASS,
    pub KeyInformation: PVOID,
    pub Length: ULONG,
    pub ResultLength: PULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_QUERY_KEY_INFORMATION = _REG_QUERY_KEY_INFORMATION;
pub type PREG_QUERY_KEY_INFORMATION = *mut _REG_QUERY_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_QUERY_VALUE_KEY_INFORMATION {
    pub Object: PVOID,
    pub ValueName: PUNICODE_STRING,
    pub KeyValueInformationClass: KEY_VALUE_INFORMATION_CLASS,
    pub KeyValueInformation: PVOID,
    pub Length: ULONG,
    pub ResultLength: PULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_QUERY_VALUE_KEY_INFORMATION = _REG_QUERY_VALUE_KEY_INFORMATION;
pub type PREG_QUERY_VALUE_KEY_INFORMATION = *mut _REG_QUERY_VALUE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION {
    pub Object: PVOID,
    pub ValueEntries: PKEY_VALUE_ENTRY,
    pub EntryCount: ULONG,
    pub ValueBuffer: PVOID,
    pub BufferLength: PULONG,
    pub RequiredBufferLength: PULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION = _REG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION;
pub type PREG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION = *mut _REG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_RENAME_KEY_INFORMATION {
    pub Object: PVOID,
    pub NewName: PUNICODE_STRING,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_RENAME_KEY_INFORMATION = _REG_RENAME_KEY_INFORMATION;
pub type PREG_RENAME_KEY_INFORMATION = *mut _REG_RENAME_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_KEY_HANDLE_CLOSE_INFORMATION {
    pub Object: PVOID,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_KEY_HANDLE_CLOSE_INFORMATION = _REG_KEY_HANDLE_CLOSE_INFORMATION;
pub type PREG_KEY_HANDLE_CLOSE_INFORMATION = *mut _REG_KEY_HANDLE_CLOSE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_CREATE_KEY_INFORMATION {
    pub CompleteName: PUNICODE_STRING,
    pub RootObject: PVOID,
    pub ObjectType: PVOID,
    pub CreateOptions: ULONG,
    pub Class: PUNICODE_STRING,
    pub SecurityDescriptor: PVOID,
    pub SecurityQualityOfService: PVOID,
    pub DesiredAccess: ACCESS_MASK,
    pub GrantedAccess: ACCESS_MASK,
    pub Disposition: PULONG,
    pub ResultObject: *mut PVOID,
    pub CallContext: PVOID,
    pub RootObjectContext: PVOID,
    pub Transaction: PVOID,
    pub Reserved: PVOID,
}
pub type REG_CREATE_KEY_INFORMATION = _REG_CREATE_KEY_INFORMATION;
pub type REG_OPEN_KEY_INFORMATION = _REG_CREATE_KEY_INFORMATION;
pub type PREG_CREATE_KEY_INFORMATION = *mut _REG_CREATE_KEY_INFORMATION;
pub type PREG_OPEN_KEY_INFORMATION = *mut _REG_CREATE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_CREATE_KEY_INFORMATION_V1 {
    pub CompleteName: PUNICODE_STRING,
    pub RootObject: PVOID,
    pub ObjectType: PVOID,
    pub Options: ULONG,
    pub Class: PUNICODE_STRING,
    pub SecurityDescriptor: PVOID,
    pub SecurityQualityOfService: PVOID,
    pub DesiredAccess: ACCESS_MASK,
    pub GrantedAccess: ACCESS_MASK,
    pub Disposition: PULONG,
    pub ResultObject: *mut PVOID,
    pub CallContext: PVOID,
    pub RootObjectContext: PVOID,
    pub Transaction: PVOID,
    pub Version: ULONG_PTR,
    pub RemainingName: PUNICODE_STRING,
    pub Wow64Flags: ULONG,
    pub Attributes: ULONG,
    pub CheckAccessMode: KPROCESSOR_MODE,
}
pub type REG_CREATE_KEY_INFORMATION_V1 = _REG_CREATE_KEY_INFORMATION_V1;
pub type REG_OPEN_KEY_INFORMATION_V1 = _REG_CREATE_KEY_INFORMATION_V1;
pub type PREG_CREATE_KEY_INFORMATION_V1 = *mut _REG_CREATE_KEY_INFORMATION_V1;
pub type PREG_OPEN_KEY_INFORMATION_V1 = *mut _REG_CREATE_KEY_INFORMATION_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_POST_OPERATION_INFORMATION {
    pub Object: PVOID,
    pub Status: NTSTATUS,
    pub PreInformation: PVOID,
    pub ReturnStatus: NTSTATUS,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_POST_OPERATION_INFORMATION = _REG_POST_OPERATION_INFORMATION;
pub type PREG_POST_OPERATION_INFORMATION = *mut _REG_POST_OPERATION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_PRE_CREATE_KEY_INFORMATION {
    pub CompleteName: PUNICODE_STRING,
}
pub type REG_PRE_CREATE_KEY_INFORMATION = _REG_PRE_CREATE_KEY_INFORMATION;
pub type REG_PRE_OPEN_KEY_INFORMATION = _REG_PRE_CREATE_KEY_INFORMATION;
pub type PREG_PRE_CREATE_KEY_INFORMATION = *mut _REG_PRE_CREATE_KEY_INFORMATION;
pub type PREG_PRE_OPEN_KEY_INFORMATION = *mut _REG_PRE_CREATE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_POST_CREATE_KEY_INFORMATION {
    pub CompleteName: PUNICODE_STRING,
    pub Object: PVOID,
    pub Status: NTSTATUS,
}
pub type REG_POST_CREATE_KEY_INFORMATION = _REG_POST_CREATE_KEY_INFORMATION;
pub type REG_POST_OPEN_KEY_INFORMATION = _REG_POST_CREATE_KEY_INFORMATION;
pub type PREG_POST_CREATE_KEY_INFORMATION = *mut _REG_POST_CREATE_KEY_INFORMATION;
pub type PREG_POST_OPEN_KEY_INFORMATION = *mut _REG_POST_CREATE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_LOAD_KEY_INFORMATION {
    pub Object: PVOID,
    pub KeyName: PUNICODE_STRING,
    pub SourceFile: PUNICODE_STRING,
    pub Flags: ULONG,
    pub TrustClassObject: PVOID,
    pub UserEvent: PVOID,
    pub DesiredAccess: ACCESS_MASK,
    pub RootHandle: PHANDLE,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_LOAD_KEY_INFORMATION = _REG_LOAD_KEY_INFORMATION;
pub type PREG_LOAD_KEY_INFORMATION = *mut _REG_LOAD_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_UNLOAD_KEY_INFORMATION {
    pub Object: PVOID,
    pub UserEvent: PVOID,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_UNLOAD_KEY_INFORMATION = _REG_UNLOAD_KEY_INFORMATION;
pub type PREG_UNLOAD_KEY_INFORMATION = *mut _REG_UNLOAD_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_CALLBACK_CONTEXT_CLEANUP_INFORMATION {
    pub Object: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_CALLBACK_CONTEXT_CLEANUP_INFORMATION = _REG_CALLBACK_CONTEXT_CLEANUP_INFORMATION;
pub type PREG_CALLBACK_CONTEXT_CLEANUP_INFORMATION = *mut _REG_CALLBACK_CONTEXT_CLEANUP_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_QUERY_KEY_SECURITY_INFORMATION {
    pub Object: PVOID,
    pub SecurityInformation: PSECURITY_INFORMATION,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
    pub Length: PULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_QUERY_KEY_SECURITY_INFORMATION = _REG_QUERY_KEY_SECURITY_INFORMATION;
pub type PREG_QUERY_KEY_SECURITY_INFORMATION = *mut _REG_QUERY_KEY_SECURITY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_SET_KEY_SECURITY_INFORMATION {
    pub Object: PVOID,
    pub SecurityInformation: PSECURITY_INFORMATION,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_SET_KEY_SECURITY_INFORMATION = _REG_SET_KEY_SECURITY_INFORMATION;
pub type PREG_SET_KEY_SECURITY_INFORMATION = *mut _REG_SET_KEY_SECURITY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_RESTORE_KEY_INFORMATION {
    pub Object: PVOID,
    pub FileHandle: HANDLE,
    pub Flags: ULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_RESTORE_KEY_INFORMATION = _REG_RESTORE_KEY_INFORMATION;
pub type PREG_RESTORE_KEY_INFORMATION = *mut _REG_RESTORE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_SAVE_KEY_INFORMATION {
    pub Object: PVOID,
    pub FileHandle: HANDLE,
    pub Format: ULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_SAVE_KEY_INFORMATION = _REG_SAVE_KEY_INFORMATION;
pub type PREG_SAVE_KEY_INFORMATION = *mut _REG_SAVE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_REPLACE_KEY_INFORMATION {
    pub Object: PVOID,
    pub OldFileName: PUNICODE_STRING,
    pub NewFileName: PUNICODE_STRING,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_REPLACE_KEY_INFORMATION = _REG_REPLACE_KEY_INFORMATION;
pub type PREG_REPLACE_KEY_INFORMATION = *mut _REG_REPLACE_KEY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_QUERY_KEY_NAME {
    pub Object: PVOID,
    pub ObjectNameInfo: POBJECT_NAME_INFORMATION,
    pub Length: ULONG,
    pub ReturnLength: PULONG,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_QUERY_KEY_NAME = _REG_QUERY_KEY_NAME;
pub type PREG_QUERY_KEY_NAME = *mut _REG_QUERY_KEY_NAME;
unsafe extern "C" {
    pub fn CmRegisterCallback(
        Function: PEX_CALLBACK_FUNCTION,
        Context: PVOID,
        Cookie: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn CmUnRegisterCallback(Cookie: LARGE_INTEGER) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn CmRegisterCallbackEx(
        Function: PEX_CALLBACK_FUNCTION,
        Altitude: PCUNICODE_STRING,
        Driver: PVOID,
        Context: PVOID,
        Cookie: PLARGE_INTEGER,
        Reserved: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn CmGetCallbackVersion(Major: PULONG, Minor: PULONG);
}
unsafe extern "C" {
    pub fn CmSetCallbackObjectContext(
        Object: PVOID,
        Cookie: PLARGE_INTEGER,
        NewContext: PVOID,
        OldContext: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn CmCallbackGetKeyObjectID(
        Cookie: PLARGE_INTEGER,
        Object: PVOID,
        ObjectID: PULONG_PTR,
        ObjectName: *mut PCUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn CmGetBoundTransaction(Cookie: PLARGE_INTEGER, Object: PVOID) -> PVOID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_LOAD_KEY_INFORMATION_V2 {
    pub Object: PVOID,
    pub KeyName: PUNICODE_STRING,
    pub SourceFile: PUNICODE_STRING,
    pub Flags: ULONG,
    pub TrustClassObject: PVOID,
    pub UserEvent: PVOID,
    pub DesiredAccess: ACCESS_MASK,
    pub RootHandle: PHANDLE,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Version: ULONG_PTR,
    pub FileAccessToken: PVOID,
}
pub type REG_LOAD_KEY_INFORMATION_V2 = _REG_LOAD_KEY_INFORMATION_V2;
pub type PREG_LOAD_KEY_INFORMATION_V2 = *mut _REG_LOAD_KEY_INFORMATION_V2;
unsafe extern "C" {
    pub fn CmCallbackGetKeyObjectIDEx(
        Cookie: PLARGE_INTEGER,
        Object: PVOID,
        ObjectID: PULONG_PTR,
        ObjectName: *mut PCUNICODE_STRING,
        Flags: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn CmCallbackReleaseKeyObjectIDEx(ObjectName: PCUNICODE_STRING);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_SAVE_MERGED_KEY_INFORMATION {
    pub Object: PVOID,
    pub FileHandle: HANDLE,
    pub HighKeyObject: PVOID,
    pub LowKeyObject: PVOID,
    pub CallContext: PVOID,
    pub ObjectContext: PVOID,
    pub Reserved: PVOID,
}
pub type REG_SAVE_MERGED_KEY_INFORMATION = _REG_SAVE_MERGED_KEY_INFORMATION;
pub type PREG_SAVE_MERGED_KEY_INFORMATION = *mut _REG_SAVE_MERGED_KEY_INFORMATION;
unsafe extern "C" {
    pub static mut Mm64BitPhysicalAddress: PBOOLEAN;
}
unsafe extern "C" {
    pub static mut MmBadPointer: PVOID;
}
pub const _MM_SYSTEM_SIZE_MmSmallSystem: _MM_SYSTEM_SIZE = 0;
pub const _MM_SYSTEM_SIZE_MmMediumSystem: _MM_SYSTEM_SIZE = 1;
pub const _MM_SYSTEM_SIZE_MmLargeSystem: _MM_SYSTEM_SIZE = 2;
pub type _MM_SYSTEM_SIZE = core::ffi::c_int;
pub use self::_MM_SYSTEM_SIZE as MM_SYSTEMSIZE;
unsafe extern "C" {
    pub fn MmQuerySystemSize() -> MM_SYSTEMSIZE;
}
unsafe extern "C" {
    pub fn MmIsVerifierEnabled(VerifierFlags: PULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmAddVerifierThunks(ThunkBuffer: PVOID, ThunkBufferSize: ULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmAddVerifierSpecialThunks(
        EntryRoutine: ULONG_PTR,
        ThunkBuffer: PVOID,
        ThunkBufferSize: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmProbeAndLockSelectedPages(
        MemoryDescriptorList: PMDL,
        SegmentArray: PFILE_SEGMENT_ELEMENT,
        AccessMode: KPROCESSOR_MODE,
        Operation: LOCK_OPERATION,
    );
}
unsafe extern "C" {
    pub fn MmProbeAndLockProcessPages(
        MemoryDescriptorList: PMDL,
        Process: PEPROCESS,
        AccessMode: KPROCESSOR_MODE,
        Operation: LOCK_OPERATION,
    );
}
unsafe extern "C" {
    pub fn MmProbeAndLockPages(
        MemoryDescriptorList: PMDL,
        AccessMode: KPROCESSOR_MODE,
        Operation: LOCK_OPERATION,
    );
}
unsafe extern "C" {
    pub fn MmUnlockPages(MemoryDescriptorList: PMDL);
}
unsafe extern "C" {
    pub fn MmBuildMdlForNonPagedPool(MemoryDescriptorList: PMDL);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MM_PHYSICAL_ADDRESS_LIST {
    pub PhysicalAddress: PHYSICAL_ADDRESS,
    pub NumberOfBytes: SIZE_T,
}
pub type MM_PHYSICAL_ADDRESS_LIST = _MM_PHYSICAL_ADDRESS_LIST;
pub type PMM_PHYSICAL_ADDRESS_LIST = *mut _MM_PHYSICAL_ADDRESS_LIST;
unsafe extern "C" {
    pub fn MmAllocateMdlForIoSpace(
        PhysicalAddressList: PMM_PHYSICAL_ADDRESS_LIST,
        NumberOfEntries: SIZE_T,
        NewMdl: *mut PMDL,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmAreMdlPagesCached(MemoryDescriptorList: PMDL) -> LOGICAL;
}
unsafe extern "C" {
    pub fn MmSetPermanentCacheAttribute(
        StartAddress: PHYSICAL_ADDRESS,
        NumberOfBytes: LARGE_INTEGER,
        CacheType: MEMORY_CACHING_TYPE,
        Flags: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmMapLockedPages(MemoryDescriptorList: PMDL, AccessMode: KPROCESSOR_MODE) -> PVOID;
}
pub type MM_MDL_ROUTINE =
::core::option::Option<unsafe extern "C" fn(DriverContext: PVOID, MappedVa: PVOID)>;
pub type PMM_MDL_ROUTINE = MM_MDL_ROUTINE;
unsafe extern "C" {
    pub fn MmMapMdl(
        MemoryDescriptorList: PMDL,
        Protection: ULONG,
        DriverRoutine: PMM_MDL_ROUTINE,
        DriverContext: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmMapMemoryDumpMdlEx(
        Va: PVOID,
        PageTotal: PFN_NUMBER,
        MemoryDumpMdl: PMDL,
        Flags: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmIsIoSpaceActive(StartAddress: PHYSICAL_ADDRESS, NumberOfBytes: SIZE_T) -> LOGICAL;
}
pub type PMM_GET_SYSTEM_ROUTINE_ADDRESS_EX = ::core::option::Option<
    unsafe extern "C" fn(ModuleName: PUNICODE_STRING, FunctionName: PSTR) -> PVOID,
>;
unsafe extern "C" {
    pub fn MmAdvanceMdl(Mdl: PMDL, NumberOfBytes: ULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmProtectMdlSystemAddress(MemoryDescriptorList: PMDL, NewProtect: ULONG) -> NTSTATUS;
}
pub const _MM_PAGE_PRIORITY_LowPagePriority: _MM_PAGE_PRIORITY = 0;
pub const _MM_PAGE_PRIORITY_NormalPagePriority: _MM_PAGE_PRIORITY = 16;
pub const _MM_PAGE_PRIORITY_HighPagePriority: _MM_PAGE_PRIORITY = 32;
pub type _MM_PAGE_PRIORITY = core::ffi::c_int;
pub use self::_MM_PAGE_PRIORITY as MM_PAGE_PRIORITY;
unsafe extern "C" {
    pub fn MmMapLockedPagesSpecifyCache(
        MemoryDescriptorList: PMDL,
        AccessMode: KPROCESSOR_MODE,
        CacheType: MEMORY_CACHING_TYPE,
        RequestedAddress: PVOID,
        BugCheckOnFailure: ULONG,
        Priority: ULONG,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn MmUnmapLockedPages(BaseAddress: PVOID, MemoryDescriptorList: PMDL);
}
unsafe extern "C" {
    pub fn MmAllocateMappingAddressEx(NumberOfBytes: SIZE_T, PoolTag: ULONG, Flags: ULONG)
                                      -> PVOID;
}
unsafe extern "C" {
    pub fn MmAllocateMappingAddress(NumberOfBytes: SIZE_T, PoolTag: ULONG) -> PVOID;
}
unsafe extern "C" {
    pub fn MmFreeMappingAddress(BaseAddress: PVOID, PoolTag: ULONG);
}
unsafe extern "C" {
    pub fn MmMapLockedPagesWithReservedMapping(
        MappingAddress: PVOID,
        PoolTag: ULONG,
        MemoryDescriptorList: PMDL,
        CacheType: MEMORY_CACHING_TYPE,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn MmUnmapReservedMapping(BaseAddress: PVOID, PoolTag: ULONG, MemoryDescriptorList: PMDL);
}
unsafe extern "C" {
    pub fn MmAllocateNodePagesForMdlEx(
        LowAddress: PHYSICAL_ADDRESS,
        HighAddress: PHYSICAL_ADDRESS,
        SkipBytes: PHYSICAL_ADDRESS,
        TotalBytes: SIZE_T,
        CacheType: MEMORY_CACHING_TYPE,
        IdealNode: ULONG,
        Flags: ULONG,
    ) -> PMDL;
}
pub type MM_NODE_NUMBER_ZERO_BASED = ULONG;
pub type MM_NODE_NUMBER_ONE_BASED = ULONG;
unsafe extern "C" {
    pub fn MmAllocatePartitionNodePagesForMdlEx(
        LowAddress: PHYSICAL_ADDRESS,
        HighAddress: PHYSICAL_ADDRESS,
        SkipBytes: PHYSICAL_ADDRESS,
        TotalBytes: SIZE_T,
        CacheType: MEMORY_CACHING_TYPE,
        IdealNode: MM_NODE_NUMBER_ZERO_BASED,
        Flags: ULONG,
        PartitionObject: PVOID,
    ) -> PMDL;
}
unsafe extern "C" {
    pub fn MmAllocatePagesForMdlEx(
        LowAddress: PHYSICAL_ADDRESS,
        HighAddress: PHYSICAL_ADDRESS,
        SkipBytes: PHYSICAL_ADDRESS,
        TotalBytes: SIZE_T,
        CacheType: MEMORY_CACHING_TYPE,
        Flags: ULONG,
    ) -> PMDL;
}
unsafe extern "C" {
    pub fn MmAllocatePagesForMdl(
        LowAddress: PHYSICAL_ADDRESS,
        HighAddress: PHYSICAL_ADDRESS,
        SkipBytes: PHYSICAL_ADDRESS,
        TotalBytes: SIZE_T,
    ) -> PMDL;
}
unsafe extern "C" {
    pub fn MmFreePagesFromMdlEx(MemoryDescriptorList: PMDL, Flags: ULONG);
}
unsafe extern "C" {
    pub fn MmFreePagesFromMdl(MemoryDescriptorList: PMDL);
}
unsafe extern "C" {
    pub fn MmMapIoSpace(
        PhysicalAddress: PHYSICAL_ADDRESS,
        NumberOfBytes: SIZE_T,
        CacheType: MEMORY_CACHING_TYPE,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn MmUnmapIoSpace(BaseAddress: PVOID, NumberOfBytes: SIZE_T);
}
unsafe extern "C" {
    pub fn MmMapIoSpaceEx(
        PhysicalAddress: PHYSICAL_ADDRESS,
        NumberOfBytes: SIZE_T,
        Protect: ULONG,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn MmAllocateContiguousMemory(
        NumberOfBytes: SIZE_T,
        HighestAcceptableAddress: PHYSICAL_ADDRESS,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn MmAllocateContiguousMemorySpecifyCache(
        NumberOfBytes: SIZE_T,
        LowestAcceptableAddress: PHYSICAL_ADDRESS,
        HighestAcceptableAddress: PHYSICAL_ADDRESS,
        BoundaryAddressMultiple: PHYSICAL_ADDRESS,
        CacheType: MEMORY_CACHING_TYPE,
    ) -> PVOID;
}
pub type NODE_REQUIREMENT = ULONG;
unsafe extern "C" {
    pub fn MmAllocateContiguousMemorySpecifyCacheNode(
        NumberOfBytes: SIZE_T,
        LowestAcceptableAddress: PHYSICAL_ADDRESS,
        HighestAcceptableAddress: PHYSICAL_ADDRESS,
        BoundaryAddressMultiple: PHYSICAL_ADDRESS,
        CacheType: MEMORY_CACHING_TYPE,
        PreferredNode: NODE_REQUIREMENT,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn MmAllocateContiguousNodeMemory(
        NumberOfBytes: SIZE_T,
        LowestAcceptableAddress: PHYSICAL_ADDRESS,
        HighestAcceptableAddress: PHYSICAL_ADDRESS,
        BoundaryAddressMultiple: PHYSICAL_ADDRESS,
        Protect: ULONG,
        PreferredNode: NODE_REQUIREMENT,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn MmAllocateContiguousMemoryEx(
        NumberOfBytes: PSIZE_T,
        LowestAcceptableAddress: PHYSICAL_ADDRESS,
        HighestAcceptableAddress: PHYSICAL_ADDRESS,
        BoundaryAddressMultiple: PHYSICAL_ADDRESS,
        PreferredNode: NODE_REQUIREMENT,
        Protect: ULONG,
        PartitionObject: PVOID,
        Tag: ULONG,
        Flags: ULONG,
        BaseAddress: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmFreeContiguousMemory(BaseAddress: PVOID);
}
unsafe extern "C" {
    pub fn MmFreeContiguousMemorySpecifyCache(
        BaseAddress: PVOID,
        NumberOfBytes: SIZE_T,
        CacheType: MEMORY_CACHING_TYPE,
    );
}
unsafe extern "C" {
    pub fn MmSizeOfMdl(Base: PVOID, Length: SIZE_T) -> SIZE_T;
}
unsafe extern "C" {
    pub fn MmCreateMdl(MemoryDescriptorList: PMDL, Base: PVOID, Length: SIZE_T) -> PMDL;
}
pub const _MM_MDL_PAGE_CONTENTS_STATE_MmMdlPageContentsDynamic: _MM_MDL_PAGE_CONTENTS_STATE = 0;
pub const _MM_MDL_PAGE_CONTENTS_STATE_MmMdlPageContentsInvariant: _MM_MDL_PAGE_CONTENTS_STATE = 1;
pub const _MM_MDL_PAGE_CONTENTS_STATE_MmMdlPageContentsQuery: _MM_MDL_PAGE_CONTENTS_STATE = 2;
pub type _MM_MDL_PAGE_CONTENTS_STATE = core::ffi::c_int;
pub use self::_MM_MDL_PAGE_CONTENTS_STATE as MM_MDL_PAGE_CONTENTS_STATE;
pub use self::_MM_MDL_PAGE_CONTENTS_STATE as PMM_MDL_PAGE_CONTENTS_STATE;
unsafe extern "C" {
    pub fn MmMdlPageContentsState(
        MemoryDescriptorList: PMDL,
        State: MM_MDL_PAGE_CONTENTS_STATE,
    ) -> MM_MDL_PAGE_CONTENTS_STATE;
}
unsafe extern "C" {
    pub fn MmLockPagableDataSection(AddressWithinSection: PVOID) -> PVOID;
}
unsafe extern "C" {
    pub fn MmResetDriverPaging(AddressWithinSection: PVOID);
}
unsafe extern "C" {
    pub fn MmPageEntireDriver(AddressWithinSection: PVOID) -> PVOID;
}
unsafe extern "C" {
    pub fn MmUnlockPagableImageSection(ImageSectionHandle: PVOID);
}
pub type PMM_DLL_INITIALIZE =
::core::option::Option<unsafe extern "C" fn(RegistryPath: PUNICODE_STRING) -> NTSTATUS>;
pub type PMM_DLL_UNLOAD = ::core::option::Option<unsafe extern "C" fn() -> NTSTATUS>;
unsafe extern "C" {
    pub fn MmIsDriverSuspectForVerifier(DriverObject: *mut _DRIVER_OBJECT) -> LOGICAL;
}
unsafe extern "C" {
    pub fn MmIsDriverVerifying(DriverObject: *mut _DRIVER_OBJECT) -> LOGICAL;
}
unsafe extern "C" {
    pub fn MmIsDriverVerifyingByAddress(AddressWithinSection: PVOID) -> LOGICAL;
}
unsafe extern "C" {
    pub fn MmProtectDriverSection(
        AddressWithinSection: PVOID,
        Size: SIZE_T,
        Flags: ULONG,
    ) -> NTSTATUS;
}
pub const _SECURITY_OPERATION_CODE_SetSecurityDescriptor: _SECURITY_OPERATION_CODE = 0;
pub const _SECURITY_OPERATION_CODE_QuerySecurityDescriptor: _SECURITY_OPERATION_CODE = 1;
pub const _SECURITY_OPERATION_CODE_DeleteSecurityDescriptor: _SECURITY_OPERATION_CODE = 2;
pub const _SECURITY_OPERATION_CODE_AssignSecurityDescriptor: _SECURITY_OPERATION_CODE = 3;
pub type _SECURITY_OPERATION_CODE = core::ffi::c_int;
pub use self::_SECURITY_OPERATION_CODE as SECURITY_OPERATION_CODE;
pub type PSECURITY_OPERATION_CODE = *mut _SECURITY_OPERATION_CODE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_SUBJECT_CONTEXT {
    pub ClientToken: PACCESS_TOKEN,
    pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    pub PrimaryToken: PACCESS_TOKEN,
    pub ProcessAuditId: PVOID,
}
pub type SECURITY_SUBJECT_CONTEXT = _SECURITY_SUBJECT_CONTEXT;
pub type PSECURITY_SUBJECT_CONTEXT = *mut _SECURITY_SUBJECT_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _INITIAL_PRIVILEGE_SET {
    pub PrivilegeCount: ULONG,
    pub Control: ULONG,
    pub Privilege: [LUID_AND_ATTRIBUTES; 3usize],
}
pub type INITIAL_PRIVILEGE_SET = _INITIAL_PRIVILEGE_SET;
pub type PINITIAL_PRIVILEGE_SET = *mut _INITIAL_PRIVILEGE_SET;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ACCESS_STATE {
    pub OperationID: LUID,
    pub SecurityEvaluated: BOOLEAN,
    pub GenerateAudit: BOOLEAN,
    pub GenerateOnClose: BOOLEAN,
    pub PrivilegesAllocated: BOOLEAN,
    pub Flags: ULONG,
    pub RemainingDesiredAccess: ACCESS_MASK,
    pub PreviouslyGrantedAccess: ACCESS_MASK,
    pub OriginalDesiredAccess: ACCESS_MASK,
    pub SubjectSecurityContext: SECURITY_SUBJECT_CONTEXT,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
    pub AuxData: PVOID,
    pub Privileges: _ACCESS_STATE__bindgen_ty_1,
    pub AuditPrivileges: BOOLEAN,
    pub ObjectName: UNICODE_STRING,
    pub ObjectTypeName: UNICODE_STRING,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ACCESS_STATE__bindgen_ty_1 {
    pub InitialPrivilegeSet: INITIAL_PRIVILEGE_SET,
    pub PrivilegeSet: PRIVILEGE_SET,
}
pub type ACCESS_STATE = _ACCESS_STATE;
pub type NTFS_DEREF_EXPORTED_SECURITY_DESCRIPTOR = ::core::option::Option<
    unsafe extern "C" fn(Vcb: PVOID, SecurityDescriptor: PSECURITY_DESCRIPTOR),
>;
pub type PNTFS_DEREF_EXPORTED_SECURITY_DESCRIPTOR = NTFS_DEREF_EXPORTED_SECURITY_DESCRIPTOR;
unsafe extern "C" {
    pub fn SeCaptureSubjectContext(SubjectContext: PSECURITY_SUBJECT_CONTEXT);
}
unsafe extern "C" {
    pub fn SeLockSubjectContext(SubjectContext: PSECURITY_SUBJECT_CONTEXT);
}
unsafe extern "C" {
    pub fn SeUnlockSubjectContext(SubjectContext: PSECURITY_SUBJECT_CONTEXT);
}
unsafe extern "C" {
    pub fn SeReleaseSubjectContext(SubjectContext: PSECURITY_SUBJECT_CONTEXT);
}
unsafe extern "C" {
    pub fn SeAssignSecurity(
        ParentDescriptor: PSECURITY_DESCRIPTOR,
        ExplicitDescriptor: PSECURITY_DESCRIPTOR,
        NewDescriptor: *mut PSECURITY_DESCRIPTOR,
        IsDirectoryObject: BOOLEAN,
        SubjectContext: PSECURITY_SUBJECT_CONTEXT,
        GenericMapping: PGENERIC_MAPPING,
        PoolType: POOL_TYPE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeComputeAutoInheritByObjectType(
        ObjectType: PVOID,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        ParentSecurityDescriptor: PSECURITY_DESCRIPTOR,
    ) -> ULONG;
}
unsafe extern "C" {
    pub fn SeAssignSecurityEx(
        ParentDescriptor: PSECURITY_DESCRIPTOR,
        ExplicitDescriptor: PSECURITY_DESCRIPTOR,
        NewDescriptor: *mut PSECURITY_DESCRIPTOR,
        ObjectType: *mut GUID,
        IsDirectoryObject: BOOLEAN,
        AutoInheritFlags: ULONG,
        SubjectContext: PSECURITY_SUBJECT_CONTEXT,
        GenericMapping: PGENERIC_MAPPING,
        PoolType: POOL_TYPE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeDeassignSecurity(SecurityDescriptor: *mut PSECURITY_DESCRIPTOR) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeObjectCreateSaclAccessBits(SecurityDescriptor: PSECURITY_DESCRIPTOR) -> ULONG;
}
unsafe extern "C" {
    pub fn SeAccessCheck(
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        SubjectSecurityContext: PSECURITY_SUBJECT_CONTEXT,
        SubjectContextLocked: BOOLEAN,
        DesiredAccess: ACCESS_MASK,
        PreviouslyGrantedAccess: ACCESS_MASK,
        Privileges: *mut PPRIVILEGE_SET,
        GenericMapping: PGENERIC_MAPPING,
        AccessMode: KPROCESSOR_MODE,
        GrantedAccess: PACCESS_MASK,
        AccessStatus: PNTSTATUS,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn SeSetAuditParameter(
        AuditParameters: PSE_ADT_PARAMETER_ARRAY,
        Type: SE_ADT_PARAMETER_TYPE,
        Index: ULONG,
        Data: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeReportSecurityEvent(
        Flags: ULONG,
        SourceName: PUNICODE_STRING,
        UserSid: PSID,
        AuditParameters: PSE_ADT_PARAMETER_ARRAY,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeValidSecurityDescriptor(
        Length: ULONG,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
    ) -> BOOLEAN;
}
pub const _SE_IMAGE_TYPE_SeImageTypeElamDriver: _SE_IMAGE_TYPE = 0;
pub const _SE_IMAGE_TYPE_SeImageTypeDriver: _SE_IMAGE_TYPE = 1;
pub const _SE_IMAGE_TYPE_SeImageTypePlatformSecureFile: _SE_IMAGE_TYPE = 2;
pub const _SE_IMAGE_TYPE_SeImageTypeDynamicCodeFile: _SE_IMAGE_TYPE = 3;
pub const _SE_IMAGE_TYPE_SeImageTypeMax: _SE_IMAGE_TYPE = 4;
pub type _SE_IMAGE_TYPE = core::ffi::c_int;
pub use self::_SE_IMAGE_TYPE as SE_IMAGE_TYPE;
pub type PSE_IMAGE_TYPE = *mut _SE_IMAGE_TYPE;
pub type PBDCB_IMAGE_INFORMATION = *mut _BDCB_IMAGE_INFORMATION;
pub type SE_IMAGE_VERIFICATION_CALLBACK_FUNCTION = ::core::option::Option<
    unsafe extern "C" fn(
        CallbackContext: PVOID,
        ImageType: SE_IMAGE_TYPE,
        ImageInformation: PBDCB_IMAGE_INFORMATION,
    ),
>;
pub type PSE_IMAGE_VERIFICATION_CALLBACK_FUNCTION = SE_IMAGE_VERIFICATION_CALLBACK_FUNCTION;
pub const _SE_IMAGE_VERIFICATION_CALLBACK_TYPE_SeImageVerificationCallbackInformational:
_SE_IMAGE_VERIFICATION_CALLBACK_TYPE = 0;
pub type _SE_IMAGE_VERIFICATION_CALLBACK_TYPE = core::ffi::c_int;
pub use self::_SE_IMAGE_VERIFICATION_CALLBACK_TYPE as SE_IMAGE_VERIFICATION_CALLBACK_TYPE;
pub type PSE_IMAGE_VERIFICATION_CALLBACK_TYPE = *mut _SE_IMAGE_VERIFICATION_CALLBACK_TYPE;
pub type SE_IMAGE_VERIFICATION_CALLBACK_TOKEN = PVOID;
pub type PSE_IMAGE_VERIFICATION_CALLBACK_TOKEN = *mut PVOID;
unsafe extern "C" {
    pub fn SeRegisterImageVerificationCallback(
        ImageType: SE_IMAGE_TYPE,
        CallbackType: SE_IMAGE_VERIFICATION_CALLBACK_TYPE,
        CallbackFunction: PSE_IMAGE_VERIFICATION_CALLBACK_FUNCTION,
        CallbackContext: PVOID,
        Token: SE_IMAGE_VERIFICATION_CALLBACK_TOKEN,
        CallbackHandle: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeUnregisterImageVerificationCallback(CallbackHandle: PVOID);
}
unsafe extern "C" {
    pub fn PsCreateSystemThread(
        ThreadHandle: PHANDLE,
        DesiredAccess: ULONG,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        ProcessHandle: HANDLE,
        ClientId: PCLIENT_ID,
        StartRoutine: PKSTART_ROUTINE,
        StartContext: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsTerminateSystemThread(ExitStatus: NTSTATUS) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsWrapApcWow64Thread(ApcContext: *mut PVOID, ApcRoutine: *mut PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsGetVersion(
        MajorVersion: PULONG,
        MinorVersion: PULONG,
        BuildNumber: PULONG,
        CSDVersion: PUNICODE_STRING,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn PsQueryTotalCycleTimeProcess(Process: PEPROCESS, CycleTimeStamp: PULONG64) -> ULONG64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AFFINITY_TOKEN {
    _unused: [u8; 0],
}
pub type PAFFINITY_TOKEN = *mut _AFFINITY_TOKEN;
unsafe extern "C" {
    pub fn PsAllocateAffinityToken(AffinityToken: *mut PAFFINITY_TOKEN) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsFreeAffinityToken(AffinityToken: PAFFINITY_TOKEN);
}
unsafe extern "C" {
    pub fn PsSetSystemMultipleGroupAffinityThread(
        GroupAffinities: PGROUP_AFFINITY,
        GroupCount: USHORT,
        AffinityToken: PAFFINITY_TOKEN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsRevertToUserMultipleGroupAffinityThread(AffinityToken: PAFFINITY_TOKEN);
}
pub const _CREATE_FILE_TYPE_CreateFileTypeNone: _CREATE_FILE_TYPE = 0;
pub const _CREATE_FILE_TYPE_CreateFileTypeNamedPipe: _CREATE_FILE_TYPE = 1;
pub const _CREATE_FILE_TYPE_CreateFileTypeMailslot: _CREATE_FILE_TYPE = 2;
pub type _CREATE_FILE_TYPE = core::ffi::c_int;
pub use self::_CREATE_FILE_TYPE as CREATE_FILE_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NAMED_PIPE_CREATE_PARAMETERS {
    pub NamedPipeType: ULONG,
    pub ReadMode: ULONG,
    pub CompletionMode: ULONG,
    pub MaximumInstances: ULONG,
    pub InboundQuota: ULONG,
    pub OutboundQuota: ULONG,
    pub DefaultTimeout: LARGE_INTEGER,
    pub TimeoutSpecified: BOOLEAN,
}
pub type NAMED_PIPE_CREATE_PARAMETERS = _NAMED_PIPE_CREATE_PARAMETERS;
pub type PNAMED_PIPE_CREATE_PARAMETERS = *mut _NAMED_PIPE_CREATE_PARAMETERS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MAILSLOT_CREATE_PARAMETERS {
    pub MailslotQuota: ULONG,
    pub MaximumMessageSize: ULONG,
    pub ReadTimeout: LARGE_INTEGER,
    pub TimeoutSpecified: BOOLEAN,
}
pub type MAILSLOT_CREATE_PARAMETERS = _MAILSLOT_CREATE_PARAMETERS;
pub type PMAILSLOT_CREATE_PARAMETERS = *mut _MAILSLOT_CREATE_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVE_LAYOUT_INFORMATION {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISK_PARTITION {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCSI_REQUEST_BLOCK {
    _unused: [u8; 0],
}
pub type IO_DPC_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(
        Dpc: PKDPC,
        DeviceObject: *mut _DEVICE_OBJECT,
        Irp: *mut _IRP,
        Context: PVOID,
    ),
>;
pub type PIO_DPC_ROUTINE = IO_DPC_ROUTINE;
pub type IO_TIMER_ROUTINE =
::core::option::Option<unsafe extern "C" fn(DeviceObject: *mut _DEVICE_OBJECT, Context: PVOID)>;
pub type PIO_TIMER_ROUTINE = IO_TIMER_ROUTINE;
pub type DRIVER_INITIALIZE = ::core::option::Option<
    unsafe extern "C" fn(
        DriverObject: *mut _DRIVER_OBJECT,
        RegistryPath: PUNICODE_STRING,
    ) -> NTSTATUS,
>;
pub type PDRIVER_INITIALIZE = DRIVER_INITIALIZE;
pub type DRIVER_CANCEL =
::core::option::Option<unsafe extern "C" fn(DeviceObject: *mut _DEVICE_OBJECT, Irp: *mut _IRP)>;
pub type PDRIVER_CANCEL = DRIVER_CANCEL;
pub type DRIVER_DISPATCH = ::core::option::Option<
    unsafe extern "C" fn(DeviceObject: *mut _DEVICE_OBJECT, Irp: *mut _IRP) -> NTSTATUS,
>;
pub type PDRIVER_DISPATCH = DRIVER_DISPATCH;
pub type DRIVER_DISPATCH_RAISED = DRIVER_DISPATCH;
pub type DRIVER_DISPATCH_PAGED = ::core::option::Option<
    unsafe extern "C" fn(DeviceObject: *mut _DEVICE_OBJECT, Irp: *mut _IRP) -> NTSTATUS,
>;
pub type PDRIVER_DISPATCH_PAGED = DRIVER_DISPATCH_PAGED;
pub type DRIVER_STARTIO =
::core::option::Option<unsafe extern "C" fn(DeviceObject: *mut _DEVICE_OBJECT, Irp: *mut _IRP)>;
pub type PDRIVER_STARTIO = DRIVER_STARTIO;
pub type DRIVER_UNLOAD =
::core::option::Option<unsafe extern "C" fn(DriverObject: *mut _DRIVER_OBJECT)>;
pub type PDRIVER_UNLOAD = DRIVER_UNLOAD;
pub type DRIVER_ADD_DEVICE = ::core::option::Option<
    unsafe extern "C" fn(
        DriverObject: *mut _DRIVER_OBJECT,
        PhysicalDeviceObject: *mut _DEVICE_OBJECT,
    ) -> NTSTATUS,
>;
pub type PDRIVER_ADD_DEVICE = DRIVER_ADD_DEVICE;
pub type FAST_IO_CHECK_IF_POSSIBLE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        Wait: BOOLEAN,
        LockKey: ULONG,
        CheckForReadOperation: BOOLEAN,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_CHECK_IF_POSSIBLE = FAST_IO_CHECK_IF_POSSIBLE;
pub type FAST_IO_READ = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        Wait: BOOLEAN,
        LockKey: ULONG,
        Buffer: PVOID,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_READ = FAST_IO_READ;
pub type FAST_IO_WRITE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        Wait: BOOLEAN,
        LockKey: ULONG,
        Buffer: PVOID,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_WRITE = FAST_IO_WRITE;
pub type FAST_IO_QUERY_BASIC_INFO = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        Wait: BOOLEAN,
        Buffer: PFILE_BASIC_INFORMATION,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_QUERY_BASIC_INFO = FAST_IO_QUERY_BASIC_INFO;
pub type FAST_IO_QUERY_STANDARD_INFO = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        Wait: BOOLEAN,
        Buffer: PFILE_STANDARD_INFORMATION,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_QUERY_STANDARD_INFO = FAST_IO_QUERY_STANDARD_INFO;
pub type FAST_IO_LOCK = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: PLARGE_INTEGER,
        ProcessId: PEPROCESS,
        Key: ULONG,
        FailImmediately: BOOLEAN,
        ExclusiveLock: BOOLEAN,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_LOCK = FAST_IO_LOCK;
pub type FAST_IO_UNLOCK_SINGLE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: PLARGE_INTEGER,
        ProcessId: PEPROCESS,
        Key: ULONG,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_UNLOCK_SINGLE = FAST_IO_UNLOCK_SINGLE;
pub type FAST_IO_UNLOCK_ALL = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        ProcessId: PEPROCESS,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_UNLOCK_ALL = FAST_IO_UNLOCK_ALL;
pub type FAST_IO_UNLOCK_ALL_BY_KEY = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        ProcessId: PVOID,
        Key: ULONG,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_UNLOCK_ALL_BY_KEY = FAST_IO_UNLOCK_ALL_BY_KEY;
pub type FAST_IO_DEVICE_CONTROL = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        Wait: BOOLEAN,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
        IoControlCode: ULONG,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_DEVICE_CONTROL = FAST_IO_DEVICE_CONTROL;
pub type FAST_IO_ACQUIRE_FILE =
::core::option::Option<unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT)>;
pub type PFAST_IO_ACQUIRE_FILE = FAST_IO_ACQUIRE_FILE;
pub type FAST_IO_RELEASE_FILE =
::core::option::Option<unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT)>;
pub type PFAST_IO_RELEASE_FILE = FAST_IO_RELEASE_FILE;
pub type FAST_IO_DETACH_DEVICE = ::core::option::Option<
    unsafe extern "C" fn(SourceDevice: *mut _DEVICE_OBJECT, TargetDevice: *mut _DEVICE_OBJECT),
>;
pub type PFAST_IO_DETACH_DEVICE = FAST_IO_DETACH_DEVICE;
pub type FAST_IO_QUERY_NETWORK_OPEN_INFO = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        Wait: BOOLEAN,
        Buffer: *mut _FILE_NETWORK_OPEN_INFORMATION,
        IoStatus: *mut _IO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_QUERY_NETWORK_OPEN_INFO = FAST_IO_QUERY_NETWORK_OPEN_INFO;
pub type FAST_IO_MDL_READ = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        LockKey: ULONG,
        MdlChain: *mut PMDL,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_MDL_READ = FAST_IO_MDL_READ;
pub type FAST_IO_MDL_READ_COMPLETE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        MdlChain: PMDL,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_MDL_READ_COMPLETE = FAST_IO_MDL_READ_COMPLETE;
pub type FAST_IO_PREPARE_MDL_WRITE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        LockKey: ULONG,
        MdlChain: *mut PMDL,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_PREPARE_MDL_WRITE = FAST_IO_PREPARE_MDL_WRITE;
pub type FAST_IO_MDL_WRITE_COMPLETE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        MdlChain: PMDL,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_MDL_WRITE_COMPLETE = FAST_IO_MDL_WRITE_COMPLETE;
pub type FAST_IO_ACQUIRE_FOR_MOD_WRITE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        EndingOffset: PLARGE_INTEGER,
        ResourceToRelease: *mut *mut _ERESOURCE,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> NTSTATUS,
>;
pub type PFAST_IO_ACQUIRE_FOR_MOD_WRITE = FAST_IO_ACQUIRE_FOR_MOD_WRITE;
pub type FAST_IO_RELEASE_FOR_MOD_WRITE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        ResourceToRelease: *mut _ERESOURCE,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> NTSTATUS,
>;
pub type PFAST_IO_RELEASE_FOR_MOD_WRITE = FAST_IO_RELEASE_FOR_MOD_WRITE;
pub type FAST_IO_ACQUIRE_FOR_CCFLUSH = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> NTSTATUS,
>;
pub type PFAST_IO_ACQUIRE_FOR_CCFLUSH = FAST_IO_ACQUIRE_FOR_CCFLUSH;
pub type FAST_IO_RELEASE_FOR_CCFLUSH = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> NTSTATUS,
>;
pub type PFAST_IO_RELEASE_FOR_CCFLUSH = FAST_IO_RELEASE_FOR_CCFLUSH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _COMPRESSED_DATA_INFO {
    _unused: [u8; 0],
}
pub type FAST_IO_READ_COMPRESSED = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        LockKey: ULONG,
        Buffer: PVOID,
        MdlChain: *mut PMDL,
        IoStatus: PIO_STATUS_BLOCK,
        CompressedDataInfo: *mut _COMPRESSED_DATA_INFO,
        CompressedDataInfoLength: ULONG,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_READ_COMPRESSED = FAST_IO_READ_COMPRESSED;
pub type FAST_IO_WRITE_COMPRESSED = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        LockKey: ULONG,
        Buffer: PVOID,
        MdlChain: *mut PMDL,
        IoStatus: PIO_STATUS_BLOCK,
        CompressedDataInfo: *mut _COMPRESSED_DATA_INFO,
        CompressedDataInfoLength: ULONG,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_WRITE_COMPRESSED = FAST_IO_WRITE_COMPRESSED;
pub type FAST_IO_MDL_READ_COMPLETE_COMPRESSED = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        MdlChain: PMDL,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_MDL_READ_COMPLETE_COMPRESSED = FAST_IO_MDL_READ_COMPLETE_COMPRESSED;
pub type FAST_IO_MDL_WRITE_COMPLETE_COMPRESSED = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        MdlChain: PMDL,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED = FAST_IO_MDL_WRITE_COMPLETE_COMPRESSED;
pub type FAST_IO_QUERY_OPEN = ::core::option::Option<
    unsafe extern "C" fn(
        Irp: *mut _IRP,
        NetworkInformation: PFILE_NETWORK_OPEN_INFORMATION,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_QUERY_OPEN = FAST_IO_QUERY_OPEN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FAST_IO_DISPATCH {
    pub SizeOfFastIoDispatch: ULONG,
    pub FastIoCheckIfPossible: PFAST_IO_CHECK_IF_POSSIBLE,
    pub FastIoRead: PFAST_IO_READ,
    pub FastIoWrite: PFAST_IO_WRITE,
    pub FastIoQueryBasicInfo: PFAST_IO_QUERY_BASIC_INFO,
    pub FastIoQueryStandardInfo: PFAST_IO_QUERY_STANDARD_INFO,
    pub FastIoLock: PFAST_IO_LOCK,
    pub FastIoUnlockSingle: PFAST_IO_UNLOCK_SINGLE,
    pub FastIoUnlockAll: PFAST_IO_UNLOCK_ALL,
    pub FastIoUnlockAllByKey: PFAST_IO_UNLOCK_ALL_BY_KEY,
    pub FastIoDeviceControl: PFAST_IO_DEVICE_CONTROL,
    pub AcquireFileForNtCreateSection: PFAST_IO_ACQUIRE_FILE,
    pub ReleaseFileForNtCreateSection: PFAST_IO_RELEASE_FILE,
    pub FastIoDetachDevice: PFAST_IO_DETACH_DEVICE,
    pub FastIoQueryNetworkOpenInfo: PFAST_IO_QUERY_NETWORK_OPEN_INFO,
    pub AcquireForModWrite: PFAST_IO_ACQUIRE_FOR_MOD_WRITE,
    pub MdlRead: PFAST_IO_MDL_READ,
    pub MdlReadComplete: PFAST_IO_MDL_READ_COMPLETE,
    pub PrepareMdlWrite: PFAST_IO_PREPARE_MDL_WRITE,
    pub MdlWriteComplete: PFAST_IO_MDL_WRITE_COMPLETE,
    pub FastIoReadCompressed: PFAST_IO_READ_COMPRESSED,
    pub FastIoWriteCompressed: PFAST_IO_WRITE_COMPRESSED,
    pub MdlReadCompleteCompressed: PFAST_IO_MDL_READ_COMPLETE_COMPRESSED,
    pub MdlWriteCompleteCompressed: PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED,
    pub FastIoQueryOpen: PFAST_IO_QUERY_OPEN,
    pub ReleaseForModWrite: PFAST_IO_RELEASE_FOR_MOD_WRITE,
    pub AcquireForCcFlush: PFAST_IO_ACQUIRE_FOR_CCFLUSH,
    pub ReleaseForCcFlush: PFAST_IO_RELEASE_FOR_CCFLUSH,
}
pub type FAST_IO_DISPATCH = _FAST_IO_DISPATCH;
pub type PFAST_IO_DISPATCH = *mut _FAST_IO_DISPATCH;
pub const _IO_ALLOCATION_ACTION_KeepObject: _IO_ALLOCATION_ACTION = 1;
pub const _IO_ALLOCATION_ACTION_DeallocateObject: _IO_ALLOCATION_ACTION = 2;
pub const _IO_ALLOCATION_ACTION_DeallocateObjectKeepRegisters: _IO_ALLOCATION_ACTION = 3;
pub type _IO_ALLOCATION_ACTION = core::ffi::c_int;
pub use self::_IO_ALLOCATION_ACTION as IO_ALLOCATION_ACTION;
pub type PIO_ALLOCATION_ACTION = *mut _IO_ALLOCATION_ACTION;
pub type DRIVER_CONTROL = ::core::option::Option<
    unsafe extern "C" fn(
        DeviceObject: *mut _DEVICE_OBJECT,
        Irp: *mut _IRP,
        MapRegisterBase: PVOID,
        Context: PVOID,
    ) -> IO_ALLOCATION_ACTION,
>;
pub type PDRIVER_CONTROL = DRIVER_CONTROL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_SECURITY_CONTEXT {
    pub SecurityQos: PSECURITY_QUALITY_OF_SERVICE,
    pub AccessState: PACCESS_STATE,
    pub DesiredAccess: ACCESS_MASK,
    pub FullCreateOptions: ULONG,
}
pub type IO_SECURITY_CONTEXT = _IO_SECURITY_CONTEXT;
pub type PIO_SECURITY_CONTEXT = *mut _IO_SECURITY_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VPB {
    pub Type: CSHORT,
    pub Size: CSHORT,
    pub Flags: USHORT,
    pub VolumeLabelLength: USHORT,
    pub DeviceObject: *mut _DEVICE_OBJECT,
    pub RealDevice: *mut _DEVICE_OBJECT,
    pub SerialNumber: ULONG,
    pub ReferenceCount: ULONG,
    pub VolumeLabel: [WCHAR; 32usize],
}
pub type VPB = _VPB;
pub type PADAPTER_OBJECT = *mut _DMA_ADAPTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WAIT_CONTEXT_BLOCK {
    pub __bindgen_anon_1: _WAIT_CONTEXT_BLOCK__bindgen_ty_1,
    pub DeviceRoutine: PDRIVER_CONTROL,
    pub DeviceContext: PVOID,
    pub NumberOfMapRegisters: ULONG,
    pub DeviceObject: PVOID,
    pub CurrentIrp: PVOID,
    pub BufferChainingDpc: PKDPC,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WAIT_CONTEXT_BLOCK__bindgen_ty_1 {
    pub WaitQueueEntry: KDEVICE_QUEUE_ENTRY,
    pub __bindgen_anon_1: _WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1 {
    pub DmaWaitEntry: LIST_ENTRY,
    pub NumberOfChannels: ULONG,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn SyncCallback(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SyncCallback(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SyncCallback_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SyncCallback_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DmaContext(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DmaContext(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DmaContext_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DmaContext_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ZeroMapRegisters(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ZeroMapRegisters(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ZeroMapRegisters_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ZeroMapRegisters_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                9u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                9u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NumberOfRemapPages(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_NumberOfRemapPages(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NumberOfRemapPages_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                20u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NumberOfRemapPages_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                20u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SyncCallback: ULONG,
        DmaContext: ULONG,
        ZeroMapRegisters: ULONG,
        Reserved: ULONG,
        NumberOfRemapPages: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SyncCallback: u32 = unsafe { ::core::mem::transmute(SyncCallback) };
            SyncCallback as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DmaContext: u32 = unsafe { ::core::mem::transmute(DmaContext) };
            DmaContext as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ZeroMapRegisters: u32 = unsafe { ::core::mem::transmute(ZeroMapRegisters) };
            ZeroMapRegisters as u64
        });
        __bindgen_bitfield_unit.set(3usize, 9u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let NumberOfRemapPages: u32 = unsafe { ::core::mem::transmute(NumberOfRemapPages) };
            NumberOfRemapPages as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WAIT_CONTEXT_BLOCK = _WAIT_CONTEXT_BLOCK;
pub type PWAIT_CONTEXT_BLOCK = *mut _WAIT_CONTEXT_BLOCK;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _DEVICE_OBJECT {
    pub Type: CSHORT,
    pub Size: USHORT,
    pub ReferenceCount: LONG,
    pub DriverObject: *mut _DRIVER_OBJECT,
    pub NextDevice: *mut _DEVICE_OBJECT,
    pub AttachedDevice: *mut _DEVICE_OBJECT,
    pub CurrentIrp: *mut _IRP,
    pub Timer: PIO_TIMER,
    pub Flags: ULONG,
    pub Characteristics: ULONG,
    pub Vpb: PVPB,
    pub DeviceExtension: PVOID,
    pub DeviceType: ULONG,
    pub StackSize: CCHAR,
    pub Queue: _DEVICE_OBJECT__bindgen_ty_1,
    pub AlignmentRequirement: ULONG,
    pub DeviceQueue: KDEVICE_QUEUE,
    pub Dpc: KDPC,
    pub ActiveThreadCount: ULONG,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
    pub DeviceLock: KEVENT,
    pub SectorSize: USHORT,
    pub Spare1: USHORT,
    pub DeviceObjectExtension: *mut _DEVOBJ_EXTENSION,
    pub Reserved: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DEVICE_OBJECT__bindgen_ty_1 {
    pub ListEntry: LIST_ENTRY,
    pub Wcb: WAIT_CONTEXT_BLOCK,
}
pub type DEVICE_OBJECT = _DEVICE_OBJECT;
pub type PDEVICE_OBJECT = *mut _DEVICE_OBJECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_OBJECT_POWER_EXTENSION {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVOBJ_EXTENSION {
    pub Type: CSHORT,
    pub Size: USHORT,
    pub DeviceObject: PDEVICE_OBJECT,
    pub PowerFlags: ULONG,
    pub Dope: *mut _DEVICE_OBJECT_POWER_EXTENSION,
    pub ExtensionFlags: ULONG,
    pub DeviceNode: PVOID,
    pub AttachedTo: PDEVICE_OBJECT,
    pub StartIoCount: LONG,
    pub StartIoKey: LONG,
    pub StartIoFlags: ULONG,
    pub Vpb: PVPB,
    pub DependencyNode: PVOID,
    pub InterruptContext: PVOID,
    pub InterruptCount: LONG,
    pub VerifierContext: PVOID,
}
pub type DEVOBJ_EXTENSION = _DEVOBJ_EXTENSION;
pub type PDEVOBJ_EXTENSION = *mut _DEVOBJ_EXTENSION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVER_EXTENSION {
    pub DriverObject: *mut _DRIVER_OBJECT,
    pub AddDevice: PDRIVER_ADD_DEVICE,
    pub Count: ULONG,
    pub ServiceKeyName: UNICODE_STRING,
}
pub type DRIVER_EXTENSION = _DRIVER_EXTENSION;
pub type PDRIVER_EXTENSION = *mut _DRIVER_EXTENSION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVER_OBJECT {
    pub Type: CSHORT,
    pub Size: CSHORT,
    pub DeviceObject: PDEVICE_OBJECT,
    pub Flags: ULONG,
    pub DriverStart: PVOID,
    pub DriverSize: ULONG,
    pub DriverSection: PVOID,
    pub DriverExtension: PDRIVER_EXTENSION,
    pub DriverName: UNICODE_STRING,
    pub HardwareDatabase: PUNICODE_STRING,
    pub FastIoDispatch: PFAST_IO_DISPATCH,
    pub DriverInit: PDRIVER_INITIALIZE,
    pub DriverStartIo: PDRIVER_STARTIO,
    pub DriverUnload: PDRIVER_UNLOAD,
    pub MajorFunction: [PDRIVER_DISPATCH; 28usize],
}
pub type DRIVER_OBJECT = _DRIVER_OBJECT;
pub type PDRIVER_OBJECT = *mut _DRIVER_OBJECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECTION_OBJECT_POINTERS {
    pub DataSectionObject: PVOID,
    pub SharedCacheMap: PVOID,
    pub ImageSectionObject: PVOID,
}
pub type SECTION_OBJECT_POINTERS = _SECTION_OBJECT_POINTERS;
pub type PSECTION_OBJECT_POINTERS = *mut SECTION_OBJECT_POINTERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_COMPLETION_CONTEXT {
    pub Port: PVOID,
    pub Key: PVOID,
    pub UsageCount: LONG_PTR,
}
pub type IO_COMPLETION_CONTEXT = _IO_COMPLETION_CONTEXT;
pub type PIO_COMPLETION_CONTEXT = *mut _IO_COMPLETION_CONTEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_OBJECT {
    pub Type: CSHORT,
    pub Size: CSHORT,
    pub DeviceObject: PDEVICE_OBJECT,
    pub Vpb: PVPB,
    pub FsContext: PVOID,
    pub FsContext2: PVOID,
    pub SectionObjectPointer: PSECTION_OBJECT_POINTERS,
    pub PrivateCacheMap: PVOID,
    pub FinalStatus: NTSTATUS,
    pub RelatedFileObject: *mut _FILE_OBJECT,
    pub LockOperation: BOOLEAN,
    pub DeletePending: BOOLEAN,
    pub ReadAccess: BOOLEAN,
    pub WriteAccess: BOOLEAN,
    pub DeleteAccess: BOOLEAN,
    pub SharedRead: BOOLEAN,
    pub SharedWrite: BOOLEAN,
    pub SharedDelete: BOOLEAN,
    pub Flags: ULONG,
    pub FileName: UNICODE_STRING,
    pub CurrentByteOffset: LARGE_INTEGER,
    pub Waiters: ULONG,
    pub Busy: ULONG,
    pub LastLock: PVOID,
    pub Lock: KEVENT,
    pub Event: KEVENT,
    pub CompletionContext: PIO_COMPLETION_CONTEXT,
    pub IrpListLock: KSPIN_LOCK,
    pub IrpList: LIST_ENTRY,
    pub FileObjectExtension: PVOID,
}
pub type FILE_OBJECT = _FILE_OBJECT;
pub type PFILE_OBJECT = *mut _FILE_OBJECT;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _IRP {
    pub Type: CSHORT,
    pub Size: USHORT,
    pub MdlAddress: PMDL,
    pub Flags: ULONG,
    pub AssociatedIrp: _IRP__bindgen_ty_1,
    pub ThreadListEntry: LIST_ENTRY,
    pub IoStatus: IO_STATUS_BLOCK,
    pub RequestorMode: KPROCESSOR_MODE,
    pub PendingReturned: BOOLEAN,
    pub StackCount: CHAR,
    pub CurrentLocation: CHAR,
    pub Cancel: BOOLEAN,
    pub CancelIrql: KIRQL,
    pub ApcEnvironment: CCHAR,
    pub AllocationFlags: UCHAR,
    pub __bindgen_anon_1: _IRP__bindgen_ty_2,
    pub UserEvent: PKEVENT,
    pub Overlay: _IRP__bindgen_ty_3,
    pub CancelRoutine: PDRIVER_CANCEL,
    pub UserBuffer: PVOID,
    pub Tail: _IRP__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_1 {
    pub MasterIrp: *mut _IRP,
    pub IrpCount: LONG,
    pub SystemBuffer: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_2 {
    pub UserIosb: PIO_STATUS_BLOCK,
    pub IoRingContext: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_3 {
    pub AsynchronousParameters: _IRP__bindgen_ty_3__bindgen_ty_1,
    pub AllocationSize: LARGE_INTEGER,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP__bindgen_ty_3__bindgen_ty_1 {
    pub __bindgen_anon_1: _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    pub UserApcRoutine: PIO_APC_ROUTINE,
    pub IssuingProcess: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2 {
    pub UserApcContext: PVOID,
    pub IoRing: *mut _IORING_OBJECT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_4 {
    pub Overlay: _IRP__bindgen_ty_4__bindgen_ty_1,
    pub Apc: KAPC,
    pub CompletionKey: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP__bindgen_ty_4__bindgen_ty_1 {
    pub __bindgen_anon_1: _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
    pub Thread: PETHREAD,
    pub AuxiliaryBuffer: PCHAR,
    pub __bindgen_anon_2: _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2,
    pub OriginalFileObject: PFILE_OBJECT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    pub DeviceQueueEntry: KDEVICE_QUEUE_ENTRY,
    pub __bindgen_anon_1: _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub DriverContext: [PVOID; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2 {
    pub ListEntry: LIST_ENTRY,
    pub __bindgen_anon_1: _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub CurrentStackLocation: *mut _IO_STACK_LOCATION,
    pub PacketType: ULONG,
}
pub type IRP = _IRP;
pub type PIRP = *mut IRP;
pub type IO_COMPLETION_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(DeviceObject: PDEVICE_OBJECT, Irp: PIRP, Context: PVOID) -> NTSTATUS,
>;
pub type PIO_COMPLETION_ROUTINE = IO_COMPLETION_ROUTINE;
pub const _DEVICE_RELATION_TYPE_BusRelations: _DEVICE_RELATION_TYPE = 0;
pub const _DEVICE_RELATION_TYPE_EjectionRelations: _DEVICE_RELATION_TYPE = 1;
pub const _DEVICE_RELATION_TYPE_PowerRelations: _DEVICE_RELATION_TYPE = 2;
pub const _DEVICE_RELATION_TYPE_RemovalRelations: _DEVICE_RELATION_TYPE = 3;
pub const _DEVICE_RELATION_TYPE_TargetDeviceRelation: _DEVICE_RELATION_TYPE = 4;
pub const _DEVICE_RELATION_TYPE_SingleBusRelations: _DEVICE_RELATION_TYPE = 5;
pub const _DEVICE_RELATION_TYPE_TransportRelations: _DEVICE_RELATION_TYPE = 6;
pub type _DEVICE_RELATION_TYPE = core::ffi::c_int;
pub use self::_DEVICE_RELATION_TYPE as DEVICE_RELATION_TYPE;
pub type PDEVICE_RELATION_TYPE = *mut _DEVICE_RELATION_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_RELATIONS {
    pub Count: ULONG,
    pub Objects: [PDEVICE_OBJECT; 1usize],
}
pub type DEVICE_RELATIONS = _DEVICE_RELATIONS;
pub type PDEVICE_RELATIONS = *mut _DEVICE_RELATIONS;
pub const _DEVICE_USAGE_NOTIFICATION_TYPE_DeviceUsageTypeUndefined:
_DEVICE_USAGE_NOTIFICATION_TYPE = 0;
pub const _DEVICE_USAGE_NOTIFICATION_TYPE_DeviceUsageTypePaging: _DEVICE_USAGE_NOTIFICATION_TYPE =
    1;
pub const _DEVICE_USAGE_NOTIFICATION_TYPE_DeviceUsageTypeHibernation:
_DEVICE_USAGE_NOTIFICATION_TYPE = 2;
pub const _DEVICE_USAGE_NOTIFICATION_TYPE_DeviceUsageTypeDumpFile: _DEVICE_USAGE_NOTIFICATION_TYPE =
    3;
pub const _DEVICE_USAGE_NOTIFICATION_TYPE_DeviceUsageTypeBoot: _DEVICE_USAGE_NOTIFICATION_TYPE = 4;
pub const _DEVICE_USAGE_NOTIFICATION_TYPE_DeviceUsageTypePostDisplay:
_DEVICE_USAGE_NOTIFICATION_TYPE = 5;
pub const _DEVICE_USAGE_NOTIFICATION_TYPE_DeviceUsageTypeGuestAssigned:
_DEVICE_USAGE_NOTIFICATION_TYPE = 6;
pub type _DEVICE_USAGE_NOTIFICATION_TYPE = core::ffi::c_int;
pub use self::_DEVICE_USAGE_NOTIFICATION_TYPE as DEVICE_USAGE_NOTIFICATION_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
}
pub type INTERFACE = _INTERFACE;
pub type PINTERFACE = *mut _INTERFACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_CAPABILITIES {
    pub Size: USHORT,
    pub Version: USHORT,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub Address: ULONG,
    pub UINumber: ULONG,
    pub DeviceState: [DEVICE_POWER_STATE; 7usize],
    pub SystemWake: SYSTEM_POWER_STATE,
    pub DeviceWake: DEVICE_POWER_STATE,
    pub D1Latency: ULONG,
    pub D2Latency: ULONG,
    pub D3Latency: ULONG,
}
impl _DEVICE_CAPABILITIES {
    #[inline]
    pub fn DeviceD1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeviceD1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DeviceD1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DeviceD1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DeviceD2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeviceD2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DeviceD2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DeviceD2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LockSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LockSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LockSupported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_LockSupported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EjectSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EjectSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EjectSupported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_EjectSupported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Removable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Removable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Removable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Removable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DockDevice(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DockDevice(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DockDevice_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DockDevice_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UniqueID(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UniqueID(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UniqueID_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UniqueID_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SilentInstall(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SilentInstall(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SilentInstall_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SilentInstall_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RawDeviceOK(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RawDeviceOK(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RawDeviceOK_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RawDeviceOK_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SurpriseRemovalOK(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SurpriseRemovalOK(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SurpriseRemovalOK_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SurpriseRemovalOK_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn WakeFromD0(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeFromD0(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn WakeFromD0_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_WakeFromD0_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn WakeFromD1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeFromD1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn WakeFromD1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_WakeFromD1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn WakeFromD2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeFromD2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn WakeFromD2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_WakeFromD2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn WakeFromD3(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeFromD3(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn WakeFromD3_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_WakeFromD3_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn HardwareDisabled(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HardwareDisabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn HardwareDisabled_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_HardwareDisabled_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NonDynamic(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NonDynamic(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NonDynamic_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NonDynamic_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn WarmEjectSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WarmEjectSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn WarmEjectSupported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_WarmEjectSupported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NoDisplayInUI(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoDisplayInUI(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NoDisplayInUI_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NoDisplayInUI_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn WakeFromInterrupt(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeFromInterrupt(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn WakeFromInterrupt_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_WakeFromInterrupt_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SecureDevice(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SecureDevice(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SecureDevice_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SecureDevice_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ChildOfVgaEnabledBridge(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ChildOfVgaEnabledBridge(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ChildOfVgaEnabledBridge_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ChildOfVgaEnabledBridge_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DecodeIoOnBoot(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DecodeIoOnBoot(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DecodeIoOnBoot_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DecodeIoOnBoot_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                9u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                9u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DeviceD1: ULONG,
        DeviceD2: ULONG,
        LockSupported: ULONG,
        EjectSupported: ULONG,
        Removable: ULONG,
        DockDevice: ULONG,
        UniqueID: ULONG,
        SilentInstall: ULONG,
        RawDeviceOK: ULONG,
        SurpriseRemovalOK: ULONG,
        WakeFromD0: ULONG,
        WakeFromD1: ULONG,
        WakeFromD2: ULONG,
        WakeFromD3: ULONG,
        HardwareDisabled: ULONG,
        NonDynamic: ULONG,
        WarmEjectSupported: ULONG,
        NoDisplayInUI: ULONG,
        Reserved1: ULONG,
        WakeFromInterrupt: ULONG,
        SecureDevice: ULONG,
        ChildOfVgaEnabledBridge: ULONG,
        DecodeIoOnBoot: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DeviceD1: u32 = unsafe { ::core::mem::transmute(DeviceD1) };
            DeviceD1 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DeviceD2: u32 = unsafe { ::core::mem::transmute(DeviceD2) };
            DeviceD2 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let LockSupported: u32 = unsafe { ::core::mem::transmute(LockSupported) };
            LockSupported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let EjectSupported: u32 = unsafe { ::core::mem::transmute(EjectSupported) };
            EjectSupported as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Removable: u32 = unsafe { ::core::mem::transmute(Removable) };
            Removable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DockDevice: u32 = unsafe { ::core::mem::transmute(DockDevice) };
            DockDevice as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let UniqueID: u32 = unsafe { ::core::mem::transmute(UniqueID) };
            UniqueID as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SilentInstall: u32 = unsafe { ::core::mem::transmute(SilentInstall) };
            SilentInstall as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let RawDeviceOK: u32 = unsafe { ::core::mem::transmute(RawDeviceOK) };
            RawDeviceOK as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let SurpriseRemovalOK: u32 = unsafe { ::core::mem::transmute(SurpriseRemovalOK) };
            SurpriseRemovalOK as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let WakeFromD0: u32 = unsafe { ::core::mem::transmute(WakeFromD0) };
            WakeFromD0 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let WakeFromD1: u32 = unsafe { ::core::mem::transmute(WakeFromD1) };
            WakeFromD1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let WakeFromD2: u32 = unsafe { ::core::mem::transmute(WakeFromD2) };
            WakeFromD2 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let WakeFromD3: u32 = unsafe { ::core::mem::transmute(WakeFromD3) };
            WakeFromD3 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let HardwareDisabled: u32 = unsafe { ::core::mem::transmute(HardwareDisabled) };
            HardwareDisabled as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let NonDynamic: u32 = unsafe { ::core::mem::transmute(NonDynamic) };
            NonDynamic as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let WarmEjectSupported: u32 = unsafe { ::core::mem::transmute(WarmEjectSupported) };
            WarmEjectSupported as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let NoDisplayInUI: u32 = unsafe { ::core::mem::transmute(NoDisplayInUI) };
            NoDisplayInUI as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let WakeFromInterrupt: u32 = unsafe { ::core::mem::transmute(WakeFromInterrupt) };
            WakeFromInterrupt as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let SecureDevice: u32 = unsafe { ::core::mem::transmute(SecureDevice) };
            SecureDevice as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let ChildOfVgaEnabledBridge: u32 =
                unsafe { ::core::mem::transmute(ChildOfVgaEnabledBridge) };
            ChildOfVgaEnabledBridge as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let DecodeIoOnBoot: u32 = unsafe { ::core::mem::transmute(DecodeIoOnBoot) };
            DecodeIoOnBoot as u64
        });
        __bindgen_bitfield_unit.set(23usize, 9u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type DEVICE_CAPABILITIES = _DEVICE_CAPABILITIES;
pub type PDEVICE_CAPABILITIES = *mut _DEVICE_CAPABILITIES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_SEQUENCE {
    pub SequenceD1: ULONG,
    pub SequenceD2: ULONG,
    pub SequenceD3: ULONG,
}
pub type POWER_SEQUENCE = _POWER_SEQUENCE;
pub type PPOWER_SEQUENCE = *mut _POWER_SEQUENCE;
pub const BUS_QUERY_ID_TYPE_BusQueryDeviceID: BUS_QUERY_ID_TYPE = 0;
pub const BUS_QUERY_ID_TYPE_BusQueryHardwareIDs: BUS_QUERY_ID_TYPE = 1;
pub const BUS_QUERY_ID_TYPE_BusQueryCompatibleIDs: BUS_QUERY_ID_TYPE = 2;
pub const BUS_QUERY_ID_TYPE_BusQueryInstanceID: BUS_QUERY_ID_TYPE = 3;
pub const BUS_QUERY_ID_TYPE_BusQueryDeviceSerialNumber: BUS_QUERY_ID_TYPE = 4;
pub const BUS_QUERY_ID_TYPE_BusQueryContainerID: BUS_QUERY_ID_TYPE = 5;
pub type BUS_QUERY_ID_TYPE = core::ffi::c_int;
pub type PBUS_QUERY_ID_TYPE = *mut BUS_QUERY_ID_TYPE;
pub type PNP_DEVICE_STATE = ULONG;
pub type PPNP_DEVICE_STATE = *mut ULONG;
pub const DEVICE_TEXT_TYPE_DeviceTextDescription: DEVICE_TEXT_TYPE = 0;
pub const DEVICE_TEXT_TYPE_DeviceTextLocationInformation: DEVICE_TEXT_TYPE = 1;
pub type DEVICE_TEXT_TYPE = core::ffi::c_int;
pub type PDEVICE_TEXT_TYPE = *mut DEVICE_TEXT_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION {
    pub MajorFunction: UCHAR,
    pub MinorFunction: UCHAR,
    pub Flags: UCHAR,
    pub Control: UCHAR,
    pub Parameters: _IO_STACK_LOCATION__bindgen_ty_1,
    pub DeviceObject: PDEVICE_OBJECT,
    pub FileObject: PFILE_OBJECT,
    pub CompletionRoutine: PIO_COMPLETION_ROUTINE,
    pub Context: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STACK_LOCATION__bindgen_ty_1 {
    pub Create: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1,
    pub CreatePipe: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2,
    pub CreateMailslot: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3,
    pub Read: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4,
    pub Write: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5,
    pub QueryDirectory: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6,
    pub NotifyDirectory: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7,
    pub NotifyDirectoryEx: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8,
    pub QueryFile: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9,
    pub SetFile: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10,
    pub QueryEa: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11,
    pub SetEa: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12,
    pub QueryVolume: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13,
    pub SetVolume: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14,
    pub FileSystemControl: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15,
    pub LockControl: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16,
    pub DeviceIoControl: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17,
    pub QuerySecurity: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18,
    pub SetSecurity: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19,
    pub MountVolume: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20,
    pub VerifyVolume: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21,
    pub Scsi: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22,
    pub QueryQuota: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23,
    pub SetQuota: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24,
    pub QueryDeviceRelations: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25,
    pub QueryInterface: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26,
    pub DeviceCapabilities: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27,
    pub FilterResourceRequirements: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28,
    pub ReadWriteConfig: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29,
    pub SetLock: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30,
    pub QueryId: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31,
    pub QueryDeviceText: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32,
    pub UsageNotification: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33,
    pub WaitWake: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34,
    pub PowerSequence: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35,
    pub Power: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36,
    pub StartDevice: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37,
    pub WMI: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38,
    pub Others: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1 {
    pub SecurityContext: PIO_SECURITY_CONTEXT,
    pub Options: ULONG,
    pub __bindgen_padding_0: [u16; 2usize],
    pub FileAttributes: USHORT,
    pub ShareAccess: USHORT,
    pub __bindgen_padding_1: u32,
    pub EaLength: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2 {
    pub SecurityContext: PIO_SECURITY_CONTEXT,
    pub Options: ULONG,
    pub __bindgen_padding_0: [u16; 2usize],
    pub Reserved: USHORT,
    pub ShareAccess: USHORT,
    pub Parameters: PNAMED_PIPE_CREATE_PARAMETERS,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3 {
    pub SecurityContext: PIO_SECURITY_CONTEXT,
    pub Options: ULONG,
    pub __bindgen_padding_0: [u16; 2usize],
    pub Reserved: USHORT,
    pub ShareAccess: USHORT,
    pub Parameters: PMAILSLOT_CREATE_PARAMETERS,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub Key: ULONG,
    pub Flags: ULONG,
    pub ByteOffset: LARGE_INTEGER,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub Key: ULONG,
    pub Flags: ULONG,
    pub ByteOffset: LARGE_INTEGER,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6 {
    pub Length: ULONG,
    pub FileName: PUNICODE_STRING,
    pub FileInformationClass: FILE_INFORMATION_CLASS,
    pub __bindgen_padding_0: u32,
    pub FileIndex: ULONG,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub CompletionFilter: ULONG,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub CompletionFilter: ULONG,
    pub __bindgen_padding_1: u32,
    pub DirectoryNotifyInformationClass: DIRECTORY_NOTIFY_INFORMATION_CLASS,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub FileInformationClass: FILE_INFORMATION_CLASS,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub FileInformationClass: FILE_INFORMATION_CLASS,
    pub FileObject: PFILE_OBJECT,
    pub __bindgen_anon_1: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1 {
    pub __bindgen_anon_1:
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1__bindgen_ty_1,
    pub ClusterCount: ULONG,
    pub DeleteHandle: HANDLE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1__bindgen_ty_1 {
    pub ReplaceIfExists: BOOLEAN,
    pub AdvanceOnly: BOOLEAN,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11 {
    pub Length: ULONG,
    pub EaList: PVOID,
    pub EaListLength: ULONG,
    pub __bindgen_padding_0: u32,
    pub EaIndex: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12 {
    pub Length: ULONG,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub FsInformationClass: FS_INFORMATION_CLASS,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub FsInformationClass: FS_INFORMATION_CLASS,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15 {
    pub OutputBufferLength: ULONG,
    pub __bindgen_padding_0: u32,
    pub InputBufferLength: ULONG,
    pub __bindgen_padding_1: u32,
    pub FsControlCode: ULONG,
    pub Type3InputBuffer: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16 {
    pub Length: PLARGE_INTEGER,
    pub Key: ULONG,
    pub ByteOffset: LARGE_INTEGER,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17 {
    pub OutputBufferLength: ULONG,
    pub __bindgen_padding_0: u32,
    pub InputBufferLength: ULONG,
    pub __bindgen_padding_1: u32,
    pub IoControlCode: ULONG,
    pub Type3InputBuffer: PVOID,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18 {
    pub SecurityInformation: SECURITY_INFORMATION,
    pub __bindgen_padding_0: u32,
    pub Length: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19 {
    pub SecurityInformation: SECURITY_INFORMATION,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20 {
    pub Vpb: PVPB,
    pub DeviceObject: PDEVICE_OBJECT,
    pub OutputBufferLength: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21 {
    pub Vpb: PVPB,
    pub DeviceObject: PDEVICE_OBJECT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22 {
    pub Srb: *mut _SCSI_REQUEST_BLOCK,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23 {
    pub Length: ULONG,
    pub StartSid: PSID,
    pub SidList: PFILE_GET_QUOTA_INFORMATION,
    pub SidListLength: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24 {
    pub Length: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25 {
    pub Type: DEVICE_RELATION_TYPE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26 {
    pub InterfaceType: *const GUID,
    pub Size: USHORT,
    pub Version: USHORT,
    pub Interface: PINTERFACE,
    pub InterfaceSpecificData: PVOID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27 {
    pub Capabilities: PDEVICE_CAPABILITIES,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28 {
    pub IoResourceRequirementList: PIO_RESOURCE_REQUIREMENTS_LIST,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29 {
    pub WhichSpace: ULONG,
    pub Buffer: PVOID,
    pub Offset: ULONG,
    pub __bindgen_padding_0: u32,
    pub Length: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30 {
    pub Lock: BOOLEAN,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31 {
    pub IdType: BUS_QUERY_ID_TYPE,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32 {
    pub DeviceTextType: DEVICE_TEXT_TYPE,
    pub __bindgen_padding_0: u32,
    pub LocaleId: LCID,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33 {
    pub InPath: BOOLEAN,
    pub Reserved: [BOOLEAN; 3usize],
    pub __bindgen_padding_0: u32,
    pub Type: DEVICE_USAGE_NOTIFICATION_TYPE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34 {
    pub PowerState: SYSTEM_POWER_STATE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35 {
    pub PowerSequence: PPOWER_SEQUENCE,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36 {
    pub __bindgen_anon_1: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1,
    pub __bindgen_padding_0: u32,
    pub Type: POWER_STATE_TYPE,
    pub __bindgen_padding_1: u32,
    pub State: POWER_STATE,
    pub __bindgen_padding_2: u32,
    pub ShutdownType: POWER_ACTION,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1 {
    pub SystemContext: ULONG,
    pub SystemPowerStateContext: SYSTEM_POWER_STATE_CONTEXT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37 {
    pub AllocatedResources: PCM_RESOURCE_LIST,
    pub AllocatedResourcesTranslated: PCM_RESOURCE_LIST,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38 {
    pub ProviderId: ULONG_PTR,
    pub DataPath: PVOID,
    pub BufferSize: ULONG,
    pub Buffer: PVOID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39 {
    pub Argument1: PVOID,
    pub Argument2: PVOID,
    pub Argument3: PVOID,
    pub Argument4: PVOID,
}
pub type IO_STACK_LOCATION = _IO_STACK_LOCATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHARE_ACCESS {
    pub OpenCount: ULONG,
    pub Readers: ULONG,
    pub Writers: ULONG,
    pub Deleters: ULONG,
    pub SharedRead: ULONG,
    pub SharedWrite: ULONG,
    pub SharedDelete: ULONG,
}
pub type SHARE_ACCESS = _SHARE_ACCESS;
pub type PSHARE_ACCESS = *mut _SHARE_ACCESS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LINK_SHARE_ACCESS {
    pub OpenCount: ULONG,
    pub Deleters: ULONG,
    pub SharedDelete: ULONG,
}
pub type LINK_SHARE_ACCESS = _LINK_SHARE_ACCESS;
pub type PLINK_SHARE_ACCESS = *mut _LINK_SHARE_ACCESS;
unsafe extern "C" {
    pub fn IoAcquireCancelSpinLock(Irql: PKIRQL);
}
unsafe extern "C" {
    pub fn IoAllocateDriverObjectExtension(
        DriverObject: PDRIVER_OBJECT,
        ClientIdentificationAddress: PVOID,
        DriverObjectExtensionSize: ULONG,
        DriverObjectExtension: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoAllocateErrorLogEntry(IoObject: PVOID, EntrySize: UCHAR) -> PVOID;
}
unsafe extern "C" {
    pub fn IoAllocateIrp(StackSize: CCHAR, ChargeQuota: BOOLEAN) -> PIRP;
}
unsafe extern "C" {
    pub fn IoAllocateIrpEx(
        DeviceObject: PDEVICE_OBJECT,
        StackSize: CCHAR,
        ChargeQuota: BOOLEAN,
    ) -> PIRP;
}
unsafe extern "C" {
    pub fn IoAllocateMdl(
        VirtualAddress: PVOID,
        Length: ULONG,
        SecondaryBuffer: BOOLEAN,
        ChargeQuota: BOOLEAN,
        Irp: PIRP,
    ) -> PMDL;
}
pub const _IO_PAGING_PRIORITY_IoPagingPriorityInvalid: _IO_PAGING_PRIORITY = 0;
pub const _IO_PAGING_PRIORITY_IoPagingPriorityNormal: _IO_PAGING_PRIORITY = 1;
pub const _IO_PAGING_PRIORITY_IoPagingPriorityHigh: _IO_PAGING_PRIORITY = 2;
pub const _IO_PAGING_PRIORITY_IoPagingPriorityReserved1: _IO_PAGING_PRIORITY = 3;
pub const _IO_PAGING_PRIORITY_IoPagingPriorityReserved2: _IO_PAGING_PRIORITY = 4;
pub type _IO_PAGING_PRIORITY = core::ffi::c_int;
pub use self::_IO_PAGING_PRIORITY as IO_PAGING_PRIORITY;
unsafe extern "C" {
    pub fn IoAttachDevice(
        SourceDevice: PDEVICE_OBJECT,
        TargetDevice: PUNICODE_STRING,
        AttachedDevice: *mut PDEVICE_OBJECT,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoAttachDeviceToDeviceStack(
        SourceDevice: PDEVICE_OBJECT,
        TargetDevice: PDEVICE_OBJECT,
    ) -> PDEVICE_OBJECT;
}
unsafe extern "C" {
    pub fn IoBuildAsynchronousFsdRequest(
        MajorFunction: ULONG,
        DeviceObject: PDEVICE_OBJECT,
        Buffer: PVOID,
        Length: ULONG,
        StartingOffset: PLARGE_INTEGER,
        IoStatusBlock: PIO_STATUS_BLOCK,
    ) -> PIRP;
}
unsafe extern "C" {
    pub fn IoBuildDeviceIoControlRequest(
        IoControlCode: ULONG,
        DeviceObject: PDEVICE_OBJECT,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
        InternalDeviceIoControl: BOOLEAN,
        Event: PKEVENT,
        IoStatusBlock: PIO_STATUS_BLOCK,
    ) -> PIRP;
}
unsafe extern "C" {
    pub fn IoBuildPartialMdl(
        SourceMdl: PMDL,
        TargetMdl: PMDL,
        VirtualAddress: PVOID,
        Length: ULONG,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BOOTDISK_INFORMATION {
    pub BootPartitionOffset: LONGLONG,
    pub SystemPartitionOffset: LONGLONG,
    pub BootDeviceSignature: ULONG,
    pub SystemDeviceSignature: ULONG,
}
pub type BOOTDISK_INFORMATION = _BOOTDISK_INFORMATION;
pub type PBOOTDISK_INFORMATION = *mut _BOOTDISK_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BOOTDISK_INFORMATION_EX {
    pub BootPartitionOffset: LONGLONG,
    pub SystemPartitionOffset: LONGLONG,
    pub BootDeviceSignature: ULONG,
    pub SystemDeviceSignature: ULONG,
    pub BootDeviceGuid: GUID,
    pub SystemDeviceGuid: GUID,
    pub BootDeviceIsGpt: BOOLEAN,
    pub SystemDeviceIsGpt: BOOLEAN,
}
pub type BOOTDISK_INFORMATION_EX = _BOOTDISK_INFORMATION_EX;
pub type PBOOTDISK_INFORMATION_EX = *mut _BOOTDISK_INFORMATION_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LOADER_PARTITION_INFORMATION_EX {
    pub PartitionStyle: ULONG,
    pub PartitionNumber: ULONG,
    pub __bindgen_anon_1: _LOADER_PARTITION_INFORMATION_EX__bindgen_ty_1,
    pub Flags: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LOADER_PARTITION_INFORMATION_EX__bindgen_ty_1 {
    pub Signature: ULONG,
    pub DeviceId: GUID,
}
pub type LOADER_PARTITION_INFORMATION_EX = _LOADER_PARTITION_INFORMATION_EX;
pub type PLOADER_PARTITION_INFORMATION_EX = *mut _LOADER_PARTITION_INFORMATION_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _BOOTDISK_INFORMATION_LITE {
    pub NumberEntries: ULONG,
    pub Entries: [LOADER_PARTITION_INFORMATION_EX; 1usize],
}
pub type BOOTDISK_INFORMATION_LITE = _BOOTDISK_INFORMATION_LITE;
pub type PBOOTDISK_INFORMATION_LITE = *mut _BOOTDISK_INFORMATION_LITE;
unsafe extern "C" {
    pub fn IoGetBootDiskInformation(
        BootDiskInformation: PBOOTDISK_INFORMATION,
        Size: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoGetBootDiskInformationLite(
        BootDiskInformation: *mut PBOOTDISK_INFORMATION_LITE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoBuildSynchronousFsdRequest(
        MajorFunction: ULONG,
        DeviceObject: PDEVICE_OBJECT,
        Buffer: PVOID,
        Length: ULONG,
        StartingOffset: PLARGE_INTEGER,
        Event: PKEVENT,
        IoStatusBlock: PIO_STATUS_BLOCK,
    ) -> PIRP;
}
unsafe extern "C" {
    pub fn IofCallDriver(DeviceObject: PDEVICE_OBJECT, Irp: PIRP) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoCancelIrp(Irp: PIRP) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn IoCheckShareAccess(
        DesiredAccess: ACCESS_MASK,
        DesiredShareAccess: ULONG,
        FileObject: PFILE_OBJECT,
        ShareAccess: PSHARE_ACCESS,
        Update: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoCheckShareAccessEx(
        DesiredAccess: ACCESS_MASK,
        DesiredShareAccess: ULONG,
        FileObject: PFILE_OBJECT,
        ShareAccess: PSHARE_ACCESS,
        Update: BOOLEAN,
        WritePermission: PBOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoCheckLinkShareAccess(
        DesiredAccess: ACCESS_MASK,
        DesiredShareAccess: ULONG,
        FileObject: PFILE_OBJECT,
        ShareAccess: PSHARE_ACCESS,
        LinkShareAccess: PLINK_SHARE_ACCESS,
        IoShareAccessFlags: ULONG,
    ) -> NTSTATUS;
}
pub const _IO_COMPLETION_ROUTINE_RESULT_ContinueCompletion: _IO_COMPLETION_ROUTINE_RESULT = 0;
pub const _IO_COMPLETION_ROUTINE_RESULT_StopCompletion: _IO_COMPLETION_ROUTINE_RESULT = -1073741802;
pub type _IO_COMPLETION_ROUTINE_RESULT = core::ffi::c_int;
pub use self::_IO_COMPLETION_ROUTINE_RESULT as IO_COMPLETION_ROUTINE_RESULT;
pub type PIO_COMPLETION_ROUTINE_RESULT = *mut _IO_COMPLETION_ROUTINE_RESULT;
unsafe extern "C" {
    pub fn IofCompleteRequest(Irp: PIRP, PriorityBoost: CCHAR);
}
unsafe extern "C" {
    pub fn IoConnectInterrupt(
        InterruptObject: *mut PKINTERRUPT,
        ServiceRoutine: PKSERVICE_ROUTINE,
        ServiceContext: PVOID,
        SpinLock: PKSPIN_LOCK,
        Vector: ULONG,
        Irql: KIRQL,
        SynchronizeIrql: KIRQL,
        InterruptMode: KINTERRUPT_MODE,
        ShareVector: BOOLEAN,
        ProcessorEnableMask: KAFFINITY,
        FloatingSave: BOOLEAN,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_INTERRUPT_MESSAGE_INFO_ENTRY {
    pub MessageAddress: PHYSICAL_ADDRESS,
    pub TargetProcessorSet: KAFFINITY,
    pub InterruptObject: PKINTERRUPT,
    pub MessageData: ULONG,
    pub Vector: ULONG,
    pub Irql: KIRQL,
    pub Mode: KINTERRUPT_MODE,
    pub Polarity: KINTERRUPT_POLARITY,
}
pub type IO_INTERRUPT_MESSAGE_INFO_ENTRY = _IO_INTERRUPT_MESSAGE_INFO_ENTRY;
pub type PIO_INTERRUPT_MESSAGE_INFO_ENTRY = *mut _IO_INTERRUPT_MESSAGE_INFO_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_INTERRUPT_MESSAGE_INFO {
    pub UnifiedIrql: KIRQL,
    pub MessageCount: ULONG,
    pub MessageInfo: [IO_INTERRUPT_MESSAGE_INFO_ENTRY; 1usize],
}
pub type IO_INTERRUPT_MESSAGE_INFO = _IO_INTERRUPT_MESSAGE_INFO;
pub type PIO_INTERRUPT_MESSAGE_INFO = *mut _IO_INTERRUPT_MESSAGE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS {
    pub PhysicalDeviceObject: PDEVICE_OBJECT,
    pub InterruptObject: *mut PKINTERRUPT,
    pub ServiceRoutine: PKSERVICE_ROUTINE,
    pub ServiceContext: PVOID,
    pub SpinLock: PKSPIN_LOCK,
    pub SynchronizeIrql: KIRQL,
    pub FloatingSave: BOOLEAN,
    pub ShareVector: BOOLEAN,
    pub Vector: ULONG,
    pub Irql: KIRQL,
    pub InterruptMode: KINTERRUPT_MODE,
    pub ProcessorEnableMask: KAFFINITY,
    pub Group: USHORT,
}
pub type IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS =
_IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS;
pub type PIO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS =
*mut _IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS {
    pub PhysicalDeviceObject: PDEVICE_OBJECT,
    pub InterruptObject: *mut PKINTERRUPT,
    pub ServiceRoutine: PKSERVICE_ROUTINE,
    pub ServiceContext: PVOID,
    pub SpinLock: PKSPIN_LOCK,
    pub SynchronizeIrql: KIRQL,
    pub FloatingSave: BOOLEAN,
}
pub type IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS = _IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS;
pub type PIO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS =
*mut _IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS {
    pub PhysicalDeviceObject: PDEVICE_OBJECT,
    pub ConnectionContext: _IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS__bindgen_ty_1,
    pub MessageServiceRoutine: PKMESSAGE_SERVICE_ROUTINE,
    pub ServiceContext: PVOID,
    pub SpinLock: PKSPIN_LOCK,
    pub SynchronizeIrql: KIRQL,
    pub FloatingSave: BOOLEAN,
    pub FallBackServiceRoutine: PKSERVICE_ROUTINE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS__bindgen_ty_1 {
    pub Generic: *mut PVOID,
    pub InterruptMessageTable: *mut PIO_INTERRUPT_MESSAGE_INFO,
    pub InterruptObject: *mut PKINTERRUPT,
}
pub type IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS =
_IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS;
pub type PIO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS =
*mut _IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_CONNECT_INTERRUPT_PARAMETERS {
    pub Version: ULONG,
    pub __bindgen_anon_1: _IO_CONNECT_INTERRUPT_PARAMETERS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_CONNECT_INTERRUPT_PARAMETERS__bindgen_ty_1 {
    pub FullySpecified: IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS,
    pub LineBased: IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS,
    pub MessageBased: IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS,
}
pub type IO_CONNECT_INTERRUPT_PARAMETERS = _IO_CONNECT_INTERRUPT_PARAMETERS;
pub type PIO_CONNECT_INTERRUPT_PARAMETERS = *mut _IO_CONNECT_INTERRUPT_PARAMETERS;
unsafe extern "C" {
    pub fn IoConnectInterruptEx(Parameters: PIO_CONNECT_INTERRUPT_PARAMETERS) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoCreateDevice(
        DriverObject: PDRIVER_OBJECT,
        DeviceExtensionSize: ULONG,
        DeviceName: PUNICODE_STRING,
        DeviceType: ULONG,
        DeviceCharacteristics: ULONG,
        Exclusive: BOOLEAN,
        DeviceObject: *mut PDEVICE_OBJECT,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoIsWdmVersionAvailable(MajorVersion: UCHAR, MinorVersion: UCHAR) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn IoCreateFile(
        FileHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        AllocationSize: PLARGE_INTEGER,
        FileAttributes: ULONG,
        ShareAccess: ULONG,
        Disposition: ULONG,
        CreateOptions: ULONG,
        EaBuffer: PVOID,
        EaLength: ULONG,
        CreateFileType: CREATE_FILE_TYPE,
        InternalParameters: PVOID,
        Options: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoCreateNotificationEvent(EventName: PUNICODE_STRING, EventHandle: PHANDLE) -> PKEVENT;
}
unsafe extern "C" {
    pub fn IoCreateSymbolicLink(
        SymbolicLinkName: PUNICODE_STRING,
        DeviceName: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoCreateSynchronizationEvent(
        EventName: PUNICODE_STRING,
        EventHandle: PHANDLE,
    ) -> PKEVENT;
}
unsafe extern "C" {
    pub fn IoCreateUnprotectedSymbolicLink(
        SymbolicLinkName: PUNICODE_STRING,
        DeviceName: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoDeleteDevice(DeviceObject: PDEVICE_OBJECT);
}
unsafe extern "C" {
    pub fn IoDeleteSymbolicLink(SymbolicLinkName: PUNICODE_STRING) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoDetachDevice(TargetDevice: PDEVICE_OBJECT);
}
unsafe extern "C" {
    pub fn IoDisconnectInterrupt(InterruptObject: PKINTERRUPT);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_DISCONNECT_INTERRUPT_PARAMETERS {
    pub Version: ULONG,
    pub ConnectionContext: _IO_DISCONNECT_INTERRUPT_PARAMETERS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_DISCONNECT_INTERRUPT_PARAMETERS__bindgen_ty_1 {
    pub Generic: PVOID,
    pub InterruptObject: PKINTERRUPT,
    pub InterruptMessageTable: PIO_INTERRUPT_MESSAGE_INFO,
}
pub type IO_DISCONNECT_INTERRUPT_PARAMETERS = _IO_DISCONNECT_INTERRUPT_PARAMETERS;
pub type PIO_DISCONNECT_INTERRUPT_PARAMETERS = *mut _IO_DISCONNECT_INTERRUPT_PARAMETERS;
unsafe extern "C" {
    pub fn IoDisconnectInterruptEx(Parameters: PIO_DISCONNECT_INTERRUPT_PARAMETERS);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS {
    pub Version: ULONG,
    pub ConnectionContext: _IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS__bindgen_ty_1 {
    pub Generic: PVOID,
    pub InterruptObject: PKINTERRUPT,
    pub InterruptMessageTable: PIO_INTERRUPT_MESSAGE_INFO,
}
pub type IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS = _IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS;
pub type PIO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS =
*mut _IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS;
unsafe extern "C" {
    pub fn IoReportInterruptActive(Parameters: PIO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS);
}
unsafe extern "C" {
    pub fn IoReportInterruptInactive(Parameters: PIO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS);
}
unsafe extern "C" {
    pub fn IoGetAffinityInterrupt(
        InterruptObject: PKINTERRUPT,
        GroupAffinity: PGROUP_AFFINITY,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoFreeIrp(Irp: PIRP);
}
unsafe extern "C" {
    pub fn IoFreeMdl(Mdl: PMDL);
}
unsafe extern "C" {
    pub fn IoGetAttachedDeviceReference(DeviceObject: PDEVICE_OBJECT) -> PDEVICE_OBJECT;
}
unsafe extern "C" {
    pub fn IoGetDriverObjectExtension(
        DriverObject: PDRIVER_OBJECT,
        ClientIdentificationAddress: PVOID,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn IoGetCurrentProcess() -> PEPROCESS;
}
unsafe extern "C" {
    pub fn IoGetDeviceObjectPointer(
        ObjectName: PUNICODE_STRING,
        DesiredAccess: ACCESS_MASK,
        FileObject: *mut PFILE_OBJECT,
        DeviceObject: *mut PDEVICE_OBJECT,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoGetDmaAdapter(
        PhysicalDeviceObject: PDEVICE_OBJECT,
        DeviceDescription: *mut _DEVICE_DESCRIPTION,
        NumberOfMapRegisters: PULONG,
    ) -> *mut _DMA_ADAPTER;
}
pub type DMA_IOMMU_INTERFACE = _DMA_IOMMU_INTERFACE;
pub type PDMA_IOMMU_INTERFACE = *mut _DMA_IOMMU_INTERFACE;
unsafe extern "C" {
    pub fn IoGetIommuInterface(Version: ULONG, InterfaceOut: PDMA_IOMMU_INTERFACE) -> NTSTATUS;
}
pub type DMA_IOMMU_INTERFACE_EX = _DMA_IOMMU_INTERFACE_EX;
pub type PDMA_IOMMU_INTERFACE_EX = *mut _DMA_IOMMU_INTERFACE_EX;
unsafe extern "C" {
    pub fn IoGetIommuInterfaceEx(
        Version: ULONG,
        Flags: ULONGLONG,
        InterfaceOut: PDMA_IOMMU_INTERFACE_EX,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoForwardIrpSynchronously(DeviceObject: PDEVICE_OBJECT, Irp: PIRP) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn IoSynchronousCallDriver(DeviceObject: PDEVICE_OBJECT, Irp: PIRP) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoGetInitialStack() -> PVOID;
}
unsafe extern "C" {
    pub fn IoGetStackLimits(LowLimit: PULONG_PTR, HighLimit: PULONG_PTR);
}
unsafe extern "C" {
    pub fn IoWithinStackLimits(RegionStart: ULONG_PTR, RegionSize: SIZE_T) -> LOGICAL;
}
unsafe extern "C" {
    pub fn IoGetRelatedDeviceObject(FileObject: PFILE_OBJECT) -> PDEVICE_OBJECT;
}
unsafe extern "C" {
    pub fn IoGetTopLevelIrp() -> PIRP;
}
unsafe extern "C" {
    pub fn IoInitializeIrp(Irp: PIRP, PacketSize: USHORT, StackSize: CCHAR);
}
unsafe extern "C" {
    pub fn IoCleanupIrp(Irp: PIRP);
}
unsafe extern "C" {
    pub fn IoInitializeIrpEx(
        Irp: PIRP,
        DeviceObject: PDEVICE_OBJECT,
        PacketSize: USHORT,
        StackSize: CCHAR,
    );
}
unsafe extern "C" {
    pub fn IoInitializeTimer(
        DeviceObject: PDEVICE_OBJECT,
        TimerRoutine: PIO_TIMER_ROUTINE,
        Context: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoReuseIrp(Irp: PIRP, Iostatus: NTSTATUS);
}
unsafe extern "C" {
    pub fn IoRegisterShutdownNotification(DeviceObject: PDEVICE_OBJECT) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoRegisterLastChanceShutdownNotification(DeviceObject: PDEVICE_OBJECT) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoReleaseCancelSpinLock(Irql: KIRQL);
}
unsafe extern "C" {
    pub fn IoRemoveShareAccess(FileObject: PFILE_OBJECT, ShareAccess: PSHARE_ACCESS);
}
unsafe extern "C" {
    pub fn IoRemoveLinkShareAccess(
        FileObject: PFILE_OBJECT,
        ShareAccess: PSHARE_ACCESS,
        LinkShareAccess: PLINK_SHARE_ACCESS,
    );
}
unsafe extern "C" {
    pub fn IoRemoveLinkShareAccessEx(
        FileObject: PFILE_OBJECT,
        ShareAccess: PSHARE_ACCESS,
        LinkShareAccess: PLINK_SHARE_ACCESS,
        IoShareAccessFlags: ULONG,
    );
}
unsafe extern "C" {
    pub fn IoSetCompletionRoutineEx(
        DeviceObject: PDEVICE_OBJECT,
        Irp: PIRP,
        CompletionRoutine: PIO_COMPLETION_ROUTINE,
        Context: PVOID,
        InvokeOnSuccess: BOOLEAN,
        InvokeOnError: BOOLEAN,
        InvokeOnCancel: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoSetShareAccess(
        DesiredAccess: ACCESS_MASK,
        DesiredShareAccess: ULONG,
        FileObject: PFILE_OBJECT,
        ShareAccess: PSHARE_ACCESS,
    );
}
unsafe extern "C" {
    pub fn IoSetShareAccessEx(
        DesiredAccess: ACCESS_MASK,
        DesiredShareAccess: ULONG,
        FileObject: PFILE_OBJECT,
        ShareAccess: PSHARE_ACCESS,
        WritePermission: PBOOLEAN,
    );
}
unsafe extern "C" {
    pub fn IoSetLinkShareAccess(
        DesiredAccess: ACCESS_MASK,
        DesiredShareAccess: ULONG,
        FileObject: PFILE_OBJECT,
        ShareAccess: PSHARE_ACCESS,
        LinkShareAccess: PLINK_SHARE_ACCESS,
        IoShareAccessFlags: ULONG,
    );
}
unsafe extern "C" {
    pub fn IoSetTopLevelIrp(Irp: PIRP);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_REMOVE_LOCK_TRACKING_BLOCK {
    _unused: [u8; 0],
}
pub type PIO_REMOVE_LOCK_TRACKING_BLOCK = *mut _IO_REMOVE_LOCK_TRACKING_BLOCK;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_REMOVE_LOCK_COMMON_BLOCK {
    pub Removed: BOOLEAN,
    pub Reserved: [BOOLEAN; 3usize],
    pub IoCount: LONG,
    pub RemoveEvent: KEVENT,
}
pub type IO_REMOVE_LOCK_COMMON_BLOCK = _IO_REMOVE_LOCK_COMMON_BLOCK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_REMOVE_LOCK_DBG_BLOCK {
    pub Signature: LONG,
    pub HighWatermark: ULONG,
    pub MaxLockedTicks: LONGLONG,
    pub AllocateTag: LONG,
    pub LockList: LIST_ENTRY,
    pub Spin: KSPIN_LOCK,
    pub LowMemoryCount: LONG,
    pub Reserved1: [ULONG; 4usize],
    pub Reserved2: PVOID,
    pub Blocks: PIO_REMOVE_LOCK_TRACKING_BLOCK,
}
pub type IO_REMOVE_LOCK_DBG_BLOCK = _IO_REMOVE_LOCK_DBG_BLOCK;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_REMOVE_LOCK {
    pub Common: IO_REMOVE_LOCK_COMMON_BLOCK,
}
pub type IO_REMOVE_LOCK = _IO_REMOVE_LOCK;
pub type PIO_REMOVE_LOCK = *mut _IO_REMOVE_LOCK;
unsafe extern "C" {
    pub fn IoInitializeRemoveLockEx(
        Lock: PIO_REMOVE_LOCK,
        AllocateTag: ULONG,
        MaxLockedMinutes: ULONG,
        HighWatermark: ULONG,
        RemlockSize: ULONG,
    );
}
unsafe extern "C" {
    pub fn IoAcquireRemoveLockEx(
        RemoveLock: PIO_REMOVE_LOCK,
        Tag: PVOID,
        File: PCSTR,
        Line: ULONG,
        RemlockSize: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoReleaseRemoveLockEx(RemoveLock: PIO_REMOVE_LOCK, Tag: PVOID, RemlockSize: ULONG);
}
unsafe extern "C" {
    pub fn IoReleaseRemoveLockAndWaitEx(
        RemoveLock: PIO_REMOVE_LOCK,
        Tag: PVOID,
        RemlockSize: ULONG,
    );
}
unsafe extern "C" {
    pub fn IoSizeOfIrpEx(DeviceObject: PDEVICE_OBJECT, StackSize: CCHAR) -> USHORT;
}
unsafe extern "C" {
    pub fn IoStartNextPacket(DeviceObject: PDEVICE_OBJECT, Cancelable: BOOLEAN);
}
unsafe extern "C" {
    pub fn IoStartNextPacketByKey(DeviceObject: PDEVICE_OBJECT, Cancelable: BOOLEAN, Key: ULONG);
}
unsafe extern "C" {
    pub fn IoStartPacket(
        DeviceObject: PDEVICE_OBJECT,
        Irp: PIRP,
        Key: PULONG,
        CancelFunction: PDRIVER_CANCEL,
    );
}
unsafe extern "C" {
    pub fn IoSetStartIoAttributes(
        DeviceObject: PDEVICE_OBJECT,
        DeferredStartIo: BOOLEAN,
        NonCancelable: BOOLEAN,
    );
}
unsafe extern "C" {
    pub fn IoStartTimer(DeviceObject: PDEVICE_OBJECT);
}
unsafe extern "C" {
    pub fn IoStopTimer(DeviceObject: PDEVICE_OBJECT);
}
unsafe extern "C" {
    pub fn IoUnregisterShutdownNotification(DeviceObject: PDEVICE_OBJECT);
}
unsafe extern "C" {
    pub fn IoUpdateShareAccess(FileObject: PFILE_OBJECT, ShareAccess: PSHARE_ACCESS);
}
unsafe extern "C" {
    pub fn IoUpdateLinkShareAccess(
        FileObject: PFILE_OBJECT,
        ShareAccess: PSHARE_ACCESS,
        LinkShareAccess: PLINK_SHARE_ACCESS,
    );
}
unsafe extern "C" {
    pub fn IoUpdateLinkShareAccessEx(
        FileObject: PFILE_OBJECT,
        ShareAccess: PSHARE_ACCESS,
        LinkShareAccess: PLINK_SHARE_ACCESS,
        IoShareAccessFlags: ULONG,
    );
}
unsafe extern "C" {
    pub fn IoWriteErrorLogEntry(ElEntry: PVOID);
}
unsafe extern "C" {
    pub fn IoCreateSystemThread(
        IoObject: PVOID,
        ThreadHandle: PHANDLE,
        DesiredAccess: ULONG,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        ProcessHandle: HANDLE,
        ClientId: PCLIENT_ID,
        StartRoutine: PKSTART_ROUTINE,
        StartContext: PVOID,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_WORKITEM {
    _unused: [u8; 0],
}
pub type PIO_WORKITEM = *mut _IO_WORKITEM;
pub type IO_WORKITEM_ROUTINE =
::core::option::Option<unsafe extern "C" fn(DeviceObject: PDEVICE_OBJECT, Context: PVOID)>;
pub type PIO_WORKITEM_ROUTINE = IO_WORKITEM_ROUTINE;
unsafe extern "C" {
    pub fn IoAllocateWorkItem(DeviceObject: PDEVICE_OBJECT) -> PIO_WORKITEM;
}
unsafe extern "C" {
    pub fn IoFreeWorkItem(IoWorkItem: PIO_WORKITEM);
}
unsafe extern "C" {
    pub fn IoQueueWorkItem(
        IoWorkItem: PIO_WORKITEM,
        WorkerRoutine: PIO_WORKITEM_ROUTINE,
        QueueType: WORK_QUEUE_TYPE,
        Context: PVOID,
    );
}
pub type IO_WORKITEM_ROUTINE_EX = ::core::option::Option<
    unsafe extern "C" fn(IoObject: PVOID, Context: PVOID, IoWorkItem: PIO_WORKITEM),
>;
pub type PIO_WORKITEM_ROUTINE_EX = IO_WORKITEM_ROUTINE_EX;
unsafe extern "C" {
    pub fn IoQueueWorkItemEx(
        IoWorkItem: PIO_WORKITEM,
        WorkerRoutine: PIO_WORKITEM_ROUTINE_EX,
        QueueType: WORK_QUEUE_TYPE,
        Context: PVOID,
    );
}
unsafe extern "C" {
    pub fn IoSizeofWorkItem() -> ULONG;
}
unsafe extern "C" {
    pub fn IoInitializeWorkItem(IoObject: PVOID, IoWorkItem: PIO_WORKITEM);
}
unsafe extern "C" {
    pub fn IoUninitializeWorkItem(IoWorkItem: PIO_WORKITEM);
}
unsafe extern "C" {
    pub fn IoTryQueueWorkItem(
        IoWorkItem: PIO_WORKITEM,
        WorkerRoutine: PIO_WORKITEM_ROUTINE_EX,
        QueueType: WORK_QUEUE_TYPE,
        Context: PVOID,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn IoWMIRegistrationControl(DeviceObject: PDEVICE_OBJECT, Action: ULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoWMIAllocateInstanceIds(
        Guid: LPCGUID,
        InstanceCount: ULONG,
        FirstInstanceId: *mut ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoWMISuggestInstanceName(
        PhysicalDeviceObject: PDEVICE_OBJECT,
        SymbolicLinkName: PUNICODE_STRING,
        CombineNames: BOOLEAN,
        SuggestedInstanceName: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoWMIWriteEvent(WnodeEventItem: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoWMIDeviceObjectToProviderId(DeviceObject: PDEVICE_OBJECT) -> ULONG;
}
unsafe extern "C" {
    pub fn IoWMIOpenBlock(
        Guid: LPCGUID,
        DesiredAccess: ULONG,
        DataBlockObject: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoWMIQueryAllData(
        DataBlockObject: PVOID,
        InOutBufferSize: PULONG,
        OutBuffer: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoWMIQueryAllDataMultiple(
        DataBlockObjectList: *mut PVOID,
        ObjectCount: ULONG,
        InOutBufferSize: PULONG,
        OutBuffer: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoWMIQuerySingleInstance(
        DataBlockObject: PVOID,
        InstanceName: PUNICODE_STRING,
        InOutBufferSize: PULONG,
        OutBuffer: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoWMIQuerySingleInstanceMultiple(
        DataBlockObjectList: *mut PVOID,
        InstanceNames: PUNICODE_STRING,
        ObjectCount: ULONG,
        InOutBufferSize: PULONG,
        OutBuffer: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoWMISetSingleInstance(
        DataBlockObject: PVOID,
        InstanceName: PUNICODE_STRING,
        Version: ULONG,
        ValueBufferSize: ULONG,
        ValueBuffer: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoWMISetSingleItem(
        DataBlockObject: PVOID,
        InstanceName: PUNICODE_STRING,
        DataItemId: ULONG,
        Version: ULONG,
        ValueBufferSize: ULONG,
        ValueBuffer: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoWMIExecuteMethod(
        DataBlockObject: PVOID,
        InstanceName: PUNICODE_STRING,
        MethodId: ULONG,
        InBufferSize: ULONG,
        OutBufferSize: PULONG,
        InOutBuffer: PUCHAR,
    ) -> NTSTATUS;
}
pub type FWMI_NOTIFICATION_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Wnode: PVOID, Context: PVOID)>;
pub type WMI_NOTIFICATION_CALLBACK = FWMI_NOTIFICATION_CALLBACK;
unsafe extern "C" {
    pub fn IoWMISetNotificationCallback(
        Object: PVOID,
        Callback: WMI_NOTIFICATION_CALLBACK,
        Context: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoWMIHandleToInstanceName(
        DataBlockObject: PVOID,
        FileHandle: HANDLE,
        InstanceName: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoWMIDeviceObjectToInstanceName(
        DataBlockObject: PVOID,
        DeviceObject: PDEVICE_OBJECT,
        InstanceName: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoIs32bitProcess(Irp: PIRP) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn IoIsInitiator32bitProcess(Irp: PIRP) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn IoFreeErrorLogEntry(ElEntry: PVOID);
}
pub type IO_CSQ = _IO_CSQ;
pub type PIO_CSQ = *mut _IO_CSQ;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_CSQ_IRP_CONTEXT {
    pub Type: ULONG,
    pub Irp: PIRP,
    pub Csq: PIO_CSQ,
}
pub type IO_CSQ_IRP_CONTEXT = _IO_CSQ_IRP_CONTEXT;
pub type PIO_CSQ_IRP_CONTEXT = *mut _IO_CSQ_IRP_CONTEXT;
pub type IO_CSQ_INSERT_IRP =
::core::option::Option<unsafe extern "C" fn(Csq: *mut _IO_CSQ, Irp: PIRP)>;
pub type PIO_CSQ_INSERT_IRP = IO_CSQ_INSERT_IRP;
pub type IO_CSQ_INSERT_IRP_EX = ::core::option::Option<
    unsafe extern "C" fn(Csq: *mut _IO_CSQ, Irp: PIRP, InsertContext: PVOID) -> NTSTATUS,
>;
pub type PIO_CSQ_INSERT_IRP_EX = IO_CSQ_INSERT_IRP_EX;
pub type IO_CSQ_REMOVE_IRP = ::core::option::Option<unsafe extern "C" fn(Csq: PIO_CSQ, Irp: PIRP)>;
pub type PIO_CSQ_REMOVE_IRP = IO_CSQ_REMOVE_IRP;
pub type IO_CSQ_PEEK_NEXT_IRP = ::core::option::Option<
    unsafe extern "C" fn(Csq: PIO_CSQ, Irp: PIRP, PeekContext: PVOID) -> PIRP,
>;
pub type PIO_CSQ_PEEK_NEXT_IRP = IO_CSQ_PEEK_NEXT_IRP;
pub type IO_CSQ_ACQUIRE_LOCK =
::core::option::Option<unsafe extern "C" fn(Csq: PIO_CSQ, Irql: PKIRQL)>;
pub type PIO_CSQ_ACQUIRE_LOCK = IO_CSQ_ACQUIRE_LOCK;
pub type IO_CSQ_RELEASE_LOCK =
::core::option::Option<unsafe extern "C" fn(Csq: PIO_CSQ, Irql: KIRQL)>;
pub type PIO_CSQ_RELEASE_LOCK = IO_CSQ_RELEASE_LOCK;
pub type IO_CSQ_COMPLETE_CANCELED_IRP =
::core::option::Option<unsafe extern "C" fn(Csq: PIO_CSQ, Irp: PIRP)>;
pub type PIO_CSQ_COMPLETE_CANCELED_IRP = IO_CSQ_COMPLETE_CANCELED_IRP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_CSQ {
    pub Type: ULONG,
    pub CsqInsertIrp: PIO_CSQ_INSERT_IRP,
    pub CsqRemoveIrp: PIO_CSQ_REMOVE_IRP,
    pub CsqPeekNextIrp: PIO_CSQ_PEEK_NEXT_IRP,
    pub CsqAcquireLock: PIO_CSQ_ACQUIRE_LOCK,
    pub CsqReleaseLock: PIO_CSQ_RELEASE_LOCK,
    pub CsqCompleteCanceledIrp: PIO_CSQ_COMPLETE_CANCELED_IRP,
    pub ReservePointer: PVOID,
}
unsafe extern "C" {
    pub fn IoCsqInitialize(
        Csq: PIO_CSQ,
        CsqInsertIrp: PIO_CSQ_INSERT_IRP,
        CsqRemoveIrp: PIO_CSQ_REMOVE_IRP,
        CsqPeekNextIrp: PIO_CSQ_PEEK_NEXT_IRP,
        CsqAcquireLock: PIO_CSQ_ACQUIRE_LOCK,
        CsqReleaseLock: PIO_CSQ_RELEASE_LOCK,
        CsqCompleteCanceledIrp: PIO_CSQ_COMPLETE_CANCELED_IRP,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoCsqInitializeEx(
        Csq: PIO_CSQ,
        CsqInsertIrp: PIO_CSQ_INSERT_IRP_EX,
        CsqRemoveIrp: PIO_CSQ_REMOVE_IRP,
        CsqPeekNextIrp: PIO_CSQ_PEEK_NEXT_IRP,
        CsqAcquireLock: PIO_CSQ_ACQUIRE_LOCK,
        CsqReleaseLock: PIO_CSQ_RELEASE_LOCK,
        CsqCompleteCanceledIrp: PIO_CSQ_COMPLETE_CANCELED_IRP,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoCsqInsertIrp(Csq: PIO_CSQ, Irp: PIRP, Context: PIO_CSQ_IRP_CONTEXT);
}
unsafe extern "C" {
    pub fn IoCsqInsertIrpEx(
        Csq: PIO_CSQ,
        Irp: PIRP,
        Context: PIO_CSQ_IRP_CONTEXT,
        InsertContext: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoCsqRemoveNextIrp(Csq: PIO_CSQ, PeekContext: PVOID) -> PIRP;
}
unsafe extern "C" {
    pub fn IoCsqRemoveIrp(Csq: PIO_CSQ, Context: PIO_CSQ_IRP_CONTEXT) -> PIRP;
}
unsafe extern "C" {
    pub fn IoValidateDeviceIoControlAccess(Irp: PIRP, RequiredAccess: ULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoGetIoPriorityHint(Irp: PIRP) -> IO_PRIORITY_HINT;
}
unsafe extern "C" {
    pub fn IoSetIoPriorityHint(Irp: PIRP, PriorityHint: IO_PRIORITY_HINT) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoAllocateSfioStreamIdentifier(
        FileObject: PFILE_OBJECT,
        Length: ULONG,
        Signature: PVOID,
        StreamIdentifier: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoGetSfioStreamIdentifier(FileObject: PFILE_OBJECT, Signature: PVOID) -> PVOID;
}
unsafe extern "C" {
    pub fn IoFreeSfioStreamIdentifier(FileObject: PFILE_OBJECT, Signature: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoGetIoAttributionHandle(Irp: PIRP, IoAttributionHandle: *mut PVOID) -> NTSTATUS;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_ATTRIBUTION_INFORMATION {
    pub Version: ULONG,
    pub Flags: _IO_ATTRIBUTION_INFORMATION__bindgen_ty_1,
    pub Length: ULONG,
    pub ServiceStartTime: ULONGLONG,
    pub CurrentTime: ULONGLONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_ATTRIBUTION_INFORMATION__bindgen_ty_1 {
    pub __bindgen_anon_1: _IO_ATTRIBUTION_INFORMATION__bindgen_ty_1__bindgen_ty_1,
    pub AllFlags: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_ATTRIBUTION_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _IO_ATTRIBUTION_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn MajorCode(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_MajorCode(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MajorCode_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MajorCode_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IoStart(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoStart(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IoStart_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IoStart_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn QueueOnly(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_QueueOnly(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn QueueOnly_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_QueueOnly_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IoFailed(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoFailed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IoFailed_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IoFailed_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VirtualDevice(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VirtualDevice(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VirtualDevice_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VirtualDevice_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Spare(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_Spare(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                20u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                20u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MajorCode: ULONG,
        IoStart: ULONG,
        QueueOnly: ULONG,
        IoFailed: ULONG,
        VirtualDevice: ULONG,
        Spare: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let MajorCode: u32 = unsafe { ::core::mem::transmute(MajorCode) };
            MajorCode as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let IoStart: u32 = unsafe { ::core::mem::transmute(IoStart) };
            IoStart as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let QueueOnly: u32 = unsafe { ::core::mem::transmute(QueueOnly) };
            QueueOnly as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let IoFailed: u32 = unsafe { ::core::mem::transmute(IoFailed) };
            IoFailed as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let VirtualDevice: u32 = unsafe { ::core::mem::transmute(VirtualDevice) };
            VirtualDevice as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
            Spare as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type IO_ATTRIBUTION_INFORMATION = _IO_ATTRIBUTION_INFORMATION;
pub type PIO_ATTRIBUTION_INFORMATION = *mut _IO_ATTRIBUTION_INFORMATION;
unsafe extern "C" {
    pub fn IoRecordIoAttribution(
        OpaqueHandle: PVOID,
        AttributionInformation: *mut IO_ATTRIBUTION_INFORMATION,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoSetIoAttributionIrp(Irp: PIRP, AttributionSource: PVOID, Flags: ULONG) -> NTSTATUS;
}
pub const _IO_ACCESS_TYPE_ReadAccess: _IO_ACCESS_TYPE = 0;
pub const _IO_ACCESS_TYPE_WriteAccess: _IO_ACCESS_TYPE = 1;
pub const _IO_ACCESS_TYPE_ModifyAccess: _IO_ACCESS_TYPE = 2;
pub type _IO_ACCESS_TYPE = core::ffi::c_int;
pub use self::_IO_ACCESS_TYPE as IO_ACCESS_TYPE;
pub const _IO_ACCESS_MODE_SequentialAccess: _IO_ACCESS_MODE = 0;
pub const _IO_ACCESS_MODE_RandomAccess: _IO_ACCESS_MODE = 1;
pub type _IO_ACCESS_MODE = core::ffi::c_int;
pub use self::_IO_ACCESS_MODE as IO_ACCESS_MODE;
pub const _IO_CONTAINER_NOTIFICATION_CLASS_IoSessionStateNotification:
_IO_CONTAINER_NOTIFICATION_CLASS = 0;
pub const _IO_CONTAINER_NOTIFICATION_CLASS_IoMaxContainerNotificationClass:
_IO_CONTAINER_NOTIFICATION_CLASS = 1;
pub type _IO_CONTAINER_NOTIFICATION_CLASS = core::ffi::c_int;
pub use self::_IO_CONTAINER_NOTIFICATION_CLASS as IO_CONTAINER_NOTIFICATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_SESSION_STATE_NOTIFICATION {
    pub Size: ULONG,
    pub Flags: ULONG,
    pub IoObject: PVOID,
    pub EventMask: ULONG,
    pub Context: PVOID,
}
pub type IO_SESSION_STATE_NOTIFICATION = _IO_SESSION_STATE_NOTIFICATION;
pub type PIO_SESSION_STATE_NOTIFICATION = *mut _IO_SESSION_STATE_NOTIFICATION;
pub const _IO_CONTAINER_INFORMATION_CLASS_IoSessionStateInformation:
_IO_CONTAINER_INFORMATION_CLASS = 0;
pub const _IO_CONTAINER_INFORMATION_CLASS_IoMaxContainerInformationClass:
_IO_CONTAINER_INFORMATION_CLASS = 1;
pub type _IO_CONTAINER_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_IO_CONTAINER_INFORMATION_CLASS as IO_CONTAINER_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_SESSION_STATE_INFORMATION {
    pub SessionId: ULONG,
    pub SessionState: IO_SESSION_STATE,
    pub LocalSession: BOOLEAN,
}
pub type IO_SESSION_STATE_INFORMATION = _IO_SESSION_STATE_INFORMATION;
pub type PIO_SESSION_STATE_INFORMATION = *mut _IO_SESSION_STATE_INFORMATION;
unsafe extern "C" {
    pub fn IoGetContainerInformation(
        InformationClass: IO_CONTAINER_INFORMATION_CLASS,
        ContainerObject: PVOID,
        Buffer: PVOID,
        BufferLength: ULONG,
    ) -> NTSTATUS;
}
pub type PIO_CONTAINER_NOTIFICATION_FUNCTION =
::core::option::Option<unsafe extern "C" fn() -> NTSTATUS>;
pub type IO_SESSION_NOTIFICATION_FUNCTION = ::core::option::Option<
    unsafe extern "C" fn(
        SessionObject: PVOID,
        IoObject: PVOID,
        Event: ULONG,
        Context: PVOID,
        NotificationPayload: PVOID,
        PayloadLength: ULONG,
    ) -> NTSTATUS,
>;
pub type PIO_SESSION_NOTIFICATION_FUNCTION = IO_SESSION_NOTIFICATION_FUNCTION;
unsafe extern "C" {
    pub fn IoRegisterContainerNotification(
        NotificationClass: IO_CONTAINER_NOTIFICATION_CLASS,
        CallbackFunction: PIO_CONTAINER_NOTIFICATION_FUNCTION,
        NotificationInformation: PVOID,
        NotificationInformationLength: ULONG,
        CallbackRegistration: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoUnregisterContainerNotification(CallbackRegistration: PVOID);
}
unsafe extern "C" {
    pub fn IoReserveKsrPersistentMemory(
        DriverObject: PDRIVER_OBJECT,
        PhysicalDeviceObject: PDEVICE_OBJECT,
        Size: SIZE_T,
        Flags: ULONG,
        DataHandle: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoFreeKsrPersistentMemory(DataHandle: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoQueryKsrPersistentMemorySize(
        DriverObject: PDRIVER_OBJECT,
        PhysicalDeviceObject: PDEVICE_OBJECT,
        BufferSize: PSIZE_T,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoAcquireKsrPersistentMemory(
        DriverObject: PDRIVER_OBJECT,
        PhysicalDeviceObject: PDEVICE_OBJECT,
        Buffer: PVOID,
        Size: PSIZE_T,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoWriteKsrPersistentMemory(DataHandle: PVOID, Buffer: PVOID, Size: SIZE_T) -> NTSTATUS;
}
pub type IO_PERSISTED_MEMORY_ENUMERATION_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        DriverObject: PDRIVER_OBJECT,
        PhysicalDeviceObject: PDEVICE_OBJECT,
        PhysicalDeviceId: PUNICODE_STRING,
        DataTag: PUSHORT,
        DataVersion: PULONG,
        Context: PVOID,
    ) -> NTSTATUS,
>;
pub type PIO_PERSISTED_MEMORY_ENUMERATION_CALLBACK = IO_PERSISTED_MEMORY_ENUMERATION_CALLBACK;
unsafe extern "C" {
    pub fn IoEnumerateKsrPersistentMemoryEx(
        DriverObject: PDRIVER_OBJECT,
        PhysicalDeviceObject: PDEVICE_OBJECT,
        PhysicalDeviceId: PUNICODE_STRING,
        Callback: PIO_PERSISTED_MEMORY_ENUMERATION_CALLBACK,
        CallbackContext: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoReserveKsrPersistentMemoryEx(
        DriverObject: PDRIVER_OBJECT,
        PhysicalDeviceObject: PDEVICE_OBJECT,
        PhysicalDeviceId: PUNICODE_STRING,
        DataTag: PUSHORT,
        DataVersion: ULONG,
        Size: SIZE_T,
        Flags: ULONG,
        DataHandle: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoQueryKsrPersistentMemorySizeEx(
        DriverObject: PDRIVER_OBJECT,
        PhysicalDeviceObject: PDEVICE_OBJECT,
        PhysicalDeviceId: PUNICODE_STRING,
        DataTag: PUSHORT,
        DataVersion: PULONG,
        BufferSize: PSIZE_T,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoAcquireKsrPersistentMemoryEx(
        DriverObject: PDRIVER_OBJECT,
        PhysicalDeviceObject: PDEVICE_OBJECT,
        PhysicalDeviceId: PUNICODE_STRING,
        DataTag: PUSHORT,
        DataVersion: PULONG,
        Buffer: PVOID,
        Size: PSIZE_T,
    ) -> NTSTATUS;
}
pub type TRACEHANDLE = ULONG64;
pub type PTRACEHANDLE = *mut ULONG64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETW_TRACE_SESSION_SETTINGS {
    pub Version: ULONG,
    pub BufferSize: ULONG,
    pub MinimumBuffers: ULONG,
    pub MaximumBuffers: ULONG,
    pub LoggerMode: ULONG,
    pub FlushTimer: ULONG,
    pub FlushThreshold: ULONG,
    pub ClockType: ULONG,
}
pub type ETW_TRACE_SESSION_SETTINGS = _ETW_TRACE_SESSION_SETTINGS;
pub type PETW_TRACE_SESSION_SETTINGS = *mut _ETW_TRACE_SESSION_SETTINGS;
pub const _TRACE_INFORMATION_CLASS_TraceIdClass: _TRACE_INFORMATION_CLASS = 0;
pub const _TRACE_INFORMATION_CLASS_TraceHandleClass: _TRACE_INFORMATION_CLASS = 1;
pub const _TRACE_INFORMATION_CLASS_TraceEnableFlagsClass: _TRACE_INFORMATION_CLASS = 2;
pub const _TRACE_INFORMATION_CLASS_TraceEnableLevelClass: _TRACE_INFORMATION_CLASS = 3;
pub const _TRACE_INFORMATION_CLASS_GlobalLoggerHandleClass: _TRACE_INFORMATION_CLASS = 4;
pub const _TRACE_INFORMATION_CLASS_EventLoggerHandleClass: _TRACE_INFORMATION_CLASS = 5;
pub const _TRACE_INFORMATION_CLASS_AllLoggerHandlesClass: _TRACE_INFORMATION_CLASS = 6;
pub const _TRACE_INFORMATION_CLASS_TraceHandleByNameClass: _TRACE_INFORMATION_CLASS = 7;
pub const _TRACE_INFORMATION_CLASS_LoggerEventsLostClass: _TRACE_INFORMATION_CLASS = 8;
pub const _TRACE_INFORMATION_CLASS_TraceSessionSettingsClass: _TRACE_INFORMATION_CLASS = 9;
pub const _TRACE_INFORMATION_CLASS_LoggerEventsLoggedClass: _TRACE_INFORMATION_CLASS = 10;
pub const _TRACE_INFORMATION_CLASS_DiskIoNotifyRoutinesClass: _TRACE_INFORMATION_CLASS = 11;
pub const _TRACE_INFORMATION_CLASS_TraceInformationClassReserved1: _TRACE_INFORMATION_CLASS = 12;
pub const _TRACE_INFORMATION_CLASS_FltIoNotifyRoutinesClass: _TRACE_INFORMATION_CLASS = 13;
pub const _TRACE_INFORMATION_CLASS_TraceInformationClassReserved2: _TRACE_INFORMATION_CLASS = 14;
pub const _TRACE_INFORMATION_CLASS_WdfNotifyRoutinesClass: _TRACE_INFORMATION_CLASS = 15;
pub const _TRACE_INFORMATION_CLASS_MaxTraceInformationClass: _TRACE_INFORMATION_CLASS = 16;
pub type _TRACE_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_TRACE_INFORMATION_CLASS as TRACE_INFORMATION_CLASS;
unsafe extern "C" {
    pub fn WmiQueryTraceInformation(
        TraceInformationClass: TRACE_INFORMATION_CLASS,
        TraceInformation: PVOID,
        TraceInformationLength: ULONG,
        RequiredLength: PULONG,
        Buffer: PVOID,
    ) -> NTSTATUS;
}
pub type REGHANDLE = ULONGLONG;
pub type PREGHANDLE = *mut ULONGLONG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EVENT_DATA_DESCRIPTOR {
    pub Ptr: ULONGLONG,
    pub Size: ULONG,
    pub __bindgen_anon_1: _EVENT_DATA_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EVENT_DATA_DESCRIPTOR__bindgen_ty_1 {
    pub Reserved: ULONG,
    pub __bindgen_anon_1: _EVENT_DATA_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_DATA_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    pub Type: UCHAR,
    pub Reserved1: UCHAR,
    pub Reserved2: USHORT,
}
pub type EVENT_DATA_DESCRIPTOR = _EVENT_DATA_DESCRIPTOR;
pub type PEVENT_DATA_DESCRIPTOR = *mut _EVENT_DATA_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_DESCRIPTOR {
    pub Id: USHORT,
    pub Version: UCHAR,
    pub Channel: UCHAR,
    pub Level: UCHAR,
    pub Opcode: UCHAR,
    pub Task: USHORT,
    pub Keyword: ULONGLONG,
}
pub type EVENT_DESCRIPTOR = _EVENT_DESCRIPTOR;
pub type PEVENT_DESCRIPTOR = *mut _EVENT_DESCRIPTOR;
pub type PCEVENT_DESCRIPTOR = *const EVENT_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_FILTER_DESCRIPTOR {
    pub Ptr: ULONGLONG,
    pub Size: ULONG,
    pub Type: ULONG,
}
pub type EVENT_FILTER_DESCRIPTOR = _EVENT_FILTER_DESCRIPTOR;
pub type PEVENT_FILTER_DESCRIPTOR = *mut _EVENT_FILTER_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_FILTER_HEADER {
    pub Id: USHORT,
    pub Version: UCHAR,
    pub Reserved: [UCHAR; 5usize],
    pub InstanceId: ULONGLONG,
    pub Size: ULONG,
    pub NextOffset: ULONG,
}
pub type EVENT_FILTER_HEADER = _EVENT_FILTER_HEADER;
pub type PEVENT_FILTER_HEADER = *mut _EVENT_FILTER_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_FILTER_EVENT_ID {
    pub FilterIn: BOOLEAN,
    pub Reserved: UCHAR,
    pub Count: USHORT,
    pub Events: [USHORT; 1usize],
}
pub type EVENT_FILTER_EVENT_ID = _EVENT_FILTER_EVENT_ID;
pub type PEVENT_FILTER_EVENT_ID = *mut _EVENT_FILTER_EVENT_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_FILTER_EVENT_NAME {
    pub MatchAnyKeyword: ULONGLONG,
    pub MatchAllKeyword: ULONGLONG,
    pub Level: UCHAR,
    pub FilterIn: BOOLEAN,
    pub NameCount: USHORT,
    pub Names: [UCHAR; 1usize],
}
pub type EVENT_FILTER_EVENT_NAME = _EVENT_FILTER_EVENT_NAME;
pub type PEVENT_FILTER_EVENT_NAME = *mut _EVENT_FILTER_EVENT_NAME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_FILTER_LEVEL_KW {
    pub MatchAnyKeyword: ULONGLONG,
    pub MatchAllKeyword: ULONGLONG,
    pub Level: UCHAR,
    pub FilterIn: BOOLEAN,
}
pub type EVENT_FILTER_LEVEL_KW = _EVENT_FILTER_LEVEL_KW;
pub type PEVENT_FILTER_LEVEL_KW = *mut _EVENT_FILTER_LEVEL_KW;
pub const _EVENT_INFO_CLASS_EventProviderBinaryTrackInfo: _EVENT_INFO_CLASS = 0;
pub const _EVENT_INFO_CLASS_EventProviderSetReserved1: _EVENT_INFO_CLASS = 1;
pub const _EVENT_INFO_CLASS_EventProviderSetTraits: _EVENT_INFO_CLASS = 2;
pub const _EVENT_INFO_CLASS_EventProviderUseDescriptorType: _EVENT_INFO_CLASS = 3;
pub const _EVENT_INFO_CLASS_MaxEventInfo: _EVENT_INFO_CLASS = 4;
pub type _EVENT_INFO_CLASS = core::ffi::c_int;
pub use self::_EVENT_INFO_CLASS as EVENT_INFO_CLASS;
pub type PETWENABLECALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: LPCGUID,
        arg2: ULONG,
        arg3: UCHAR,
        arg4: ULONGLONG,
        arg5: ULONGLONG,
        arg6: PEVENT_FILTER_DESCRIPTOR,
        arg7: PVOID,
    ),
>;
unsafe extern "C" {
    pub fn EtwRegister(
        ProviderId: LPCGUID,
        EnableCallback: PETWENABLECALLBACK,
        CallbackContext: PVOID,
        RegHandle: PREGHANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn EtwUnregister(RegHandle: REGHANDLE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn EtwSetInformation(
        RegHandle: REGHANDLE,
        InformationClass: EVENT_INFO_CLASS,
        EventInformation: PVOID,
        InformationLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn EtwEventEnabled(RegHandle: REGHANDLE, EventDescriptor: PCEVENT_DESCRIPTOR) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn EtwProviderEnabled(RegHandle: REGHANDLE, Level: UCHAR, Keyword: ULONGLONG) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn EtwActivityIdControl(ControlCode: ULONG, ActivityId: LPGUID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn EtwWrite(
        RegHandle: REGHANDLE,
        EventDescriptor: PCEVENT_DESCRIPTOR,
        ActivityId: LPCGUID,
        UserDataCount: ULONG,
        UserData: PEVENT_DATA_DESCRIPTOR,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn EtwWriteTransfer(
        RegHandle: REGHANDLE,
        EventDescriptor: PCEVENT_DESCRIPTOR,
        ActivityId: LPCGUID,
        RelatedActivityId: LPCGUID,
        UserDataCount: ULONG,
        UserData: PEVENT_DATA_DESCRIPTOR,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn EtwWriteString(
        RegHandle: REGHANDLE,
        Level: UCHAR,
        Keyword: ULONGLONG,
        ActivityId: LPCGUID,
        String: PCWSTR,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn EtwWriteEx(
        RegHandle: REGHANDLE,
        EventDescriptor: PCEVENT_DESCRIPTOR,
        Filter: ULONG64,
        Flags: ULONG,
        ActivityId: LPCGUID,
        RelatedActivityId: LPCGUID,
        UserDataCount: ULONG,
        UserData: PEVENT_DATA_DESCRIPTOR,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeEtwWriteKMCveEvent(
        CveId: PCUNICODE_STRING,
        AdditionalDetails: PCUNICODE_STRING,
    ) -> NTSTATUS;
}
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyDeviceDescription: DEVICE_REGISTRY_PROPERTY = 0;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyHardwareID: DEVICE_REGISTRY_PROPERTY = 1;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyCompatibleIDs: DEVICE_REGISTRY_PROPERTY = 2;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyBootConfiguration: DEVICE_REGISTRY_PROPERTY = 3;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyBootConfigurationTranslated:
DEVICE_REGISTRY_PROPERTY = 4;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyClassName: DEVICE_REGISTRY_PROPERTY = 5;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyClassGuid: DEVICE_REGISTRY_PROPERTY = 6;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyDriverKeyName: DEVICE_REGISTRY_PROPERTY = 7;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyManufacturer: DEVICE_REGISTRY_PROPERTY = 8;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyFriendlyName: DEVICE_REGISTRY_PROPERTY = 9;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyLocationInformation: DEVICE_REGISTRY_PROPERTY = 10;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyPhysicalDeviceObjectName:
DEVICE_REGISTRY_PROPERTY = 11;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyBusTypeGuid: DEVICE_REGISTRY_PROPERTY = 12;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyLegacyBusType: DEVICE_REGISTRY_PROPERTY = 13;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyBusNumber: DEVICE_REGISTRY_PROPERTY = 14;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyEnumeratorName: DEVICE_REGISTRY_PROPERTY = 15;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyAddress: DEVICE_REGISTRY_PROPERTY = 16;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyUINumber: DEVICE_REGISTRY_PROPERTY = 17;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyInstallState: DEVICE_REGISTRY_PROPERTY = 18;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyRemovalPolicy: DEVICE_REGISTRY_PROPERTY = 19;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyResourceRequirements: DEVICE_REGISTRY_PROPERTY =
    20;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyAllocatedResources: DEVICE_REGISTRY_PROPERTY = 21;
pub const DEVICE_REGISTRY_PROPERTY_DevicePropertyContainerID: DEVICE_REGISTRY_PROPERTY = 22;
pub type DEVICE_REGISTRY_PROPERTY = core::ffi::c_int;
pub type TRANSLATE_BUS_ADDRESS = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        BusAddress: PHYSICAL_ADDRESS,
        Length: ULONG,
        AddressSpace: PULONG,
        TranslatedAddress: PPHYSICAL_ADDRESS,
    ) -> BOOLEAN,
>;
pub type PTRANSLATE_BUS_ADDRESS = TRANSLATE_BUS_ADDRESS;
pub type GET_DMA_ADAPTER = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        DeviceDescriptor: *mut _DEVICE_DESCRIPTION,
        NumberOfMapRegisters: PULONG,
    ) -> *mut _DMA_ADAPTER,
>;
pub type PGET_DMA_ADAPTER = GET_DMA_ADAPTER;
pub type GET_SET_DEVICE_DATA = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        DataType: ULONG,
        Buffer: PVOID,
        Offset: ULONG,
        Length: ULONG,
    ) -> ULONG,
>;
pub type PGET_SET_DEVICE_DATA = GET_SET_DEVICE_DATA;
pub const _DEVICE_INSTALL_STATE_InstallStateInstalled: _DEVICE_INSTALL_STATE = 0;
pub const _DEVICE_INSTALL_STATE_InstallStateNeedsReinstall: _DEVICE_INSTALL_STATE = 1;
pub const _DEVICE_INSTALL_STATE_InstallStateFailedInstall: _DEVICE_INSTALL_STATE = 2;
pub const _DEVICE_INSTALL_STATE_InstallStateFinishInstall: _DEVICE_INSTALL_STATE = 3;
pub type _DEVICE_INSTALL_STATE = core::ffi::c_int;
pub use self::_DEVICE_INSTALL_STATE as DEVICE_INSTALL_STATE;
pub type PDEVICE_INSTALL_STATE = *mut _DEVICE_INSTALL_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PNP_BUS_INFORMATION {
    pub BusTypeGuid: GUID,
    pub LegacyBusType: INTERFACE_TYPE,
    pub BusNumber: ULONG,
}
pub type PNP_BUS_INFORMATION = _PNP_BUS_INFORMATION;
pub type PPNP_BUS_INFORMATION = *mut _PNP_BUS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LEGACY_BUS_INFORMATION {
    pub BusTypeGuid: GUID,
    pub LegacyBusType: INTERFACE_TYPE,
    pub BusNumber: ULONG,
}
pub type LEGACY_BUS_INFORMATION = _LEGACY_BUS_INFORMATION;
pub type PLEGACY_BUS_INFORMATION = *mut _LEGACY_BUS_INFORMATION;
pub const _DEVICE_REMOVAL_POLICY_RemovalPolicyExpectNoRemoval: _DEVICE_REMOVAL_POLICY = 1;
pub const _DEVICE_REMOVAL_POLICY_RemovalPolicyExpectOrderlyRemoval: _DEVICE_REMOVAL_POLICY = 2;
pub const _DEVICE_REMOVAL_POLICY_RemovalPolicyExpectSurpriseRemoval: _DEVICE_REMOVAL_POLICY = 3;
pub type _DEVICE_REMOVAL_POLICY = core::ffi::c_int;
pub use self::_DEVICE_REMOVAL_POLICY as DEVICE_REMOVAL_POLICY;
pub type PDEVICE_REMOVAL_POLICY = *mut _DEVICE_REMOVAL_POLICY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BUS_INTERFACE_STANDARD {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub TranslateBusAddress: PTRANSLATE_BUS_ADDRESS,
    pub GetDmaAdapter: PGET_DMA_ADAPTER,
    pub SetBusData: PGET_SET_DEVICE_DATA,
    pub GetBusData: PGET_SET_DEVICE_DATA,
}
pub type BUS_INTERFACE_STANDARD = _BUS_INTERFACE_STANDARD;
pub type PBUS_INTERFACE_STANDARD = *mut _BUS_INTERFACE_STANDARD;
pub type GET_VIRTUAL_DEVICE_DATA = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        VirtualFunction: USHORT,
        Buffer: PVOID,
        Offset: ULONG,
        Length: ULONG,
    ) -> ULONG,
>;
pub type PGET_VIRTUAL_DEVICE_DATA = GET_VIRTUAL_DEVICE_DATA;
pub type SET_VIRTUAL_DEVICE_DATA = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        VirtualFunction: USHORT,
        Buffer: PVOID,
        Offset: ULONG,
        Length: ULONG,
    ) -> ULONG,
>;
pub type PSET_VIRTUAL_DEVICE_DATA = SET_VIRTUAL_DEVICE_DATA;
pub type GET_VIRTUAL_DEVICE_LOCATION = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        VirtualFunction: USHORT,
        SegmentNumber: PUINT16,
        BusNumber: PUINT8,
        FunctionNumber: PUINT8,
    ) -> NTSTATUS,
>;
pub type PGET_VIRTUAL_DEVICE_LOCATION = GET_VIRTUAL_DEVICE_LOCATION;
pub type GET_VIRTUAL_DEVICE_RESOURCES =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, CapturedBusNumbers: PUINT8)>;
pub type PGET_VIRTUAL_DEVICE_RESOURCES = GET_VIRTUAL_DEVICE_RESOURCES;
pub type ENABLE_VIRTUALIZATION = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        NumVFs: UINT16,
        EnableVfMigration: BOOLEAN,
        EnableMigrationInterrupt: BOOLEAN,
        EnableVirtualization: BOOLEAN,
    ) -> NTSTATUS,
>;
pub type PENABLE_VIRTUALIZATION = ENABLE_VIRTUALIZATION;
pub type GET_VIRTUAL_FUNCTION_PROBED_BARS = ::core::option::Option<
    unsafe extern "C" fn(Context: PVOID, BaseRegisterValues: PULONG) -> NTSTATUS,
>;
pub type PGET_VIRTUAL_FUNCTION_PROBED_BARS = GET_VIRTUAL_FUNCTION_PROBED_BARS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_VIRTUALIZATION_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub SetVirtualFunctionData: PSET_VIRTUAL_DEVICE_DATA,
    pub GetVirtualFunctionData: PGET_VIRTUAL_DEVICE_DATA,
    pub GetLocation: PGET_VIRTUAL_DEVICE_LOCATION,
    pub GetResources: PGET_VIRTUAL_DEVICE_RESOURCES,
    pub EnableVirtualization: PENABLE_VIRTUALIZATION,
    pub GetVirtualFunctionProbedBars: PGET_VIRTUAL_FUNCTION_PROBED_BARS,
}
pub type PCI_VIRTUALIZATION_INTERFACE = _PCI_VIRTUALIZATION_INTERFACE;
pub type PPCI_VIRTUALIZATION_INTERFACE = *mut _PCI_VIRTUALIZATION_INTERFACE;
pub const _PCI_ACS_BIT_PciAcsReserved: _PCI_ACS_BIT = 0;
pub const _PCI_ACS_BIT_PciAcsBitEnable: _PCI_ACS_BIT = 1;
pub const _PCI_ACS_BIT_PciAcsBitDisable: _PCI_ACS_BIT = 2;
pub const _PCI_ACS_BIT_PciAcsBitDontCare: _PCI_ACS_BIT = 3;
pub type _PCI_ACS_BIT = core::ffi::c_int;
pub use self::_PCI_ACS_BIT as PCI_ACS_BIT;
pub type PPCI_ACS_BIT = *mut _PCI_ACS_BIT;
pub type PCI_SET_ACS = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        EnableSourceValidation: PCI_ACS_BIT,
        EnableTranslationBlocking: PCI_ACS_BIT,
        EnableP2PRequestRedirect: PCI_ACS_BIT,
        EnableCompletionRedirect: PCI_ACS_BIT,
        EnableUpstreamForwarding: PCI_ACS_BIT,
        EnableEgressControl: PCI_ACS_BIT,
        EnableDirectTranslatedP2P: PCI_ACS_BIT,
    ) -> NTSTATUS,
>;
pub type PPCI_SET_ACS = PCI_SET_ACS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_SECURITY_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub SetAccessControlServices: PPCI_SET_ACS,
}
pub type PCI_SECURITY_INTERFACE = _PCI_SECURITY_INTERFACE;
pub type PPCI_SECURITY_INTERFACE = *mut _PCI_SECURITY_INTERFACE;
pub type PCI_SET_ACS2 = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        ScenariosToModify: ULONG,
        ScenarioState: ULONG,
    ) -> NTSTATUS,
>;
pub type PPCI_SET_ACS2 = PCI_SET_ACS2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_SECURITY_INTERFACE2 {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub Flags: ULONG,
    pub SupportedScenarios: ULONG,
    pub SetAccessControlServices: PPCI_SET_ACS2,
}
pub type PCI_SECURITY_INTERFACE2 = _PCI_SECURITY_INTERFACE2;
pub type PPCI_SECURITY_INTERFACE2 = *mut _PCI_SECURITY_INTERFACE2;
pub type PCI_SET_ATS =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, EnableAts: BOOLEAN) -> NTSTATUS>;
pub type PPCI_SET_ATS = PCI_SET_ATS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_ATS_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub SetAddressTranslationServices: PPCI_SET_ATS,
    pub InvalidateQueueDepth: UCHAR,
}
pub type PCI_ATS_INTERFACE = _PCI_ATS_INTERFACE;
pub type PPCI_ATS_INTERFACE = *mut _PCI_ATS_INTERFACE;
pub type PREENUMERATE_SELF = ::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REENUMERATE_SELF_INTERFACE_STANDARD {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub SurpriseRemoveAndReenumerateSelf: PREENUMERATE_SELF,
}
pub type REENUMERATE_SELF_INTERFACE_STANDARD = _REENUMERATE_SELF_INTERFACE_STANDARD;
pub type PREENUMERATE_SELF_INTERFACE_STANDARD = *mut _REENUMERATE_SELF_INTERFACE_STANDARD;
pub type PQUERYEXTENDEDADDRESS =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, ExtendedAddress: PULONG64)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PNP_EXTENDED_ADDRESS_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub QueryExtendedAddress: PQUERYEXTENDEDADDRESS,
}
pub type PNP_EXTENDED_ADDRESS_INTERFACE = _PNP_EXTENDED_ADDRESS_INTERFACE;
pub type PPNP_EXTENDED_ADDRESS_INTERFACE = *mut _PNP_EXTENDED_ADDRESS_INTERFACE;
pub type SET_D3COLD_SUPPORT =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, D3ColdSupport: BOOLEAN)>;
pub type PSET_D3COLD_SUPPORT = SET_D3COLD_SUPPORT;
pub const _DEVICE_WAKE_DEPTH_DeviceWakeDepthNotWakeable: _DEVICE_WAKE_DEPTH = 0;
pub const _DEVICE_WAKE_DEPTH_DeviceWakeDepthD0: _DEVICE_WAKE_DEPTH = 1;
pub const _DEVICE_WAKE_DEPTH_DeviceWakeDepthD1: _DEVICE_WAKE_DEPTH = 2;
pub const _DEVICE_WAKE_DEPTH_DeviceWakeDepthD2: _DEVICE_WAKE_DEPTH = 3;
pub const _DEVICE_WAKE_DEPTH_DeviceWakeDepthD3hot: _DEVICE_WAKE_DEPTH = 4;
pub const _DEVICE_WAKE_DEPTH_DeviceWakeDepthD3cold: _DEVICE_WAKE_DEPTH = 5;
pub const _DEVICE_WAKE_DEPTH_DeviceWakeDepthMaximum: _DEVICE_WAKE_DEPTH = 6;
pub type _DEVICE_WAKE_DEPTH = core::ffi::c_int;
pub use self::_DEVICE_WAKE_DEPTH as DEVICE_WAKE_DEPTH;
pub type PDEVICE_WAKE_DEPTH = *mut _DEVICE_WAKE_DEPTH;
pub type GET_IDLE_WAKE_INFO = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        SystemPowerState: SYSTEM_POWER_STATE,
        DeepestWakeableDstate: PDEVICE_WAKE_DEPTH,
    ) -> NTSTATUS,
>;
pub type PGET_IDLE_WAKE_INFO = GET_IDLE_WAKE_INFO;
pub type GET_D3COLD_CAPABILITY = ::core::option::Option<
    unsafe extern "C" fn(Context: PVOID, D3ColdSupported: PBOOLEAN) -> NTSTATUS,
>;
pub type PGET_D3COLD_CAPABILITY = GET_D3COLD_CAPABILITY;
pub const _D3COLD_LAST_TRANSITION_STATUS_LastDStateTransitionStatusUnknown:
_D3COLD_LAST_TRANSITION_STATUS = 0;
pub const _D3COLD_LAST_TRANSITION_STATUS_LastDStateTransitionD3hot: _D3COLD_LAST_TRANSITION_STATUS =
    1;
pub const _D3COLD_LAST_TRANSITION_STATUS_LastDStateTransitionD3cold:
_D3COLD_LAST_TRANSITION_STATUS = 2;
pub type _D3COLD_LAST_TRANSITION_STATUS = core::ffi::c_int;
pub use self::_D3COLD_LAST_TRANSITION_STATUS as D3COLD_LAST_TRANSITION_STATUS;
pub type PD3COLD_LAST_TRANSITION_STATUS = *mut _D3COLD_LAST_TRANSITION_STATUS;
pub type GET_D3COLD_LAST_TRANSITION_STATUS = ::core::option::Option<
    unsafe extern "C" fn(Context: PVOID, LastTransitionStatus: PD3COLD_LAST_TRANSITION_STATUS),
>;
pub type PGET_D3COLD_LAST_TRANSITION_STATUS = GET_D3COLD_LAST_TRANSITION_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _D3COLD_SUPPORT_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub SetD3ColdSupport: PSET_D3COLD_SUPPORT,
    pub GetIdleWakeInfo: PGET_IDLE_WAKE_INFO,
    pub GetD3ColdCapability: PGET_D3COLD_CAPABILITY,
    pub GetBusDriverD3ColdSupport: PGET_D3COLD_CAPABILITY,
    pub GetLastTransitionStatus: PGET_D3COLD_LAST_TRANSITION_STATUS,
}
pub type D3COLD_SUPPORT_INTERFACE = _D3COLD_SUPPORT_INTERFACE;
pub type PD3COLD_SUPPORT_INTERFACE = *mut _D3COLD_SUPPORT_INTERFACE;
pub type D3COLD_REQUEST_CORE_POWER_RAIL =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, CorePowerRailNeeded: BOOLEAN)>;
pub type PD3COLD_REQUEST_CORE_POWER_RAIL = D3COLD_REQUEST_CORE_POWER_RAIL;
pub type D3COLD_REQUEST_AUX_POWER = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        AuxPowerInMilliWatts: ULONG,
        RetryInSeconds: PULONG,
    ) -> NTSTATUS,
>;
pub type PD3COLD_REQUEST_AUX_POWER = D3COLD_REQUEST_AUX_POWER;
pub type D3COLD_REQUEST_PERST_DELAY = ::core::option::Option<
    unsafe extern "C" fn(Context: PVOID, DelayInMicroSeconds: ULONG) -> NTSTATUS,
>;
pub type PD3COLD_REQUEST_PERST_DELAY = D3COLD_REQUEST_PERST_DELAY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _D3COLD_AUX_POWER_AND_TIMING_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub RequestCorePowerRail: PD3COLD_REQUEST_CORE_POWER_RAIL,
    pub RequestAuxPower: PD3COLD_REQUEST_AUX_POWER,
    pub RequestPerstDelay: PD3COLD_REQUEST_PERST_DELAY,
}
pub type D3COLD_AUX_POWER_AND_TIMING_INTERFACE = _D3COLD_AUX_POWER_AND_TIMING_INTERFACE;
pub type PD3COLD_AUX_POWER_AND_TIMING_INTERFACE = *mut _D3COLD_AUX_POWER_AND_TIMING_INTERFACE;
pub type FPGA_BUS_SCAN = ::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
pub type PFPGA_BUS_SCAN = FPGA_BUS_SCAN;
pub type FPGA_CONTROL_LINK =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, Enable: BOOLEAN) -> NTSTATUS>;
pub type PFPGA_CONTROL_LINK = FPGA_CONTROL_LINK;
pub type FPGA_CONTROL_CONFIG_SPACE =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, Enable: BOOLEAN) -> NTSTATUS>;
pub type PFPGA_CONTROL_CONFIG_SPACE = FPGA_CONTROL_CONFIG_SPACE;
pub type FPGA_CONTROL_ERROR_REPORTING = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        UncorrectableMask: ULONG,
        CorrectableMask: ULONG,
        DisableErrorReporting: BOOLEAN,
    ) -> NTSTATUS,
>;
pub type PFPGA_CONTROL_ERROR_REPORTING = FPGA_CONTROL_ERROR_REPORTING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FPGA_CONTROL_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub BusScan: PFPGA_BUS_SCAN,
    pub ControlLink: PFPGA_CONTROL_LINK,
    pub ControlConfigSpace: PFPGA_CONTROL_CONFIG_SPACE,
    pub ControlErrorReporting: PFPGA_CONTROL_ERROR_REPORTING,
}
pub type FPGA_CONTROL_INTERFACE = _FPGA_CONTROL_INTERFACE;
pub type PFPGA_CONTROL_INTERFACE = *mut _FPGA_CONTROL_INTERFACE;
pub type PTM_DEVICE_QUERY_GRANULARITY =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, Granularity: PUCHAR) -> NTSTATUS>;
pub type PPTM_DEVICE_QUERY_GRANULARITY = PTM_DEVICE_QUERY_GRANULARITY;
pub type PTM_DEVICE_QUERY_TIME_SOURCE =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, TimeSource: PULONG) -> NTSTATUS>;
pub type PPTM_DEVICE_QUERY_TIME_SOURCE = PTM_DEVICE_QUERY_TIME_SOURCE;
pub type PTM_DEVICE_ENABLE =
::core::option::Option<unsafe extern "C" fn(Context: PVOID) -> NTSTATUS>;
pub type PPTM_DEVICE_ENABLE = PTM_DEVICE_ENABLE;
pub type PTM_DEVICE_DISABLE =
::core::option::Option<unsafe extern "C" fn(Context: PVOID) -> NTSTATUS>;
pub type PPTM_DEVICE_DISABLE = PTM_DEVICE_DISABLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PTM_CONTROL_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub QueryGranularity: PPTM_DEVICE_QUERY_GRANULARITY,
    pub QueryTimeSource: PPTM_DEVICE_QUERY_TIME_SOURCE,
    pub Enable: PPTM_DEVICE_ENABLE,
    pub Disable: PPTM_DEVICE_DISABLE,
}
pub type PTM_CONTROL_INTERFACE = _PTM_CONTROL_INTERFACE;
pub type PPTM_CONTROL_INTERFACE = *mut _PTM_CONTROL_INTERFACE;
pub type GET_UPDATED_BUS_RESOURCE = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        UpdatedResourceList: *mut PCM_RESOURCE_LIST,
        UpdatedTranslatedResourceList: *mut PCM_RESOURCE_LIST,
    ) -> NTSTATUS,
>;
pub type PGET_UPDATED_BUS_RESOURCE = GET_UPDATED_BUS_RESOURCE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BUS_RESOURCE_UPDATE_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub GetUpdatedBusResource: PGET_UPDATED_BUS_RESOURCE,
}
pub type BUS_RESOURCE_UPDATE_INTERFACE = _BUS_RESOURCE_UPDATE_INTERFACE;
pub type PBUS_RESOURCE_UPDATE_INTERFACE = *mut _BUS_RESOURCE_UPDATE_INTERFACE;
pub const _NPEM_CONTROL_STANDARD_CONTROL_BIT_InitiateReset: _NPEM_CONTROL_STANDARD_CONTROL_BIT = 1;
pub const _NPEM_CONTROL_STANDARD_CONTROL_BIT_OkControl: _NPEM_CONTROL_STANDARD_CONTROL_BIT = 2;
pub const _NPEM_CONTROL_STANDARD_CONTROL_BIT_LocateControl: _NPEM_CONTROL_STANDARD_CONTROL_BIT = 3;
pub const _NPEM_CONTROL_STANDARD_CONTROL_BIT_FailControl: _NPEM_CONTROL_STANDARD_CONTROL_BIT = 4;
pub const _NPEM_CONTROL_STANDARD_CONTROL_BIT_RebuildControl: _NPEM_CONTROL_STANDARD_CONTROL_BIT = 5;
pub const _NPEM_CONTROL_STANDARD_CONTROL_BIT_PFAControl: _NPEM_CONTROL_STANDARD_CONTROL_BIT = 6;
pub const _NPEM_CONTROL_STANDARD_CONTROL_BIT_HotSpareControl: _NPEM_CONTROL_STANDARD_CONTROL_BIT =
    7;
pub const _NPEM_CONTROL_STANDARD_CONTROL_BIT_InACriticalArrayControl:
_NPEM_CONTROL_STANDARD_CONTROL_BIT = 8;
pub const _NPEM_CONTROL_STANDARD_CONTROL_BIT_InAFailedArrayControl:
_NPEM_CONTROL_STANDARD_CONTROL_BIT = 9;
pub const _NPEM_CONTROL_STANDARD_CONTROL_BIT_InvalidDeviceTypeControl:
_NPEM_CONTROL_STANDARD_CONTROL_BIT = 10;
pub const _NPEM_CONTROL_STANDARD_CONTROL_BIT_DisabledControl: _NPEM_CONTROL_STANDARD_CONTROL_BIT =
    11;
pub type _NPEM_CONTROL_STANDARD_CONTROL_BIT = core::ffi::c_int;
pub use self::_NPEM_CONTROL_STANDARD_CONTROL_BIT as NPEM_CONTROL_STANDARD_CONTROL_BIT;
pub type PNPEM_CONTROL_STANDARD_CONTROL_BIT = *mut _NPEM_CONTROL_STANDARD_CONTROL_BIT;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NPEM_CAPABILITY_STANDARD {
    pub __bindgen_anon_1: _NPEM_CAPABILITY_STANDARD__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NPEM_CAPABILITY_STANDARD__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _NPEM_CAPABILITY_STANDARD__bindgen_ty_1 {
    #[inline]
    pub fn Capable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Capable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Capable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Capable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ResetCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ResetCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ResetCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ResetCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn OkCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OkCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn OkCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_OkCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LocateCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LocateCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LocateCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_LocateCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FailCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FailCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FailCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FailCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RebuildCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RebuildCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RebuildCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RebuildCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PFACapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PFACapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PFACapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PFACapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn HotSpareCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HotSpareCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn HotSpareCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_HotSpareCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn InACriticalArrayCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InACriticalArrayCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InACriticalArrayCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_InACriticalArrayCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn InAFailedArrayCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InAFailedArrayCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InAFailedArrayCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_InAFailedArrayCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn InvalidDeviceTypeCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InvalidDeviceTypeCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InvalidDeviceTypeCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_InvalidDeviceTypeCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DisabledCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisabledCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DisabledCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DisabledCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                20u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                20u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Capable: ULONG,
        ResetCapable: ULONG,
        OkCapable: ULONG,
        LocateCapable: ULONG,
        FailCapable: ULONG,
        RebuildCapable: ULONG,
        PFACapable: ULONG,
        HotSpareCapable: ULONG,
        InACriticalArrayCapable: ULONG,
        InAFailedArrayCapable: ULONG,
        InvalidDeviceTypeCapable: ULONG,
        DisabledCapable: ULONG,
        Rsvd: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Capable: u32 = unsafe { ::core::mem::transmute(Capable) };
            Capable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ResetCapable: u32 = unsafe { ::core::mem::transmute(ResetCapable) };
            ResetCapable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let OkCapable: u32 = unsafe { ::core::mem::transmute(OkCapable) };
            OkCapable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let LocateCapable: u32 = unsafe { ::core::mem::transmute(LocateCapable) };
            LocateCapable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let FailCapable: u32 = unsafe { ::core::mem::transmute(FailCapable) };
            FailCapable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let RebuildCapable: u32 = unsafe { ::core::mem::transmute(RebuildCapable) };
            RebuildCapable as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PFACapable: u32 = unsafe { ::core::mem::transmute(PFACapable) };
            PFACapable as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let HotSpareCapable: u32 = unsafe { ::core::mem::transmute(HotSpareCapable) };
            HotSpareCapable as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let InACriticalArrayCapable: u32 =
                unsafe { ::core::mem::transmute(InACriticalArrayCapable) };
            InACriticalArrayCapable as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let InAFailedArrayCapable: u32 =
                unsafe { ::core::mem::transmute(InAFailedArrayCapable) };
            InAFailedArrayCapable as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let InvalidDeviceTypeCapable: u32 =
                unsafe { ::core::mem::transmute(InvalidDeviceTypeCapable) };
            InvalidDeviceTypeCapable as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let DisabledCapable: u32 = unsafe { ::core::mem::transmute(DisabledCapable) };
            DisabledCapable as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let Rsvd: u32 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NPEM_CAPABILITY_STANDARD = _NPEM_CAPABILITY_STANDARD;
pub type PNPEM_CAPABILITY_STANDARD = *mut _NPEM_CAPABILITY_STANDARD;
pub type NPEM_CONTROL_ENABLE_DISABLE =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, EnableNpem: BOOLEAN) -> NTSTATUS>;
pub type PNPEM_CONTROL_ENABLE_DISABLE = NPEM_CONTROL_ENABLE_DISABLE;
pub type NPEM_CONTROL_QUERY_STANDARD_CAPABILITIES = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        StandardCapabilities: PNPEM_CAPABILITY_STANDARD,
    ) -> NTSTATUS,
>;
pub type PNPEM_CONTROL_QUERY_STANDARD_CAPABILITIES = NPEM_CONTROL_QUERY_STANDARD_CAPABILITIES;
pub type NPEM_CONTROL_SET_STANDARD_CONTROL = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        StandardControl: NPEM_CONTROL_STANDARD_CONTROL_BIT,
        Set: BOOLEAN,
    ) -> NTSTATUS,
>;
pub type PNPEM_CONTROL_SET_STANDARD_CONTROL = NPEM_CONTROL_SET_STANDARD_CONTROL;
pub type NPEM_CONTROL_QUERY_CONTROL =
::core::option::Option<unsafe extern "C" fn(Context: PVOID) -> ULONG>;
pub type PNPEM_CONTROL_QUERY_CONTROL = NPEM_CONTROL_QUERY_CONTROL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NPEM_CONTROL_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub SetNpemSupportState: PNPEM_CONTROL_ENABLE_DISABLE,
    pub QueryStandardCapabilities: PNPEM_CONTROL_QUERY_STANDARD_CAPABILITIES,
    pub SetStandardControl: PNPEM_CONTROL_SET_STANDARD_CONTROL,
    pub QueryNpemControl: PNPEM_CONTROL_QUERY_CONTROL,
}
pub type NPEM_CONTROL_INTERFACE = _NPEM_CONTROL_INTERFACE;
pub type PNPEM_CONTROL_INTERFACE = *mut _NPEM_CONTROL_INTERFACE;
pub type PGPE_SERVICE_ROUTINE =
::core::option::Option<unsafe extern "C" fn(arg1: PVOID, arg2: PVOID) -> BOOLEAN>;
pub type PGPE_CONNECT_VECTOR = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: PDEVICE_OBJECT,
        arg2: ULONG,
        arg3: KINTERRUPT_MODE,
        arg4: BOOLEAN,
        arg5: PGPE_SERVICE_ROUTINE,
        arg6: PVOID,
        arg7: PVOID,
    ) -> NTSTATUS,
>;
pub type PGPE_DISCONNECT_VECTOR =
::core::option::Option<unsafe extern "C" fn(arg1: PVOID) -> NTSTATUS>;
pub type PGPE_ENABLE_EVENT =
::core::option::Option<unsafe extern "C" fn(arg1: PDEVICE_OBJECT, arg2: PVOID) -> NTSTATUS>;
pub type PGPE_DISABLE_EVENT =
::core::option::Option<unsafe extern "C" fn(arg1: PDEVICE_OBJECT, arg2: PVOID) -> NTSTATUS>;
pub type PGPE_CLEAR_STATUS =
::core::option::Option<unsafe extern "C" fn(arg1: PDEVICE_OBJECT, arg2: PVOID) -> NTSTATUS>;
pub type PDEVICE_NOTIFY_CALLBACK =
::core::option::Option<unsafe extern "C" fn(arg1: PVOID, arg2: ULONG)>;
pub type PREGISTER_FOR_DEVICE_NOTIFICATIONS = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: PDEVICE_OBJECT,
        arg2: PDEVICE_NOTIFY_CALLBACK,
        arg3: PVOID,
    ) -> NTSTATUS,
>;
pub type PUNREGISTER_FOR_DEVICE_NOTIFICATIONS = ::core::option::Option<
    unsafe extern "C" fn(arg1: PDEVICE_OBJECT, arg2: PDEVICE_NOTIFY_CALLBACK),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACPI_INTERFACE_STANDARD {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub GpeConnectVector: PGPE_CONNECT_VECTOR,
    pub GpeDisconnectVector: PGPE_DISCONNECT_VECTOR,
    pub GpeEnableEvent: PGPE_ENABLE_EVENT,
    pub GpeDisableEvent: PGPE_DISABLE_EVENT,
    pub GpeClearStatus: PGPE_CLEAR_STATUS,
    pub RegisterForDeviceNotifications: PREGISTER_FOR_DEVICE_NOTIFICATIONS,
    pub UnregisterForDeviceNotifications: PUNREGISTER_FOR_DEVICE_NOTIFICATIONS,
}
pub type ACPI_INTERFACE_STANDARD = _ACPI_INTERFACE_STANDARD;
pub type PACPI_INTERFACE_STANDARD = *mut _ACPI_INTERFACE_STANDARD;
pub type PGPE_SERVICE_ROUTINE2 = ::core::option::Option<
    unsafe extern "C" fn(ObjectContext: PVOID, ServiceContext: PVOID) -> BOOLEAN,
>;
pub type PGPE_CONNECT_VECTOR2 = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        GpeNumber: ULONG,
        Mode: KINTERRUPT_MODE,
        Shareable: BOOLEAN,
        ServiceRoutine: PGPE_SERVICE_ROUTINE,
        ServiceContext: PVOID,
        ObjectContext: *mut PVOID,
    ) -> NTSTATUS,
>;
pub type PGPE_DISCONNECT_VECTOR2 =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, ObjectContext: PVOID) -> NTSTATUS>;
pub type PGPE_ENABLE_EVENT2 =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, ObjectContext: PVOID) -> NTSTATUS>;
pub type PGPE_DISABLE_EVENT2 =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, ObjectContext: PVOID) -> NTSTATUS>;
pub type PGPE_CLEAR_STATUS2 =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, ObjectContext: PVOID) -> NTSTATUS>;
pub type PDEVICE_NOTIFY_CALLBACK2 =
::core::option::Option<unsafe extern "C" fn(NotificationContext: PVOID, NotifyCode: ULONG)>;
pub type PREGISTER_FOR_DEVICE_NOTIFICATIONS2 = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        NotificationHandler: PDEVICE_NOTIFY_CALLBACK2,
        NotificationContext: PVOID,
    ) -> NTSTATUS,
>;
pub type PUNREGISTER_FOR_DEVICE_NOTIFICATIONS2 =
::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACPI_INTERFACE_STANDARD2 {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub GpeConnectVector: PGPE_CONNECT_VECTOR2,
    pub GpeDisconnectVector: PGPE_DISCONNECT_VECTOR2,
    pub GpeEnableEvent: PGPE_ENABLE_EVENT2,
    pub GpeDisableEvent: PGPE_DISABLE_EVENT2,
    pub GpeClearStatus: PGPE_CLEAR_STATUS2,
    pub RegisterForDeviceNotifications: PREGISTER_FOR_DEVICE_NOTIFICATIONS2,
    pub UnregisterForDeviceNotifications: PUNREGISTER_FOR_DEVICE_NOTIFICATIONS2,
}
pub type PACPI_INTERFACE_STANDARD2 = *mut ACPI_INTERFACE_STANDARD2;
unsafe extern "C" {
    pub fn IoInvalidateDeviceRelations(DeviceObject: PDEVICE_OBJECT, Type: DEVICE_RELATION_TYPE);
}
unsafe extern "C" {
    pub fn IoRequestDeviceEject(PhysicalDeviceObject: PDEVICE_OBJECT);
}
pub type PIO_DEVICE_EJECT_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Status: NTSTATUS, Context: PVOID)>;
unsafe extern "C" {
    pub fn IoRequestDeviceEjectEx(
        PhysicalDeviceObject: PDEVICE_OBJECT,
        Callback: PIO_DEVICE_EJECT_CALLBACK,
        Context: PVOID,
        DriverObject: PDRIVER_OBJECT,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoGetDeviceProperty(
        DeviceObject: PDEVICE_OBJECT,
        DeviceProperty: DEVICE_REGISTRY_PROPERTY,
        BufferLength: ULONG,
        PropertyBuffer: PVOID,
        ResultLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoOpenDeviceRegistryKey(
        DeviceObject: PDEVICE_OBJECT,
        DevInstKeyType: ULONG,
        DesiredAccess: ACCESS_MASK,
        DeviceRegKey: PHANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoRegisterDeviceInterface(
        PhysicalDeviceObject: PDEVICE_OBJECT,
        InterfaceClassGuid: *const GUID,
        ReferenceString: PUNICODE_STRING,
        SymbolicLinkName: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoOpenDeviceInterfaceRegistryKey(
        SymbolicLinkName: PUNICODE_STRING,
        DesiredAccess: ACCESS_MASK,
        DeviceInterfaceRegKey: PHANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoSetDeviceInterfaceState(
        SymbolicLinkName: PUNICODE_STRING,
        Enable: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoGetDeviceInterfaces(
        InterfaceClassGuid: *const GUID,
        PhysicalDeviceObject: PDEVICE_OBJECT,
        Flags: ULONG,
        SymbolicLinkList: *mut PZZWSTR,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoGetDeviceInterfaceAlias(
        SymbolicLinkName: PUNICODE_STRING,
        AliasInterfaceClassGuid: *const GUID,
        AliasSymbolicLinkName: PUNICODE_STRING,
    ) -> NTSTATUS;
}
pub const _IO_NOTIFICATION_EVENT_CATEGORY_EventCategoryReserved: _IO_NOTIFICATION_EVENT_CATEGORY =
    0;
pub const _IO_NOTIFICATION_EVENT_CATEGORY_EventCategoryHardwareProfileChange:
_IO_NOTIFICATION_EVENT_CATEGORY = 1;
pub const _IO_NOTIFICATION_EVENT_CATEGORY_EventCategoryDeviceInterfaceChange:
_IO_NOTIFICATION_EVENT_CATEGORY = 2;
pub const _IO_NOTIFICATION_EVENT_CATEGORY_EventCategoryTargetDeviceChange:
_IO_NOTIFICATION_EVENT_CATEGORY = 3;
pub const _IO_NOTIFICATION_EVENT_CATEGORY_EventCategoryKernelSoftRestart:
_IO_NOTIFICATION_EVENT_CATEGORY = 4;
pub type _IO_NOTIFICATION_EVENT_CATEGORY = core::ffi::c_int;
pub use self::_IO_NOTIFICATION_EVENT_CATEGORY as IO_NOTIFICATION_EVENT_CATEGORY;
pub type DRIVER_NOTIFICATION_CALLBACK_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(NotificationStructure: PVOID, Context: PVOID) -> NTSTATUS,
>;
pub type PDRIVER_NOTIFICATION_CALLBACK_ROUTINE = DRIVER_NOTIFICATION_CALLBACK_ROUTINE;
unsafe extern "C" {
    pub fn IoRegisterPlugPlayNotification(
        EventCategory: IO_NOTIFICATION_EVENT_CATEGORY,
        EventCategoryFlags: ULONG,
        EventCategoryData: PVOID,
        DriverObject: PDRIVER_OBJECT,
        CallbackRoutine: PDRIVER_NOTIFICATION_CALLBACK_ROUTINE,
        Context: PVOID,
        NotificationEntry: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoUnregisterPlugPlayNotification(NotificationEntry: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoUnregisterPlugPlayNotificationEx(NotificationEntry: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoReportTargetDeviceChange(
        PhysicalDeviceObject: PDEVICE_OBJECT,
        NotificationStructure: PVOID,
    ) -> NTSTATUS;
}
pub type DEVICE_CHANGE_COMPLETE_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
pub type PDEVICE_CHANGE_COMPLETE_CALLBACK = DEVICE_CHANGE_COMPLETE_CALLBACK;
unsafe extern "C" {
    pub fn IoInvalidateDeviceState(PhysicalDeviceObject: PDEVICE_OBJECT);
}
unsafe extern "C" {
    pub fn IoReportTargetDeviceChangeAsynchronous(
        PhysicalDeviceObject: PDEVICE_OBJECT,
        NotificationStructure: PVOID,
        Callback: PDEVICE_CHANGE_COMPLETE_CALLBACK,
        Context: PVOID,
    ) -> NTSTATUS;
}
pub const _DRIVER_DIRECTORY_TYPE_DriverDirectoryImage: _DRIVER_DIRECTORY_TYPE = 0;
pub const _DRIVER_DIRECTORY_TYPE_DriverDirectoryData: _DRIVER_DIRECTORY_TYPE = 1;
pub const _DRIVER_DIRECTORY_TYPE_DriverDirectorySharedData: _DRIVER_DIRECTORY_TYPE = 2;
pub type _DRIVER_DIRECTORY_TYPE = core::ffi::c_int;
pub use self::_DRIVER_DIRECTORY_TYPE as DRIVER_DIRECTORY_TYPE;
pub type PDRIVER_DIRECTORY_TYPE = *mut _DRIVER_DIRECTORY_TYPE;
unsafe extern "C" {
    pub fn IoGetDriverDirectory(
        DriverObject: PDRIVER_OBJECT,
        DirectoryType: DRIVER_DIRECTORY_TYPE,
        Flags: ULONG,
        DriverDirectoryHandle: PHANDLE,
    ) -> NTSTATUS;
}
pub const _DEVICE_DIRECTORY_TYPE_DeviceDirectoryData: _DEVICE_DIRECTORY_TYPE = 0;
pub type _DEVICE_DIRECTORY_TYPE = core::ffi::c_int;
pub use self::_DEVICE_DIRECTORY_TYPE as DEVICE_DIRECTORY_TYPE;
pub type PDEVICE_DIRECTORY_TYPE = *mut _DEVICE_DIRECTORY_TYPE;
unsafe extern "C" {
    pub fn IoGetDeviceDirectory(
        PhysicalDeviceObject: PDEVICE_OBJECT,
        DirectoryType: DEVICE_DIRECTORY_TYPE,
        Flags: ULONG,
        Reserved: PVOID,
        DeviceDirectoryHandle: PHANDLE,
    ) -> NTSTATUS;
}
pub const _DRIVER_REGKEY_TYPE_DriverRegKeyParameters: _DRIVER_REGKEY_TYPE = 0;
pub const _DRIVER_REGKEY_TYPE_DriverRegKeyPersistentState: _DRIVER_REGKEY_TYPE = 1;
pub const _DRIVER_REGKEY_TYPE_DriverRegKeySharedPersistentState: _DRIVER_REGKEY_TYPE = 2;
pub type _DRIVER_REGKEY_TYPE = core::ffi::c_int;
pub use self::_DRIVER_REGKEY_TYPE as DRIVER_REGKEY_TYPE;
pub type PDRIVER_REGKEY_TYPE = *mut _DRIVER_REGKEY_TYPE;
unsafe extern "C" {
    pub fn IoOpenDriverRegistryKey(
        DriverObject: PDRIVER_OBJECT,
        RegKeyType: DRIVER_REGKEY_TYPE,
        DesiredAccess: ACCESS_MASK,
        Flags: ULONG,
        DriverRegKey: PHANDLE,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PLUGPLAY_NOTIFICATION_HEADER {
    pub Version: USHORT,
    pub Size: USHORT,
    pub Event: GUID,
}
pub type PLUGPLAY_NOTIFICATION_HEADER = _PLUGPLAY_NOTIFICATION_HEADER;
pub type PPLUGPLAY_NOTIFICATION_HEADER = *mut _PLUGPLAY_NOTIFICATION_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HWPROFILE_CHANGE_NOTIFICATION {
    pub Version: USHORT,
    pub Size: USHORT,
    pub Event: GUID,
}
pub type HWPROFILE_CHANGE_NOTIFICATION = _HWPROFILE_CHANGE_NOTIFICATION;
pub type PHWPROFILE_CHANGE_NOTIFICATION = *mut _HWPROFILE_CHANGE_NOTIFICATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION {
    pub Version: USHORT,
    pub Size: USHORT,
    pub Event: GUID,
    pub InterfaceClassGuid: GUID,
    pub SymbolicLinkName: PUNICODE_STRING,
}
pub type DEVICE_INTERFACE_CHANGE_NOTIFICATION = _DEVICE_INTERFACE_CHANGE_NOTIFICATION;
pub type PDEVICE_INTERFACE_CHANGE_NOTIFICATION = *mut _DEVICE_INTERFACE_CHANGE_NOTIFICATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TARGET_DEVICE_REMOVAL_NOTIFICATION {
    pub Version: USHORT,
    pub Size: USHORT,
    pub Event: GUID,
    pub FileObject: PFILE_OBJECT,
}
pub type TARGET_DEVICE_REMOVAL_NOTIFICATION = _TARGET_DEVICE_REMOVAL_NOTIFICATION;
pub type PTARGET_DEVICE_REMOVAL_NOTIFICATION = *mut _TARGET_DEVICE_REMOVAL_NOTIFICATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KERNEL_SOFT_RESTART_NOTIFICATION {
    pub Version: USHORT,
    pub Size: USHORT,
    pub Event: GUID,
}
pub type KERNEL_SOFT_RESTART_NOTIFICATION = _KERNEL_SOFT_RESTART_NOTIFICATION;
pub type PKERNEL_SOFT_RESTART_NOTIFICATION = *mut _KERNEL_SOFT_RESTART_NOTIFICATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TARGET_DEVICE_CUSTOM_NOTIFICATION {
    pub Version: USHORT,
    pub Size: USHORT,
    pub Event: GUID,
    pub FileObject: PFILE_OBJECT,
    pub NameBufferOffset: LONG,
    pub CustomDataBuffer: [UCHAR; 1usize],
}
pub type TARGET_DEVICE_CUSTOM_NOTIFICATION = _TARGET_DEVICE_CUSTOM_NOTIFICATION;
pub type PTARGET_DEVICE_CUSTOM_NOTIFICATION = *mut _TARGET_DEVICE_CUSTOM_NOTIFICATION;
pub type DEVPROPTYPE = ULONG;
pub type PDEVPROPTYPE = *mut ULONG;
pub type DEVPROP_BOOLEAN = CHAR;
pub type PDEVPROP_BOOLEAN = *mut CHAR;
pub type DEVPROPGUID = GUID;
pub type PDEVPROPGUID = *mut GUID;
pub type DEVPROPID = ULONG;
pub type PDEVPROPID = *mut ULONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVPROPKEY {
    pub fmtid: DEVPROPGUID,
    pub pid: DEVPROPID,
}
pub type DEVPROPKEY = _DEVPROPKEY;
pub type PDEVPROPKEY = *mut _DEVPROPKEY;
pub const _DEVPROPSTORE_DEVPROP_STORE_SYSTEM: _DEVPROPSTORE = 0;
pub const _DEVPROPSTORE_DEVPROP_STORE_USER: _DEVPROPSTORE = 1;
pub type _DEVPROPSTORE = core::ffi::c_int;
pub use self::_DEVPROPSTORE as DEVPROPSTORE;
pub type PDEVPROPSTORE = *mut _DEVPROPSTORE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVPROPCOMPKEY {
    pub Key: DEVPROPKEY,
    pub Store: DEVPROPSTORE,
    pub LocaleName: PCWSTR,
}
pub type DEVPROPCOMPKEY = _DEVPROPCOMPKEY;
pub type PDEVPROPCOMPKEY = *mut _DEVPROPCOMPKEY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVPROPERTY {
    pub CompKey: DEVPROPCOMPKEY,
    pub Type: DEVPROPTYPE,
    pub BufferSize: ULONG,
    pub Buffer: PVOID,
}
pub type DEVPROPERTY = _DEVPROPERTY;
pub type PDEVPROPERTY = *mut _DEVPROPERTY;
unsafe extern "C" {
    pub fn IoSetDevicePropertyData(
        Pdo: PDEVICE_OBJECT,
        PropertyKey: *const DEVPROPKEY,
        Lcid: LCID,
        Flags: ULONG,
        Type: DEVPROPTYPE,
        Size: ULONG,
        Data: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoGetDevicePropertyData(
        Pdo: PDEVICE_OBJECT,
        PropertyKey: *const DEVPROPKEY,
        Lcid: LCID,
        Flags: ULONG,
        Size: ULONG,
        Data: PVOID,
        RequiredSize: PULONG,
        Type: PDEVPROPTYPE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoSetDeviceInterfacePropertyData(
        SymbolicLinkName: PUNICODE_STRING,
        PropertyKey: *const DEVPROPKEY,
        Lcid: LCID,
        Flags: ULONG,
        Type: DEVPROPTYPE,
        Size: ULONG,
        Data: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoGetDeviceInterfacePropertyData(
        SymbolicLinkName: PUNICODE_STRING,
        PropertyKey: *const DEVPROPKEY,
        Lcid: LCID,
        Flags: ULONG,
        Size: ULONG,
        Data: PVOID,
        RequiredSize: PULONG,
        Type: PDEVPROPTYPE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoGetDeviceNumaNode(Pdo: PDEVICE_OBJECT, NodeNumber: PUSHORT) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoReplacePartitionUnit(
        TargetPdo: PDEVICE_OBJECT,
        SparePdo: PDEVICE_OBJECT,
        Flags: ULONG,
    ) -> NTSTATUS;
}
pub type PPNP_REPLACE_DRIVER_INTERFACE = *mut _PNP_REPLACE_DRIVER_INTERFACE;
pub type PREPLACE_DRIVER_INIT = ::core::option::Option<
    unsafe extern "C" fn(Interface: PPNP_REPLACE_DRIVER_INTERFACE, Unused: PVOID) -> NTSTATUS,
>;
pub type PREPLACE_MAP_MEMORY = ::core::option::Option<
    unsafe extern "C" fn(
        TargetPhysicalAddress: PHYSICAL_ADDRESS,
        SparePhysicalAddress: PHYSICAL_ADDRESS,
        NumberOfBytes: PLARGE_INTEGER,
        TargetAddress: *mut PVOID,
        SpareAddress: *mut PVOID,
    ) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PNP_REPLACE_MEMORY_LIST {
    pub AllocatedCount: ULONG,
    pub Count: ULONG,
    pub TotalLength: ULONGLONG,
    pub Ranges: [_PNP_REPLACE_MEMORY_LIST__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PNP_REPLACE_MEMORY_LIST__bindgen_ty_1 {
    pub Address: PHYSICAL_ADDRESS,
    pub Length: ULONGLONG,
}
pub type PNP_REPLACE_MEMORY_LIST = _PNP_REPLACE_MEMORY_LIST;
pub type PPNP_REPLACE_MEMORY_LIST = *mut _PNP_REPLACE_MEMORY_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PNP_REPLACE_PROCESSOR_LIST {
    pub Affinity: PKAFFINITY,
    pub GroupCount: ULONG,
    pub AllocatedCount: ULONG,
    pub Count: ULONG,
    pub ApicIds: [ULONG; 1usize],
}
pub type PNP_REPLACE_PROCESSOR_LIST = _PNP_REPLACE_PROCESSOR_LIST;
pub type PPNP_REPLACE_PROCESSOR_LIST = *mut _PNP_REPLACE_PROCESSOR_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PNP_REPLACE_PROCESSOR_LIST_V1 {
    pub AffinityMask: KAFFINITY,
    pub AllocatedCount: ULONG,
    pub Count: ULONG,
    pub ApicIds: [ULONG; 1usize],
}
pub type PNP_REPLACE_PROCESSOR_LIST_V1 = _PNP_REPLACE_PROCESSOR_LIST_V1;
pub type PPNP_REPLACE_PROCESSOR_LIST_V1 = *mut _PNP_REPLACE_PROCESSOR_LIST_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PNP_REPLACE_PARAMETERS {
    pub Size: ULONG,
    pub Version: ULONG,
    pub Target: ULONG64,
    pub Spare: ULONG64,
    pub TargetProcessors: PPNP_REPLACE_PROCESSOR_LIST,
    pub SpareProcessors: PPNP_REPLACE_PROCESSOR_LIST,
    pub TargetMemory: PPNP_REPLACE_MEMORY_LIST,
    pub SpareMemory: PPNP_REPLACE_MEMORY_LIST,
    pub MapMemory: PREPLACE_MAP_MEMORY,
}
pub type PNP_REPLACE_PARAMETERS = _PNP_REPLACE_PARAMETERS;
pub type PPNP_REPLACE_PARAMETERS = *mut _PNP_REPLACE_PARAMETERS;
pub type PREPLACE_UNLOAD = ::core::option::Option<unsafe extern "C" fn()>;
pub type PREPLACE_BEGIN = ::core::option::Option<
    unsafe extern "C" fn(Parameters: PPNP_REPLACE_PARAMETERS, Context: *mut PVOID) -> NTSTATUS,
>;
pub type PREPLACE_END = ::core::option::Option<unsafe extern "C" fn(Context: PVOID) -> NTSTATUS>;
pub type PREPLACE_MIRROR_PHYSICAL_MEMORY = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        PhysicalAddress: PHYSICAL_ADDRESS,
        ByteCount: LARGE_INTEGER,
    ) -> NTSTATUS,
>;
pub type PREPLACE_SET_PROCESSOR_ID = ::core::option::Option<
    unsafe extern "C" fn(Context: PVOID, ApicId: ULONG, Target: BOOLEAN) -> NTSTATUS,
>;
pub type PREPLACE_SWAP = ::core::option::Option<unsafe extern "C" fn(Context: PVOID) -> NTSTATUS>;
pub type PREPLACE_INITIATE_HARDWARE_MIRROR =
::core::option::Option<unsafe extern "C" fn(Context: PVOID) -> NTSTATUS>;
pub type PREPLACE_MIRROR_PLATFORM_MEMORY =
::core::option::Option<unsafe extern "C" fn(Context: PVOID) -> NTSTATUS>;
pub type PREPLACE_GET_MEMORY_DESTINATION = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        SourceAddress: PHYSICAL_ADDRESS,
        DestinationAddress: PPHYSICAL_ADDRESS,
    ) -> NTSTATUS,
>;
pub type PREPLACE_ENABLE_DISABLE_HARDWARE_QUIESCE =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, Enable: BOOLEAN) -> NTSTATUS>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PNP_REPLACE_DRIVER_INTERFACE {
    pub Size: ULONG,
    pub Version: ULONG,
    pub Flags: ULONG,
    pub Unload: PREPLACE_UNLOAD,
    pub BeginReplace: PREPLACE_BEGIN,
    pub EndReplace: PREPLACE_END,
    pub MirrorPhysicalMemory: PREPLACE_MIRROR_PHYSICAL_MEMORY,
    pub SetProcessorId: PREPLACE_SET_PROCESSOR_ID,
    pub Swap: PREPLACE_SWAP,
    pub InitiateHardwareMirror: PREPLACE_INITIATE_HARDWARE_MIRROR,
    pub MirrorPlatformMemory: PREPLACE_MIRROR_PLATFORM_MEMORY,
    pub GetMemoryDestination: PREPLACE_GET_MEMORY_DESTINATION,
    pub EnableDisableHardwareQuiesce: PREPLACE_ENABLE_DISABLE_HARDWARE_QUIESCE,
}
pub type PNP_REPLACE_DRIVER_INTERFACE = _PNP_REPLACE_DRIVER_INTERFACE;
pub type PCRASHDUMP_POWER_ON =
::core::option::Option<unsafe extern "C" fn(Context: PVOID) -> NTSTATUS>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRASHDUMP_FUNCTIONS_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub PowerOn: PCRASHDUMP_POWER_ON,
}
pub type CRASHDUMP_FUNCTIONS_INTERFACE = _CRASHDUMP_FUNCTIONS_INTERFACE;
pub type PCRASHDUMP_FUNCTIONS_INTERFACE = *mut _CRASHDUMP_FUNCTIONS_INTERFACE;
pub const _DEVICE_RESET_TYPE_FunctionLevelDeviceReset: _DEVICE_RESET_TYPE = 0;
pub const _DEVICE_RESET_TYPE_PlatformLevelDeviceReset: _DEVICE_RESET_TYPE = 1;
pub type _DEVICE_RESET_TYPE = core::ffi::c_int;
pub use self::_DEVICE_RESET_TYPE as DEVICE_RESET_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DEVICE_BUS_SPECIFIC_RESET_TYPE {
    pub Pci: _DEVICE_BUS_SPECIFIC_RESET_TYPE__bindgen_ty_1,
    pub Acpi: _DEVICE_BUS_SPECIFIC_RESET_TYPE__bindgen_ty_2,
    pub AsULONGLONG: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_BUS_SPECIFIC_RESET_TYPE__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _DEVICE_BUS_SPECIFIC_RESET_TYPE__bindgen_ty_1 {
    #[inline]
    pub fn FunctionLevelDeviceReset(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_FunctionLevelDeviceReset(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FunctionLevelDeviceReset_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_FunctionLevelDeviceReset_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PlatformLevelDeviceReset(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PlatformLevelDeviceReset(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PlatformLevelDeviceReset_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_PlatformLevelDeviceReset_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SecondaryBusReset(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_SecondaryBusReset(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SecondaryBusReset_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_SecondaryBusReset_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 61u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 61u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                61u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                61u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FunctionLevelDeviceReset: ULONGLONG,
        PlatformLevelDeviceReset: ULONGLONG,
        SecondaryBusReset: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let FunctionLevelDeviceReset: u64 =
                unsafe { ::core::mem::transmute(FunctionLevelDeviceReset) };
            FunctionLevelDeviceReset as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PlatformLevelDeviceReset: u64 =
                unsafe { ::core::mem::transmute(PlatformLevelDeviceReset) };
            PlatformLevelDeviceReset as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SecondaryBusReset: u64 = unsafe { ::core::mem::transmute(SecondaryBusReset) };
            SecondaryBusReset as u64
        });
        __bindgen_bitfield_unit.set(3usize, 61u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_BUS_SPECIFIC_RESET_TYPE__bindgen_ty_2 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _DEVICE_BUS_SPECIFIC_RESET_TYPE__bindgen_ty_2 {
    #[inline]
    pub fn FunctionLevelDeviceReset(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_FunctionLevelDeviceReset(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FunctionLevelDeviceReset_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_FunctionLevelDeviceReset_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PlatformLevelDeviceReset(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PlatformLevelDeviceReset(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PlatformLevelDeviceReset_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_PlatformLevelDeviceReset_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 62u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 62u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                62u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                62u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FunctionLevelDeviceReset: ULONGLONG,
        PlatformLevelDeviceReset: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let FunctionLevelDeviceReset: u64 =
                unsafe { ::core::mem::transmute(FunctionLevelDeviceReset) };
            FunctionLevelDeviceReset as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PlatformLevelDeviceReset: u64 =
                unsafe { ::core::mem::transmute(PlatformLevelDeviceReset) };
            PlatformLevelDeviceReset as u64
        });
        __bindgen_bitfield_unit.set(2usize, 62u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type DEVICE_BUS_SPECIFIC_RESET_TYPE = _DEVICE_BUS_SPECIFIC_RESET_TYPE;
pub type PDEVICE_BUS_SPECIFIC_RESET_TYPE = *mut _DEVICE_BUS_SPECIFIC_RESET_TYPE;
pub type DEVICE_RESET_COMPLETION =
::core::option::Option<unsafe extern "C" fn(Status: NTSTATUS, Context: PVOID)>;
pub type PDEVICE_RESET_COMPLETION = DEVICE_RESET_COMPLETION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FUNCTION_LEVEL_DEVICE_RESET_PARAMETERS {
    pub Size: ULONG,
    pub DeviceResetCompletion: PDEVICE_RESET_COMPLETION,
    pub CompletionContext: PVOID,
}
pub type FUNCTION_LEVEL_DEVICE_RESET_PARAMETERS = _FUNCTION_LEVEL_DEVICE_RESET_PARAMETERS;
pub type PFUNCTION_LEVEL_DEVICE_RESET_PARAMETERS = *mut _FUNCTION_LEVEL_DEVICE_RESET_PARAMETERS;
pub type DEVICE_RESET_HANDLER = ::core::option::Option<
    unsafe extern "C" fn(
        InterfaceContext: PVOID,
        ResetType: DEVICE_RESET_TYPE,
        Flags: ULONG,
        ResetParameters: PVOID,
    ) -> NTSTATUS,
>;
pub type PDEVICE_RESET_HANDLER = DEVICE_RESET_HANDLER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DEVICE_BUS_SPECIFIC_RESET_INFO {
    pub BusTypeGuid: GUID,
    pub ResetTypeSupported: DEVICE_BUS_SPECIFIC_RESET_TYPE,
}
pub type DEVICE_BUS_SPECIFIC_RESET_INFO = _DEVICE_BUS_SPECIFIC_RESET_INFO;
pub type PDEVICE_BUS_SPECIFIC_RESET_INFO = *mut _DEVICE_BUS_SPECIFIC_RESET_INFO;
pub type DEVICE_QUERY_BUS_SPECIFIC_RESET_HANDLER = ::core::option::Option<
    unsafe extern "C" fn(
        InterfaceContext: PVOID,
        ResetInfoCount: PULONG,
        ResetInfoSupported: PDEVICE_BUS_SPECIFIC_RESET_INFO,
    ) -> NTSTATUS,
>;
pub type PDEVICE_QUERY_BUS_SPECIFIC_RESET_HANDLER = DEVICE_QUERY_BUS_SPECIFIC_RESET_HANDLER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _BUS_SPECIFIC_RESET_FLAGS {
    pub u: _BUS_SPECIFIC_RESET_FLAGS__bindgen_ty_1,
    pub AsUlonglong: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BUS_SPECIFIC_RESET_FLAGS__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _BUS_SPECIFIC_RESET_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn KeepStackReset(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_KeepStackReset(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn KeepStackReset_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_KeepStackReset_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 63u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 63u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                63u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                63u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        KeepStackReset: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let KeepStackReset: u64 = unsafe { ::core::mem::transmute(KeepStackReset) };
            KeepStackReset as u64
        });
        __bindgen_bitfield_unit.set(1usize, 63u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type BUS_SPECIFIC_RESET_FLAGS = _BUS_SPECIFIC_RESET_FLAGS;
pub type PBUS_SPECIFIC_RESET_FLAGS = *mut _BUS_SPECIFIC_RESET_FLAGS;
pub type DEVICE_BUS_SPECIFIC_RESET_HANDLER = ::core::option::Option<
    unsafe extern "C" fn(
        InterfaceContext: PVOID,
        BusType: *const GUID,
        ResetTypeSelected: DEVICE_BUS_SPECIFIC_RESET_TYPE,
        Flags: PBUS_SPECIFIC_RESET_FLAGS,
        ResetParameters: PVOID,
    ) -> NTSTATUS,
>;
pub type PDEVICE_BUS_SPECIFIC_RESET_HANDLER = DEVICE_BUS_SPECIFIC_RESET_HANDLER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DEVICE_RESET_STATUS_FLAGS {
    pub u: _DEVICE_RESET_STATUS_FLAGS__bindgen_ty_1,
    pub AsUlonglong: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_RESET_STATUS_FLAGS__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _DEVICE_RESET_STATUS_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn KeepStackReset(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_KeepStackReset(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn KeepStackReset_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_KeepStackReset_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RecoveringFromBusError(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RecoveringFromBusError(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RecoveringFromBusError_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_RecoveringFromBusError_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 62u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 62u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                62u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                62u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        KeepStackReset: ULONGLONG,
        RecoveringFromBusError: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let KeepStackReset: u64 = unsafe { ::core::mem::transmute(KeepStackReset) };
            KeepStackReset as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let RecoveringFromBusError: u64 =
                unsafe { ::core::mem::transmute(RecoveringFromBusError) };
            RecoveringFromBusError as u64
        });
        __bindgen_bitfield_unit.set(2usize, 62u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type DEVICE_RESET_STATUS_FLAGS = _DEVICE_RESET_STATUS_FLAGS;
pub type PDEVICE_RESET_STATUS_FLAGS = *mut _DEVICE_RESET_STATUS_FLAGS;
pub type GET_DEVICE_RESET_STATUS = ::core::option::Option<
    unsafe extern "C" fn(
        InterfaceContext: PVOID,
        IsResetting: PBOOLEAN,
        ResetTypeSelected: PDEVICE_BUS_SPECIFIC_RESET_TYPE,
        Flags: PDEVICE_RESET_STATUS_FLAGS,
    ) -> NTSTATUS,
>;
pub type PGET_DEVICE_RESET_STATUS = GET_DEVICE_RESET_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_RESET_INTERFACE_STANDARD {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub DeviceReset: PDEVICE_RESET_HANDLER,
    pub SupportedResetTypes: ULONG,
    pub Reserved: PVOID,
    pub QueryBusSpecificResetInfo: PDEVICE_QUERY_BUS_SPECIFIC_RESET_HANDLER,
    pub DeviceBusSpecificReset: PDEVICE_BUS_SPECIFIC_RESET_HANDLER,
    pub GetDeviceResetStatus: PGET_DEVICE_RESET_STATUS,
}
pub type DEVICE_RESET_INTERFACE_STANDARD = _DEVICE_RESET_INTERFACE_STANDARD;
pub type PDEVICE_RESET_INTERFACE_STANDARD = *mut _DEVICE_RESET_INTERFACE_STANDARD;
pub type SECURE_DRIVER_PROCESS_REFERENCE =
::core::option::Option<unsafe extern "C" fn(InterfaceContext: PVOID) -> PEPROCESS>;
pub type PSECURE_DRIVER_PROCESS_REFERENCE = SECURE_DRIVER_PROCESS_REFERENCE;
pub type SECURE_DRIVER_PROCESS_DEREFERENCE =
::core::option::Option<unsafe extern "C" fn(InterfaceContext: PVOID, Process: PEPROCESS)>;
pub type PSECURE_DRIVER_PROCESS_DEREFERENCE = SECURE_DRIVER_PROCESS_DEREFERENCE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURE_DRIVER_INTERFACE {
    pub InterfaceHeader: INTERFACE,
    pub ProcessReference: PSECURE_DRIVER_PROCESS_REFERENCE,
    pub ProcessDereference: PSECURE_DRIVER_PROCESS_DEREFERENCE,
    pub Reserved: ULONG,
}
pub type SECURE_DRIVER_INTERFACE = _SECURE_DRIVER_INTERFACE;
pub type PSECURE_DRIVER_INTERFACE = *mut _SECURE_DRIVER_INTERFACE;
pub type GET_SDEV_IDENTIFIER =
::core::option::Option<unsafe extern "C" fn(InterfaceContext: PVOID) -> ULONGLONG>;
pub type PGET_SDEV_IDENTIFIER = GET_SDEV_IDENTIFIER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDEV_IDENTIFIER_INTERFACE {
    pub InterfaceHeader: INTERFACE,
    pub GetIdentifier: PGET_SDEV_IDENTIFIER,
}
pub type SDEV_IDENTIFIER_INTERFACE = _SDEV_IDENTIFIER_INTERFACE;
pub type PSDEV_IDENTIFIER_INTERFACE = *mut _SDEV_IDENTIFIER_INTERFACE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DEVICE_DESCRIPTION {
    pub Version: ULONG,
    pub Master: BOOLEAN,
    pub ScatterGather: BOOLEAN,
    pub DemandMode: BOOLEAN,
    pub AutoInitialize: BOOLEAN,
    pub Dma32BitAddresses: BOOLEAN,
    pub IgnoreCount: BOOLEAN,
    pub Reserved1: BOOLEAN,
    pub Dma64BitAddresses: BOOLEAN,
    pub BusNumber: ULONG,
    pub DmaChannel: ULONG,
    pub InterfaceType: INTERFACE_TYPE,
    pub DmaWidth: DMA_WIDTH,
    pub DmaSpeed: DMA_SPEED,
    pub MaximumLength: ULONG,
    pub DmaPort: ULONG,
    pub DmaAddressWidth: ULONG,
    pub DmaControllerInstance: ULONG,
    pub DmaRequestLine: ULONG,
    pub DeviceAddress: PHYSICAL_ADDRESS,
}
pub type DEVICE_DESCRIPTION = _DEVICE_DESCRIPTION;
pub type PDEVICE_DESCRIPTION = *mut _DEVICE_DESCRIPTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DMA_ADAPTER_INFO_V1 {
    pub ReadDmaCounterAvailable: ULONG,
    pub ScatterGatherLimit: ULONG,
    pub DmaAddressWidth: ULONG,
    pub Flags: ULONG,
    pub MinimumTransferUnit: ULONG,
}
pub type DMA_ADAPTER_INFO_V1 = _DMA_ADAPTER_INFO_V1;
pub type PDMA_ADAPTER_INFO_V1 = *mut _DMA_ADAPTER_INFO_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DMA_ADAPTER_INFO_CRASHDUMP {
    pub DeviceDescription: DEVICE_DESCRIPTION,
    pub DeviceIdSize: SIZE_T,
    pub DeviceId: PVOID,
}
pub type DMA_ADAPTER_INFO_CRASHDUMP = _DMA_ADAPTER_INFO_CRASHDUMP;
pub type PDMA_ADAPTER_INFO_CRASHDUMP = *mut _DMA_ADAPTER_INFO_CRASHDUMP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DMA_ADAPTER_INFO {
    pub Version: ULONG,
    pub __bindgen_anon_1: _DMA_ADAPTER_INFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DMA_ADAPTER_INFO__bindgen_ty_1 {
    pub V1: DMA_ADAPTER_INFO_V1,
    pub Crashdump: DMA_ADAPTER_INFO_CRASHDUMP,
}
pub type DMA_ADAPTER_INFO = _DMA_ADAPTER_INFO;
pub type PDMA_ADAPTER_INFO = *mut _DMA_ADAPTER_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DMA_TRANSFER_INFO_V1 {
    pub MapRegisterCount: ULONG,
    pub ScatterGatherElementCount: ULONG,
    pub ScatterGatherListSize: ULONG,
}
pub type DMA_TRANSFER_INFO_V1 = _DMA_TRANSFER_INFO_V1;
pub type PDMA_TRANSFER_INFO_V1 = *mut _DMA_TRANSFER_INFO_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DMA_TRANSFER_INFO_V2 {
    pub MapRegisterCount: ULONG,
    pub ScatterGatherElementCount: ULONG,
    pub ScatterGatherListSize: ULONG,
    pub LogicalPageCount: ULONG,
}
pub type DMA_TRANSFER_INFO_V2 = _DMA_TRANSFER_INFO_V2;
pub type PDMA_TRANSFER_INFO_V2 = *mut _DMA_TRANSFER_INFO_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DMA_TRANSFER_INFO {
    pub Version: ULONG,
    pub __bindgen_anon_1: _DMA_TRANSFER_INFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DMA_TRANSFER_INFO__bindgen_ty_1 {
    pub V1: DMA_TRANSFER_INFO_V1,
    pub V2: DMA_TRANSFER_INFO_V2,
}
pub type DMA_TRANSFER_INFO = _DMA_TRANSFER_INFO;
pub type PDMA_TRANSFER_INFO = *mut _DMA_TRANSFER_INFO;
unsafe extern "C" {
    pub fn KeFlushWriteBuffer();
}
unsafe extern "C" {
    pub fn KeQueryPerformanceCounter(PerformanceFrequency: PLARGE_INTEGER) -> LARGE_INTEGER;
}
unsafe extern "C" {
    pub fn KeStallExecutionProcessor(MicroSeconds: ULONG);
}
pub type PROCESSOR_HALT_ROUTINE =
::core::option::Option<unsafe extern "C" fn(Context: PVOID) -> NTSTATUS>;
pub type PPROCESSOR_HALT_ROUTINE = PROCESSOR_HALT_ROUTINE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IOMMU_DMA_DEVICE {
    _unused: [u8; 0],
}
pub type IOMMU_DMA_DEVICE = _IOMMU_DMA_DEVICE;
pub type PIOMMU_DMA_DEVICE = *mut _IOMMU_DMA_DEVICE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SCATTER_GATHER_ELEMENT {
    pub Address: PHYSICAL_ADDRESS,
    pub Length: ULONG,
    pub Reserved: ULONG_PTR,
}
pub type SCATTER_GATHER_ELEMENT = _SCATTER_GATHER_ELEMENT;
pub type PSCATTER_GATHER_ELEMENT = *mut _SCATTER_GATHER_ELEMENT;
#[repr(C)]
pub struct _SCATTER_GATHER_LIST {
    pub NumberOfElements: ULONG,
    pub Reserved: ULONG_PTR,
    pub Elements: __IncompleteArrayField<SCATTER_GATHER_ELEMENT>,
}
pub type SCATTER_GATHER_LIST = _SCATTER_GATHER_LIST;
pub type PSCATTER_GATHER_LIST = *mut _SCATTER_GATHER_LIST;
pub type PDMA_OPERATIONS = *mut _DMA_OPERATIONS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DMA_ADAPTER {
    pub Version: USHORT,
    pub Size: USHORT,
    pub DmaOperations: PDMA_OPERATIONS,
}
pub type DMA_ADAPTER = _DMA_ADAPTER;
pub type PDMA_ADAPTER = *mut _DMA_ADAPTER;
pub const DMA_COMPLETION_STATUS_DmaComplete: DMA_COMPLETION_STATUS = 0;
pub const DMA_COMPLETION_STATUS_DmaAborted: DMA_COMPLETION_STATUS = 1;
pub const DMA_COMPLETION_STATUS_DmaError: DMA_COMPLETION_STATUS = 2;
pub const DMA_COMPLETION_STATUS_DmaCancelled: DMA_COMPLETION_STATUS = 3;
pub type DMA_COMPLETION_STATUS = core::ffi::c_int;
pub const _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE_CommonBufferConfigTypeLogicalAddressLimits : _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE = 0 ;
pub const _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE_CommonBufferConfigTypeSubSection:
_DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE = 1;
pub const _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE_CommonBufferConfigTypeHardwareAccessPermissions : _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE = 2 ;
pub const _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE_CommonBufferConfigTypeMax:
_DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE = 3;
pub type _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE = core::ffi::c_int;
pub use self::_DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE as DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE;
pub type PDMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE =
*mut _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE;
pub const _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE_CommonBufferHardwareAccessReadOnly : _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE = 0 ;
pub const _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE_CommonBufferHardwareAccessWriteOnly : _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE = 1 ;
pub const _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE_CommonBufferHardwareAccessReadWrite : _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE = 2 ;
pub const _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE_CommonBufferHardwareAccessMax:
_DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE = 3;
pub type _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE = core::ffi::c_int;
pub use self::_DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE as DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE;
pub type PDMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE =
*mut _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION {
    pub ConfigType: DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE,
    pub __bindgen_anon_1: _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION__bindgen_ty_1 {
    pub LogicalAddressLimits: _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION__bindgen_ty_1__bindgen_ty_1,
    pub SubSection: _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION__bindgen_ty_1__bindgen_ty_2,
    pub HardwareAccessType: DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE,
    pub Reserved: [ULONGLONG; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION__bindgen_ty_1__bindgen_ty_1 {
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION__bindgen_ty_1__bindgen_ty_2 {
    pub Offset: ULONGLONG,
    pub Length: ULONG,
}
pub type DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION = _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION;
pub type PDMA_COMMON_BUFFER_EXTENDED_CONFIGURATION = *mut _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION;
pub type PPUT_DMA_ADAPTER = ::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER)>;
pub type PALLOCATE_COMMON_BUFFER = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        Length: ULONG,
        LogicalAddress: PPHYSICAL_ADDRESS,
        CacheEnabled: BOOLEAN,
    ) -> PVOID,
>;
pub type PFREE_COMMON_BUFFER = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        Length: ULONG,
        LogicalAddress: PHYSICAL_ADDRESS,
        VirtualAddress: PVOID,
        CacheEnabled: BOOLEAN,
    ),
>;
pub type PALLOCATE_ADAPTER_CHANNEL = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        DeviceObject: PDEVICE_OBJECT,
        NumberOfMapRegisters: ULONG,
        ExecutionRoutine: PDRIVER_CONTROL,
        Context: PVOID,
    ) -> NTSTATUS,
>;
pub type PFLUSH_ADAPTER_BUFFERS = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        Mdl: PMDL,
        MapRegisterBase: PVOID,
        CurrentVa: PVOID,
        Length: ULONG,
        WriteToDevice: BOOLEAN,
    ) -> BOOLEAN,
>;
pub type PFREE_ADAPTER_CHANNEL =
::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER)>;
pub type PFREE_ADAPTER_OBJECT = ::core::option::Option<
    unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER, AllocationAction: IO_ALLOCATION_ACTION),
>;
pub type PFREE_MAP_REGISTERS = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        MapRegisterBase: PVOID,
        NumberOfMapRegisters: ULONG,
    ),
>;
pub type PMAP_TRANSFER = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        Mdl: PMDL,
        MapRegisterBase: PVOID,
        CurrentVa: PVOID,
        Length: PULONG,
        WriteToDevice: BOOLEAN,
    ) -> PHYSICAL_ADDRESS,
>;
pub type PGET_DMA_ALIGNMENT =
::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER) -> ULONG>;
pub type PREAD_DMA_COUNTER =
::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER) -> ULONG>;
pub type DRIVER_LIST_CONTROL = ::core::option::Option<
    unsafe extern "C" fn(
        DeviceObject: *mut _DEVICE_OBJECT,
        Irp: *mut _IRP,
        ScatterGather: PSCATTER_GATHER_LIST,
        Context: PVOID,
    ),
>;
pub type PDRIVER_LIST_CONTROL = DRIVER_LIST_CONTROL;
pub type PGET_SCATTER_GATHER_LIST = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        DeviceObject: PDEVICE_OBJECT,
        Mdl: PMDL,
        CurrentVa: PVOID,
        Length: ULONG,
        ExecutionRoutine: PDRIVER_LIST_CONTROL,
        Context: PVOID,
        WriteToDevice: BOOLEAN,
    ) -> NTSTATUS,
>;
pub type PPUT_SCATTER_GATHER_LIST = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        ScatterGather: PSCATTER_GATHER_LIST,
        WriteToDevice: BOOLEAN,
    ),
>;
pub type PCALCULATE_SCATTER_GATHER_LIST_SIZE = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        Mdl: PMDL,
        CurrentVa: PVOID,
        Length: ULONG,
        ScatterGatherListSize: PULONG,
        pNumberOfMapRegisters: PULONG,
    ) -> NTSTATUS,
>;
pub type PBUILD_SCATTER_GATHER_LIST = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        DeviceObject: PDEVICE_OBJECT,
        Mdl: PMDL,
        CurrentVa: PVOID,
        Length: ULONG,
        ExecutionRoutine: PDRIVER_LIST_CONTROL,
        Context: PVOID,
        WriteToDevice: BOOLEAN,
        ScatterGatherBuffer: PVOID,
        ScatterGatherLength: ULONG,
    ) -> NTSTATUS,
>;
pub type PBUILD_MDL_FROM_SCATTER_GATHER_LIST = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        ScatterGather: PSCATTER_GATHER_LIST,
        OriginalMdl: PMDL,
        TargetMdl: *mut PMDL,
    ) -> NTSTATUS,
>;
pub type PGET_DMA_ADAPTER_INFO = ::core::option::Option<
    unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER, AdapterInfo: PDMA_ADAPTER_INFO) -> NTSTATUS,
>;
pub type PGET_DMA_TRANSFER_INFO = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        Mdl: PMDL,
        Offset: ULONGLONG,
        Length: ULONG,
        WriteOnly: BOOLEAN,
        TransferInfo: PDMA_TRANSFER_INFO,
    ) -> NTSTATUS,
>;
pub type PCONFIGURE_ADAPTER_CHANNEL = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        FunctionNumber: ULONG,
        Context: PVOID,
    ) -> NTSTATUS,
>;
pub type PINITIALIZE_DMA_TRANSFER_CONTEXT = ::core::option::Option<
    unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER, DmaTransferContext: PVOID) -> NTSTATUS,
>;
pub type PALLOCATE_COMMON_BUFFER_EX = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        MaximumAddress: PPHYSICAL_ADDRESS,
        Length: ULONG,
        LogicalAddress: PPHYSICAL_ADDRESS,
        CacheEnabled: BOOLEAN,
        PreferredNode: NODE_REQUIREMENT,
    ) -> PVOID,
>;
pub type PALLOCATE_ADAPTER_CHANNEL_EX = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        DeviceObject: PDEVICE_OBJECT,
        DmaTransferContext: PVOID,
        NumberOfMapRegisters: ULONG,
        Flags: ULONG,
        ExecutionRoutine: PDRIVER_CONTROL,
        ExecutionContext: PVOID,
        MapRegisterBase: *mut PVOID,
    ) -> NTSTATUS,
>;
pub type DMA_COMPLETION_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        DeviceObject: PDEVICE_OBJECT,
        CompletionContext: PVOID,
        Status: DMA_COMPLETION_STATUS,
    ),
>;
pub type PDMA_COMPLETION_ROUTINE = DMA_COMPLETION_ROUTINE;
pub type PMAP_TRANSFER_EX = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        Mdl: PMDL,
        MapRegisterBase: PVOID,
        Offset: ULONGLONG,
        DeviceOffset: ULONG,
        Length: PULONG,
        WriteToDevice: BOOLEAN,
        ScatterGatherBuffer: PSCATTER_GATHER_LIST,
        ScatterGatherBufferLength: ULONG,
        DmaCompletionRoutine: PDMA_COMPLETION_ROUTINE,
        CompletionContext: PVOID,
    ) -> NTSTATUS,
>;
pub type PCANCEL_ADAPTER_CHANNEL = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        DeviceObject: PDEVICE_OBJECT,
        DmaTransferContext: PVOID,
    ) -> BOOLEAN,
>;
pub type PCANCEL_MAPPED_TRANSFER = ::core::option::Option<
    unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER, DmaTransferContext: PVOID) -> NTSTATUS,
>;
pub type PFLUSH_ADAPTER_BUFFERS_EX = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        Mdl: PMDL,
        MapRegisterBase: PVOID,
        Offset: ULONGLONG,
        Length: ULONG,
        WriteToDevice: BOOLEAN,
    ) -> NTSTATUS,
>;
pub type PGET_SCATTER_GATHER_LIST_EX = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        DeviceObject: PDEVICE_OBJECT,
        DmaTransferContext: PVOID,
        Mdl: PMDL,
        Offset: ULONGLONG,
        Length: ULONG,
        Flags: ULONG,
        ExecutionRoutine: PDRIVER_LIST_CONTROL,
        Context: PVOID,
        WriteToDevice: BOOLEAN,
        DmaCompletionRoutine: PDMA_COMPLETION_ROUTINE,
        CompletionContext: PVOID,
        ScatterGatherList: *mut PSCATTER_GATHER_LIST,
    ) -> NTSTATUS,
>;
pub type PBUILD_SCATTER_GATHER_LIST_EX = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        DeviceObject: PDEVICE_OBJECT,
        DmaTransferContext: PVOID,
        Mdl: PMDL,
        Offset: ULONGLONG,
        Length: ULONG,
        Flags: ULONG,
        ExecutionRoutine: PDRIVER_LIST_CONTROL,
        Context: PVOID,
        WriteToDevice: BOOLEAN,
        ScatterGatherBuffer: PVOID,
        ScatterGatherLength: ULONG,
        DmaCompletionRoutine: PDMA_COMPLETION_ROUTINE,
        CompletionContext: PVOID,
        ScatterGatherList: PVOID,
    ) -> NTSTATUS,
>;
pub type PALLOCATE_DOMAIN_COMMON_BUFFER = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        DomainHandle: HANDLE,
        MaximumAddress: PPHYSICAL_ADDRESS,
        Length: ULONG,
        Flags: ULONG,
        CacheType: *mut MEMORY_CACHING_TYPE,
        PreferredNode: NODE_REQUIREMENT,
        LogicalAddress: PPHYSICAL_ADDRESS,
        VirtualAddress: *mut PVOID,
    ) -> NTSTATUS,
>;
pub type PALLOCATE_COMMON_BUFFER_WITH_BOUNDS = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        MinimumAddress: PPHYSICAL_ADDRESS,
        MaximumAddress: PPHYSICAL_ADDRESS,
        Length: ULONG,
        Flags: ULONG,
        CacheType: *mut MEMORY_CACHING_TYPE,
        PreferredNode: NODE_REQUIREMENT,
        LogicalAddress: PPHYSICAL_ADDRESS,
    ) -> PVOID,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DMA_COMMON_BUFFER_VECTOR {
    _unused: [u8; 0],
}
pub type DMA_COMMON_BUFFER_VECTOR = _DMA_COMMON_BUFFER_VECTOR;
pub type PDMA_COMMON_BUFFER_VECTOR = *mut _DMA_COMMON_BUFFER_VECTOR;
pub type PALLOCATE_COMMON_BUFFER_VECTOR = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        LowAddress: PHYSICAL_ADDRESS,
        HighAddress: PHYSICAL_ADDRESS,
        CacheType: MEMORY_CACHING_TYPE,
        IdealNode: NODE_REQUIREMENT,
        Flags: ULONG,
        NumberOfElements: ULONG,
        SizeOfElements: ULONGLONG,
        VectorOut: *mut PDMA_COMMON_BUFFER_VECTOR,
    ) -> NTSTATUS,
>;
pub type PGET_COMMON_BUFFER_FROM_VECTOR_BY_INDEX = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        Vector: PDMA_COMMON_BUFFER_VECTOR,
        Index: ULONG,
        VirtualAddressOut: *mut PVOID,
        LogicalAddressOut: PPHYSICAL_ADDRESS,
    ),
>;
pub type PFREE_COMMON_BUFFER_FROM_VECTOR = ::core::option::Option<
    unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER, Vector: PDMA_COMMON_BUFFER_VECTOR, Index: ULONG),
>;
pub type PFREE_COMMON_BUFFER_VECTOR = ::core::option::Option<
    unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER, Vector: PDMA_COMMON_BUFFER_VECTOR),
>;
pub type PCREATE_COMMON_BUFFER_FROM_MDL = ::core::option::Option<
    unsafe extern "C" fn(
        DmaAdapter: PDMA_ADAPTER,
        Mdl: PMDL,
        ExtendedConfigs: PDMA_COMMON_BUFFER_EXTENDED_CONFIGURATION,
        ExtendedConfigsCount: ULONG,
        LogicalAddress: PPHYSICAL_ADDRESS,
    ) -> NTSTATUS,
>;
pub type PFLUSH_DMA_BUFFER = ::core::option::Option<
    unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER, Mdl: PMDL, ReadOperation: BOOLEAN) -> NTSTATUS,
>;
pub type PJOIN_DMA_DOMAIN = ::core::option::Option<
    unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER, DomainHandle: HANDLE) -> NTSTATUS,
>;
pub type PLEAVE_DMA_DOMAIN =
::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER) -> NTSTATUS>;
pub type PGET_DMA_DOMAIN =
::core::option::Option<unsafe extern "C" fn(DmaAdapter: PDMA_ADAPTER) -> HANDLE>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DMA_OPERATIONS {
    pub Size: ULONG,
    pub PutDmaAdapter: PPUT_DMA_ADAPTER,
    pub AllocateCommonBuffer: PALLOCATE_COMMON_BUFFER,
    pub FreeCommonBuffer: PFREE_COMMON_BUFFER,
    pub AllocateAdapterChannel: PALLOCATE_ADAPTER_CHANNEL,
    pub FlushAdapterBuffers: PFLUSH_ADAPTER_BUFFERS,
    pub FreeAdapterChannel: PFREE_ADAPTER_CHANNEL,
    pub FreeMapRegisters: PFREE_MAP_REGISTERS,
    pub MapTransfer: PMAP_TRANSFER,
    pub GetDmaAlignment: PGET_DMA_ALIGNMENT,
    pub ReadDmaCounter: PREAD_DMA_COUNTER,
    pub GetScatterGatherList: PGET_SCATTER_GATHER_LIST,
    pub PutScatterGatherList: PPUT_SCATTER_GATHER_LIST,
    pub CalculateScatterGatherList: PCALCULATE_SCATTER_GATHER_LIST_SIZE,
    pub BuildScatterGatherList: PBUILD_SCATTER_GATHER_LIST,
    pub BuildMdlFromScatterGatherList: PBUILD_MDL_FROM_SCATTER_GATHER_LIST,
    pub GetDmaAdapterInfo: PGET_DMA_ADAPTER_INFO,
    pub GetDmaTransferInfo: PGET_DMA_TRANSFER_INFO,
    pub InitializeDmaTransferContext: PINITIALIZE_DMA_TRANSFER_CONTEXT,
    pub AllocateCommonBufferEx: PALLOCATE_COMMON_BUFFER_EX,
    pub AllocateAdapterChannelEx: PALLOCATE_ADAPTER_CHANNEL_EX,
    pub ConfigureAdapterChannel: PCONFIGURE_ADAPTER_CHANNEL,
    pub CancelAdapterChannel: PCANCEL_ADAPTER_CHANNEL,
    pub MapTransferEx: PMAP_TRANSFER_EX,
    pub GetScatterGatherListEx: PGET_SCATTER_GATHER_LIST_EX,
    pub BuildScatterGatherListEx: PBUILD_SCATTER_GATHER_LIST_EX,
    pub FlushAdapterBuffersEx: PFLUSH_ADAPTER_BUFFERS_EX,
    pub FreeAdapterObject: PFREE_ADAPTER_OBJECT,
    pub CancelMappedTransfer: PCANCEL_MAPPED_TRANSFER,
    pub AllocateDomainCommonBuffer: PALLOCATE_DOMAIN_COMMON_BUFFER,
    pub FlushDmaBuffer: PFLUSH_DMA_BUFFER,
    pub JoinDmaDomain: PJOIN_DMA_DOMAIN,
    pub LeaveDmaDomain: PLEAVE_DMA_DOMAIN,
    pub GetDmaDomain: PGET_DMA_DOMAIN,
    pub AllocateCommonBufferWithBounds: PALLOCATE_COMMON_BUFFER_WITH_BOUNDS,
    pub AllocateCommonBufferVector: PALLOCATE_COMMON_BUFFER_VECTOR,
    pub GetCommonBufferFromVectorByIndex: PGET_COMMON_BUFFER_FROM_VECTOR_BY_INDEX,
    pub FreeCommonBufferFromVector: PFREE_COMMON_BUFFER_FROM_VECTOR,
    pub FreeCommonBufferVector: PFREE_COMMON_BUFFER_VECTOR,
    pub CreateCommonBufferFromMdl: PCREATE_COMMON_BUFFER_FROM_MDL,
}
pub type DMA_OPERATIONS = _DMA_OPERATIONS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IOMMU_DMA_DOMAIN {
    _unused: [u8; 0],
}
pub type IOMMU_DMA_DOMAIN = _IOMMU_DMA_DOMAIN;
pub type PIOMMU_DMA_DOMAIN = *mut _IOMMU_DMA_DOMAIN;
pub const _FAULT_INFORMATION_ARCH_FaultInformationInvalid: _FAULT_INFORMATION_ARCH = 0;
pub const _FAULT_INFORMATION_ARCH_FaultInformationArm64: _FAULT_INFORMATION_ARCH = 1;
pub const _FAULT_INFORMATION_ARCH_FaultInformationX64: _FAULT_INFORMATION_ARCH = 2;
pub type _FAULT_INFORMATION_ARCH = core::ffi::c_int;
pub use self::_FAULT_INFORMATION_ARCH as FAULT_INFORMATION_ARCH;
pub type PFAULT_INFORMATION_ARCH = *mut _FAULT_INFORMATION_ARCH;
pub const _FAULT_INFORMATION_ARM64_TYPE_UnsupportedUpstreamTransaction:
_FAULT_INFORMATION_ARM64_TYPE = 0;
pub const _FAULT_INFORMATION_ARM64_TYPE_AddressSizeFault: _FAULT_INFORMATION_ARM64_TYPE = 1;
pub const _FAULT_INFORMATION_ARM64_TYPE_TlbMatchConflict: _FAULT_INFORMATION_ARM64_TYPE = 2;
pub const _FAULT_INFORMATION_ARM64_TYPE_ExternalFault: _FAULT_INFORMATION_ARM64_TYPE = 3;
pub const _FAULT_INFORMATION_ARM64_TYPE_PermissionFault: _FAULT_INFORMATION_ARM64_TYPE = 4;
pub const _FAULT_INFORMATION_ARM64_TYPE_AccessFlagFault: _FAULT_INFORMATION_ARM64_TYPE = 5;
pub const _FAULT_INFORMATION_ARM64_TYPE_TranslationFault: _FAULT_INFORMATION_ARM64_TYPE = 6;
pub const _FAULT_INFORMATION_ARM64_TYPE_MaxFaultType: _FAULT_INFORMATION_ARM64_TYPE = 7;
pub type _FAULT_INFORMATION_ARM64_TYPE = core::ffi::c_int;
pub use self::_FAULT_INFORMATION_ARM64_TYPE as FAULT_INFORMATION_ARM64_TYPE;
pub type PFAULT_INFORMATION_ARM64_TYPE = *mut _FAULT_INFORMATION_ARM64_TYPE;
pub use self::_FAULT_INFORMATION_ARM64_TYPE as FAULT_INFORMATION_X64_TYPE;
pub type PFAULT_INFORMATION_X64_TYPE = *mut _FAULT_INFORMATION_ARM64_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FAULT_INFORMATION_X64_FLAGS {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _FAULT_INFORMATION_X64_FLAGS {
    #[inline]
    pub fn FaultAddressValid(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FaultAddressValid(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FaultAddressValid_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FaultAddressValid_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FaultAddressValid: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let FaultAddressValid: u32 = unsafe { ::core::mem::transmute(FaultAddressValid) };
            FaultAddressValid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type FAULT_INFORMATION_X64_FLAGS = _FAULT_INFORMATION_X64_FLAGS;
pub type PFAULT_INFORMATION_X64_FLAGS = *mut _FAULT_INFORMATION_X64_FLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FAULT_INFORMATION_ARM64_FLAGS {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _FAULT_INFORMATION_ARM64_FLAGS {
    #[inline]
    pub fn WriteNotRead(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WriteNotRead(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn WriteNotRead_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_WriteNotRead_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn InstructionNotData(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InstructionNotData(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InstructionNotData_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_InstructionNotData_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Privileged(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Privileged(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Privileged_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Privileged_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FaultAddressValid(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FaultAddressValid(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FaultAddressValid_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FaultAddressValid_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                28u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                28u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        WriteNotRead: ULONG,
        InstructionNotData: ULONG,
        Privileged: ULONG,
        FaultAddressValid: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let WriteNotRead: u32 = unsafe { ::core::mem::transmute(WriteNotRead) };
            WriteNotRead as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let InstructionNotData: u32 = unsafe { ::core::mem::transmute(InstructionNotData) };
            InstructionNotData as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Privileged: u32 = unsafe { ::core::mem::transmute(Privileged) };
            Privileged as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let FaultAddressValid: u32 = unsafe { ::core::mem::transmute(FaultAddressValid) };
            FaultAddressValid as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type FAULT_INFORMATION_ARM64_FLAGS = _FAULT_INFORMATION_ARM64_FLAGS;
pub type PFAULT_INFORMATION_ARM64_FLAGS = *mut _FAULT_INFORMATION_ARM64_FLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FAULT_INFORMATION_X64 {
    pub DomainHandle: PVOID,
    pub FaultAddress: PVOID,
    pub Flags: FAULT_INFORMATION_X64_FLAGS,
    pub Type: FAULT_INFORMATION_X64_TYPE,
    pub IommuBaseAddress: ULONG64,
    pub PciSegment: ULONG,
}
pub type FAULT_INFORMATION_X64 = _FAULT_INFORMATION_X64;
pub type PFAULT_INFORMATION_X64 = *mut _FAULT_INFORMATION_X64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FAULT_INFORMATION_ARM64 {
    pub DomainHandle: PVOID,
    pub FaultAddress: PVOID,
    pub PhysicalDeviceObject: PDEVICE_OBJECT,
    pub InputMappingId: ULONG,
    pub Flags: FAULT_INFORMATION_ARM64_FLAGS,
    pub Type: FAULT_INFORMATION_ARM64_TYPE,
    pub IommuBaseAddress: ULONG64,
}
pub type FAULT_INFORMATION_ARM64 = _FAULT_INFORMATION_ARM64;
pub type PFAULT_INFORMATION_ARM64 = *mut _FAULT_INFORMATION_ARM64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FAULT_INFORMATION {
    pub Type: FAULT_INFORMATION_ARCH,
    pub IsStage1: BOOLEAN,
    pub __bindgen_anon_1: _FAULT_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FAULT_INFORMATION__bindgen_ty_1 {
    pub Arm64: FAULT_INFORMATION_ARM64,
    pub X64: FAULT_INFORMATION_X64,
}
pub type FAULT_INFORMATION = _FAULT_INFORMATION;
pub type PFAULT_INFORMATION = *mut _FAULT_INFORMATION;
pub const _DOMAIN_CONFIGURATION_ARCH_DomainConfigurationArm64: _DOMAIN_CONFIGURATION_ARCH = 0;
pub const _DOMAIN_CONFIGURATION_ARCH_DomainConfigurationX64: _DOMAIN_CONFIGURATION_ARCH = 1;
pub const _DOMAIN_CONFIGURATION_ARCH_DomainConfigurationInvalid: _DOMAIN_CONFIGURATION_ARCH = 2;
pub type _DOMAIN_CONFIGURATION_ARCH = core::ffi::c_int;
pub use self::_DOMAIN_CONFIGURATION_ARCH as DOMAIN_CONFIGURATION_ARCH;
pub type PDOMAIN_CONFIGURATION_ARCH = *mut _DOMAIN_CONFIGURATION_ARCH;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DOMAIN_CONFIGURATION_ARM64 {
    pub Ttbr0: PHYSICAL_ADDRESS,
    pub Ttbr1: PHYSICAL_ADDRESS,
    pub Mair0: ULONG,
    pub Mair1: ULONG,
    pub InputSize0: UCHAR,
    pub InputSize1: UCHAR,
    pub CoherentTableWalks: BOOLEAN,
    pub TranslationEnabled: BOOLEAN,
}
pub type DOMAIN_CONFIGURATION_ARM64 = _DOMAIN_CONFIGURATION_ARM64;
pub type PDOMAIN_CONFIGURATION_ARM64 = *mut _DOMAIN_CONFIGURATION_ARM64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DOMAIN_CONFIGURATION_X64 {
    pub FirstLevelPageTableRoot: PHYSICAL_ADDRESS,
    pub TranslationEnabled: BOOLEAN,
}
pub type DOMAIN_CONFIGURATION_X64 = _DOMAIN_CONFIGURATION_X64;
pub type PDOMAIN_CONFIGURATION_X64 = *mut _DOMAIN_CONFIGURATION_X64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DOMAIN_CONFIGURATION {
    pub Type: DOMAIN_CONFIGURATION_ARCH,
    pub __bindgen_anon_1: _DOMAIN_CONFIGURATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DOMAIN_CONFIGURATION__bindgen_ty_1 {
    pub Arm64: DOMAIN_CONFIGURATION_ARM64,
    pub X64: DOMAIN_CONFIGURATION_X64,
}
pub type DOMAIN_CONFIGURATION = _DOMAIN_CONFIGURATION;
pub type PDOMAIN_CONFIGURATION = *mut _DOMAIN_CONFIGURATION;
pub type IOMMU_DEVICE_FAULT_HANDLER = ::core::option::Option<
    unsafe extern "C" fn(Context: PVOID, FaultInformation: PFAULT_INFORMATION),
>;
pub type PIOMMU_DEVICE_FAULT_HANDLER = IOMMU_DEVICE_FAULT_HANDLER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_FAULT_CONFIGURATION {
    pub FaultHandler: PIOMMU_DEVICE_FAULT_HANDLER,
    pub FaultContext: PVOID,
}
pub type DEVICE_FAULT_CONFIGURATION = _DEVICE_FAULT_CONFIGURATION;
pub type PDEVICE_FAULT_CONFIGURATION = *mut _DEVICE_FAULT_CONFIGURATION;
pub type IOMMU_DMA_LOGICAL_ADDRESS = ULONGLONG;
pub type PIOMMU_DMA_LOGICAL_ADDRESS = *mut ULONGLONG;
pub const _IOMMU_DMA_DOMAIN_TYPE_DomainTypeTranslate: _IOMMU_DMA_DOMAIN_TYPE = 0;
pub const _IOMMU_DMA_DOMAIN_TYPE_DomainTypePassThrough: _IOMMU_DMA_DOMAIN_TYPE = 1;
pub const _IOMMU_DMA_DOMAIN_TYPE_DomainTypeUnmanaged: _IOMMU_DMA_DOMAIN_TYPE = 2;
pub const _IOMMU_DMA_DOMAIN_TYPE_DomainTypeTranslateS1: _IOMMU_DMA_DOMAIN_TYPE = 3;
pub const _IOMMU_DMA_DOMAIN_TYPE_DomainTypeMax: _IOMMU_DMA_DOMAIN_TYPE = 4;
pub type _IOMMU_DMA_DOMAIN_TYPE = core::ffi::c_int;
pub use self::_IOMMU_DMA_DOMAIN_TYPE as IOMMU_DMA_DOMAIN_TYPE;
pub type PIOMMU_DMA_DOMAIN_TYPE = *mut _IOMMU_DMA_DOMAIN_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IOMMU_DMA_DOMAIN_CREATION_FLAGS {
    pub __bindgen_anon_1: _IOMMU_DMA_DOMAIN_CREATION_FLAGS__bindgen_ty_1,
    pub AsUlonglong: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IOMMU_DMA_DOMAIN_CREATION_FLAGS__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _IOMMU_DMA_DOMAIN_CREATION_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 64u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 64u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                64u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                64u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(Reserved: ULONGLONG) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 64u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type IOMMU_DMA_DOMAIN_CREATION_FLAGS = _IOMMU_DMA_DOMAIN_CREATION_FLAGS;
pub type PIOMMU_DMA_DOMAIN_CREATION_FLAGS = *mut _IOMMU_DMA_DOMAIN_CREATION_FLAGS;
pub const _IOMMU_DEVICE_CREATION_CONFIGURATION_TYPE_IommuDeviceCreationConfigTypeNone:
_IOMMU_DEVICE_CREATION_CONFIGURATION_TYPE = 0;
pub const _IOMMU_DEVICE_CREATION_CONFIGURATION_TYPE_IommuDeviceCreationConfigTypeAcpi:
_IOMMU_DEVICE_CREATION_CONFIGURATION_TYPE = 1;
pub const _IOMMU_DEVICE_CREATION_CONFIGURATION_TYPE_IommuDeviceCreationConfigTypeDeviceId:
_IOMMU_DEVICE_CREATION_CONFIGURATION_TYPE = 2;
pub const _IOMMU_DEVICE_CREATION_CONFIGURATION_TYPE_IommuDeviceCreationConfigTypeMax:
_IOMMU_DEVICE_CREATION_CONFIGURATION_TYPE = 3;
pub type _IOMMU_DEVICE_CREATION_CONFIGURATION_TYPE = core::ffi::c_int;
pub use self::_IOMMU_DEVICE_CREATION_CONFIGURATION_TYPE as IOMMU_DEVICE_CREATION_CONFIGURATION_TYPE;
pub type PIOMMU_DEVICE_CREATION_CONFIGURATION_TYPE = *mut _IOMMU_DEVICE_CREATION_CONFIGURATION_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IOMMU_DEVICE_CREATION_CONFIGURATION_ACPI {
    pub InputMappingBase: UINT32,
    pub MappingsCount: UINT32,
}
pub type IOMMU_DEVICE_CREATION_CONFIGURATION_ACPI = _IOMMU_DEVICE_CREATION_CONFIGURATION_ACPI;
pub type PIOMMU_DEVICE_CREATION_CONFIGURATION_ACPI = *mut _IOMMU_DEVICE_CREATION_CONFIGURATION_ACPI;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IOMMU_DEVICE_CREATION_CONFIGURATION {
    pub NextConfiguration: LIST_ENTRY,
    pub ConfigType: IOMMU_DEVICE_CREATION_CONFIGURATION_TYPE,
    pub __bindgen_anon_1: _IOMMU_DEVICE_CREATION_CONFIGURATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IOMMU_DEVICE_CREATION_CONFIGURATION__bindgen_ty_1 {
    pub Acpi: IOMMU_DEVICE_CREATION_CONFIGURATION_ACPI,
    pub DeviceId: PVOID,
}
pub type IOMMU_DEVICE_CREATION_CONFIGURATION = _IOMMU_DEVICE_CREATION_CONFIGURATION;
pub type PIOMMU_DEVICE_CREATION_CONFIGURATION = *mut _IOMMU_DEVICE_CREATION_CONFIGURATION;
pub const _IOMMU_MAP_PHYSICAL_ADDRESS_TYPE_MapPhysicalAddressTypeMdl:
_IOMMU_MAP_PHYSICAL_ADDRESS_TYPE = 0;
pub const _IOMMU_MAP_PHYSICAL_ADDRESS_TYPE_MapPhysicalAddressTypeContiguousRange:
_IOMMU_MAP_PHYSICAL_ADDRESS_TYPE = 1;
pub const _IOMMU_MAP_PHYSICAL_ADDRESS_TYPE_MapPhysicalAddressTypePfn:
_IOMMU_MAP_PHYSICAL_ADDRESS_TYPE = 2;
pub const _IOMMU_MAP_PHYSICAL_ADDRESS_TYPE_MapPhysicalAddressTypeMax:
_IOMMU_MAP_PHYSICAL_ADDRESS_TYPE = 3;
pub type _IOMMU_MAP_PHYSICAL_ADDRESS_TYPE = core::ffi::c_int;
pub use self::_IOMMU_MAP_PHYSICAL_ADDRESS_TYPE as IOMMU_MAP_PHYSICAL_ADDRESS_TYPE;
pub type PIOMMU_MAP_PHYSICAL_ADDRESS_TYPE = *mut _IOMMU_MAP_PHYSICAL_ADDRESS_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IOMMU_MAP_PHYSICAL_ADDRESS {
    pub MapType: IOMMU_MAP_PHYSICAL_ADDRESS_TYPE,
    pub __bindgen_anon_1: _IOMMU_MAP_PHYSICAL_ADDRESS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IOMMU_MAP_PHYSICAL_ADDRESS__bindgen_ty_1 {
    pub Mdl: _IOMMU_MAP_PHYSICAL_ADDRESS__bindgen_ty_1__bindgen_ty_1,
    pub ContiguousRange: _IOMMU_MAP_PHYSICAL_ADDRESS__bindgen_ty_1__bindgen_ty_2,
    pub PfnArray: _IOMMU_MAP_PHYSICAL_ADDRESS__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IOMMU_MAP_PHYSICAL_ADDRESS__bindgen_ty_1__bindgen_ty_1 {
    pub Mdl: PMDL,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IOMMU_MAP_PHYSICAL_ADDRESS__bindgen_ty_1__bindgen_ty_2 {
    pub Base: PHYSICAL_ADDRESS,
    pub Size: SIZE_T,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IOMMU_MAP_PHYSICAL_ADDRESS__bindgen_ty_1__bindgen_ty_3 {
    pub PageFrame: PPFN_NUMBER,
    pub NumberOfPages: SIZE_T,
}
pub type IOMMU_MAP_PHYSICAL_ADDRESS = _IOMMU_MAP_PHYSICAL_ADDRESS;
pub type PIOMMU_MAP_PHYSICAL_ADDRESS = *mut _IOMMU_MAP_PHYSICAL_ADDRESS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IOMMU_DMA_RESERVED_REGION {
    pub RegionNext: *mut _IOMMU_DMA_RESERVED_REGION,
    pub Base: IOMMU_DMA_LOGICAL_ADDRESS,
    pub NumberOfPages: SIZE_T,
    pub ShouldMap: BOOLEAN,
}
pub type IOMMU_DMA_RESERVED_REGION = _IOMMU_DMA_RESERVED_REGION;
pub type PIOMMU_DMA_RESERVED_REGION = *mut _IOMMU_DMA_RESERVED_REGION;
pub const _IOMMU_DMA_LOGICAL_ALLOCATOR_TYPE_IommuDmaLogicalAllocatorNone:
_IOMMU_DMA_LOGICAL_ALLOCATOR_TYPE = 0;
pub const _IOMMU_DMA_LOGICAL_ALLOCATOR_TYPE_IommuDmaLogicalAllocatorBuddy:
_IOMMU_DMA_LOGICAL_ALLOCATOR_TYPE = 1;
pub const _IOMMU_DMA_LOGICAL_ALLOCATOR_TYPE_IommuDmaLogicalAllocatorMax:
_IOMMU_DMA_LOGICAL_ALLOCATOR_TYPE = 2;
pub type _IOMMU_DMA_LOGICAL_ALLOCATOR_TYPE = core::ffi::c_int;
pub use self::_IOMMU_DMA_LOGICAL_ALLOCATOR_TYPE as IOMMU_DMA_LOGICAL_ALLOCATOR_TYPE;
pub type PIOMMU_DMA_LOGICAL_ALLOCATOR_TYPE = *mut _IOMMU_DMA_LOGICAL_ALLOCATOR_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IOMMU_DMA_LOGICAL_ALLOCATOR_CONFIG {
    pub LogicalAllocatorType: IOMMU_DMA_LOGICAL_ALLOCATOR_TYPE,
    pub __bindgen_anon_1: _IOMMU_DMA_LOGICAL_ALLOCATOR_CONFIG__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IOMMU_DMA_LOGICAL_ALLOCATOR_CONFIG__bindgen_ty_1 {
    pub BuddyAllocatorConfig: _IOMMU_DMA_LOGICAL_ALLOCATOR_CONFIG__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IOMMU_DMA_LOGICAL_ALLOCATOR_CONFIG__bindgen_ty_1__bindgen_ty_1 {
    pub AddressWidth: ULONG,
}
pub type IOMMU_DMA_LOGICAL_ALLOCATOR_CONFIG = _IOMMU_DMA_LOGICAL_ALLOCATOR_CONFIG;
pub type PIOMMU_DMA_LOGICAL_ALLOCATOR_CONFIG = *mut _IOMMU_DMA_LOGICAL_ALLOCATOR_CONFIG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IOMMU_DMA_LOGICAL_ADDRESS_TOKEN {
    pub LogicalAddressBase: IOMMU_DMA_LOGICAL_ADDRESS,
    pub Size: SIZE_T,
}
pub type IOMMU_DMA_LOGICAL_ADDRESS_TOKEN = _IOMMU_DMA_LOGICAL_ADDRESS_TOKEN;
pub type PIOMMU_DMA_LOGICAL_ADDRESS_TOKEN = *mut _IOMMU_DMA_LOGICAL_ADDRESS_TOKEN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IOMMU_DMA_LOGICAL_ADDRESS_TOKEN_MAPPED_SEGMENT {
    pub OwningToken: PIOMMU_DMA_LOGICAL_ADDRESS_TOKEN,
    pub Offset: SIZE_T,
    pub Size: SIZE_T,
}
pub type IOMMU_DMA_LOGICAL_ADDRESS_TOKEN_MAPPED_SEGMENT =
_IOMMU_DMA_LOGICAL_ADDRESS_TOKEN_MAPPED_SEGMENT;
pub type PIOMMU_DMA_LOGICAL_ADDRESS_TOKEN_MAPPED_SEGMENT =
*mut _IOMMU_DMA_LOGICAL_ADDRESS_TOKEN_MAPPED_SEGMENT;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IOMMU_INTERFACE_STATE_CHANGE_FIELDS {
    pub __bindgen_anon_1: _IOMMU_INTERFACE_STATE_CHANGE_FIELDS__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IOMMU_INTERFACE_STATE_CHANGE_FIELDS__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _IOMMU_INTERFACE_STATE_CHANGE_FIELDS__bindgen_ty_1 {
    #[inline]
    pub fn AvailableDomainTypes(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AvailableDomainTypes(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AvailableDomainTypes_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AvailableDomainTypes_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AvailableDomainTypes: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let AvailableDomainTypes: u32 = unsafe { ::core::mem::transmute(AvailableDomainTypes) };
            AvailableDomainTypes as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type IOMMU_INTERFACE_STATE_CHANGE_FIELDS = _IOMMU_INTERFACE_STATE_CHANGE_FIELDS;
pub type PIOMMU_INTERFACE_STATE_CHANGE_FIELDS = *mut _IOMMU_INTERFACE_STATE_CHANGE_FIELDS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IOMMU_INTERFACE_STATE_CHANGE {
    pub PresentFields: IOMMU_INTERFACE_STATE_CHANGE_FIELDS,
    pub AvailableDomainTypes: ULONG,
}
pub type IOMMU_INTERFACE_STATE_CHANGE = _IOMMU_INTERFACE_STATE_CHANGE;
pub type PIOMMU_INTERFACE_STATE_CHANGE = *mut _IOMMU_INTERFACE_STATE_CHANGE;
pub type IOMMU_INTERFACE_STATE_CHANGE_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(StateChange: PIOMMU_INTERFACE_STATE_CHANGE, Context: PVOID),
>;
pub type PIOMMU_INTERFACE_STATE_CHANGE_CALLBACK = IOMMU_INTERFACE_STATE_CHANGE_CALLBACK;
pub type IOMMU_DOMAIN_CREATE = ::core::option::Option<
    unsafe extern "C" fn(
        OsManagedPageTable: BOOLEAN,
        DomainOut: *mut PIOMMU_DMA_DOMAIN,
    ) -> NTSTATUS,
>;
pub type PIOMMU_DOMAIN_CREATE = IOMMU_DOMAIN_CREATE;
pub type IOMMU_DOMAIN_DELETE =
::core::option::Option<unsafe extern "C" fn(Domain: PIOMMU_DMA_DOMAIN) -> NTSTATUS>;
pub type PIOMMU_DOMAIN_DELETE = IOMMU_DOMAIN_DELETE;
pub type IOMMU_DOMAIN_ATTACH_DEVICE = ::core::option::Option<
    unsafe extern "C" fn(
        Domain: PIOMMU_DMA_DOMAIN,
        PhysicalDeviceObject: PDEVICE_OBJECT,
        InputMappingIdBase: ULONG,
        MappingCount: ULONG,
    ) -> NTSTATUS,
>;
pub type PIOMMU_DOMAIN_ATTACH_DEVICE = IOMMU_DOMAIN_ATTACH_DEVICE;
pub type IOMMU_DOMAIN_DETACH_DEVICE = ::core::option::Option<
    unsafe extern "C" fn(
        Domain: PIOMMU_DMA_DOMAIN,
        PhysicalDeviceObject: PDEVICE_OBJECT,
        InputMappingId: ULONG,
    ) -> NTSTATUS,
>;
pub type PIOMMU_DOMAIN_DETACH_DEVICE = IOMMU_DOMAIN_DETACH_DEVICE;
pub type IOMMU_SET_DEVICE_FAULT_REPORTING = ::core::option::Option<
    unsafe extern "C" fn(
        PhysicalDeviceObject: PDEVICE_OBJECT,
        InputMappingIdBase: ULONG,
        Enable: BOOLEAN,
        FaultConfig: PDEVICE_FAULT_CONFIGURATION,
    ) -> NTSTATUS,
>;
pub type PIOMMU_SET_DEVICE_FAULT_REPORTING = IOMMU_SET_DEVICE_FAULT_REPORTING;
pub type IOMMU_DOMAIN_CONFIGURE = ::core::option::Option<
    unsafe extern "C" fn(
        Domain: PIOMMU_DMA_DOMAIN,
        Configuration: PDOMAIN_CONFIGURATION,
    ) -> NTSTATUS,
>;
pub type PIOMMU_DOMAIN_CONFIGURE = IOMMU_DOMAIN_CONFIGURE;
pub type IOMMU_FLUSH_DOMAIN =
::core::option::Option<unsafe extern "C" fn(Domain: PIOMMU_DMA_DOMAIN) -> NTSTATUS>;
pub type PIOMMU_FLUSH_DOMAIN = IOMMU_FLUSH_DOMAIN;
pub type IOMMU_FLUSH_DOMAIN_VA_LIST = ::core::option::Option<
    unsafe extern "C" fn(
        Domain: PIOMMU_DMA_DOMAIN,
        LastLevel: BOOLEAN,
        Number: ULONG,
        VaList: PVOID,
    ) -> NTSTATUS,
>;
pub type PIOMMU_FLUSH_DOMAIN_VA_LIST = IOMMU_FLUSH_DOMAIN_VA_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _INPUT_MAPPING_ELEMENT {
    pub InputMappingId: ULONG,
}
pub type INPUT_MAPPING_ELEMENT = _INPUT_MAPPING_ELEMENT;
pub type PINPUT_MAPPING_ELEMENT = *mut _INPUT_MAPPING_ELEMENT;
pub type IOMMU_QUERY_INPUT_MAPPINGS = ::core::option::Option<
    unsafe extern "C" fn(
        PhysicalDeviceObject: PDEVICE_OBJECT,
        Buffer: PINPUT_MAPPING_ELEMENT,
        BufferLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS,
>;
pub type PIOMMU_QUERY_INPUT_MAPPINGS = IOMMU_QUERY_INPUT_MAPPINGS;
pub type IOMMU_MAP_LOGICAL_RANGE = ::core::option::Option<
    unsafe extern "C" fn(
        Domain: PIOMMU_DMA_DOMAIN,
        Permissions: ULONG,
        Mdl: PMDL,
        LogicalAddress: ULONGLONG,
    ) -> NTSTATUS,
>;
pub type PIOMMU_MAP_LOGICAL_RANGE = IOMMU_MAP_LOGICAL_RANGE;
pub type IOMMU_UNMAP_LOGICAL_RANGE = ::core::option::Option<
    unsafe extern "C" fn(
        Domain: PIOMMU_DMA_DOMAIN,
        LogicalAddress: ULONGLONG,
        NumberOfPages: ULONGLONG,
    ) -> NTSTATUS,
>;
pub type PIOMMU_UNMAP_LOGICAL_RANGE = IOMMU_UNMAP_LOGICAL_RANGE;
pub type IOMMU_MAP_IDENTITY_RANGE = ::core::option::Option<
    unsafe extern "C" fn(Domain: PIOMMU_DMA_DOMAIN, Permissions: ULONG, Mdl: PMDL) -> NTSTATUS,
>;
pub type PIOMMU_MAP_IDENTITY_RANGE = IOMMU_MAP_IDENTITY_RANGE;
pub type IOMMU_UNMAP_IDENTITY_RANGE =
::core::option::Option<unsafe extern "C" fn(Domain: PIOMMU_DMA_DOMAIN, Mdl: PMDL) -> NTSTATUS>;
pub type PIOMMU_UNMAP_IDENTITY_RANGE = IOMMU_UNMAP_IDENTITY_RANGE;
pub type IOMMU_DOMAIN_CREATE_EX = ::core::option::Option<
    unsafe extern "C" fn(
        DomainType: IOMMU_DMA_DOMAIN_TYPE,
        Flags: IOMMU_DMA_DOMAIN_CREATION_FLAGS,
        LogicalAllocatorConfig: PIOMMU_DMA_LOGICAL_ALLOCATOR_CONFIG,
        ReservedRegions: PIOMMU_DMA_RESERVED_REGION,
        DomainOut: *mut PIOMMU_DMA_DOMAIN,
    ) -> NTSTATUS,
>;
pub type PIOMMU_DOMAIN_CREATE_EX = IOMMU_DOMAIN_CREATE_EX;
pub type IOMMU_DOMAIN_ATTACH_DEVICE_EX = ::core::option::Option<
    unsafe extern "C" fn(Domain: PIOMMU_DMA_DOMAIN, DmaDevice: PIOMMU_DMA_DEVICE) -> NTSTATUS,
>;
pub type PIOMMU_DOMAIN_ATTACH_DEVICE_EX = IOMMU_DOMAIN_ATTACH_DEVICE_EX;
pub type IOMMU_DOMAIN_DETACH_DEVICE_EX =
::core::option::Option<unsafe extern "C" fn(DmaDevice: PIOMMU_DMA_DEVICE) -> NTSTATUS>;
pub type PIOMMU_DOMAIN_DETACH_DEVICE_EX = IOMMU_DOMAIN_DETACH_DEVICE_EX;
pub type IOMMU_MAP_LOGICAL_RANGE_EX = ::core::option::Option<
    unsafe extern "C" fn(
        Domain: PIOMMU_DMA_DOMAIN,
        Permissions: ULONG,
        PhysicalAddressToMap: PIOMMU_MAP_PHYSICAL_ADDRESS,
        ExplicitLogicalAddress: PIOMMU_DMA_LOGICAL_ADDRESS,
        MinLogicalAddress: PIOMMU_DMA_LOGICAL_ADDRESS,
        MaxLogicalAddress: PIOMMU_DMA_LOGICAL_ADDRESS,
        LogicalAddressOut: PIOMMU_DMA_LOGICAL_ADDRESS,
    ) -> NTSTATUS,
>;
pub type PIOMMU_MAP_LOGICAL_RANGE_EX = IOMMU_MAP_LOGICAL_RANGE_EX;
pub type IOMMU_MAP_IDENTITY_RANGE_EX = ::core::option::Option<
    unsafe extern "C" fn(
        Domain: PIOMMU_DMA_DOMAIN,
        Permissions: ULONG,
        PhysicalAddressToMap: PIOMMU_MAP_PHYSICAL_ADDRESS,
    ) -> NTSTATUS,
>;
pub type PIOMMU_MAP_IDENTITY_RANGE_EX = IOMMU_MAP_IDENTITY_RANGE_EX;
pub type IOMMU_UNMAP_IDENTITY_RANGE_EX = ::core::option::Option<
    unsafe extern "C" fn(
        Domain: PIOMMU_DMA_DOMAIN,
        MappedPhysicalAddress: PIOMMU_MAP_PHYSICAL_ADDRESS,
    ) -> NTSTATUS,
>;
pub type PIOMMU_UNMAP_IDENTITY_RANGE_EX = IOMMU_UNMAP_IDENTITY_RANGE_EX;
pub type IOMMU_DEVICE_QUERY_DOMAIN_TYPES = ::core::option::Option<
    unsafe extern "C" fn(DmaDevice: PIOMMU_DMA_DEVICE, AvailableDomains: PULONG),
>;
pub type PIOMMU_DEVICE_QUERY_DOMAIN_TYPES = IOMMU_DEVICE_QUERY_DOMAIN_TYPES;
pub type IOMMU_REGISTER_INTERFACE_STATE_CHANGE_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        StateChangeCallback: PIOMMU_INTERFACE_STATE_CHANGE_CALLBACK,
        Context: PVOID,
        DmaDevice: PIOMMU_DMA_DEVICE,
        StateFields: PIOMMU_INTERFACE_STATE_CHANGE_FIELDS,
    ) -> NTSTATUS,
>;
pub type PIOMMU_REGISTER_INTERFACE_STATE_CHANGE_CALLBACK =
IOMMU_REGISTER_INTERFACE_STATE_CHANGE_CALLBACK;
pub type IOMMU_UNREGISTER_INTERFACE_STATE_CHANGE_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        StateChangeCallback: PIOMMU_INTERFACE_STATE_CHANGE_CALLBACK,
        DmaDevice: PIOMMU_DMA_DEVICE,
    ) -> NTSTATUS,
>;
pub type PIOMMU_UNREGISTER_INTERFACE_STATE_CHANGE_CALLBACK =
IOMMU_UNREGISTER_INTERFACE_STATE_CHANGE_CALLBACK;
pub type IOMMU_RESERVE_LOGICAL_ADDRESS_RANGE = ::core::option::Option<
    unsafe extern "C" fn(
        Domain: PIOMMU_DMA_DOMAIN,
        Size: SIZE_T,
        ExplicitLogicalAddress: PIOMMU_DMA_LOGICAL_ADDRESS,
        MinLogicalAddress: PIOMMU_DMA_LOGICAL_ADDRESS,
        MaxLogicalAddress: PIOMMU_DMA_LOGICAL_ADDRESS,
        LogicalAddressToken: *mut PIOMMU_DMA_LOGICAL_ADDRESS_TOKEN,
    ) -> NTSTATUS,
>;
pub type PIOMMU_RESERVE_LOGICAL_ADDRESS_RANGE = IOMMU_RESERVE_LOGICAL_ADDRESS_RANGE;
pub type IOMMU_FREE_RESERVED_LOGICAL_ADDRESS_RANGE = ::core::option::Option<
    unsafe extern "C" fn(LogicalAddressToken: PIOMMU_DMA_LOGICAL_ADDRESS_TOKEN) -> NTSTATUS,
>;
pub type PIOMMU_FREE_RESERVED_LOGICAL_ADDRESS_RANGE = IOMMU_FREE_RESERVED_LOGICAL_ADDRESS_RANGE;
pub type IOMMU_MAP_RESERVED_LOGICAL_RANGE = ::core::option::Option<
    unsafe extern "C" fn(
        LogicalAddressToken: PIOMMU_DMA_LOGICAL_ADDRESS_TOKEN,
        Offset: SIZE_T,
        Permissions: ULONG,
        PhysicalAddressToMap: PIOMMU_MAP_PHYSICAL_ADDRESS,
        MappedSegment: PIOMMU_DMA_LOGICAL_ADDRESS_TOKEN_MAPPED_SEGMENT,
    ) -> NTSTATUS,
>;
pub type PIOMMU_MAP_RESERVED_LOGICAL_RANGE = IOMMU_MAP_RESERVED_LOGICAL_RANGE;
pub type IOMMU_UNMAP_RESERVED_LOGICAL_RANGE = ::core::option::Option<
    unsafe extern "C" fn(
        MappedSegment: PIOMMU_DMA_LOGICAL_ADDRESS_TOKEN_MAPPED_SEGMENT,
    ) -> NTSTATUS,
>;
pub type PIOMMU_UNMAP_RESERVED_LOGICAL_RANGE = IOMMU_UNMAP_RESERVED_LOGICAL_RANGE;
pub type IOMMU_DEVICE_CREATE = ::core::option::Option<
    unsafe extern "C" fn(
        DeviceObject: PDEVICE_OBJECT,
        DeviceConfig: PIOMMU_DEVICE_CREATION_CONFIGURATION,
        DmaDeviceOut: *mut PIOMMU_DMA_DEVICE,
    ) -> NTSTATUS,
>;
pub type PIOMMU_DEVICE_CREATE = IOMMU_DEVICE_CREATE;
pub type IOMMU_DEVICE_DELETE =
::core::option::Option<unsafe extern "C" fn(DmaDevice: PIOMMU_DMA_DEVICE) -> NTSTATUS>;
pub type PIOMMU_DEVICE_DELETE = IOMMU_DEVICE_DELETE;
pub type IOMMU_SET_DEVICE_FAULT_REPORTING_EX = ::core::option::Option<
    unsafe extern "C" fn(
        DmaDevice: PIOMMU_DMA_DEVICE,
        InputMappingIdBase: ULONG,
        Enable: BOOLEAN,
        FaultConfig: PDEVICE_FAULT_CONFIGURATION,
    ) -> NTSTATUS,
>;
pub type PIOMMU_SET_DEVICE_FAULT_REPORTING_EX = IOMMU_SET_DEVICE_FAULT_REPORTING_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DMA_IOMMU_INTERFACE {
    pub Version: ULONG,
    pub CreateDomain: PIOMMU_DOMAIN_CREATE,
    pub DeleteDomain: PIOMMU_DOMAIN_DELETE,
    pub AttachDevice: PIOMMU_DOMAIN_ATTACH_DEVICE,
    pub DetachDevice: PIOMMU_DOMAIN_DETACH_DEVICE,
    pub FlushDomain: PIOMMU_FLUSH_DOMAIN,
    pub FlushDomainByVaList: PIOMMU_FLUSH_DOMAIN_VA_LIST,
    pub QueryInputMappings: PIOMMU_QUERY_INPUT_MAPPINGS,
    pub MapLogicalRange: PIOMMU_MAP_LOGICAL_RANGE,
    pub UnmapLogicalRange: PIOMMU_UNMAP_LOGICAL_RANGE,
    pub MapIdentityRange: PIOMMU_MAP_IDENTITY_RANGE,
    pub UnmapIdentityRange: PIOMMU_UNMAP_IDENTITY_RANGE,
    pub SetDeviceFaultReporting: PIOMMU_SET_DEVICE_FAULT_REPORTING,
    pub ConfigureDomain: PIOMMU_DOMAIN_CONFIGURE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DMA_IOMMU_INTERFACE_V1 {
    pub CreateDomain: PIOMMU_DOMAIN_CREATE,
    pub DeleteDomain: PIOMMU_DOMAIN_DELETE,
    pub AttachDevice: PIOMMU_DOMAIN_ATTACH_DEVICE,
    pub DetachDevice: PIOMMU_DOMAIN_DETACH_DEVICE,
    pub FlushDomain: PIOMMU_FLUSH_DOMAIN,
    pub FlushDomainByVaList: PIOMMU_FLUSH_DOMAIN_VA_LIST,
    pub QueryInputMappings: PIOMMU_QUERY_INPUT_MAPPINGS,
    pub MapLogicalRange: PIOMMU_MAP_LOGICAL_RANGE,
    pub UnmapLogicalRange: PIOMMU_UNMAP_LOGICAL_RANGE,
    pub MapIdentityRange: PIOMMU_MAP_IDENTITY_RANGE,
    pub UnmapIdentityRange: PIOMMU_UNMAP_IDENTITY_RANGE,
    pub SetDeviceFaultReporting: PIOMMU_SET_DEVICE_FAULT_REPORTING,
    pub ConfigureDomain: PIOMMU_DOMAIN_CONFIGURE,
}
pub type DMA_IOMMU_INTERFACE_V1 = _DMA_IOMMU_INTERFACE_V1;
pub type PDMA_IOMMU_INTERFACE_V1 = *mut _DMA_IOMMU_INTERFACE_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DMA_IOMMU_INTERFACE_V2 {
    pub CreateDomainEx: PIOMMU_DOMAIN_CREATE_EX,
    pub DeleteDomain: PIOMMU_DOMAIN_DELETE,
    pub AttachDeviceEx: PIOMMU_DOMAIN_ATTACH_DEVICE_EX,
    pub DetachDeviceEx: PIOMMU_DOMAIN_DETACH_DEVICE_EX,
    pub FlushDomain: PIOMMU_FLUSH_DOMAIN,
    pub FlushDomainByVaList: PIOMMU_FLUSH_DOMAIN_VA_LIST,
    pub QueryInputMappings: PIOMMU_QUERY_INPUT_MAPPINGS,
    pub MapLogicalRangeEx: PIOMMU_MAP_LOGICAL_RANGE_EX,
    pub UnmapLogicalRange: PIOMMU_UNMAP_LOGICAL_RANGE,
    pub MapIdentityRangeEx: PIOMMU_MAP_IDENTITY_RANGE_EX,
    pub UnmapIdentityRangeEx: PIOMMU_UNMAP_IDENTITY_RANGE_EX,
    pub SetDeviceFaultReportingEx: PIOMMU_SET_DEVICE_FAULT_REPORTING_EX,
    pub ConfigureDomain: PIOMMU_DOMAIN_CONFIGURE,
    pub QueryAvailableDomainTypes: PIOMMU_DEVICE_QUERY_DOMAIN_TYPES,
    pub RegisterInterfaceStateChangeCallback: PIOMMU_REGISTER_INTERFACE_STATE_CHANGE_CALLBACK,
    pub UnregisterInterfaceStateChangeCallback: PIOMMU_UNREGISTER_INTERFACE_STATE_CHANGE_CALLBACK,
    pub ReserveLogicalAddressRange: PIOMMU_RESERVE_LOGICAL_ADDRESS_RANGE,
    pub FreeReservedLogicalAddressRange: PIOMMU_FREE_RESERVED_LOGICAL_ADDRESS_RANGE,
    pub MapReservedLogicalRange: PIOMMU_MAP_RESERVED_LOGICAL_RANGE,
    pub UnmapReservedLogicalRange: PIOMMU_UNMAP_RESERVED_LOGICAL_RANGE,
    pub CreateDevice: PIOMMU_DEVICE_CREATE,
    pub DeleteDevice: PIOMMU_DEVICE_DELETE,
}
pub type DMA_IOMMU_INTERFACE_V2 = _DMA_IOMMU_INTERFACE_V2;
pub type PDMA_IOMMU_INTERFACE_V2 = *mut _DMA_IOMMU_INTERFACE_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DMA_IOMMU_INTERFACE_EX {
    pub Size: SIZE_T,
    pub Version: ULONG,
    pub __bindgen_anon_1: _DMA_IOMMU_INTERFACE_EX__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DMA_IOMMU_INTERFACE_EX__bindgen_ty_1 {
    pub V1: DMA_IOMMU_INTERFACE_V1,
    pub V2: DMA_IOMMU_INTERFACE_V2,
}
unsafe extern "C" {
    pub fn PoSetHiberRange(
        MemoryMap: PVOID,
        Flags: ULONG,
        Address: PVOID,
        Length: ULONG_PTR,
        Tag: ULONG,
    );
}
unsafe extern "C" {
    pub fn PoSetSystemState(Flags: EXECUTION_STATE);
}
unsafe extern "C" {
    pub fn PoRegisterSystemState(StateHandle: PVOID, Flags: EXECUTION_STATE) -> PVOID;
}
unsafe extern "C" {
    pub fn PoCreatePowerRequest(
        PowerRequest: *mut PVOID,
        DeviceObject: PDEVICE_OBJECT,
        Context: PCOUNTED_REASON_CONTEXT,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PoSetPowerRequest(PowerRequest: PVOID, Type: POWER_REQUEST_TYPE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PoClearPowerRequest(PowerRequest: PVOID, Type: POWER_REQUEST_TYPE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PoDeletePowerRequest(PowerRequest: PVOID);
}
pub type REQUEST_POWER_COMPLETE = ::core::option::Option<
    unsafe extern "C" fn(
        DeviceObject: PDEVICE_OBJECT,
        MinorFunction: UCHAR,
        PowerState: POWER_STATE,
        Context: PVOID,
        IoStatus: PIO_STATUS_BLOCK,
    ),
>;
pub type PREQUEST_POWER_COMPLETE = REQUEST_POWER_COMPLETE;
unsafe extern "C" {
    pub fn PoRequestPowerIrp(
        DeviceObject: PDEVICE_OBJECT,
        MinorFunction: UCHAR,
        PowerState: POWER_STATE,
        CompletionFunction: PREQUEST_POWER_COMPLETE,
        Context: PVOID,
        Irp: *mut PIRP,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PoSetSystemWake(Irp: PIRP);
}
unsafe extern "C" {
    pub fn PoSetSystemWakeDevice(DeviceObject: PDEVICE_OBJECT);
}
unsafe extern "C" {
    pub fn PoGetSystemWake(Irp: PIRP) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn PoUnregisterSystemState(StateHandle: PVOID);
}
unsafe extern "C" {
    pub fn PoSetPowerState(
        DeviceObject: PDEVICE_OBJECT,
        Type: POWER_STATE_TYPE,
        State: POWER_STATE,
    ) -> POWER_STATE;
}
unsafe extern "C" {
    pub fn PoCallDriver(DeviceObject: PDEVICE_OBJECT, Irp: PIRP) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PoStartNextPowerIrp(Irp: PIRP);
}
unsafe extern "C" {
    pub fn PoRegisterDeviceForIdleDetection(
        DeviceObject: PDEVICE_OBJECT,
        ConservationIdleTime: ULONG,
        PerformanceIdleTime: ULONG,
        State: DEVICE_POWER_STATE,
    ) -> PULONG;
}
unsafe extern "C" {
    pub fn PoSetDeviceBusyEx(IdlePointer: PULONG);
}
unsafe extern "C" {
    pub fn PoStartDeviceBusy(IdlePointer: PULONG);
}
unsafe extern "C" {
    pub fn PoEndDeviceBusy(IdlePointer: PULONG);
}
unsafe extern "C" {
    pub fn PoQueryWatchdogTime(Pdo: PDEVICE_OBJECT, SecondsRemaining: PULONG) -> BOOLEAN;
}
pub type POWER_SETTING_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        SettingGuid: LPCGUID,
        Value: PVOID,
        ValueLength: ULONG,
        Context: PVOID,
    ) -> NTSTATUS,
>;
pub type PPOWER_SETTING_CALLBACK = POWER_SETTING_CALLBACK;
unsafe extern "C" {
    pub fn PoRegisterPowerSettingCallback(
        DeviceObject: PDEVICE_OBJECT,
        SettingGuid: LPCGUID,
        Callback: PPOWER_SETTING_CALLBACK,
        Context: PVOID,
        Handle: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PoUnregisterPowerSettingCallback(Handle: PVOID) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct POHANDLE__ {
    pub unused: core::ffi::c_int,
}
pub type POHANDLE = *mut POHANDLE__;
pub type PO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, Component: ULONG)>;
pub type PPO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK = PO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK;
pub type PO_FX_COMPONENT_IDLE_CONDITION_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, Component: ULONG)>;
pub type PPO_FX_COMPONENT_IDLE_CONDITION_CALLBACK = PO_FX_COMPONENT_IDLE_CONDITION_CALLBACK;
pub type PO_FX_COMPONENT_IDLE_STATE_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, Component: ULONG, State: ULONG)>;
pub type PPO_FX_COMPONENT_IDLE_STATE_CALLBACK = PO_FX_COMPONENT_IDLE_STATE_CALLBACK;
pub type PO_FX_DEVICE_POWER_REQUIRED_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
pub type PPO_FX_DEVICE_POWER_REQUIRED_CALLBACK = PO_FX_DEVICE_POWER_REQUIRED_CALLBACK;
pub type PO_FX_DEVICE_POWER_NOT_REQUIRED_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
pub type PPO_FX_DEVICE_POWER_NOT_REQUIRED_CALLBACK = PO_FX_DEVICE_POWER_NOT_REQUIRED_CALLBACK;
pub type PO_FX_POWER_CONTROL_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        DeviceContext: PVOID,
        PowerControlCode: LPCGUID,
        InBuffer: PVOID,
        InBufferSize: SIZE_T,
        OutBuffer: PVOID,
        OutBufferSize: SIZE_T,
        BytesReturned: PSIZE_T,
    ) -> NTSTATUS,
>;
pub type PPO_FX_POWER_CONTROL_CALLBACK = PO_FX_POWER_CONTROL_CALLBACK;
pub type PO_FX_COMPONENT_CRITICAL_TRANSITION_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, Component: ULONG, Active: BOOLEAN)>;
pub type PPO_FX_COMPONENT_CRITICAL_TRANSITION_CALLBACK =
PO_FX_COMPONENT_CRITICAL_TRANSITION_CALLBACK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_FX_COMPONENT_IDLE_STATE {
    pub TransitionLatency: ULONGLONG,
    pub ResidencyRequirement: ULONGLONG,
    pub NominalPower: ULONG,
}
pub type PO_FX_COMPONENT_IDLE_STATE = _PO_FX_COMPONENT_IDLE_STATE;
pub type PPO_FX_COMPONENT_IDLE_STATE = *mut _PO_FX_COMPONENT_IDLE_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_FX_COMPONENT_V1 {
    pub Id: GUID,
    pub IdleStateCount: ULONG,
    pub DeepestWakeableIdleState: ULONG,
    pub IdleStates: PPO_FX_COMPONENT_IDLE_STATE,
}
pub type PO_FX_COMPONENT_V1 = _PO_FX_COMPONENT_V1;
pub type PPO_FX_COMPONENT_V1 = *mut _PO_FX_COMPONENT_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_FX_DEVICE_V1 {
    pub Version: ULONG,
    pub ComponentCount: ULONG,
    pub ComponentActiveConditionCallback: PPO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK,
    pub ComponentIdleConditionCallback: PPO_FX_COMPONENT_IDLE_CONDITION_CALLBACK,
    pub ComponentIdleStateCallback: PPO_FX_COMPONENT_IDLE_STATE_CALLBACK,
    pub DevicePowerRequiredCallback: PPO_FX_DEVICE_POWER_REQUIRED_CALLBACK,
    pub DevicePowerNotRequiredCallback: PPO_FX_DEVICE_POWER_NOT_REQUIRED_CALLBACK,
    pub PowerControlCallback: PPO_FX_POWER_CONTROL_CALLBACK,
    pub DeviceContext: PVOID,
    pub Components: [PO_FX_COMPONENT_V1; 1usize],
}
pub type PO_FX_DEVICE_V1 = _PO_FX_DEVICE_V1;
pub type PPO_FX_DEVICE_V1 = *mut _PO_FX_DEVICE_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_FX_COMPONENT_V2 {
    pub Id: GUID,
    pub Flags: ULONGLONG,
    pub DeepestWakeableIdleState: ULONG,
    pub IdleStateCount: ULONG,
    pub IdleStates: PPO_FX_COMPONENT_IDLE_STATE,
    pub ProviderCount: ULONG,
    pub Providers: PULONG,
}
pub type PO_FX_COMPONENT_V2 = _PO_FX_COMPONENT_V2;
pub type PPO_FX_COMPONENT_V2 = *mut _PO_FX_COMPONENT_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_FX_DEVICE_V2 {
    pub Version: ULONG,
    pub Flags: ULONGLONG,
    pub ComponentActiveConditionCallback: PPO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK,
    pub ComponentIdleConditionCallback: PPO_FX_COMPONENT_IDLE_CONDITION_CALLBACK,
    pub ComponentIdleStateCallback: PPO_FX_COMPONENT_IDLE_STATE_CALLBACK,
    pub DevicePowerRequiredCallback: PPO_FX_DEVICE_POWER_REQUIRED_CALLBACK,
    pub DevicePowerNotRequiredCallback: PPO_FX_DEVICE_POWER_NOT_REQUIRED_CALLBACK,
    pub PowerControlCallback: PPO_FX_POWER_CONTROL_CALLBACK,
    pub DeviceContext: PVOID,
    pub ComponentCount: ULONG,
    pub Components: [PO_FX_COMPONENT_V2; 1usize],
}
pub type PO_FX_DEVICE_V2 = _PO_FX_DEVICE_V2;
pub type PPO_FX_DEVICE_V2 = *mut _PO_FX_DEVICE_V2;
pub type PO_FX_DIRECTED_POWER_UP_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, Flags: ULONG)>;
pub type PPO_FX_DIRECTED_POWER_UP_CALLBACK = PO_FX_DIRECTED_POWER_UP_CALLBACK;
pub type PO_FX_DIRECTED_POWER_DOWN_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, Flags: ULONG)>;
pub type PPO_FX_DIRECTED_POWER_DOWN_CALLBACK = PO_FX_DIRECTED_POWER_DOWN_CALLBACK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_FX_DEVICE_V3 {
    pub Version: ULONG,
    pub Flags: ULONGLONG,
    pub ComponentActiveConditionCallback: PPO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK,
    pub ComponentIdleConditionCallback: PPO_FX_COMPONENT_IDLE_CONDITION_CALLBACK,
    pub ComponentIdleStateCallback: PPO_FX_COMPONENT_IDLE_STATE_CALLBACK,
    pub DevicePowerRequiredCallback: PPO_FX_DEVICE_POWER_REQUIRED_CALLBACK,
    pub DevicePowerNotRequiredCallback: PPO_FX_DEVICE_POWER_NOT_REQUIRED_CALLBACK,
    pub PowerControlCallback: PPO_FX_POWER_CONTROL_CALLBACK,
    pub DirectedPowerUpCallback: PPO_FX_DIRECTED_POWER_UP_CALLBACK,
    pub DirectedPowerDownCallback: PPO_FX_DIRECTED_POWER_DOWN_CALLBACK,
    pub DirectedFxTimeoutInSeconds: ULONG,
    pub DeviceContext: PVOID,
    pub ComponentCount: ULONG,
    pub Components: [PO_FX_COMPONENT_V2; 1usize],
}
pub type PO_FX_DEVICE_V3 = _PO_FX_DEVICE_V3;
pub type PPO_FX_DEVICE_V3 = *mut _PO_FX_DEVICE_V3;
pub type PO_FX_COMPONENT = PO_FX_COMPONENT_V1;
pub type PPO_FX_COMPONENT = *mut PO_FX_COMPONENT_V1;
pub type PO_FX_DEVICE = PO_FX_DEVICE_V1;
pub type PPO_FX_DEVICE = *mut PO_FX_DEVICE_V1;
pub const _PO_FX_PERF_STATE_UNIT_PoFxPerfStateUnitOther: _PO_FX_PERF_STATE_UNIT = 0;
pub const _PO_FX_PERF_STATE_UNIT_PoFxPerfStateUnitFrequency: _PO_FX_PERF_STATE_UNIT = 1;
pub const _PO_FX_PERF_STATE_UNIT_PoFxPerfStateUnitBandwidth: _PO_FX_PERF_STATE_UNIT = 2;
pub const _PO_FX_PERF_STATE_UNIT_PoFxPerfStateUnitMaximum: _PO_FX_PERF_STATE_UNIT = 3;
pub type _PO_FX_PERF_STATE_UNIT = core::ffi::c_int;
pub use self::_PO_FX_PERF_STATE_UNIT as PO_FX_PERF_STATE_UNIT;
pub type PPO_FX_PERF_STATE_UNIT = *mut _PO_FX_PERF_STATE_UNIT;
pub const _PO_FX_PERF_STATE_TYPE_PoFxPerfStateTypeDiscrete: _PO_FX_PERF_STATE_TYPE = 0;
pub const _PO_FX_PERF_STATE_TYPE_PoFxPerfStateTypeRange: _PO_FX_PERF_STATE_TYPE = 1;
pub const _PO_FX_PERF_STATE_TYPE_PoFxPerfStateTypeMaximum: _PO_FX_PERF_STATE_TYPE = 2;
pub type _PO_FX_PERF_STATE_TYPE = core::ffi::c_int;
pub use self::_PO_FX_PERF_STATE_TYPE as PO_FX_PERF_STATE_TYPE;
pub type PPO_FX_PERF_STATE_TYPE = *mut _PO_FX_PERF_STATE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_FX_PERF_STATE {
    pub Value: ULONGLONG,
    pub Context: PVOID,
}
pub type PO_FX_PERF_STATE = _PO_FX_PERF_STATE;
pub type PPO_FX_PERF_STATE = *mut _PO_FX_PERF_STATE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PO_FX_COMPONENT_PERF_SET {
    pub Name: UNICODE_STRING,
    pub Flags: ULONGLONG,
    pub Unit: PO_FX_PERF_STATE_UNIT,
    pub Type: PO_FX_PERF_STATE_TYPE,
    pub __bindgen_anon_1: _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1 {
    pub Discrete: _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1__bindgen_ty_1,
    pub Range: _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1__bindgen_ty_1 {
    pub Count: ULONG,
    pub States: PPO_FX_PERF_STATE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_FX_COMPONENT_PERF_SET__bindgen_ty_1__bindgen_ty_2 {
    pub Minimum: ULONGLONG,
    pub Maximum: ULONGLONG,
}
pub type PO_FX_COMPONENT_PERF_SET = _PO_FX_COMPONENT_PERF_SET;
pub type PPO_FX_COMPONENT_PERF_SET = *mut _PO_FX_COMPONENT_PERF_SET;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PO_FX_COMPONENT_PERF_INFO {
    pub PerfStateSetsCount: ULONG,
    pub PerfStateSets: [PO_FX_COMPONENT_PERF_SET; 1usize],
}
pub type PO_FX_COMPONENT_PERF_INFO = _PO_FX_COMPONENT_PERF_INFO;
pub type PPO_FX_COMPONENT_PERF_INFO = *mut _PO_FX_COMPONENT_PERF_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PO_FX_PERF_STATE_CHANGE {
    pub Set: ULONG,
    pub __bindgen_anon_1: _PO_FX_PERF_STATE_CHANGE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PO_FX_PERF_STATE_CHANGE__bindgen_ty_1 {
    pub StateIndex: ULONG,
    pub StateValue: ULONGLONG,
}
pub type PO_FX_PERF_STATE_CHANGE = _PO_FX_PERF_STATE_CHANGE;
pub type PPO_FX_PERF_STATE_CHANGE = *mut _PO_FX_PERF_STATE_CHANGE;
unsafe extern "C" {
    pub fn PoFxRegisterDevice(
        Pdo: PDEVICE_OBJECT,
        Device: PPO_FX_DEVICE,
        Handle: *mut POHANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PoFxStartDevicePowerManagement(Handle: POHANDLE);
}
unsafe extern "C" {
    pub fn PoFxUnregisterDevice(Handle: POHANDLE);
}
unsafe extern "C" {
    pub fn PoFxRegisterCrashdumpDevice(Handle: POHANDLE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PoFxPowerOnCrashdumpDevice(Handle: POHANDLE, Context: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PoFxActivateComponent(Handle: POHANDLE, Component: ULONG, Flags: ULONG);
}
unsafe extern "C" {
    pub fn PoFxCompleteDevicePowerNotRequired(Handle: POHANDLE);
}
unsafe extern "C" {
    pub fn PoFxCompleteIdleCondition(Handle: POHANDLE, Component: ULONG);
}
unsafe extern "C" {
    pub fn PoFxCompleteIdleState(Handle: POHANDLE, Component: ULONG);
}
unsafe extern "C" {
    pub fn PoFxIdleComponent(Handle: POHANDLE, Component: ULONG, Flags: ULONG);
}
unsafe extern "C" {
    pub fn PoFxSetComponentLatency(Handle: POHANDLE, Component: ULONG, Latency: ULONGLONG);
}
unsafe extern "C" {
    pub fn PoFxSetComponentResidency(Handle: POHANDLE, Component: ULONG, Residency: ULONGLONG);
}
unsafe extern "C" {
    pub fn PoFxSetComponentWake(Handle: POHANDLE, Component: ULONG, WakeHint: BOOLEAN);
}
unsafe extern "C" {
    pub fn PoFxSetDeviceIdleTimeout(Handle: POHANDLE, IdleTimeout: ULONGLONG);
}
unsafe extern "C" {
    pub fn PoFxReportDevicePoweredOn(Handle: POHANDLE);
}
unsafe extern "C" {
    pub fn PoFxPowerControl(
        Handle: POHANDLE,
        PowerControlCode: LPCGUID,
        InBuffer: PVOID,
        InBufferSize: SIZE_T,
        OutBuffer: PVOID,
        OutBufferSize: SIZE_T,
        BytesReturned: PSIZE_T,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PoFxNotifySurprisePowerOn(Pdo: PDEVICE_OBJECT);
}
pub type PO_FX_COMPONENT_PERF_STATE_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        Component: ULONG,
        Succeeded: BOOLEAN,
        RequestContext: PVOID,
    ),
>;
pub type PPO_FX_COMPONENT_PERF_STATE_CALLBACK = PO_FX_COMPONENT_PERF_STATE_CALLBACK;
unsafe extern "C" {
    pub fn PoFxRegisterComponentPerfStates(
        Handle: POHANDLE,
        Component: ULONG,
        Flags: ULONGLONG,
        ComponentPerfStateCallback: PPO_FX_COMPONENT_PERF_STATE_CALLBACK,
        InputStateInfo: PPO_FX_COMPONENT_PERF_INFO,
        OutputStateInfo: *mut PPO_FX_COMPONENT_PERF_INFO,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PoFxIssueComponentPerfStateChange(
        Handle: POHANDLE,
        Flags: ULONG,
        Component: ULONG,
        PerfChange: PPO_FX_PERF_STATE_CHANGE,
        Context: PVOID,
    );
}
unsafe extern "C" {
    pub fn PoFxIssueComponentPerfStateChangeMultiple(
        Handle: POHANDLE,
        Flags: ULONG,
        Component: ULONG,
        PerfChangesCount: ULONG,
        PerfChanges: *mut PO_FX_PERF_STATE_CHANGE,
        Context: PVOID,
    );
}
unsafe extern "C" {
    pub fn PoFxQueryCurrentComponentPerfState(
        Handle: POHANDLE,
        Flags: ULONG,
        Component: ULONG,
        SetIndex: ULONG,
        CurrentPerf: PULONGLONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PoFxSetTargetDripsDevicePowerState(
        Handle: POHANDLE,
        TargetState: DEVICE_POWER_STATE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PoFxCompleteDirectedPowerDown(Handle: POHANDLE);
}
unsafe extern "C" {
    pub fn PoCreateThermalRequest(
        ThermalRequest: *mut PVOID,
        TargetDeviceObject: PDEVICE_OBJECT,
        PolicyDeviceObject: PDEVICE_OBJECT,
        Context: PCOUNTED_REASON_CONTEXT,
        Flags: ULONG,
    ) -> NTSTATUS;
}
pub const _PO_THERMAL_REQUEST_TYPE_PoThermalRequestPassive: _PO_THERMAL_REQUEST_TYPE = 0;
pub const _PO_THERMAL_REQUEST_TYPE_PoThermalRequestActive: _PO_THERMAL_REQUEST_TYPE = 1;
pub type _PO_THERMAL_REQUEST_TYPE = core::ffi::c_int;
pub use self::_PO_THERMAL_REQUEST_TYPE as PO_THERMAL_REQUEST_TYPE;
pub type PPO_THERMAL_REQUEST_TYPE = *mut _PO_THERMAL_REQUEST_TYPE;
unsafe extern "C" {
    pub fn PoGetThermalRequestSupport(
        ThermalRequest: PVOID,
        Type: PO_THERMAL_REQUEST_TYPE,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn PoSetThermalPassiveCooling(ThermalRequest: PVOID, Throttle: UCHAR) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PoSetThermalActiveCooling(ThermalRequest: PVOID, Engaged: BOOLEAN) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PoDeleteThermalRequest(ThermalRequest: PVOID);
}
pub type PO_FX_DRIPS_WATCHDOG_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(Context: PVOID, PhysicalDeviceObject: PDEVICE_OBJECT, UniqueId: ULONG),
>;
pub type PPO_FX_DRIPS_WATCHDOG_CALLBACK = PO_FX_DRIPS_WATCHDOG_CALLBACK;
unsafe extern "C" {
    pub fn PoFxRegisterDripsWatchdogCallback(
        Handle: POHANDLE,
        Callback: PPO_FX_DRIPS_WATCHDOG_CALLBACK,
        IncludeChildDevices: BOOLEAN,
        MatchingDriverObject: PDRIVER_OBJECT,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_HANDLE_INFORMATION {
    pub HandleAttributes: ULONG,
    pub GrantedAccess: ACCESS_MASK,
}
pub type OBJECT_HANDLE_INFORMATION = _OBJECT_HANDLE_INFORMATION;
pub type POBJECT_HANDLE_INFORMATION = *mut _OBJECT_HANDLE_INFORMATION;
unsafe extern "C" {
    pub fn ObReferenceObjectByHandle(
        Handle: HANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectType: POBJECT_TYPE,
        AccessMode: KPROCESSOR_MODE,
        Object: *mut PVOID,
        HandleInformation: POBJECT_HANDLE_INFORMATION,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ObReferenceObjectByHandleWithTag(
        Handle: HANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectType: POBJECT_TYPE,
        AccessMode: KPROCESSOR_MODE,
        Tag: ULONG,
        Object: *mut PVOID,
        HandleInformation: POBJECT_HANDLE_INFORMATION,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ObReferenceObjectSafe(Object: PVOID) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ObReferenceObjectSafeWithTag(Object: PVOID, Tag: ULONG) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ObCloseHandle(Handle: HANDLE, PreviousMode: KPROCESSOR_MODE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ObfReferenceObject(Object: PVOID) -> LONG_PTR;
}
unsafe extern "C" {
    pub fn ObfReferenceObjectWithTag(Object: PVOID, Tag: ULONG) -> LONG_PTR;
}
unsafe extern "C" {
    pub fn ObReferenceObjectByPointer(
        Object: PVOID,
        DesiredAccess: ACCESS_MASK,
        ObjectType: POBJECT_TYPE,
        AccessMode: KPROCESSOR_MODE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ObReferenceObjectByPointerWithTag(
        Object: PVOID,
        DesiredAccess: ACCESS_MASK,
        ObjectType: POBJECT_TYPE,
        AccessMode: KPROCESSOR_MODE,
        Tag: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ObfDereferenceObject(Object: PVOID) -> LONG_PTR;
}
unsafe extern "C" {
    pub fn ObfDereferenceObjectWithTag(Object: PVOID, Tag: ULONG) -> LONG_PTR;
}
unsafe extern "C" {
    pub fn ObDereferenceObjectDeferDelete(Object: PVOID);
}
unsafe extern "C" {
    pub fn ObDereferenceObjectDeferDeleteWithTag(Object: PVOID, Tag: ULONG);
}
unsafe extern "C" {
    pub fn ObGetObjectSecurity(
        Object: PVOID,
        SecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
        MemoryAllocated: PBOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ObReleaseObjectSecurity(
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        MemoryAllocated: BOOLEAN,
    );
}
pub type OB_OPERATION = ULONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OB_PRE_CREATE_HANDLE_INFORMATION {
    pub DesiredAccess: ACCESS_MASK,
    pub OriginalDesiredAccess: ACCESS_MASK,
}
pub type OB_PRE_CREATE_HANDLE_INFORMATION = _OB_PRE_CREATE_HANDLE_INFORMATION;
pub type POB_PRE_CREATE_HANDLE_INFORMATION = *mut _OB_PRE_CREATE_HANDLE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OB_PRE_DUPLICATE_HANDLE_INFORMATION {
    pub DesiredAccess: ACCESS_MASK,
    pub OriginalDesiredAccess: ACCESS_MASK,
    pub SourceProcess: PVOID,
    pub TargetProcess: PVOID,
}
pub type OB_PRE_DUPLICATE_HANDLE_INFORMATION = _OB_PRE_DUPLICATE_HANDLE_INFORMATION;
pub type POB_PRE_DUPLICATE_HANDLE_INFORMATION = *mut _OB_PRE_DUPLICATE_HANDLE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OB_PRE_OPERATION_PARAMETERS {
    pub CreateHandleInformation: OB_PRE_CREATE_HANDLE_INFORMATION,
    pub DuplicateHandleInformation: OB_PRE_DUPLICATE_HANDLE_INFORMATION,
}
pub type OB_PRE_OPERATION_PARAMETERS = _OB_PRE_OPERATION_PARAMETERS;
pub type POB_PRE_OPERATION_PARAMETERS = *mut _OB_PRE_OPERATION_PARAMETERS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OB_PRE_OPERATION_INFORMATION {
    pub Operation: OB_OPERATION,
    pub __bindgen_anon_1: _OB_PRE_OPERATION_INFORMATION__bindgen_ty_1,
    pub Object: PVOID,
    pub ObjectType: POBJECT_TYPE,
    pub CallContext: PVOID,
    pub Parameters: POB_PRE_OPERATION_PARAMETERS,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OB_PRE_OPERATION_INFORMATION__bindgen_ty_1 {
    pub Flags: ULONG,
    pub __bindgen_anon_1: _OB_PRE_OPERATION_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OB_PRE_OPERATION_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _OB_PRE_OPERATION_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn KernelHandle(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_KernelHandle(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn KernelHandle_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_KernelHandle_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        KernelHandle: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let KernelHandle: u32 = unsafe { ::core::mem::transmute(KernelHandle) };
            KernelHandle as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type OB_PRE_OPERATION_INFORMATION = _OB_PRE_OPERATION_INFORMATION;
pub type POB_PRE_OPERATION_INFORMATION = *mut _OB_PRE_OPERATION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OB_POST_CREATE_HANDLE_INFORMATION {
    pub GrantedAccess: ACCESS_MASK,
}
pub type OB_POST_CREATE_HANDLE_INFORMATION = _OB_POST_CREATE_HANDLE_INFORMATION;
pub type POB_POST_CREATE_HANDLE_INFORMATION = *mut _OB_POST_CREATE_HANDLE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OB_POST_DUPLICATE_HANDLE_INFORMATION {
    pub GrantedAccess: ACCESS_MASK,
}
pub type OB_POST_DUPLICATE_HANDLE_INFORMATION = _OB_POST_DUPLICATE_HANDLE_INFORMATION;
pub type POB_POST_DUPLICATE_HANDLE_INFORMATION = *mut _OB_POST_DUPLICATE_HANDLE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OB_POST_OPERATION_PARAMETERS {
    pub CreateHandleInformation: OB_POST_CREATE_HANDLE_INFORMATION,
    pub DuplicateHandleInformation: OB_POST_DUPLICATE_HANDLE_INFORMATION,
}
pub type OB_POST_OPERATION_PARAMETERS = _OB_POST_OPERATION_PARAMETERS;
pub type POB_POST_OPERATION_PARAMETERS = *mut _OB_POST_OPERATION_PARAMETERS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OB_POST_OPERATION_INFORMATION {
    pub Operation: OB_OPERATION,
    pub __bindgen_anon_1: _OB_POST_OPERATION_INFORMATION__bindgen_ty_1,
    pub Object: PVOID,
    pub ObjectType: POBJECT_TYPE,
    pub CallContext: PVOID,
    pub ReturnStatus: NTSTATUS,
    pub Parameters: POB_POST_OPERATION_PARAMETERS,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OB_POST_OPERATION_INFORMATION__bindgen_ty_1 {
    pub Flags: ULONG,
    pub __bindgen_anon_1: _OB_POST_OPERATION_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OB_POST_OPERATION_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _OB_POST_OPERATION_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn KernelHandle(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_KernelHandle(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn KernelHandle_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_KernelHandle_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        KernelHandle: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let KernelHandle: u32 = unsafe { ::core::mem::transmute(KernelHandle) };
            KernelHandle as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type OB_POST_OPERATION_INFORMATION = _OB_POST_OPERATION_INFORMATION;
pub type POB_POST_OPERATION_INFORMATION = *mut _OB_POST_OPERATION_INFORMATION;
pub const _OB_PREOP_CALLBACK_STATUS_OB_PREOP_SUCCESS: _OB_PREOP_CALLBACK_STATUS = 0;
pub type _OB_PREOP_CALLBACK_STATUS = core::ffi::c_int;
pub use self::_OB_PREOP_CALLBACK_STATUS as OB_PREOP_CALLBACK_STATUS;
pub type POB_PREOP_CALLBACK_STATUS = *mut _OB_PREOP_CALLBACK_STATUS;
pub type POB_PRE_OPERATION_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        RegistrationContext: PVOID,
        OperationInformation: POB_PRE_OPERATION_INFORMATION,
    ) -> OB_PREOP_CALLBACK_STATUS,
>;
pub type POB_POST_OPERATION_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        RegistrationContext: PVOID,
        OperationInformation: POB_POST_OPERATION_INFORMATION,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OB_OPERATION_REGISTRATION {
    pub ObjectType: *mut POBJECT_TYPE,
    pub Operations: OB_OPERATION,
    pub PreOperation: POB_PRE_OPERATION_CALLBACK,
    pub PostOperation: POB_POST_OPERATION_CALLBACK,
}
pub type OB_OPERATION_REGISTRATION = _OB_OPERATION_REGISTRATION;
pub type POB_OPERATION_REGISTRATION = *mut _OB_OPERATION_REGISTRATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OB_CALLBACK_REGISTRATION {
    pub Version: USHORT,
    pub OperationRegistrationCount: USHORT,
    pub Altitude: UNICODE_STRING,
    pub RegistrationContext: PVOID,
    pub OperationRegistration: *mut OB_OPERATION_REGISTRATION,
}
pub type OB_CALLBACK_REGISTRATION = _OB_CALLBACK_REGISTRATION;
pub type POB_CALLBACK_REGISTRATION = *mut _OB_CALLBACK_REGISTRATION;
unsafe extern "C" {
    pub fn ObRegisterCallbacks(
        CallbackRegistration: POB_CALLBACK_REGISTRATION,
        RegistrationHandle: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ObUnRegisterCallbacks(RegistrationHandle: PVOID);
}
unsafe extern "C" {
    pub fn ObGetFilterVersion() -> USHORT;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_SEGMENT_BUS_NUMBER {
    pub u: _PCI_SEGMENT_BUS_NUMBER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_SEGMENT_BUS_NUMBER__bindgen_ty_1 {
    pub bits: _PCI_SEGMENT_BUS_NUMBER__bindgen_ty_1__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_SEGMENT_BUS_NUMBER__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_SEGMENT_BUS_NUMBER__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn BusNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BusNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn BusNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_BusNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SegmentNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_SegmentNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SegmentNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SegmentNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BusNumber: ULONG,
        SegmentNumber: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let BusNumber: u32 = unsafe { ::core::mem::transmute(BusNumber) };
            BusNumber as u64
        });
        __bindgen_bitfield_unit.set(8usize, 16u8, {
            let SegmentNumber: u32 = unsafe { ::core::mem::transmute(SegmentNumber) };
            SegmentNumber as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_SEGMENT_BUS_NUMBER = _PCI_SEGMENT_BUS_NUMBER;
pub type PPCI_SEGMENT_BUS_NUMBER = *mut _PCI_SEGMENT_BUS_NUMBER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_SLOT_NUMBER {
    pub u: _PCI_SLOT_NUMBER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_SLOT_NUMBER__bindgen_ty_1 {
    pub bits: _PCI_SLOT_NUMBER__bindgen_ty_1__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_SLOT_NUMBER__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_SLOT_NUMBER__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn DeviceNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_DeviceNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DeviceNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DeviceNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FunctionNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_FunctionNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FunctionNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FunctionNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DeviceNumber: ULONG,
        FunctionNumber: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let DeviceNumber: u32 = unsafe { ::core::mem::transmute(DeviceNumber) };
            DeviceNumber as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let FunctionNumber: u32 = unsafe { ::core::mem::transmute(FunctionNumber) };
            FunctionNumber as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_SLOT_NUMBER = _PCI_SLOT_NUMBER;
pub type PPCI_SLOT_NUMBER = *mut _PCI_SLOT_NUMBER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_COMMON_HEADER {
    pub VendorID: USHORT,
    pub DeviceID: USHORT,
    pub Command: USHORT,
    pub Status: USHORT,
    pub RevisionID: UCHAR,
    pub ProgIf: UCHAR,
    pub SubClass: UCHAR,
    pub BaseClass: UCHAR,
    pub CacheLineSize: UCHAR,
    pub LatencyTimer: UCHAR,
    pub HeaderType: UCHAR,
    pub BIST: UCHAR,
    pub u: _PCI_COMMON_HEADER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_COMMON_HEADER__bindgen_ty_1 {
    pub type0: _PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_0,
    pub type1: _PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_1,
    pub type2: _PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_0 {
    pub BaseAddresses: [ULONG; 6usize],
    pub CIS: ULONG,
    pub SubVendorID: USHORT,
    pub SubSystemID: USHORT,
    pub ROMBaseAddress: ULONG,
    pub CapabilitiesPtr: UCHAR,
    pub Reserved1: [UCHAR; 3usize],
    pub Reserved2: ULONG,
    pub InterruptLine: UCHAR,
    pub InterruptPin: UCHAR,
    pub MinimumGrant: UCHAR,
    pub MaximumLatency: UCHAR,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_1 {
    pub BaseAddresses: [ULONG; 2usize],
    pub PrimaryBus: UCHAR,
    pub SecondaryBus: UCHAR,
    pub SubordinateBus: UCHAR,
    pub SecondaryLatency: UCHAR,
    pub IOBase: UCHAR,
    pub IOLimit: UCHAR,
    pub SecondaryStatus: USHORT,
    pub MemoryBase: USHORT,
    pub MemoryLimit: USHORT,
    pub PrefetchBase: USHORT,
    pub PrefetchLimit: USHORT,
    pub PrefetchBaseUpper32: ULONG,
    pub PrefetchLimitUpper32: ULONG,
    pub IOBaseUpper16: USHORT,
    pub IOLimitUpper16: USHORT,
    pub CapabilitiesPtr: UCHAR,
    pub Reserved1: [UCHAR; 3usize],
    pub ROMBaseAddress: ULONG,
    pub InterruptLine: UCHAR,
    pub InterruptPin: UCHAR,
    pub BridgeControl: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_2 {
    pub SocketRegistersBaseAddress: ULONG,
    pub CapabilitiesPtr: UCHAR,
    pub Reserved: UCHAR,
    pub SecondaryStatus: USHORT,
    pub PrimaryBus: UCHAR,
    pub SecondaryBus: UCHAR,
    pub SubordinateBus: UCHAR,
    pub SecondaryLatency: UCHAR,
    pub Range: [_PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_2__bindgen_ty_1; 4usize],
    pub InterruptLine: UCHAR,
    pub InterruptPin: UCHAR,
    pub BridgeControl: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_COMMON_HEADER__bindgen_ty_1__PCI_HEADER_TYPE_2__bindgen_ty_1 {
    pub Base: ULONG,
    pub Limit: ULONG,
}
pub type PCI_COMMON_HEADER = _PCI_COMMON_HEADER;
pub type PPCI_COMMON_HEADER = *mut _PCI_COMMON_HEADER;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_COMMON_CONFIG {
    pub __bindgen_padding_0: [u8; 64usize],
    pub DeviceSpecific: [UCHAR; 192usize],
}
pub type PCI_COMMON_CONFIG = _PCI_COMMON_CONFIG;
pub type PPCI_COMMON_CONFIG = *mut _PCI_COMMON_CONFIG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_CAPABILITIES_HEADER {
    pub CapabilityID: UCHAR,
    pub Next: UCHAR,
}
pub type PCI_CAPABILITIES_HEADER = _PCI_CAPABILITIES_HEADER;
pub type PPCI_CAPABILITIES_HEADER = *mut _PCI_CAPABILITIES_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_PMC {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub Support: _PCI_PMC__PM_SUPPORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_PMC__PM_SUPPORT {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _PCI_PMC__PM_SUPPORT {
    #[inline]
    pub fn Rsvd2(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd2_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd2_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn D1(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_D1(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn D1_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_D1_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn D2(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_D2(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn D2_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_D2_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PMED0(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PMED0(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PMED0_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_PMED0_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PMED1(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PMED1(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PMED1_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_PMED1_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PMED2(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PMED2(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PMED2_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_PMED2_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PMED3Hot(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PMED3Hot(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PMED3Hot_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_PMED3Hot_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PMED3Cold(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PMED3Cold(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PMED3Cold_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_PMED3Cold_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Rsvd2: UCHAR,
        D1: UCHAR,
        D2: UCHAR,
        PMED0: UCHAR,
        PMED1: UCHAR,
        PMED2: UCHAR,
        PMED3Hot: UCHAR,
        PMED3Cold: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Rsvd2: u8 = unsafe { ::core::mem::transmute(Rsvd2) };
            Rsvd2 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let D1: u8 = unsafe { ::core::mem::transmute(D1) };
            D1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let D2: u8 = unsafe { ::core::mem::transmute(D2) };
            D2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PMED0: u8 = unsafe { ::core::mem::transmute(PMED0) };
            PMED0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PMED1: u8 = unsafe { ::core::mem::transmute(PMED1) };
            PMED1 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PMED2: u8 = unsafe { ::core::mem::transmute(PMED2) };
            PMED2 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PMED3Hot: u8 = unsafe { ::core::mem::transmute(PMED3Hot) };
            PMED3Hot as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PMED3Cold: u8 = unsafe { ::core::mem::transmute(PMED3Cold) };
            PMED3Cold as u64
        });
        __bindgen_bitfield_unit
    }
}
impl _PCI_PMC {
    #[inline]
    pub fn Version(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_Version(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Version_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Version_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PMEClock(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PMEClock(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PMEClock_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_PMEClock_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd1(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd1_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd1_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DeviceSpecificInitialization(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DeviceSpecificInitialization(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DeviceSpecificInitialization_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_DeviceSpecificInitialization_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd2(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd2_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd2_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Version: UCHAR,
        PMEClock: UCHAR,
        Rsvd1: UCHAR,
        DeviceSpecificInitialization: UCHAR,
        Rsvd2: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let Version: u8 = unsafe { ::core::mem::transmute(Version) };
            Version as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PMEClock: u8 = unsafe { ::core::mem::transmute(PMEClock) };
            PMEClock as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Rsvd1: u8 = unsafe { ::core::mem::transmute(Rsvd1) };
            Rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DeviceSpecificInitialization: u8 =
                unsafe { ::core::mem::transmute(DeviceSpecificInitialization) };
            DeviceSpecificInitialization as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let Rsvd2: u8 = unsafe { ::core::mem::transmute(Rsvd2) };
            Rsvd2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_PMC = _PCI_PMC;
pub type PPCI_PMC = *mut _PCI_PMC;
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_PMCSR {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_PMCSR {
    #[inline]
    pub fn PowerState(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_PowerState(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PowerState_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PowerState_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd1(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd1_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd1_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NoSoftReset(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_NoSoftReset(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NoSoftReset_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_NoSoftReset_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd2(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd2_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd2_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PMEEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PMEEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PMEEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PMEEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DataSelect(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_DataSelect(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DataSelect_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_DataSelect_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DataScale(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_DataScale(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DataScale_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_DataScale_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PMEStatus(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PMEStatus(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PMEStatus_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PMEStatus_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PowerState: USHORT,
        Rsvd1: USHORT,
        NoSoftReset: USHORT,
        Rsvd2: USHORT,
        PMEEnable: USHORT,
        DataSelect: USHORT,
        DataScale: USHORT,
        PMEStatus: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let PowerState: u16 = unsafe { ::core::mem::transmute(PowerState) };
            PowerState as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Rsvd1: u16 = unsafe { ::core::mem::transmute(Rsvd1) };
            Rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let NoSoftReset: u16 = unsafe { ::core::mem::transmute(NoSoftReset) };
            NoSoftReset as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let Rsvd2: u16 = unsafe { ::core::mem::transmute(Rsvd2) };
            Rsvd2 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let PMEEnable: u16 = unsafe { ::core::mem::transmute(PMEEnable) };
            PMEEnable as u64
        });
        __bindgen_bitfield_unit.set(9usize, 4u8, {
            let DataSelect: u16 = unsafe { ::core::mem::transmute(DataSelect) };
            DataSelect as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let DataScale: u16 = unsafe { ::core::mem::transmute(DataScale) };
            DataScale as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let PMEStatus: u16 = unsafe { ::core::mem::transmute(PMEStatus) };
            PMEStatus as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_PMCSR = _PCI_PMCSR;
pub type PPCI_PMCSR = *mut _PCI_PMCSR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_PMCSR_BSE {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _PCI_PMCSR_BSE {
    #[inline]
    pub fn Rsvd1(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd1_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                6u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd1_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn D3HotSupportsStopClock(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_D3HotSupportsStopClock(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn D3HotSupportsStopClock_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_D3HotSupportsStopClock_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn BusPowerClockControlEnabled(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BusPowerClockControlEnabled(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn BusPowerClockControlEnabled_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_BusPowerClockControlEnabled_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Rsvd1: UCHAR,
        D3HotSupportsStopClock: UCHAR,
        BusPowerClockControlEnabled: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let Rsvd1: u8 = unsafe { ::core::mem::transmute(Rsvd1) };
            Rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let D3HotSupportsStopClock: u8 =
                unsafe { ::core::mem::transmute(D3HotSupportsStopClock) };
            D3HotSupportsStopClock as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let BusPowerClockControlEnabled: u8 =
                unsafe { ::core::mem::transmute(BusPowerClockControlEnabled) };
            BusPowerClockControlEnabled as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_PMCSR_BSE = _PCI_PMCSR_BSE;
pub type PPCI_PMCSR_BSE = *mut _PCI_PMCSR_BSE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_PM_CAPABILITY {
    pub Header: PCI_CAPABILITIES_HEADER,
    pub PMC: _PCI_PM_CAPABILITY__bindgen_ty_1,
    pub PMCSR: _PCI_PM_CAPABILITY__bindgen_ty_2,
    pub PMCSR_BSE: _PCI_PM_CAPABILITY__bindgen_ty_3,
    pub Data: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_PM_CAPABILITY__bindgen_ty_1 {
    pub Capabilities: PCI_PMC,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_PM_CAPABILITY__bindgen_ty_2 {
    pub ControlStatus: PCI_PMCSR,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_PM_CAPABILITY__bindgen_ty_3 {
    pub BridgeSupport: PCI_PMCSR_BSE,
    pub AsUCHAR: UCHAR,
}
pub type PCI_PM_CAPABILITY = _PCI_PM_CAPABILITY;
pub type PPCI_PM_CAPABILITY = *mut _PCI_PM_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PCI_X_CAPABILITY {
    pub Header: PCI_CAPABILITIES_HEADER,
    pub Command: PCI_X_CAPABILITY__bindgen_ty_1,
    pub Status: PCI_X_CAPABILITY__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PCI_X_CAPABILITY__bindgen_ty_1 {
    pub bits: PCI_X_CAPABILITY__bindgen_ty_1__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PCI_X_CAPABILITY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl PCI_X_CAPABILITY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn DataParityErrorRecoveryEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DataParityErrorRecoveryEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DataParityErrorRecoveryEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_DataParityErrorRecoveryEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EnableRelaxedOrdering(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EnableRelaxedOrdering(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EnableRelaxedOrdering_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_EnableRelaxedOrdering_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MaxMemoryReadByteCount(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_MaxMemoryReadByteCount(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MaxMemoryReadByteCount_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_MaxMemoryReadByteCount_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MaxOutstandingSplitTransactions(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_MaxOutstandingSplitTransactions(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MaxOutstandingSplitTransactions_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_MaxOutstandingSplitTransactions_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                9u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                9u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DataParityErrorRecoveryEnable: USHORT,
        EnableRelaxedOrdering: USHORT,
        MaxMemoryReadByteCount: USHORT,
        MaxOutstandingSplitTransactions: USHORT,
        Reserved: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DataParityErrorRecoveryEnable: u16 =
                unsafe { ::core::mem::transmute(DataParityErrorRecoveryEnable) };
            DataParityErrorRecoveryEnable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let EnableRelaxedOrdering: u16 =
                unsafe { ::core::mem::transmute(EnableRelaxedOrdering) };
            EnableRelaxedOrdering as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let MaxMemoryReadByteCount: u16 =
                unsafe { ::core::mem::transmute(MaxMemoryReadByteCount) };
            MaxMemoryReadByteCount as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let MaxOutstandingSplitTransactions: u16 =
                unsafe { ::core::mem::transmute(MaxOutstandingSplitTransactions) };
            MaxOutstandingSplitTransactions as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let Reserved: u16 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PCI_X_CAPABILITY__bindgen_ty_2 {
    pub bits: PCI_X_CAPABILITY__bindgen_ty_2__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PCI_X_CAPABILITY__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl PCI_X_CAPABILITY__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn FunctionNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_FunctionNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FunctionNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FunctionNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DeviceNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_DeviceNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DeviceNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DeviceNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn BusNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BusNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn BusNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_BusNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Device64Bit(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Device64Bit(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Device64Bit_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Device64Bit_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Capable133MHz(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Capable133MHz(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Capable133MHz_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Capable133MHz_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SplitCompletionDiscarded(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SplitCompletionDiscarded(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SplitCompletionDiscarded_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SplitCompletionDiscarded_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UnexpectedSplitCompletion(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UnexpectedSplitCompletion(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UnexpectedSplitCompletion_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UnexpectedSplitCompletion_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DeviceComplexity(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeviceComplexity(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DeviceComplexity_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DeviceComplexity_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DesignedMaxMemoryReadByteCount(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_DesignedMaxMemoryReadByteCount(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DesignedMaxMemoryReadByteCount_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DesignedMaxMemoryReadByteCount_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DesignedMaxOutstandingSplitTransactions(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_DesignedMaxOutstandingSplitTransactions(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DesignedMaxOutstandingSplitTransactions_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DesignedMaxOutstandingSplitTransactions_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DesignedMaxCumulativeReadSize(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_DesignedMaxCumulativeReadSize(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DesignedMaxCumulativeReadSize_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DesignedMaxCumulativeReadSize_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReceivedSplitCompletionErrorMessage(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReceivedSplitCompletionErrorMessage(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReceivedSplitCompletionErrorMessage_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                29usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReceivedSplitCompletionErrorMessage_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                29usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CapablePCIX266(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CapablePCIX266(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CapablePCIX266_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CapablePCIX266_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CapablePCIX533(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CapablePCIX533(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CapablePCIX533_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CapablePCIX533_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FunctionNumber: ULONG,
        DeviceNumber: ULONG,
        BusNumber: ULONG,
        Device64Bit: ULONG,
        Capable133MHz: ULONG,
        SplitCompletionDiscarded: ULONG,
        UnexpectedSplitCompletion: ULONG,
        DeviceComplexity: ULONG,
        DesignedMaxMemoryReadByteCount: ULONG,
        DesignedMaxOutstandingSplitTransactions: ULONG,
        DesignedMaxCumulativeReadSize: ULONG,
        ReceivedSplitCompletionErrorMessage: ULONG,
        CapablePCIX266: ULONG,
        CapablePCIX533: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let FunctionNumber: u32 = unsafe { ::core::mem::transmute(FunctionNumber) };
            FunctionNumber as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let DeviceNumber: u32 = unsafe { ::core::mem::transmute(DeviceNumber) };
            DeviceNumber as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let BusNumber: u32 = unsafe { ::core::mem::transmute(BusNumber) };
            BusNumber as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let Device64Bit: u32 = unsafe { ::core::mem::transmute(Device64Bit) };
            Device64Bit as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let Capable133MHz: u32 = unsafe { ::core::mem::transmute(Capable133MHz) };
            Capable133MHz as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let SplitCompletionDiscarded: u32 =
                unsafe { ::core::mem::transmute(SplitCompletionDiscarded) };
            SplitCompletionDiscarded as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let UnexpectedSplitCompletion: u32 =
                unsafe { ::core::mem::transmute(UnexpectedSplitCompletion) };
            UnexpectedSplitCompletion as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let DeviceComplexity: u32 = unsafe { ::core::mem::transmute(DeviceComplexity) };
            DeviceComplexity as u64
        });
        __bindgen_bitfield_unit.set(21usize, 2u8, {
            let DesignedMaxMemoryReadByteCount: u32 =
                unsafe { ::core::mem::transmute(DesignedMaxMemoryReadByteCount) };
            DesignedMaxMemoryReadByteCount as u64
        });
        __bindgen_bitfield_unit.set(23usize, 3u8, {
            let DesignedMaxOutstandingSplitTransactions: u32 =
                unsafe { ::core::mem::transmute(DesignedMaxOutstandingSplitTransactions) };
            DesignedMaxOutstandingSplitTransactions as u64
        });
        __bindgen_bitfield_unit.set(26usize, 3u8, {
            let DesignedMaxCumulativeReadSize: u32 =
                unsafe { ::core::mem::transmute(DesignedMaxCumulativeReadSize) };
            DesignedMaxCumulativeReadSize as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let ReceivedSplitCompletionErrorMessage: u32 =
                unsafe { ::core::mem::transmute(ReceivedSplitCompletionErrorMessage) };
            ReceivedSplitCompletionErrorMessage as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let CapablePCIX266: u32 = unsafe { ::core::mem::transmute(CapablePCIX266) };
            CapablePCIX266 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let CapablePCIX533: u32 = unsafe { ::core::mem::transmute(CapablePCIX533) };
            CapablePCIX533 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PPCI_X_CAPABILITY = *mut PCI_X_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER {
    pub CapabilityID: USHORT,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER {
    #[inline]
    pub fn Version(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_Version(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Version_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Version_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Next(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_Next(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Next_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                12u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Next_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(Version: USHORT, Next: USHORT) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let Version: u16 = unsafe { ::core::mem::transmute(Version) };
            Version as u64
        });
        __bindgen_bitfield_unit.set(4usize, 12u8, {
            let Next: u16 = unsafe { ::core::mem::transmute(Next) };
            Next as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER = _PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER;
pub type PPCI_EXPRESS_ENHANCED_CAPABILITY_HEADER = *mut _PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_VENDOR_SPECIFIC_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub VsecId: USHORT,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_VENDOR_SPECIFIC_CAPABILITY {
    #[inline]
    pub fn VsecRev(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_VsecRev(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VsecRev_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_VsecRev_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VsecLength(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_VsecLength(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VsecLength_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                12u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_VsecLength_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        VsecRev: USHORT,
        VsecLength: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let VsecRev: u16 = unsafe { ::core::mem::transmute(VsecRev) };
            VsecRev as u64
        });
        __bindgen_bitfield_unit.set(4usize, 12u8, {
            let VsecLength: u16 = unsafe { ::core::mem::transmute(VsecLength) };
            VsecLength as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_VENDOR_SPECIFIC_CAPABILITY = _PCI_EXPRESS_VENDOR_SPECIFIC_CAPABILITY;
pub type PPCI_EXPRESS_VENDOR_SPECIFIC_CAPABILITY = *mut _PCI_EXPRESS_VENDOR_SPECIFIC_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_SERIAL_NUMBER_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub LowSerialNumber: ULONG,
    pub HighSerialNumber: ULONG,
}
pub type PCI_EXPRESS_SERIAL_NUMBER_CAPABILITY = _PCI_EXPRESS_SERIAL_NUMBER_CAPABILITY;
pub type PPCI_EXPRESS_SERIAL_NUMBER_CAPABILITY = *mut _PCI_EXPRESS_SERIAL_NUMBER_CAPABILITY;
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_ARI_CAPABILITY_REGISTER {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_ARI_CAPABILITY_REGISTER {
    #[inline]
    pub fn MfvcFunctionGroupsCapability(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_MfvcFunctionGroupsCapability(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MfvcFunctionGroupsCapability_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_MfvcFunctionGroupsCapability_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AcsFunctionGroupsCapability(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_AcsFunctionGroupsCapability(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AcsFunctionGroupsCapability_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_AcsFunctionGroupsCapability_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                6u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NextFunctionNumber(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_NextFunctionNumber(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NextFunctionNumber_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_NextFunctionNumber_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MfvcFunctionGroupsCapability: USHORT,
        AcsFunctionGroupsCapability: USHORT,
        Reserved: USHORT,
        NextFunctionNumber: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let MfvcFunctionGroupsCapability: u16 =
                unsafe { ::core::mem::transmute(MfvcFunctionGroupsCapability) };
            MfvcFunctionGroupsCapability as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AcsFunctionGroupsCapability: u16 =
                unsafe { ::core::mem::transmute(AcsFunctionGroupsCapability) };
            AcsFunctionGroupsCapability as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let Reserved: u16 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let NextFunctionNumber: u16 = unsafe { ::core::mem::transmute(NextFunctionNumber) };
            NextFunctionNumber as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_ARI_CAPABILITY_REGISTER = _PCI_EXPRESS_ARI_CAPABILITY_REGISTER;
pub type PPCI_EXPRESS_ARI_CAPABILITY_REGISTER = *mut _PCI_EXPRESS_ARI_CAPABILITY_REGISTER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_ARI_CONTROL_REGISTER {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_ARI_CONTROL_REGISTER {
    #[inline]
    pub fn MfvcFunctionGroupsEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_MfvcFunctionGroupsEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MfvcFunctionGroupsEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_MfvcFunctionGroupsEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AcsFunctionGroupsEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_AcsFunctionGroupsEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AcsFunctionGroupsEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_AcsFunctionGroupsEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FunctionGroup(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_FunctionGroup(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FunctionGroup_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_FunctionGroup_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved2_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                9u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved2_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                9u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MfvcFunctionGroupsEnable: USHORT,
        AcsFunctionGroupsEnable: USHORT,
        Reserved1: USHORT,
        FunctionGroup: USHORT,
        Reserved2: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let MfvcFunctionGroupsEnable: u16 =
                unsafe { ::core::mem::transmute(MfvcFunctionGroupsEnable) };
            MfvcFunctionGroupsEnable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AcsFunctionGroupsEnable: u16 =
                unsafe { ::core::mem::transmute(AcsFunctionGroupsEnable) };
            AcsFunctionGroupsEnable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let Reserved1: u16 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let FunctionGroup: u16 = unsafe { ::core::mem::transmute(FunctionGroup) };
            FunctionGroup as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let Reserved2: u16 = unsafe { ::core::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_ARI_CONTROL_REGISTER = _PCI_EXPRESS_ARI_CONTROL_REGISTER;
pub type PPCI_EXPRESS_ARI_CONTROL_REGISTER = *mut _PCI_EXPRESS_ARI_CONTROL_REGISTER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_ARI_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub Capability: PCI_EXPRESS_ARI_CAPABILITY_REGISTER,
    pub Control: PCI_EXPRESS_ARI_CONTROL_REGISTER,
}
pub type PCI_EXPRESS_ARI_CAPABILITY = _PCI_EXPRESS_ARI_CAPABILITY;
pub type PPCI_EXPRESS_ARI_CAPABILITY = *mut _PCI_EXPRESS_ARI_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VIRTUAL_CHANNEL_CAPABILITIES1 {
    pub __bindgen_anon_1: _VIRTUAL_CHANNEL_CAPABILITIES1__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VIRTUAL_CHANNEL_CAPABILITIES1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VIRTUAL_CHANNEL_CAPABILITIES1__bindgen_ty_1 {
    #[inline]
    pub fn ExtendedVCCount(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ExtendedVCCount(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ExtendedVCCount_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ExtendedVCCount_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RsvdP1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RsvdP1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RsvdP1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RsvdP1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LowPriorityExtendedVCCount(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_LowPriorityExtendedVCCount(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LowPriorityExtendedVCCount_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_LowPriorityExtendedVCCount_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RsvdP2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RsvdP2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RsvdP2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RsvdP2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReferenceClock(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ReferenceClock(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReferenceClock_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReferenceClock_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PortArbitrationTableEntrySize(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_PortArbitrationTableEntrySize(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PortArbitrationTableEntrySize_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PortArbitrationTableEntrySize_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RsvdP3(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_RsvdP3(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RsvdP3_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                20u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RsvdP3_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                20u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ExtendedVCCount: ULONG,
        RsvdP1: ULONG,
        LowPriorityExtendedVCCount: ULONG,
        RsvdP2: ULONG,
        ReferenceClock: ULONG,
        PortArbitrationTableEntrySize: ULONG,
        RsvdP3: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let ExtendedVCCount: u32 = unsafe { ::core::mem::transmute(ExtendedVCCount) };
            ExtendedVCCount as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let RsvdP1: u32 = unsafe { ::core::mem::transmute(RsvdP1) };
            RsvdP1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let LowPriorityExtendedVCCount: u32 =
                unsafe { ::core::mem::transmute(LowPriorityExtendedVCCount) };
            LowPriorityExtendedVCCount as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let RsvdP2: u32 = unsafe { ::core::mem::transmute(RsvdP2) };
            RsvdP2 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let ReferenceClock: u32 = unsafe { ::core::mem::transmute(ReferenceClock) };
            ReferenceClock as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let PortArbitrationTableEntrySize: u32 =
                unsafe { ::core::mem::transmute(PortArbitrationTableEntrySize) };
            PortArbitrationTableEntrySize as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let RsvdP3: u32 = unsafe { ::core::mem::transmute(RsvdP3) };
            RsvdP3 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type VIRTUAL_CHANNEL_CAPABILITIES1 = _VIRTUAL_CHANNEL_CAPABILITIES1;
pub type PVIRTUAL_CHANNEL_CAPABILITIES1 = *mut _VIRTUAL_CHANNEL_CAPABILITIES1;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VIRTUAL_CHANNEL_CAPABILITIES2 {
    pub __bindgen_anon_1: _VIRTUAL_CHANNEL_CAPABILITIES2__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _VIRTUAL_CHANNEL_CAPABILITIES2__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VIRTUAL_CHANNEL_CAPABILITIES2__bindgen_ty_1 {
    #[inline]
    pub fn VCArbitrationCapability(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_VCArbitrationCapability(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VCArbitrationCapability_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VCArbitrationCapability_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RsvdP(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_RsvdP(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RsvdP_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RsvdP_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VCArbitrationTableOffset(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_VCArbitrationTableOffset(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VCArbitrationTableOffset_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VCArbitrationTableOffset_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        VCArbitrationCapability: ULONG,
        RsvdP: ULONG,
        VCArbitrationTableOffset: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let VCArbitrationCapability: u32 =
                unsafe { ::core::mem::transmute(VCArbitrationCapability) };
            VCArbitrationCapability as u64
        });
        __bindgen_bitfield_unit.set(8usize, 16u8, {
            let RsvdP: u32 = unsafe { ::core::mem::transmute(RsvdP) };
            RsvdP as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let VCArbitrationTableOffset: u32 =
                unsafe { ::core::mem::transmute(VCArbitrationTableOffset) };
            VCArbitrationTableOffset as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type VIRTUAL_CHANNEL_CAPABILITIES2 = _VIRTUAL_CHANNEL_CAPABILITIES2;
pub type PVIRTUAL_CHANNEL_CAPABILITIES2 = *mut _VIRTUAL_CHANNEL_CAPABILITIES2;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VIRTUAL_CHANNEL_CONTROL {
    pub __bindgen_anon_1: _VIRTUAL_CHANNEL_CONTROL__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VIRTUAL_CHANNEL_CONTROL__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _VIRTUAL_CHANNEL_CONTROL__bindgen_ty_1 {
    #[inline]
    pub fn LoadVCArbitrationTable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LoadVCArbitrationTable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LoadVCArbitrationTable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_LoadVCArbitrationTable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VCArbitrationSelect(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_VCArbitrationSelect(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VCArbitrationSelect_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_VCArbitrationSelect_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RsvdP(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_RsvdP(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RsvdP_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                12u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_RsvdP_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        LoadVCArbitrationTable: USHORT,
        VCArbitrationSelect: USHORT,
        RsvdP: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let LoadVCArbitrationTable: u16 =
                unsafe { ::core::mem::transmute(LoadVCArbitrationTable) };
            LoadVCArbitrationTable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let VCArbitrationSelect: u16 = unsafe { ::core::mem::transmute(VCArbitrationSelect) };
            VCArbitrationSelect as u64
        });
        __bindgen_bitfield_unit.set(4usize, 12u8, {
            let RsvdP: u16 = unsafe { ::core::mem::transmute(RsvdP) };
            RsvdP as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type VIRTUAL_CHANNEL_CONTROL = _VIRTUAL_CHANNEL_CONTROL;
pub type PVIRTUAL_CHANNEL_CONTROL = *mut _VIRTUAL_CHANNEL_CONTROL;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VIRTUAL_CHANNEL_STATUS {
    pub __bindgen_anon_1: _VIRTUAL_CHANNEL_STATUS__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VIRTUAL_CHANNEL_STATUS__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _VIRTUAL_CHANNEL_STATUS__bindgen_ty_1 {
    #[inline]
    pub fn VCArbitrationTableStatus(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_VCArbitrationTableStatus(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VCArbitrationTableStatus_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_VCArbitrationTableStatus_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RsvdZ(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 15u8) as u16) }
    }
    #[inline]
    pub fn set_RsvdZ(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RsvdZ_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                15u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_RsvdZ_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                15u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        VCArbitrationTableStatus: USHORT,
        RsvdZ: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let VCArbitrationTableStatus: u16 =
                unsafe { ::core::mem::transmute(VCArbitrationTableStatus) };
            VCArbitrationTableStatus as u64
        });
        __bindgen_bitfield_unit.set(1usize, 15u8, {
            let RsvdZ: u16 = unsafe { ::core::mem::transmute(RsvdZ) };
            RsvdZ as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type VIRTUAL_CHANNEL_STATUS = _VIRTUAL_CHANNEL_STATUS;
pub type PVIRTUAL_CHANNEL_STATUS = *mut _VIRTUAL_CHANNEL_STATUS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VIRTUAL_RESOURCE_CAPABILITY {
    pub __bindgen_anon_1: _VIRTUAL_RESOURCE_CAPABILITY__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _VIRTUAL_RESOURCE_CAPABILITY__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VIRTUAL_RESOURCE_CAPABILITY__bindgen_ty_1 {
    #[inline]
    pub fn PortArbitrationCapability(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_PortArbitrationCapability(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PortArbitrationCapability_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PortArbitrationCapability_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RsvdP1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_RsvdP1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RsvdP1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RsvdP1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Undefined(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Undefined(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Undefined_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Undefined_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RejectSnoopTransactions(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RejectSnoopTransactions(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RejectSnoopTransactions_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RejectSnoopTransactions_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MaximumTimeSlots(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_MaximumTimeSlots(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MaximumTimeSlots_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                7u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MaximumTimeSlots_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RsvdP2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RsvdP2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RsvdP2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RsvdP2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PortArbitrationTableOffset(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_PortArbitrationTableOffset(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PortArbitrationTableOffset_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PortArbitrationTableOffset_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PortArbitrationCapability: ULONG,
        RsvdP1: ULONG,
        Undefined: ULONG,
        RejectSnoopTransactions: ULONG,
        MaximumTimeSlots: ULONG,
        RsvdP2: ULONG,
        PortArbitrationTableOffset: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PortArbitrationCapability: u32 =
                unsafe { ::core::mem::transmute(PortArbitrationCapability) };
            PortArbitrationCapability as u64
        });
        __bindgen_bitfield_unit.set(8usize, 6u8, {
            let RsvdP1: u32 = unsafe { ::core::mem::transmute(RsvdP1) };
            RsvdP1 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let Undefined: u32 = unsafe { ::core::mem::transmute(Undefined) };
            Undefined as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let RejectSnoopTransactions: u32 =
                unsafe { ::core::mem::transmute(RejectSnoopTransactions) };
            RejectSnoopTransactions as u64
        });
        __bindgen_bitfield_unit.set(16usize, 7u8, {
            let MaximumTimeSlots: u32 = unsafe { ::core::mem::transmute(MaximumTimeSlots) };
            MaximumTimeSlots as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let RsvdP2: u32 = unsafe { ::core::mem::transmute(RsvdP2) };
            RsvdP2 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let PortArbitrationTableOffset: u32 =
                unsafe { ::core::mem::transmute(PortArbitrationTableOffset) };
            PortArbitrationTableOffset as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type VIRTUAL_RESOURCE_CAPABILITY = _VIRTUAL_RESOURCE_CAPABILITY;
pub type PVIRTUAL_RESOURCE_CAPABILITY = *mut _VIRTUAL_RESOURCE_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VIRTUAL_RESOURCE_CONTROL {
    pub __bindgen_anon_1: _VIRTUAL_RESOURCE_CONTROL__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _VIRTUAL_RESOURCE_CONTROL__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VIRTUAL_RESOURCE_CONTROL__bindgen_ty_1 {
    #[inline]
    pub fn TcVcMap(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_TcVcMap(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TcVcMap_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_TcVcMap_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RsvdP1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_RsvdP1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RsvdP1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RsvdP1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LoadPortArbitrationTable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LoadPortArbitrationTable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LoadPortArbitrationTable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_LoadPortArbitrationTable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PortArbitrationSelect(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_PortArbitrationSelect(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PortArbitrationSelect_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PortArbitrationSelect_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RsvdP2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_RsvdP2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RsvdP2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RsvdP2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VcID(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_VcID(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VcID_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VcID_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RsvdP3(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_RsvdP3(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RsvdP3_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RsvdP3_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VcEnable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VcEnable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VcEnable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VcEnable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TcVcMap: ULONG,
        RsvdP1: ULONG,
        LoadPortArbitrationTable: ULONG,
        PortArbitrationSelect: ULONG,
        RsvdP2: ULONG,
        VcID: ULONG,
        RsvdP3: ULONG,
        VcEnable: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let TcVcMap: u32 = unsafe { ::core::mem::transmute(TcVcMap) };
            TcVcMap as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let RsvdP1: u32 = unsafe { ::core::mem::transmute(RsvdP1) };
            RsvdP1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let LoadPortArbitrationTable: u32 =
                unsafe { ::core::mem::transmute(LoadPortArbitrationTable) };
            LoadPortArbitrationTable as u64
        });
        __bindgen_bitfield_unit.set(17usize, 3u8, {
            let PortArbitrationSelect: u32 =
                unsafe { ::core::mem::transmute(PortArbitrationSelect) };
            PortArbitrationSelect as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let RsvdP2: u32 = unsafe { ::core::mem::transmute(RsvdP2) };
            RsvdP2 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 3u8, {
            let VcID: u32 = unsafe { ::core::mem::transmute(VcID) };
            VcID as u64
        });
        __bindgen_bitfield_unit.set(27usize, 4u8, {
            let RsvdP3: u32 = unsafe { ::core::mem::transmute(RsvdP3) };
            RsvdP3 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let VcEnable: u32 = unsafe { ::core::mem::transmute(VcEnable) };
            VcEnable as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type VIRTUAL_RESOURCE_CONTROL = _VIRTUAL_RESOURCE_CONTROL;
pub type PVIRTUAL_RESOURCE_CONTROL = *mut _VIRTUAL_RESOURCE_CONTROL;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VIRTUAL_RESOURCE_STATUS {
    pub __bindgen_anon_1: _VIRTUAL_RESOURCE_STATUS__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VIRTUAL_RESOURCE_STATUS__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _VIRTUAL_RESOURCE_STATUS__bindgen_ty_1 {
    #[inline]
    pub fn PortArbitrationTableStatus(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PortArbitrationTableStatus(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PortArbitrationTableStatus_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PortArbitrationTableStatus_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VcNegotiationPending(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_VcNegotiationPending(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VcNegotiationPending_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_VcNegotiationPending_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RsvdZ(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 14u8) as u16) }
    }
    #[inline]
    pub fn set_RsvdZ(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RsvdZ_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                14u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_RsvdZ_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                14u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PortArbitrationTableStatus: USHORT,
        VcNegotiationPending: USHORT,
        RsvdZ: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PortArbitrationTableStatus: u16 =
                unsafe { ::core::mem::transmute(PortArbitrationTableStatus) };
            PortArbitrationTableStatus as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let VcNegotiationPending: u16 = unsafe { ::core::mem::transmute(VcNegotiationPending) };
            VcNegotiationPending as u64
        });
        __bindgen_bitfield_unit.set(2usize, 14u8, {
            let RsvdZ: u16 = unsafe { ::core::mem::transmute(RsvdZ) };
            RsvdZ as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type VIRTUAL_RESOURCE_STATUS = _VIRTUAL_RESOURCE_STATUS;
pub type PVIRTUAL_RESOURCE_STATUS = *mut _VIRTUAL_RESOURCE_STATUS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VIRTUAL_RESOURCE {
    pub Capability: VIRTUAL_RESOURCE_CAPABILITY,
    pub Control: VIRTUAL_RESOURCE_CONTROL,
    pub RsvdP: USHORT,
    pub Status: VIRTUAL_RESOURCE_STATUS,
}
pub type VIRTUAL_RESOURCE = _VIRTUAL_RESOURCE;
pub type PVIRTUAL_RESOURCE = *mut _VIRTUAL_RESOURCE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_VIRTUAL_CHANNEL_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub Capabilities1: VIRTUAL_CHANNEL_CAPABILITIES1,
    pub Capabilities2: VIRTUAL_CHANNEL_CAPABILITIES2,
    pub Control: VIRTUAL_CHANNEL_CONTROL,
    pub Status: VIRTUAL_CHANNEL_STATUS,
    pub Resource: [VIRTUAL_RESOURCE; 8usize],
}
pub type PCI_EXPRESS_VIRTUAL_CHANNEL_CAPABILITY = _PCI_EXPRESS_VIRTUAL_CHANNEL_CAPABILITY;
pub type PPCI_EXPRESS_VIRTUAL_CHANNEL_CAPABILITY = *mut _PCI_EXPRESS_VIRTUAL_CHANNEL_CAPABILITY;
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_ATS_CAPABILITY_REGISTER {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_ATS_CAPABILITY_REGISTER {
    #[inline]
    pub fn InvalidateQueueDepth(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_InvalidateQueueDepth(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InvalidateQueueDepth_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_InvalidateQueueDepth_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PageAlignedRequest(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PageAlignedRequest(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PageAlignedRequest_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PageAlignedRequest_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn GlobalInvalidateSupported(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_GlobalInvalidateSupported(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn GlobalInvalidateSupported_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_GlobalInvalidateSupported_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RelaxedOrderingSupported(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RelaxedOrderingSupported(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RelaxedOrderingSupported_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_RelaxedOrderingSupported_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        InvalidateQueueDepth: USHORT,
        PageAlignedRequest: USHORT,
        GlobalInvalidateSupported: USHORT,
        RelaxedOrderingSupported: USHORT,
        Reserved: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let InvalidateQueueDepth: u16 = unsafe { ::core::mem::transmute(InvalidateQueueDepth) };
            InvalidateQueueDepth as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PageAlignedRequest: u16 = unsafe { ::core::mem::transmute(PageAlignedRequest) };
            PageAlignedRequest as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let GlobalInvalidateSupported: u16 =
                unsafe { ::core::mem::transmute(GlobalInvalidateSupported) };
            GlobalInvalidateSupported as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let RelaxedOrderingSupported: u16 =
                unsafe { ::core::mem::transmute(RelaxedOrderingSupported) };
            RelaxedOrderingSupported as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let Reserved: u16 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_ATS_CAPABILITY_REGISTER = _PCI_EXPRESS_ATS_CAPABILITY_REGISTER;
pub type PPCI_EXPRESS_ATS_CAPABILITY_REGISTER = *mut _PCI_EXPRESS_ATS_CAPABILITY_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_ATS_CONTROL_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_ATS_CONTROL_REGISTER__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_ATS_CONTROL_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_ATS_CONTROL_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn SmallestTransactionUnit(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_SmallestTransactionUnit(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SmallestTransactionUnit_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_SmallestTransactionUnit_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 10u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                10u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                10u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Enable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Enable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Enable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Enable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SmallestTransactionUnit: USHORT,
        Reserved: USHORT,
        Enable: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let SmallestTransactionUnit: u16 =
                unsafe { ::core::mem::transmute(SmallestTransactionUnit) };
            SmallestTransactionUnit as u64
        });
        __bindgen_bitfield_unit.set(5usize, 10u8, {
            let Reserved: u16 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let Enable: u16 = unsafe { ::core::mem::transmute(Enable) };
            Enable as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_ATS_CONTROL_REGISTER = _PCI_EXPRESS_ATS_CONTROL_REGISTER;
pub type PPCI_EXPRESS_ATS_CONTROL_REGISTER = *mut _PCI_EXPRESS_ATS_CONTROL_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_ATS_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub Capability: PCI_EXPRESS_ATS_CAPABILITY_REGISTER,
    pub Control: PCI_EXPRESS_ATS_CONTROL_REGISTER,
}
pub type PCI_EXPRESS_ATS_CAPABILITY = _PCI_EXPRESS_ATS_CAPABILITY;
pub type PPCI_EXPRESS_ATS_CAPABILITY = *mut _PCI_EXPRESS_ATS_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_PASID_CAPABILITY_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_PASID_CAPABILITY_REGISTER__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_PASID_CAPABILITY_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_PASID_CAPABILITY_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn Rsvd(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ExecutePermissionSupported(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ExecutePermissionSupported(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ExecutePermissionSupported_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ExecutePermissionSupported_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PrivilegedModeSupported(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PrivilegedModeSupported(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PrivilegedModeSupported_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PrivilegedModeSupported_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd2(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd2_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd2_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MaxPASIDWidth(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_MaxPASIDWidth(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MaxPASIDWidth_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_MaxPASIDWidth_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd3(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd3(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd3_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd3_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Rsvd: USHORT,
        ExecutePermissionSupported: USHORT,
        PrivilegedModeSupported: USHORT,
        Rsvd2: USHORT,
        MaxPASIDWidth: USHORT,
        Rsvd3: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Rsvd: u16 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ExecutePermissionSupported: u16 =
                unsafe { ::core::mem::transmute(ExecutePermissionSupported) };
            ExecutePermissionSupported as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PrivilegedModeSupported: u16 =
                unsafe { ::core::mem::transmute(PrivilegedModeSupported) };
            PrivilegedModeSupported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let Rsvd2: u16 = unsafe { ::core::mem::transmute(Rsvd2) };
            Rsvd2 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let MaxPASIDWidth: u16 = unsafe { ::core::mem::transmute(MaxPASIDWidth) };
            MaxPASIDWidth as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let Rsvd3: u16 = unsafe { ::core::mem::transmute(Rsvd3) };
            Rsvd3 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_PASID_CAPABILITY_REGISTER = _PCI_EXPRESS_PASID_CAPABILITY_REGISTER;
pub type PPCI_EXPRESS_PASID_CAPABILITY_REGISTER = *mut _PCI_EXPRESS_PASID_CAPABILITY_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_PASID_CONTROL_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_PASID_CONTROL_REGISTER__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_PASID_CONTROL_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_PASID_CONTROL_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn PASIDEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PASIDEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PASIDEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PASIDEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ExecutePermissionEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ExecutePermissionEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ExecutePermissionEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ExecutePermissionEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PrivilegedModeEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PrivilegedModeEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PrivilegedModeEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PrivilegedModeEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 13u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                13u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                13u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PASIDEnable: USHORT,
        ExecutePermissionEnable: USHORT,
        PrivilegedModeEnable: USHORT,
        Rsvd: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PASIDEnable: u16 = unsafe { ::core::mem::transmute(PASIDEnable) };
            PASIDEnable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ExecutePermissionEnable: u16 =
                unsafe { ::core::mem::transmute(ExecutePermissionEnable) };
            ExecutePermissionEnable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PrivilegedModeEnable: u16 = unsafe { ::core::mem::transmute(PrivilegedModeEnable) };
            PrivilegedModeEnable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 13u8, {
            let Rsvd: u16 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_PASID_CONTROL_REGISTER = _PCI_EXPRESS_PASID_CONTROL_REGISTER;
pub type PPCI_EXPRESS_PASID_CONTROL_REGISTER = *mut _PCI_EXPRESS_PASID_CONTROL_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_PASID_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub Capability: PCI_EXPRESS_PASID_CAPABILITY_REGISTER,
    pub Control: PCI_EXPRESS_PASID_CONTROL_REGISTER,
}
pub type PCI_EXPRESS_PASID_CAPABILITY = _PCI_EXPRESS_PASID_CAPABILITY;
pub type PPCI_EXPRESS_PASID_CAPABILITY = *mut _PCI_EXPRESS_PASID_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_PRI_STATUS_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_PRI_STATUS_REGISTER__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_PRI_STATUS_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_PRI_STATUS_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn ResponseFailure(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ResponseFailure(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ResponseFailure_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ResponseFailure_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UnexpectedPageRequestGroupIndex(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UnexpectedPageRequestGroupIndex(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UnexpectedPageRequestGroupIndex_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_UnexpectedPageRequestGroupIndex_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                6u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Stopped(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Stopped(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Stopped_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Stopped_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd2(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd2_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                6u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd2_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PrgResponsePasidRequired(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PrgResponsePasidRequired(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PrgResponsePasidRequired_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PrgResponsePasidRequired_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ResponseFailure: USHORT,
        UnexpectedPageRequestGroupIndex: USHORT,
        Rsvd: USHORT,
        Stopped: USHORT,
        Rsvd2: USHORT,
        PrgResponsePasidRequired: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ResponseFailure: u16 = unsafe { ::core::mem::transmute(ResponseFailure) };
            ResponseFailure as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let UnexpectedPageRequestGroupIndex: u16 =
                unsafe { ::core::mem::transmute(UnexpectedPageRequestGroupIndex) };
            UnexpectedPageRequestGroupIndex as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let Rsvd: u16 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Stopped: u16 = unsafe { ::core::mem::transmute(Stopped) };
            Stopped as u64
        });
        __bindgen_bitfield_unit.set(9usize, 6u8, {
            let Rsvd2: u16 = unsafe { ::core::mem::transmute(Rsvd2) };
            Rsvd2 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let PrgResponsePasidRequired: u16 =
                unsafe { ::core::mem::transmute(PrgResponsePasidRequired) };
            PrgResponsePasidRequired as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_PRI_STATUS_REGISTER = _PCI_EXPRESS_PRI_STATUS_REGISTER;
pub type PPCI_EXPRESS_PRI_STATUS_REGISTER = *mut _PCI_EXPRESS_PRI_STATUS_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_PRI_CONTROL_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_PRI_CONTROL_REGISTER__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_PRI_CONTROL_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_PRI_CONTROL_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn Enable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Enable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Enable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Enable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reset(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Reset(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reset_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reset_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 14u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                14u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                14u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Enable: USHORT,
        Reset: USHORT,
        Rsvd: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Enable: u16 = unsafe { ::core::mem::transmute(Enable) };
            Enable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Reset: u16 = unsafe { ::core::mem::transmute(Reset) };
            Reset as u64
        });
        __bindgen_bitfield_unit.set(2usize, 14u8, {
            let Rsvd: u16 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_PRI_CONTROL_REGISTER = _PCI_EXPRESS_PRI_CONTROL_REGISTER;
pub type PPCI_EXPRESS_PRI_CONTROL_REGISTER = *mut _PCI_EXPRESS_PRI_CONTROL_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_PRI_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub Control: PCI_EXPRESS_PRI_CONTROL_REGISTER,
    pub Status: PCI_EXPRESS_PRI_STATUS_REGISTER,
    pub PRCapacity: ULONG,
    pub PRAllocation: ULONG,
}
pub type PCI_EXPRESS_PRI_CAPABILITY = _PCI_EXPRESS_PRI_CAPABILITY;
pub type PPCI_EXPRESS_PRI_CAPABILITY = *mut _PCI_EXPRESS_PRI_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_PTM_CAPABILITY_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_PTM_CAPABILITY_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_PTM_CAPABILITY_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_PTM_CAPABILITY_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn RequesterCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RequesterCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RequesterCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RequesterCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ResponderCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ResponderCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ResponderCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ResponderCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RootCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RootCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RootCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RootCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LocalGranularity(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_LocalGranularity(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LocalGranularity_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_LocalGranularity_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RequesterCapable: ULONG,
        ResponderCapable: ULONG,
        RootCapable: ULONG,
        Rsvd: ULONG,
        LocalGranularity: ULONG,
        Rsvd2: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let RequesterCapable: u32 = unsafe { ::core::mem::transmute(RequesterCapable) };
            RequesterCapable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ResponderCapable: u32 = unsafe { ::core::mem::transmute(ResponderCapable) };
            ResponderCapable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RootCapable: u32 = unsafe { ::core::mem::transmute(RootCapable) };
            RootCapable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let Rsvd: u32 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let LocalGranularity: u32 = unsafe { ::core::mem::transmute(LocalGranularity) };
            LocalGranularity as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let Rsvd2: u32 = unsafe { ::core::mem::transmute(Rsvd2) };
            Rsvd2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_PTM_CAPABILITY_REGISTER = _PCI_EXPRESS_PTM_CAPABILITY_REGISTER;
pub type PPCI_EXPRESS_PTM_CAPABILITY_REGISTER = *mut _PCI_EXPRESS_PTM_CAPABILITY_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_PTM_CONTROL_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_PTM_CONTROL_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_PTM_CONTROL_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_PTM_CONTROL_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn Enable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Enable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Enable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Enable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RootSelect(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RootSelect(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RootSelect_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RootSelect_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EffectiveGranularity(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_EffectiveGranularity(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EffectiveGranularity_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_EffectiveGranularity_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Enable: ULONG,
        RootSelect: ULONG,
        Rsvd: ULONG,
        EffectiveGranularity: ULONG,
        Rsvd2: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Enable: u32 = unsafe { ::core::mem::transmute(Enable) };
            Enable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let RootSelect: u32 = unsafe { ::core::mem::transmute(RootSelect) };
            RootSelect as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let Rsvd: u32 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let EffectiveGranularity: u32 = unsafe { ::core::mem::transmute(EffectiveGranularity) };
            EffectiveGranularity as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let Rsvd2: u32 = unsafe { ::core::mem::transmute(Rsvd2) };
            Rsvd2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_PTM_CONTROL_REGISTER = _PCI_EXPRESS_PTM_CONTROL_REGISTER;
pub type PPCI_EXPRESS_PTM_CONTROL_REGISTER = *mut _PCI_EXPRESS_PTM_CONTROL_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_PTM_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub PtmCapability: PCI_EXPRESS_PTM_CAPABILITY_REGISTER,
    pub PtmControl: PCI_EXPRESS_PTM_CONTROL_REGISTER,
}
pub type PCI_EXPRESS_PTM_CAPABILITY = _PCI_EXPRESS_PTM_CAPABILITY;
pub type PPCI_EXPRESS_PTM_CAPABILITY = *mut _PCI_EXPRESS_PTM_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS {
    pub __bindgen_anon_1: _PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS__bindgen_ty_1 {
    #[inline]
    pub fn Undefined(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Undefined(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Undefined_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Undefined_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DataLinkProtocolError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DataLinkProtocolError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DataLinkProtocolError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DataLinkProtocolError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SurpriseDownError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SurpriseDownError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SurpriseDownError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SurpriseDownError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PoisonedTLP(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PoisonedTLP(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PoisonedTLP_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PoisonedTLP_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FlowControlProtocolError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FlowControlProtocolError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FlowControlProtocolError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FlowControlProtocolError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CompletionTimeout(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CompletionTimeout(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CompletionTimeout_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CompletionTimeout_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CompleterAbort(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CompleterAbort(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CompleterAbort_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CompleterAbort_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UnexpectedCompletion(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UnexpectedCompletion(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UnexpectedCompletion_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UnexpectedCompletion_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReceiverOverflow(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReceiverOverflow(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReceiverOverflow_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReceiverOverflow_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MalformedTLP(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MalformedTLP(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MalformedTLP_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MalformedTLP_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ECRCError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ECRCError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ECRCError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ECRCError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UnsupportedRequestError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UnsupportedRequestError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UnsupportedRequestError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UnsupportedRequestError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AcsViolation(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AcsViolation(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AcsViolation_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AcsViolation_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableInternalError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableInternalError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableInternalError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableInternalError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MCBlockedTlp(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MCBlockedTlp(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MCBlockedTlp_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MCBlockedTlp_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AtomicOpEgressBlocked(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AtomicOpEgressBlocked(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AtomicOpEgressBlocked_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AtomicOpEgressBlocked_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TlpPrefixBlocked(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TlpPrefixBlocked(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TlpPrefixBlocked_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_TlpPrefixBlocked_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved3(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved3(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved3_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved3_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Undefined: ULONG,
        Reserved1: ULONG,
        DataLinkProtocolError: ULONG,
        SurpriseDownError: ULONG,
        Reserved2: ULONG,
        PoisonedTLP: ULONG,
        FlowControlProtocolError: ULONG,
        CompletionTimeout: ULONG,
        CompleterAbort: ULONG,
        UnexpectedCompletion: ULONG,
        ReceiverOverflow: ULONG,
        MalformedTLP: ULONG,
        ECRCError: ULONG,
        UnsupportedRequestError: ULONG,
        AcsViolation: ULONG,
        UncorrectableInternalError: ULONG,
        MCBlockedTlp: ULONG,
        AtomicOpEgressBlocked: ULONG,
        TlpPrefixBlocked: ULONG,
        Reserved3: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Undefined: u32 = unsafe { ::core::mem::transmute(Undefined) };
            Undefined as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let DataLinkProtocolError: u32 =
                unsafe { ::core::mem::transmute(DataLinkProtocolError) };
            DataLinkProtocolError as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let SurpriseDownError: u32 = unsafe { ::core::mem::transmute(SurpriseDownError) };
            SurpriseDownError as u64
        });
        __bindgen_bitfield_unit.set(6usize, 6u8, {
            let Reserved2: u32 = unsafe { ::core::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let PoisonedTLP: u32 = unsafe { ::core::mem::transmute(PoisonedTLP) };
            PoisonedTLP as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let FlowControlProtocolError: u32 =
                unsafe { ::core::mem::transmute(FlowControlProtocolError) };
            FlowControlProtocolError as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let CompletionTimeout: u32 = unsafe { ::core::mem::transmute(CompletionTimeout) };
            CompletionTimeout as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let CompleterAbort: u32 = unsafe { ::core::mem::transmute(CompleterAbort) };
            CompleterAbort as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let UnexpectedCompletion: u32 = unsafe { ::core::mem::transmute(UnexpectedCompletion) };
            UnexpectedCompletion as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let ReceiverOverflow: u32 = unsafe { ::core::mem::transmute(ReceiverOverflow) };
            ReceiverOverflow as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let MalformedTLP: u32 = unsafe { ::core::mem::transmute(MalformedTLP) };
            MalformedTLP as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ECRCError: u32 = unsafe { ::core::mem::transmute(ECRCError) };
            ECRCError as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let UnsupportedRequestError: u32 =
                unsafe { ::core::mem::transmute(UnsupportedRequestError) };
            UnsupportedRequestError as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let AcsViolation: u32 = unsafe { ::core::mem::transmute(AcsViolation) };
            AcsViolation as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let UncorrectableInternalError: u32 =
                unsafe { ::core::mem::transmute(UncorrectableInternalError) };
            UncorrectableInternalError as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let MCBlockedTlp: u32 = unsafe { ::core::mem::transmute(MCBlockedTlp) };
            MCBlockedTlp as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let AtomicOpEgressBlocked: u32 =
                unsafe { ::core::mem::transmute(AtomicOpEgressBlocked) };
            AtomicOpEgressBlocked as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let TlpPrefixBlocked: u32 = unsafe { ::core::mem::transmute(TlpPrefixBlocked) };
            TlpPrefixBlocked as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let Reserved3: u32 = unsafe { ::core::mem::transmute(Reserved3) };
            Reserved3 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS = _PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS;
pub type PPCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS = *mut _PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK {
    pub __bindgen_anon_1: _PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK__bindgen_ty_1 {
    #[inline]
    pub fn Undefined(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Undefined(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Undefined_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Undefined_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DataLinkProtocolError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DataLinkProtocolError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DataLinkProtocolError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DataLinkProtocolError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SurpriseDownError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SurpriseDownError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SurpriseDownError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SurpriseDownError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PoisonedTLP(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PoisonedTLP(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PoisonedTLP_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PoisonedTLP_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FlowControlProtocolError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FlowControlProtocolError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FlowControlProtocolError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FlowControlProtocolError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CompletionTimeout(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CompletionTimeout(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CompletionTimeout_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CompletionTimeout_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CompleterAbort(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CompleterAbort(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CompleterAbort_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CompleterAbort_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UnexpectedCompletion(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UnexpectedCompletion(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UnexpectedCompletion_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UnexpectedCompletion_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReceiverOverflow(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReceiverOverflow(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReceiverOverflow_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReceiverOverflow_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MalformedTLP(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MalformedTLP(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MalformedTLP_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MalformedTLP_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ECRCError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ECRCError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ECRCError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ECRCError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UnsupportedRequestError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UnsupportedRequestError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UnsupportedRequestError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UnsupportedRequestError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AcsViolation(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AcsViolation(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AcsViolation_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AcsViolation_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableInternalError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableInternalError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableInternalError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableInternalError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MCBlockedTlp(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MCBlockedTlp(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MCBlockedTlp_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MCBlockedTlp_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AtomicOpEgressBlocked(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AtomicOpEgressBlocked(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AtomicOpEgressBlocked_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AtomicOpEgressBlocked_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TlpPrefixBlocked(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TlpPrefixBlocked(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TlpPrefixBlocked_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_TlpPrefixBlocked_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved3(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved3(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved3_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved3_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Undefined: ULONG,
        Reserved1: ULONG,
        DataLinkProtocolError: ULONG,
        SurpriseDownError: ULONG,
        Reserved2: ULONG,
        PoisonedTLP: ULONG,
        FlowControlProtocolError: ULONG,
        CompletionTimeout: ULONG,
        CompleterAbort: ULONG,
        UnexpectedCompletion: ULONG,
        ReceiverOverflow: ULONG,
        MalformedTLP: ULONG,
        ECRCError: ULONG,
        UnsupportedRequestError: ULONG,
        AcsViolation: ULONG,
        UncorrectableInternalError: ULONG,
        MCBlockedTlp: ULONG,
        AtomicOpEgressBlocked: ULONG,
        TlpPrefixBlocked: ULONG,
        Reserved3: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Undefined: u32 = unsafe { ::core::mem::transmute(Undefined) };
            Undefined as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let DataLinkProtocolError: u32 =
                unsafe { ::core::mem::transmute(DataLinkProtocolError) };
            DataLinkProtocolError as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let SurpriseDownError: u32 = unsafe { ::core::mem::transmute(SurpriseDownError) };
            SurpriseDownError as u64
        });
        __bindgen_bitfield_unit.set(6usize, 6u8, {
            let Reserved2: u32 = unsafe { ::core::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let PoisonedTLP: u32 = unsafe { ::core::mem::transmute(PoisonedTLP) };
            PoisonedTLP as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let FlowControlProtocolError: u32 =
                unsafe { ::core::mem::transmute(FlowControlProtocolError) };
            FlowControlProtocolError as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let CompletionTimeout: u32 = unsafe { ::core::mem::transmute(CompletionTimeout) };
            CompletionTimeout as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let CompleterAbort: u32 = unsafe { ::core::mem::transmute(CompleterAbort) };
            CompleterAbort as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let UnexpectedCompletion: u32 = unsafe { ::core::mem::transmute(UnexpectedCompletion) };
            UnexpectedCompletion as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let ReceiverOverflow: u32 = unsafe { ::core::mem::transmute(ReceiverOverflow) };
            ReceiverOverflow as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let MalformedTLP: u32 = unsafe { ::core::mem::transmute(MalformedTLP) };
            MalformedTLP as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ECRCError: u32 = unsafe { ::core::mem::transmute(ECRCError) };
            ECRCError as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let UnsupportedRequestError: u32 =
                unsafe { ::core::mem::transmute(UnsupportedRequestError) };
            UnsupportedRequestError as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let AcsViolation: u32 = unsafe { ::core::mem::transmute(AcsViolation) };
            AcsViolation as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let UncorrectableInternalError: u32 =
                unsafe { ::core::mem::transmute(UncorrectableInternalError) };
            UncorrectableInternalError as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let MCBlockedTlp: u32 = unsafe { ::core::mem::transmute(MCBlockedTlp) };
            MCBlockedTlp as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let AtomicOpEgressBlocked: u32 =
                unsafe { ::core::mem::transmute(AtomicOpEgressBlocked) };
            AtomicOpEgressBlocked as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let TlpPrefixBlocked: u32 = unsafe { ::core::mem::transmute(TlpPrefixBlocked) };
            TlpPrefixBlocked as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let Reserved3: u32 = unsafe { ::core::mem::transmute(Reserved3) };
            Reserved3 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK = _PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK;
pub type PPCI_EXPRESS_UNCORRECTABLE_ERROR_MASK = *mut _PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY {
    pub __bindgen_anon_1: _PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY__bindgen_ty_1 {
    #[inline]
    pub fn Undefined(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Undefined(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Undefined_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Undefined_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DataLinkProtocolError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DataLinkProtocolError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DataLinkProtocolError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DataLinkProtocolError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SurpriseDownError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SurpriseDownError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SurpriseDownError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SurpriseDownError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PoisonedTLP(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PoisonedTLP(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PoisonedTLP_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PoisonedTLP_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FlowControlProtocolError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FlowControlProtocolError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FlowControlProtocolError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FlowControlProtocolError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CompletionTimeout(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CompletionTimeout(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CompletionTimeout_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CompletionTimeout_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CompleterAbort(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CompleterAbort(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CompleterAbort_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CompleterAbort_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UnexpectedCompletion(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UnexpectedCompletion(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UnexpectedCompletion_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UnexpectedCompletion_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReceiverOverflow(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReceiverOverflow(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReceiverOverflow_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReceiverOverflow_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MalformedTLP(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MalformedTLP(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MalformedTLP_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MalformedTLP_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ECRCError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ECRCError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ECRCError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ECRCError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UnsupportedRequestError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UnsupportedRequestError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UnsupportedRequestError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UnsupportedRequestError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AcsViolation(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AcsViolation(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AcsViolation_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AcsViolation_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableInternalError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableInternalError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableInternalError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableInternalError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MCBlockedTlp(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MCBlockedTlp(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MCBlockedTlp_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MCBlockedTlp_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AtomicOpEgressBlocked(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AtomicOpEgressBlocked(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AtomicOpEgressBlocked_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AtomicOpEgressBlocked_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TlpPrefixBlocked(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TlpPrefixBlocked(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TlpPrefixBlocked_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_TlpPrefixBlocked_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved3(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved3(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved3_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved3_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Undefined: ULONG,
        Reserved1: ULONG,
        DataLinkProtocolError: ULONG,
        SurpriseDownError: ULONG,
        Reserved2: ULONG,
        PoisonedTLP: ULONG,
        FlowControlProtocolError: ULONG,
        CompletionTimeout: ULONG,
        CompleterAbort: ULONG,
        UnexpectedCompletion: ULONG,
        ReceiverOverflow: ULONG,
        MalformedTLP: ULONG,
        ECRCError: ULONG,
        UnsupportedRequestError: ULONG,
        AcsViolation: ULONG,
        UncorrectableInternalError: ULONG,
        MCBlockedTlp: ULONG,
        AtomicOpEgressBlocked: ULONG,
        TlpPrefixBlocked: ULONG,
        Reserved3: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Undefined: u32 = unsafe { ::core::mem::transmute(Undefined) };
            Undefined as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let DataLinkProtocolError: u32 =
                unsafe { ::core::mem::transmute(DataLinkProtocolError) };
            DataLinkProtocolError as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let SurpriseDownError: u32 = unsafe { ::core::mem::transmute(SurpriseDownError) };
            SurpriseDownError as u64
        });
        __bindgen_bitfield_unit.set(6usize, 6u8, {
            let Reserved2: u32 = unsafe { ::core::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let PoisonedTLP: u32 = unsafe { ::core::mem::transmute(PoisonedTLP) };
            PoisonedTLP as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let FlowControlProtocolError: u32 =
                unsafe { ::core::mem::transmute(FlowControlProtocolError) };
            FlowControlProtocolError as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let CompletionTimeout: u32 = unsafe { ::core::mem::transmute(CompletionTimeout) };
            CompletionTimeout as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let CompleterAbort: u32 = unsafe { ::core::mem::transmute(CompleterAbort) };
            CompleterAbort as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let UnexpectedCompletion: u32 = unsafe { ::core::mem::transmute(UnexpectedCompletion) };
            UnexpectedCompletion as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let ReceiverOverflow: u32 = unsafe { ::core::mem::transmute(ReceiverOverflow) };
            ReceiverOverflow as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let MalformedTLP: u32 = unsafe { ::core::mem::transmute(MalformedTLP) };
            MalformedTLP as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ECRCError: u32 = unsafe { ::core::mem::transmute(ECRCError) };
            ECRCError as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let UnsupportedRequestError: u32 =
                unsafe { ::core::mem::transmute(UnsupportedRequestError) };
            UnsupportedRequestError as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let AcsViolation: u32 = unsafe { ::core::mem::transmute(AcsViolation) };
            AcsViolation as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let UncorrectableInternalError: u32 =
                unsafe { ::core::mem::transmute(UncorrectableInternalError) };
            UncorrectableInternalError as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let MCBlockedTlp: u32 = unsafe { ::core::mem::transmute(MCBlockedTlp) };
            MCBlockedTlp as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let AtomicOpEgressBlocked: u32 =
                unsafe { ::core::mem::transmute(AtomicOpEgressBlocked) };
            AtomicOpEgressBlocked as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let TlpPrefixBlocked: u32 = unsafe { ::core::mem::transmute(TlpPrefixBlocked) };
            TlpPrefixBlocked as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let Reserved3: u32 = unsafe { ::core::mem::transmute(Reserved3) };
            Reserved3 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY = _PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY;
pub type PPCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY = *mut _PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_CORRECTABLE_ERROR_STATUS {
    pub __bindgen_anon_1: _PCI_EXPRESS_CORRECTABLE_ERROR_STATUS__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_CORRECTABLE_ERROR_STATUS__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_CORRECTABLE_ERROR_STATUS__bindgen_ty_1 {
    #[inline]
    pub fn ReceiverError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReceiverError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReceiverError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReceiverError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn BadTLP(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BadTLP(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn BadTLP_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_BadTLP_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn BadDLLP(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BadDLLP(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn BadDLLP_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_BadDLLP_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReplayNumRollover(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReplayNumRollover(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReplayNumRollover_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReplayNumRollover_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReplayTimerTimeout(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReplayTimerTimeout(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReplayTimerTimeout_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReplayTimerTimeout_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AdvisoryNonFatalError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AdvisoryNonFatalError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AdvisoryNonFatalError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AdvisoryNonFatalError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CorrectedInternalError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CorrectedInternalError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CorrectedInternalError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CorrectedInternalError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn HeaderLogOverflow(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HeaderLogOverflow(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn HeaderLogOverflow_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_HeaderLogOverflow_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved3(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved3(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved3_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved3_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ReceiverError: ULONG,
        Reserved1: ULONG,
        BadTLP: ULONG,
        BadDLLP: ULONG,
        ReplayNumRollover: ULONG,
        Reserved2: ULONG,
        ReplayTimerTimeout: ULONG,
        AdvisoryNonFatalError: ULONG,
        CorrectedInternalError: ULONG,
        HeaderLogOverflow: ULONG,
        Reserved3: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ReceiverError: u32 = unsafe { ::core::mem::transmute(ReceiverError) };
            ReceiverError as u64
        });
        __bindgen_bitfield_unit.set(1usize, 5u8, {
            let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let BadTLP: u32 = unsafe { ::core::mem::transmute(BadTLP) };
            BadTLP as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let BadDLLP: u32 = unsafe { ::core::mem::transmute(BadDLLP) };
            BadDLLP as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ReplayNumRollover: u32 = unsafe { ::core::mem::transmute(ReplayNumRollover) };
            ReplayNumRollover as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let Reserved2: u32 = unsafe { ::core::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ReplayTimerTimeout: u32 = unsafe { ::core::mem::transmute(ReplayTimerTimeout) };
            ReplayTimerTimeout as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let AdvisoryNonFatalError: u32 =
                unsafe { ::core::mem::transmute(AdvisoryNonFatalError) };
            AdvisoryNonFatalError as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let CorrectedInternalError: u32 =
                unsafe { ::core::mem::transmute(CorrectedInternalError) };
            CorrectedInternalError as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let HeaderLogOverflow: u32 = unsafe { ::core::mem::transmute(HeaderLogOverflow) };
            HeaderLogOverflow as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let Reserved3: u32 = unsafe { ::core::mem::transmute(Reserved3) };
            Reserved3 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_CORRECTABLE_ERROR_STATUS = _PCI_EXPRESS_CORRECTABLE_ERROR_STATUS;
pub type PPCI_CORRECTABLE_ERROR_STATUS = *mut _PCI_EXPRESS_CORRECTABLE_ERROR_STATUS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_CORRECTABLE_ERROR_MASK {
    pub __bindgen_anon_1: _PCI_EXPRESS_CORRECTABLE_ERROR_MASK__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_CORRECTABLE_ERROR_MASK__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_CORRECTABLE_ERROR_MASK__bindgen_ty_1 {
    #[inline]
    pub fn ReceiverError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReceiverError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReceiverError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReceiverError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn BadTLP(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BadTLP(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn BadTLP_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_BadTLP_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn BadDLLP(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BadDLLP(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn BadDLLP_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_BadDLLP_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReplayNumRollover(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReplayNumRollover(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReplayNumRollover_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReplayNumRollover_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReplayTimerTimeout(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReplayTimerTimeout(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReplayTimerTimeout_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReplayTimerTimeout_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AdvisoryNonFatalError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AdvisoryNonFatalError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AdvisoryNonFatalError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AdvisoryNonFatalError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CorrectedInternalError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CorrectedInternalError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CorrectedInternalError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CorrectedInternalError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn HeaderLogOverflow(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HeaderLogOverflow(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn HeaderLogOverflow_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_HeaderLogOverflow_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved3(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved3(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved3_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved3_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ReceiverError: ULONG,
        Reserved1: ULONG,
        BadTLP: ULONG,
        BadDLLP: ULONG,
        ReplayNumRollover: ULONG,
        Reserved2: ULONG,
        ReplayTimerTimeout: ULONG,
        AdvisoryNonFatalError: ULONG,
        CorrectedInternalError: ULONG,
        HeaderLogOverflow: ULONG,
        Reserved3: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ReceiverError: u32 = unsafe { ::core::mem::transmute(ReceiverError) };
            ReceiverError as u64
        });
        __bindgen_bitfield_unit.set(1usize, 5u8, {
            let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let BadTLP: u32 = unsafe { ::core::mem::transmute(BadTLP) };
            BadTLP as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let BadDLLP: u32 = unsafe { ::core::mem::transmute(BadDLLP) };
            BadDLLP as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ReplayNumRollover: u32 = unsafe { ::core::mem::transmute(ReplayNumRollover) };
            ReplayNumRollover as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let Reserved2: u32 = unsafe { ::core::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ReplayTimerTimeout: u32 = unsafe { ::core::mem::transmute(ReplayTimerTimeout) };
            ReplayTimerTimeout as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let AdvisoryNonFatalError: u32 =
                unsafe { ::core::mem::transmute(AdvisoryNonFatalError) };
            AdvisoryNonFatalError as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let CorrectedInternalError: u32 =
                unsafe { ::core::mem::transmute(CorrectedInternalError) };
            CorrectedInternalError as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let HeaderLogOverflow: u32 = unsafe { ::core::mem::transmute(HeaderLogOverflow) };
            HeaderLogOverflow as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let Reserved3: u32 = unsafe { ::core::mem::transmute(Reserved3) };
            Reserved3 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_CORRECTABLE_ERROR_MASK = _PCI_EXPRESS_CORRECTABLE_ERROR_MASK;
pub type PPCI_CORRECTABLE_ERROR_MASK = *mut _PCI_EXPRESS_CORRECTABLE_ERROR_MASK;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_AER_CAPABILITIES {
    pub __bindgen_anon_1: _PCI_EXPRESS_AER_CAPABILITIES__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_AER_CAPABILITIES__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_AER_CAPABILITIES__bindgen_ty_1 {
    #[inline]
    pub fn FirstErrorPointer(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_FirstErrorPointer(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FirstErrorPointer_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FirstErrorPointer_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ECRCGenerationCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ECRCGenerationCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ECRCGenerationCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ECRCGenerationCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ECRCGenerationEnable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ECRCGenerationEnable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ECRCGenerationEnable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ECRCGenerationEnable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ECRCCheckCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ECRCCheckCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ECRCCheckCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ECRCCheckCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ECRCCheckEnable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ECRCCheckEnable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ECRCCheckEnable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ECRCCheckEnable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MultipleHeaderRecordingCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MultipleHeaderRecordingCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MultipleHeaderRecordingCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MultipleHeaderRecordingCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MultipleHeaderRecordingEnable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MultipleHeaderRecordingEnable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MultipleHeaderRecordingEnable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MultipleHeaderRecordingEnable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TlpPrefixLogPresent(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TlpPrefixLogPresent(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TlpPrefixLogPresent_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_TlpPrefixLogPresent_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                20u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                20u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FirstErrorPointer: ULONG,
        ECRCGenerationCapable: ULONG,
        ECRCGenerationEnable: ULONG,
        ECRCCheckCapable: ULONG,
        ECRCCheckEnable: ULONG,
        MultipleHeaderRecordingCapable: ULONG,
        MultipleHeaderRecordingEnable: ULONG,
        TlpPrefixLogPresent: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let FirstErrorPointer: u32 = unsafe { ::core::mem::transmute(FirstErrorPointer) };
            FirstErrorPointer as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ECRCGenerationCapable: u32 =
                unsafe { ::core::mem::transmute(ECRCGenerationCapable) };
            ECRCGenerationCapable as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ECRCGenerationEnable: u32 = unsafe { ::core::mem::transmute(ECRCGenerationEnable) };
            ECRCGenerationEnable as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ECRCCheckCapable: u32 = unsafe { ::core::mem::transmute(ECRCCheckCapable) };
            ECRCCheckCapable as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ECRCCheckEnable: u32 = unsafe { ::core::mem::transmute(ECRCCheckEnable) };
            ECRCCheckEnable as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let MultipleHeaderRecordingCapable: u32 =
                unsafe { ::core::mem::transmute(MultipleHeaderRecordingCapable) };
            MultipleHeaderRecordingCapable as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let MultipleHeaderRecordingEnable: u32 =
                unsafe { ::core::mem::transmute(MultipleHeaderRecordingEnable) };
            MultipleHeaderRecordingEnable as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let TlpPrefixLogPresent: u32 = unsafe { ::core::mem::transmute(TlpPrefixLogPresent) };
            TlpPrefixLogPresent as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_AER_CAPABILITIES = _PCI_EXPRESS_AER_CAPABILITIES;
pub type PPCI_EXPRESS_AER_CAPABILITIES = *mut _PCI_EXPRESS_AER_CAPABILITIES;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_ROOT_ERROR_COMMAND {
    pub __bindgen_anon_1: _PCI_EXPRESS_ROOT_ERROR_COMMAND__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_ROOT_ERROR_COMMAND__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_ROOT_ERROR_COMMAND__bindgen_ty_1 {
    #[inline]
    pub fn CorrectableErrorReportingEnable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CorrectableErrorReportingEnable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CorrectableErrorReportingEnable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CorrectableErrorReportingEnable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NonFatalErrorReportingEnable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NonFatalErrorReportingEnable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NonFatalErrorReportingEnable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NonFatalErrorReportingEnable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FatalErrorReportingEnable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FatalErrorReportingEnable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FatalErrorReportingEnable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FatalErrorReportingEnable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                29u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                29u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CorrectableErrorReportingEnable: ULONG,
        NonFatalErrorReportingEnable: ULONG,
        FatalErrorReportingEnable: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CorrectableErrorReportingEnable: u32 =
                unsafe { ::core::mem::transmute(CorrectableErrorReportingEnable) };
            CorrectableErrorReportingEnable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let NonFatalErrorReportingEnable: u32 =
                unsafe { ::core::mem::transmute(NonFatalErrorReportingEnable) };
            NonFatalErrorReportingEnable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let FatalErrorReportingEnable: u32 =
                unsafe { ::core::mem::transmute(FatalErrorReportingEnable) };
            FatalErrorReportingEnable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_ROOT_ERROR_COMMAND = _PCI_EXPRESS_ROOT_ERROR_COMMAND;
pub type PPCI_EXPRESS_ROOT_ERROR_COMMAND = *mut _PCI_EXPRESS_ROOT_ERROR_COMMAND;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_ROOT_ERROR_STATUS {
    pub __bindgen_anon_1: _PCI_EXPRESS_ROOT_ERROR_STATUS__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_ROOT_ERROR_STATUS__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_ROOT_ERROR_STATUS__bindgen_ty_1 {
    #[inline]
    pub fn CorrectableErrorReceived(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CorrectableErrorReceived(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CorrectableErrorReceived_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CorrectableErrorReceived_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MultipleCorrectableErrorsReceived(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MultipleCorrectableErrorsReceived(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MultipleCorrectableErrorsReceived_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MultipleCorrectableErrorsReceived_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableErrorReceived(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableErrorReceived(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableErrorReceived_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableErrorReceived_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MultipleUncorrectableErrorsReceived(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MultipleUncorrectableErrorsReceived(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MultipleUncorrectableErrorsReceived_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MultipleUncorrectableErrorsReceived_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FirstUncorrectableFatal(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FirstUncorrectableFatal(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FirstUncorrectableFatal_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FirstUncorrectableFatal_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NonFatalErrorMessagesReceived(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NonFatalErrorMessagesReceived(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NonFatalErrorMessagesReceived_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NonFatalErrorMessagesReceived_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FatalErrorMessagesReceived(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FatalErrorMessagesReceived(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FatalErrorMessagesReceived_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FatalErrorMessagesReceived_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                20u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                20u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AdvancedErrorInterruptMessageNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_AdvancedErrorInterruptMessageNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AdvancedErrorInterruptMessageNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AdvancedErrorInterruptMessageNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CorrectableErrorReceived: ULONG,
        MultipleCorrectableErrorsReceived: ULONG,
        UncorrectableErrorReceived: ULONG,
        MultipleUncorrectableErrorsReceived: ULONG,
        FirstUncorrectableFatal: ULONG,
        NonFatalErrorMessagesReceived: ULONG,
        FatalErrorMessagesReceived: ULONG,
        Reserved: ULONG,
        AdvancedErrorInterruptMessageNumber: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CorrectableErrorReceived: u32 =
                unsafe { ::core::mem::transmute(CorrectableErrorReceived) };
            CorrectableErrorReceived as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let MultipleCorrectableErrorsReceived: u32 =
                unsafe { ::core::mem::transmute(MultipleCorrectableErrorsReceived) };
            MultipleCorrectableErrorsReceived as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let UncorrectableErrorReceived: u32 =
                unsafe { ::core::mem::transmute(UncorrectableErrorReceived) };
            UncorrectableErrorReceived as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let MultipleUncorrectableErrorsReceived: u32 =
                unsafe { ::core::mem::transmute(MultipleUncorrectableErrorsReceived) };
            MultipleUncorrectableErrorsReceived as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let FirstUncorrectableFatal: u32 =
                unsafe { ::core::mem::transmute(FirstUncorrectableFatal) };
            FirstUncorrectableFatal as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let NonFatalErrorMessagesReceived: u32 =
                unsafe { ::core::mem::transmute(NonFatalErrorMessagesReceived) };
            NonFatalErrorMessagesReceived as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let FatalErrorMessagesReceived: u32 =
                unsafe { ::core::mem::transmute(FatalErrorMessagesReceived) };
            FatalErrorMessagesReceived as u64
        });
        __bindgen_bitfield_unit.set(7usize, 20u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let AdvancedErrorInterruptMessageNumber: u32 =
                unsafe { ::core::mem::transmute(AdvancedErrorInterruptMessageNumber) };
            AdvancedErrorInterruptMessageNumber as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_ROOT_ERROR_STATUS = _PCI_EXPRESS_ROOT_ERROR_STATUS;
pub type PPCI_EXPRESS_ROOT_ERROR_STATUS = *mut _PCI_EXPRESS_ROOT_ERROR_STATUS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_ERROR_SOURCE_ID {
    pub __bindgen_anon_1: _PCI_EXPRESS_ERROR_SOURCE_ID__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_ERROR_SOURCE_ID__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_ERROR_SOURCE_ID__bindgen_ty_1 {
    #[inline]
    pub fn CorrectableSourceIdFun(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_CorrectableSourceIdFun(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CorrectableSourceIdFun_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_CorrectableSourceIdFun_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CorrectableSourceIdDev(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_CorrectableSourceIdDev(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CorrectableSourceIdDev_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_CorrectableSourceIdDev_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CorrectableSourceIdBus(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_CorrectableSourceIdBus(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CorrectableSourceIdBus_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_CorrectableSourceIdBus_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableSourceIdFun(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_UncorrectableSourceIdFun(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableSourceIdFun_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableSourceIdFun_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableSourceIdDev(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_UncorrectableSourceIdDev(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableSourceIdDev_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableSourceIdDev_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableSourceIdBus(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_UncorrectableSourceIdBus(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableSourceIdBus_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableSourceIdBus_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CorrectableSourceIdFun: USHORT,
        CorrectableSourceIdDev: USHORT,
        CorrectableSourceIdBus: USHORT,
        UncorrectableSourceIdFun: USHORT,
        UncorrectableSourceIdDev: USHORT,
        UncorrectableSourceIdBus: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let CorrectableSourceIdFun: u16 =
                unsafe { ::core::mem::transmute(CorrectableSourceIdFun) };
            CorrectableSourceIdFun as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let CorrectableSourceIdDev: u16 =
                unsafe { ::core::mem::transmute(CorrectableSourceIdDev) };
            CorrectableSourceIdDev as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let CorrectableSourceIdBus: u16 =
                unsafe { ::core::mem::transmute(CorrectableSourceIdBus) };
            CorrectableSourceIdBus as u64
        });
        __bindgen_bitfield_unit.set(16usize, 3u8, {
            let UncorrectableSourceIdFun: u16 =
                unsafe { ::core::mem::transmute(UncorrectableSourceIdFun) };
            UncorrectableSourceIdFun as u64
        });
        __bindgen_bitfield_unit.set(19usize, 5u8, {
            let UncorrectableSourceIdDev: u16 =
                unsafe { ::core::mem::transmute(UncorrectableSourceIdDev) };
            UncorrectableSourceIdDev as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let UncorrectableSourceIdBus: u16 =
                unsafe { ::core::mem::transmute(UncorrectableSourceIdBus) };
            UncorrectableSourceIdBus as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_ERROR_SOURCE_ID = _PCI_EXPRESS_ERROR_SOURCE_ID;
pub type PPCI_EXPRESS_ERROR_SOURCE_ID = *mut _PCI_EXPRESS_ERROR_SOURCE_ID;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS {
    pub __bindgen_anon_1: _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS__bindgen_ty_1 {
    #[inline]
    pub fn TargetAbortOnSplitCompletion(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TargetAbortOnSplitCompletion(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TargetAbortOnSplitCompletion_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_TargetAbortOnSplitCompletion_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MasterAbortOnSplitCompletion(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MasterAbortOnSplitCompletion(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MasterAbortOnSplitCompletion_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MasterAbortOnSplitCompletion_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReceivedTargetAbort(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReceivedTargetAbort(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReceivedTargetAbort_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReceivedTargetAbort_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReceivedMasterAbort(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReceivedMasterAbort(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReceivedMasterAbort_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReceivedMasterAbort_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RsvdZ(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RsvdZ(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RsvdZ_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RsvdZ_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UnexpectedSplitCompletionError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UnexpectedSplitCompletionError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UnexpectedSplitCompletionError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UnexpectedSplitCompletionError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableSplitCompletion(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableSplitCompletion(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableSplitCompletion_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableSplitCompletion_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableDataError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableDataError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableDataError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableDataError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableAttributeError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableAttributeError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableAttributeError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableAttributeError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableAddressError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableAddressError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableAddressError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableAddressError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DelayedTransactionDiscardTimerExpired(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DelayedTransactionDiscardTimerExpired(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DelayedTransactionDiscardTimerExpired_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DelayedTransactionDiscardTimerExpired_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PERRAsserted(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PERRAsserted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PERRAsserted_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PERRAsserted_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SERRAsserted(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SERRAsserted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SERRAsserted_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SERRAsserted_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn InternalBridgeError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InternalBridgeError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InternalBridgeError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_InternalBridgeError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                18u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                18u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TargetAbortOnSplitCompletion: ULONG,
        MasterAbortOnSplitCompletion: ULONG,
        ReceivedTargetAbort: ULONG,
        ReceivedMasterAbort: ULONG,
        RsvdZ: ULONG,
        UnexpectedSplitCompletionError: ULONG,
        UncorrectableSplitCompletion: ULONG,
        UncorrectableDataError: ULONG,
        UncorrectableAttributeError: ULONG,
        UncorrectableAddressError: ULONG,
        DelayedTransactionDiscardTimerExpired: ULONG,
        PERRAsserted: ULONG,
        SERRAsserted: ULONG,
        InternalBridgeError: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let TargetAbortOnSplitCompletion: u32 =
                unsafe { ::core::mem::transmute(TargetAbortOnSplitCompletion) };
            TargetAbortOnSplitCompletion as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let MasterAbortOnSplitCompletion: u32 =
                unsafe { ::core::mem::transmute(MasterAbortOnSplitCompletion) };
            MasterAbortOnSplitCompletion as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ReceivedTargetAbort: u32 = unsafe { ::core::mem::transmute(ReceivedTargetAbort) };
            ReceivedTargetAbort as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ReceivedMasterAbort: u32 = unsafe { ::core::mem::transmute(ReceivedMasterAbort) };
            ReceivedMasterAbort as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let RsvdZ: u32 = unsafe { ::core::mem::transmute(RsvdZ) };
            RsvdZ as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let UnexpectedSplitCompletionError: u32 =
                unsafe { ::core::mem::transmute(UnexpectedSplitCompletionError) };
            UnexpectedSplitCompletionError as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let UncorrectableSplitCompletion: u32 =
                unsafe { ::core::mem::transmute(UncorrectableSplitCompletion) };
            UncorrectableSplitCompletion as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let UncorrectableDataError: u32 =
                unsafe { ::core::mem::transmute(UncorrectableDataError) };
            UncorrectableDataError as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let UncorrectableAttributeError: u32 =
                unsafe { ::core::mem::transmute(UncorrectableAttributeError) };
            UncorrectableAttributeError as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let UncorrectableAddressError: u32 =
                unsafe { ::core::mem::transmute(UncorrectableAddressError) };
            UncorrectableAddressError as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let DelayedTransactionDiscardTimerExpired: u32 =
                unsafe { ::core::mem::transmute(DelayedTransactionDiscardTimerExpired) };
            DelayedTransactionDiscardTimerExpired as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let PERRAsserted: u32 = unsafe { ::core::mem::transmute(PERRAsserted) };
            PERRAsserted as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let SERRAsserted: u32 = unsafe { ::core::mem::transmute(SERRAsserted) };
            SERRAsserted as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let InternalBridgeError: u32 = unsafe { ::core::mem::transmute(InternalBridgeError) };
            InternalBridgeError as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS = _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS;
pub type PPCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS =
*mut _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK {
    pub __bindgen_anon_1: _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK__bindgen_ty_1 {
    #[inline]
    pub fn TargetAbortOnSplitCompletion(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TargetAbortOnSplitCompletion(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TargetAbortOnSplitCompletion_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_TargetAbortOnSplitCompletion_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MasterAbortOnSplitCompletion(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MasterAbortOnSplitCompletion(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MasterAbortOnSplitCompletion_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MasterAbortOnSplitCompletion_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReceivedTargetAbort(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReceivedTargetAbort(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReceivedTargetAbort_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReceivedTargetAbort_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReceivedMasterAbort(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReceivedMasterAbort(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReceivedMasterAbort_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReceivedMasterAbort_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RsvdZ(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RsvdZ(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RsvdZ_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RsvdZ_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UnexpectedSplitCompletionError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UnexpectedSplitCompletionError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UnexpectedSplitCompletionError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UnexpectedSplitCompletionError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableSplitCompletion(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableSplitCompletion(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableSplitCompletion_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableSplitCompletion_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableDataError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableDataError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableDataError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableDataError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableAttributeError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableAttributeError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableAttributeError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableAttributeError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableAddressError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableAddressError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableAddressError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableAddressError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DelayedTransactionDiscardTimerExpired(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DelayedTransactionDiscardTimerExpired(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DelayedTransactionDiscardTimerExpired_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DelayedTransactionDiscardTimerExpired_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PERRAsserted(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PERRAsserted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PERRAsserted_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PERRAsserted_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SERRAsserted(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SERRAsserted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SERRAsserted_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SERRAsserted_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn InternalBridgeError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InternalBridgeError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InternalBridgeError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_InternalBridgeError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                18u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                18u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TargetAbortOnSplitCompletion: ULONG,
        MasterAbortOnSplitCompletion: ULONG,
        ReceivedTargetAbort: ULONG,
        ReceivedMasterAbort: ULONG,
        RsvdZ: ULONG,
        UnexpectedSplitCompletionError: ULONG,
        UncorrectableSplitCompletion: ULONG,
        UncorrectableDataError: ULONG,
        UncorrectableAttributeError: ULONG,
        UncorrectableAddressError: ULONG,
        DelayedTransactionDiscardTimerExpired: ULONG,
        PERRAsserted: ULONG,
        SERRAsserted: ULONG,
        InternalBridgeError: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let TargetAbortOnSplitCompletion: u32 =
                unsafe { ::core::mem::transmute(TargetAbortOnSplitCompletion) };
            TargetAbortOnSplitCompletion as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let MasterAbortOnSplitCompletion: u32 =
                unsafe { ::core::mem::transmute(MasterAbortOnSplitCompletion) };
            MasterAbortOnSplitCompletion as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ReceivedTargetAbort: u32 = unsafe { ::core::mem::transmute(ReceivedTargetAbort) };
            ReceivedTargetAbort as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ReceivedMasterAbort: u32 = unsafe { ::core::mem::transmute(ReceivedMasterAbort) };
            ReceivedMasterAbort as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let RsvdZ: u32 = unsafe { ::core::mem::transmute(RsvdZ) };
            RsvdZ as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let UnexpectedSplitCompletionError: u32 =
                unsafe { ::core::mem::transmute(UnexpectedSplitCompletionError) };
            UnexpectedSplitCompletionError as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let UncorrectableSplitCompletion: u32 =
                unsafe { ::core::mem::transmute(UncorrectableSplitCompletion) };
            UncorrectableSplitCompletion as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let UncorrectableDataError: u32 =
                unsafe { ::core::mem::transmute(UncorrectableDataError) };
            UncorrectableDataError as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let UncorrectableAttributeError: u32 =
                unsafe { ::core::mem::transmute(UncorrectableAttributeError) };
            UncorrectableAttributeError as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let UncorrectableAddressError: u32 =
                unsafe { ::core::mem::transmute(UncorrectableAddressError) };
            UncorrectableAddressError as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let DelayedTransactionDiscardTimerExpired: u32 =
                unsafe { ::core::mem::transmute(DelayedTransactionDiscardTimerExpired) };
            DelayedTransactionDiscardTimerExpired as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let PERRAsserted: u32 = unsafe { ::core::mem::transmute(PERRAsserted) };
            PERRAsserted as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let SERRAsserted: u32 = unsafe { ::core::mem::transmute(SERRAsserted) };
            SERRAsserted as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let InternalBridgeError: u32 = unsafe { ::core::mem::transmute(InternalBridgeError) };
            InternalBridgeError as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK = _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK;
pub type PPCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK = *mut _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY {
    pub __bindgen_anon_1: _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY__bindgen_ty_1 {
    #[inline]
    pub fn TargetAbortOnSplitCompletion(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TargetAbortOnSplitCompletion(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TargetAbortOnSplitCompletion_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_TargetAbortOnSplitCompletion_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MasterAbortOnSplitCompletion(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MasterAbortOnSplitCompletion(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MasterAbortOnSplitCompletion_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MasterAbortOnSplitCompletion_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReceivedTargetAbort(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReceivedTargetAbort(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReceivedTargetAbort_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReceivedTargetAbort_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReceivedMasterAbort(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReceivedMasterAbort(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReceivedMasterAbort_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReceivedMasterAbort_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RsvdZ(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RsvdZ(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RsvdZ_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RsvdZ_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UnexpectedSplitCompletionError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UnexpectedSplitCompletionError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UnexpectedSplitCompletionError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UnexpectedSplitCompletionError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableSplitCompletion(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableSplitCompletion(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableSplitCompletion_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableSplitCompletion_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableDataError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableDataError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableDataError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableDataError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableAttributeError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableAttributeError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableAttributeError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableAttributeError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableAddressError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableAddressError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableAddressError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableAddressError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DelayedTransactionDiscardTimerExpired(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DelayedTransactionDiscardTimerExpired(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DelayedTransactionDiscardTimerExpired_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DelayedTransactionDiscardTimerExpired_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PERRAsserted(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PERRAsserted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PERRAsserted_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PERRAsserted_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SERRAsserted(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SERRAsserted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SERRAsserted_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SERRAsserted_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn InternalBridgeError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InternalBridgeError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InternalBridgeError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_InternalBridgeError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                18u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                18u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TargetAbortOnSplitCompletion: ULONG,
        MasterAbortOnSplitCompletion: ULONG,
        ReceivedTargetAbort: ULONG,
        ReceivedMasterAbort: ULONG,
        RsvdZ: ULONG,
        UnexpectedSplitCompletionError: ULONG,
        UncorrectableSplitCompletion: ULONG,
        UncorrectableDataError: ULONG,
        UncorrectableAttributeError: ULONG,
        UncorrectableAddressError: ULONG,
        DelayedTransactionDiscardTimerExpired: ULONG,
        PERRAsserted: ULONG,
        SERRAsserted: ULONG,
        InternalBridgeError: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let TargetAbortOnSplitCompletion: u32 =
                unsafe { ::core::mem::transmute(TargetAbortOnSplitCompletion) };
            TargetAbortOnSplitCompletion as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let MasterAbortOnSplitCompletion: u32 =
                unsafe { ::core::mem::transmute(MasterAbortOnSplitCompletion) };
            MasterAbortOnSplitCompletion as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ReceivedTargetAbort: u32 = unsafe { ::core::mem::transmute(ReceivedTargetAbort) };
            ReceivedTargetAbort as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ReceivedMasterAbort: u32 = unsafe { ::core::mem::transmute(ReceivedMasterAbort) };
            ReceivedMasterAbort as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let RsvdZ: u32 = unsafe { ::core::mem::transmute(RsvdZ) };
            RsvdZ as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let UnexpectedSplitCompletionError: u32 =
                unsafe { ::core::mem::transmute(UnexpectedSplitCompletionError) };
            UnexpectedSplitCompletionError as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let UncorrectableSplitCompletion: u32 =
                unsafe { ::core::mem::transmute(UncorrectableSplitCompletion) };
            UncorrectableSplitCompletion as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let UncorrectableDataError: u32 =
                unsafe { ::core::mem::transmute(UncorrectableDataError) };
            UncorrectableDataError as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let UncorrectableAttributeError: u32 =
                unsafe { ::core::mem::transmute(UncorrectableAttributeError) };
            UncorrectableAttributeError as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let UncorrectableAddressError: u32 =
                unsafe { ::core::mem::transmute(UncorrectableAddressError) };
            UncorrectableAddressError as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let DelayedTransactionDiscardTimerExpired: u32 =
                unsafe { ::core::mem::transmute(DelayedTransactionDiscardTimerExpired) };
            DelayedTransactionDiscardTimerExpired as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let PERRAsserted: u32 = unsafe { ::core::mem::transmute(PERRAsserted) };
            PERRAsserted as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let SERRAsserted: u32 = unsafe { ::core::mem::transmute(SERRAsserted) };
            SERRAsserted as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let InternalBridgeError: u32 = unsafe { ::core::mem::transmute(InternalBridgeError) };
            InternalBridgeError as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY =
_PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY;
pub type PPCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY =
*mut _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_SEC_AER_CAPABILITIES {
    pub __bindgen_anon_1: _PCI_EXPRESS_SEC_AER_CAPABILITIES__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_SEC_AER_CAPABILITIES__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_SEC_AER_CAPABILITIES__bindgen_ty_1 {
    #[inline]
    pub fn SecondaryUncorrectableFirstErrorPtr(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_SecondaryUncorrectableFirstErrorPtr(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SecondaryUncorrectableFirstErrorPtr_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SecondaryUncorrectableFirstErrorPtr_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                27u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                27u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SecondaryUncorrectableFirstErrorPtr: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let SecondaryUncorrectableFirstErrorPtr: u32 =
                unsafe { ::core::mem::transmute(SecondaryUncorrectableFirstErrorPtr) };
            SecondaryUncorrectableFirstErrorPtr as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_SEC_AER_CAPABILITIES = _PCI_EXPRESS_SEC_AER_CAPABILITIES;
pub type PPCI_EXPRESS_SEC_AER_CAPABILITIES = *mut _PCI_EXPRESS_SEC_AER_CAPABILITIES;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_AER_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub UncorrectableErrorStatus: PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS,
    pub UncorrectableErrorMask: PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK,
    pub UncorrectableErrorSeverity: PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY,
    pub CorrectableErrorStatus: PCI_EXPRESS_CORRECTABLE_ERROR_STATUS,
    pub CorrectableErrorMask: PCI_EXPRESS_CORRECTABLE_ERROR_MASK,
    pub CapabilitiesAndControl: PCI_EXPRESS_AER_CAPABILITIES,
    pub HeaderLog: [ULONG; 4usize],
    pub SecUncorrectableErrorStatus: PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS,
    pub SecUncorrectableErrorMask: PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK,
    pub SecUncorrectableErrorSeverity: PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY,
    pub SecCapabilitiesAndControl: PCI_EXPRESS_SEC_AER_CAPABILITIES,
    pub SecHeaderLog: [ULONG; 4usize],
}
pub type PCI_EXPRESS_AER_CAPABILITY = _PCI_EXPRESS_AER_CAPABILITY;
pub type PPCI_EXPRESS_AER_CAPABILITY = *mut _PCI_EXPRESS_AER_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_ROOTPORT_AER_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub UncorrectableErrorStatus: PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS,
    pub UncorrectableErrorMask: PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK,
    pub UncorrectableErrorSeverity: PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY,
    pub CorrectableErrorStatus: PCI_EXPRESS_CORRECTABLE_ERROR_STATUS,
    pub CorrectableErrorMask: PCI_EXPRESS_CORRECTABLE_ERROR_MASK,
    pub CapabilitiesAndControl: PCI_EXPRESS_AER_CAPABILITIES,
    pub HeaderLog: [ULONG; 4usize],
    pub RootErrorCommand: PCI_EXPRESS_ROOT_ERROR_COMMAND,
    pub RootErrorStatus: PCI_EXPRESS_ROOT_ERROR_STATUS,
    pub ErrorSourceId: PCI_EXPRESS_ERROR_SOURCE_ID,
}
pub type PCI_EXPRESS_ROOTPORT_AER_CAPABILITY = _PCI_EXPRESS_ROOTPORT_AER_CAPABILITY;
pub type PPCI_EXPRESS_ROOTPORT_AER_CAPABILITY = *mut _PCI_EXPRESS_ROOTPORT_AER_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_BRIDGE_AER_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub UncorrectableErrorStatus: PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS,
    pub UncorrectableErrorMask: PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK,
    pub UncorrectableErrorSeverity: PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY,
    pub CorrectableErrorStatus: PCI_EXPRESS_CORRECTABLE_ERROR_STATUS,
    pub CorrectableErrorMask: PCI_EXPRESS_CORRECTABLE_ERROR_MASK,
    pub CapabilitiesAndControl: PCI_EXPRESS_AER_CAPABILITIES,
    pub HeaderLog: [ULONG; 4usize],
    pub SecUncorrectableErrorStatus: PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS,
    pub SecUncorrectableErrorMask: PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK,
    pub SecUncorrectableErrorSeverity: PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY,
    pub SecCapabilitiesAndControl: PCI_EXPRESS_SEC_AER_CAPABILITIES,
    pub SecHeaderLog: [ULONG; 4usize],
}
pub type PCI_EXPRESS_BRIDGE_AER_CAPABILITY = _PCI_EXPRESS_BRIDGE_AER_CAPABILITY;
pub type PPCI_EXPRESS_BRIDGE_AER_CAPABILITY = *mut _PCI_EXPRESS_BRIDGE_AER_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_ACS_CAPABILITY_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_ACS_CAPABILITY_REGISTER__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_ACS_CAPABILITY_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_ACS_CAPABILITY_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn SourceValidation(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SourceValidation(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SourceValidation_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_SourceValidation_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TranslationBlocking(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TranslationBlocking(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TranslationBlocking_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_TranslationBlocking_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RequestRedirect(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RequestRedirect(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RequestRedirect_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_RequestRedirect_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CompletionRedirect(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CompletionRedirect(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CompletionRedirect_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_CompletionRedirect_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UpstreamForwarding(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UpstreamForwarding(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UpstreamForwarding_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_UpstreamForwarding_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EgressControl(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EgressControl(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EgressControl_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_EgressControl_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DirectTranslation(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DirectTranslation(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DirectTranslation_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_DirectTranslation_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EnhancedCapability(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EnhancedCapability(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EnhancedCapability_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_EnhancedCapability_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EgressControlVectorSize(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_EgressControlVectorSize(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EgressControlVectorSize_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_EgressControlVectorSize_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SourceValidation: USHORT,
        TranslationBlocking: USHORT,
        RequestRedirect: USHORT,
        CompletionRedirect: USHORT,
        UpstreamForwarding: USHORT,
        EgressControl: USHORT,
        DirectTranslation: USHORT,
        EnhancedCapability: USHORT,
        EgressControlVectorSize: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SourceValidation: u16 = unsafe { ::core::mem::transmute(SourceValidation) };
            SourceValidation as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TranslationBlocking: u16 = unsafe { ::core::mem::transmute(TranslationBlocking) };
            TranslationBlocking as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RequestRedirect: u16 = unsafe { ::core::mem::transmute(RequestRedirect) };
            RequestRedirect as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let CompletionRedirect: u16 = unsafe { ::core::mem::transmute(CompletionRedirect) };
            CompletionRedirect as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let UpstreamForwarding: u16 = unsafe { ::core::mem::transmute(UpstreamForwarding) };
            UpstreamForwarding as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let EgressControl: u16 = unsafe { ::core::mem::transmute(EgressControl) };
            EgressControl as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let DirectTranslation: u16 = unsafe { ::core::mem::transmute(DirectTranslation) };
            DirectTranslation as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let EnhancedCapability: u16 = unsafe { ::core::mem::transmute(EnhancedCapability) };
            EnhancedCapability as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let EgressControlVectorSize: u16 =
                unsafe { ::core::mem::transmute(EgressControlVectorSize) };
            EgressControlVectorSize as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_ACS_CAPABILITY_REGISTER = _PCI_EXPRESS_ACS_CAPABILITY_REGISTER;
pub type PPCI_EXPRESS_ACS_CAPABILITY_REGISTER = *mut _PCI_EXPRESS_ACS_CAPABILITY_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_ACS_CONTROL {
    pub __bindgen_anon_1: _PCI_EXPRESS_ACS_CONTROL__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_ACS_CONTROL__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_ACS_CONTROL__bindgen_ty_1 {
    #[inline]
    pub fn SourceValidation(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SourceValidation(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SourceValidation_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_SourceValidation_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TranslationBlocking(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TranslationBlocking(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TranslationBlocking_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_TranslationBlocking_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RequestRedirect(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RequestRedirect(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RequestRedirect_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_RequestRedirect_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CompletionRedirect(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CompletionRedirect(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CompletionRedirect_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_CompletionRedirect_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UpstreamForwarding(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UpstreamForwarding(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UpstreamForwarding_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_UpstreamForwarding_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EgressControl(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EgressControl(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EgressControl_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_EgressControl_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DirectTranslation(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DirectTranslation(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DirectTranslation_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_DirectTranslation_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IoBlocking(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_IoBlocking(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IoBlocking_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_IoBlocking_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DspMemoryControl(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_DspMemoryControl(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DspMemoryControl_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_DspMemoryControl_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UspMemoryControl(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_UspMemoryControl(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UspMemoryControl_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_UspMemoryControl_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UnclaimedRedirect(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UnclaimedRedirect(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UnclaimedRedirect_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_UnclaimedRedirect_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SourceValidation: USHORT,
        TranslationBlocking: USHORT,
        RequestRedirect: USHORT,
        CompletionRedirect: USHORT,
        UpstreamForwarding: USHORT,
        EgressControl: USHORT,
        DirectTranslation: USHORT,
        IoBlocking: USHORT,
        DspMemoryControl: USHORT,
        UspMemoryControl: USHORT,
        UnclaimedRedirect: USHORT,
        Reserved: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SourceValidation: u16 = unsafe { ::core::mem::transmute(SourceValidation) };
            SourceValidation as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TranslationBlocking: u16 = unsafe { ::core::mem::transmute(TranslationBlocking) };
            TranslationBlocking as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RequestRedirect: u16 = unsafe { ::core::mem::transmute(RequestRedirect) };
            RequestRedirect as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let CompletionRedirect: u16 = unsafe { ::core::mem::transmute(CompletionRedirect) };
            CompletionRedirect as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let UpstreamForwarding: u16 = unsafe { ::core::mem::transmute(UpstreamForwarding) };
            UpstreamForwarding as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let EgressControl: u16 = unsafe { ::core::mem::transmute(EgressControl) };
            EgressControl as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let DirectTranslation: u16 = unsafe { ::core::mem::transmute(DirectTranslation) };
            DirectTranslation as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let IoBlocking: u16 = unsafe { ::core::mem::transmute(IoBlocking) };
            IoBlocking as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let DspMemoryControl: u16 = unsafe { ::core::mem::transmute(DspMemoryControl) };
            DspMemoryControl as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let UspMemoryControl: u16 = unsafe { ::core::mem::transmute(UspMemoryControl) };
            UspMemoryControl as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let UnclaimedRedirect: u16 = unsafe { ::core::mem::transmute(UnclaimedRedirect) };
            UnclaimedRedirect as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let Reserved: u16 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_ACS_CONTROL = _PCI_EXPRESS_ACS_CONTROL;
pub type PPCI_EXPRESS_ACS_CONTROL = *mut _PCI_EXPRESS_ACS_CONTROL;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_ACS_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub Capability: PCI_EXPRESS_ACS_CAPABILITY_REGISTER,
    pub Control: PCI_EXPRESS_ACS_CONTROL,
    pub EgressControl: [ULONG; 1usize],
}
pub type PCI_EXPRESS_ACS_CAPABILITY = _PCI_EXPRESS_ACS_CAPABILITY;
pub type PPCI_EXPRESS_ACS_CAPABILITY = *mut _PCI_EXPRESS_ACS_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_SRIOV_CAPS {
    pub __bindgen_anon_1: _PCI_EXPRESS_SRIOV_CAPS__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_SRIOV_CAPS__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_SRIOV_CAPS__bindgen_ty_1 {
    #[inline]
    pub fn VFMigrationCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VFMigrationCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VFMigrationCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VFMigrationCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                20u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                20u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VFMigrationInterruptNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_VFMigrationInterruptNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VFMigrationInterruptNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                11u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VFMigrationInterruptNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                11u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        VFMigrationCapable: ULONG,
        Reserved1: ULONG,
        VFMigrationInterruptNumber: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let VFMigrationCapable: u32 = unsafe { ::core::mem::transmute(VFMigrationCapable) };
            VFMigrationCapable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 20u8, {
            let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 11u8, {
            let VFMigrationInterruptNumber: u32 =
                unsafe { ::core::mem::transmute(VFMigrationInterruptNumber) };
            VFMigrationInterruptNumber as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_SRIOV_CAPS = _PCI_EXPRESS_SRIOV_CAPS;
pub type PPCI_EXPRESS_SRIOV_CAPS = *mut _PCI_EXPRESS_SRIOV_CAPS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_SRIOV_CONTROL {
    pub __bindgen_anon_1: _PCI_EXPRESS_SRIOV_CONTROL__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_SRIOV_CONTROL__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_SRIOV_CONTROL__bindgen_ty_1 {
    #[inline]
    pub fn VFEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_VFEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VFEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_VFEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VFMigrationEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_VFMigrationEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VFMigrationEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_VFMigrationEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VFMigrationInterruptEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_VFMigrationInterruptEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VFMigrationInterruptEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_VFMigrationInterruptEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VFMemorySpaceEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_VFMemorySpaceEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VFMemorySpaceEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_VFMemorySpaceEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ARICapableHierarchy(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ARICapableHierarchy(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ARICapableHierarchy_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ARICapableHierarchy_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 11u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                11u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                11u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        VFEnable: USHORT,
        VFMigrationEnable: USHORT,
        VFMigrationInterruptEnable: USHORT,
        VFMemorySpaceEnable: USHORT,
        ARICapableHierarchy: USHORT,
        Reserved1: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let VFEnable: u16 = unsafe { ::core::mem::transmute(VFEnable) };
            VFEnable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let VFMigrationEnable: u16 = unsafe { ::core::mem::transmute(VFMigrationEnable) };
            VFMigrationEnable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let VFMigrationInterruptEnable: u16 =
                unsafe { ::core::mem::transmute(VFMigrationInterruptEnable) };
            VFMigrationInterruptEnable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let VFMemorySpaceEnable: u16 = unsafe { ::core::mem::transmute(VFMemorySpaceEnable) };
            VFMemorySpaceEnable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ARICapableHierarchy: u16 = unsafe { ::core::mem::transmute(ARICapableHierarchy) };
            ARICapableHierarchy as u64
        });
        __bindgen_bitfield_unit.set(5usize, 11u8, {
            let Reserved1: u16 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_SRIOV_CONTROL = _PCI_EXPRESS_SRIOV_CONTROL;
pub type PPCI_EXPRESS_SRIOV_CONTROL = *mut _PCI_EXPRESS_SRIOV_CONTROL;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_SRIOV_STATUS {
    pub __bindgen_anon_1: _PCI_EXPRESS_SRIOV_STATUS__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_SRIOV_STATUS__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_SRIOV_STATUS__bindgen_ty_1 {
    #[inline]
    pub fn VFMigrationStatus(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_VFMigrationStatus(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VFMigrationStatus_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_VFMigrationStatus_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 15u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                15u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                15u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        VFMigrationStatus: USHORT,
        Reserved1: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let VFMigrationStatus: u16 = unsafe { ::core::mem::transmute(VFMigrationStatus) };
            VFMigrationStatus as u64
        });
        __bindgen_bitfield_unit.set(1usize, 15u8, {
            let Reserved1: u16 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_SRIOV_STATUS = _PCI_EXPRESS_SRIOV_STATUS;
pub type PPCI_EXPRESS_SRIOV_STATUS = *mut _PCI_EXPRESS_SRIOV_STATUS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY {
    pub __bindgen_anon_1: _PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY__bindgen_ty_1 {
    #[inline]
    pub fn VFMigrationStateBIR(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_VFMigrationStateBIR(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VFMigrationStateBIR_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VFMigrationStateBIR_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VFMigrationStateOffset(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_VFMigrationStateOffset(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VFMigrationStateOffset_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                29u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VFMigrationStateOffset_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                29u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        VFMigrationStateBIR: ULONG,
        VFMigrationStateOffset: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let VFMigrationStateBIR: u32 = unsafe { ::core::mem::transmute(VFMigrationStateBIR) };
            VFMigrationStateBIR as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let VFMigrationStateOffset: u32 =
                unsafe { ::core::mem::transmute(VFMigrationStateOffset) };
            VFMigrationStateOffset as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY = _PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY;
pub type PPCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY = *mut _PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_SRIOV_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub SRIOVCapabilities: PCI_EXPRESS_SRIOV_CAPS,
    pub SRIOVControl: PCI_EXPRESS_SRIOV_CONTROL,
    pub SRIOVStatus: PCI_EXPRESS_SRIOV_STATUS,
    pub InitialVFs: USHORT,
    pub TotalVFs: USHORT,
    pub NumVFs: USHORT,
    pub FunctionDependencyLink: UCHAR,
    pub RsvdP1: UCHAR,
    pub FirstVFOffset: USHORT,
    pub VFStride: USHORT,
    pub RsvdP2: USHORT,
    pub VFDeviceId: USHORT,
    pub SupportedPageSizes: ULONG,
    pub SystemPageSize: ULONG,
    pub BaseAddresses: [ULONG; 6usize],
    pub VFMigrationStateArrayOffset: PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY,
}
pub type PCI_EXPRESS_SRIOV_CAPABILITY = _PCI_EXPRESS_SRIOV_CAPABILITY;
pub type PPCI_EXPRESS_SRIOV_CAPABILITY = *mut _PCI_EXPRESS_SRIOV_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_DEVICE_PRESENCE_PARAMETERS {
    pub Size: ULONG,
    pub Flags: ULONG,
    pub VendorID: USHORT,
    pub DeviceID: USHORT,
    pub RevisionID: UCHAR,
    pub SubVendorID: USHORT,
    pub SubSystemID: USHORT,
    pub BaseClass: UCHAR,
    pub SubClass: UCHAR,
    pub ProgIf: UCHAR,
}
pub type PCI_DEVICE_PRESENCE_PARAMETERS = _PCI_DEVICE_PRESENCE_PARAMETERS;
pub type PPCI_DEVICE_PRESENCE_PARAMETERS = *mut _PCI_DEVICE_PRESENCE_PARAMETERS;
pub type PCI_IS_DEVICE_PRESENT = ::core::option::Option<
    unsafe extern "C" fn(
        VendorID: USHORT,
        DeviceID: USHORT,
        RevisionID: UCHAR,
        SubVendorID: USHORT,
        SubSystemID: USHORT,
        Flags: ULONG,
    ) -> BOOLEAN,
>;
pub type PPCI_IS_DEVICE_PRESENT = PCI_IS_DEVICE_PRESENT;
pub type PCI_IS_DEVICE_PRESENT_EX = ::core::option::Option<
    unsafe extern "C" fn(Context: PVOID, Parameters: PPCI_DEVICE_PRESENCE_PARAMETERS) -> BOOLEAN,
>;
pub type PPCI_IS_DEVICE_PRESENT_EX = PCI_IS_DEVICE_PRESENT_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_DEVICE_PRESENT_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub IsDevicePresent: PPCI_IS_DEVICE_PRESENT,
    pub IsDevicePresentEx: PPCI_IS_DEVICE_PRESENT_EX,
}
pub type PCI_DEVICE_PRESENT_INTERFACE = _PCI_DEVICE_PRESENT_INTERFACE;
pub type PPCI_DEVICE_PRESENT_INTERFACE = *mut _PCI_DEVICE_PRESENT_INTERFACE;
pub type PCI_EXPRESS_ENTER_LINK_QUIESCENT_MODE =
::core::option::Option<unsafe extern "C" fn(Context: PVOID) -> NTSTATUS>;
pub type PPCI_EXPRESS_ENTER_LINK_QUIESCENT_MODE = PCI_EXPRESS_ENTER_LINK_QUIESCENT_MODE;
pub type PCI_EXPRESS_EXIT_LINK_QUIESCENT_MODE =
::core::option::Option<unsafe extern "C" fn(Context: PVOID) -> NTSTATUS>;
pub type PPCI_EXPRESS_EXIT_LINK_QUIESCENT_MODE = PCI_EXPRESS_EXIT_LINK_QUIESCENT_MODE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_LINK_QUIESCENT_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub PciExpressEnterLinkQuiescentMode: PPCI_EXPRESS_ENTER_LINK_QUIESCENT_MODE,
    pub PciExpressExitLinkQuiescentMode: PPCI_EXPRESS_EXIT_LINK_QUIESCENT_MODE,
}
pub type PCI_EXPRESS_LINK_QUIESCENT_INTERFACE = _PCI_EXPRESS_LINK_QUIESCENT_INTERFACE;
pub type PPCI_EXPRESS_LINK_QUIESCENT_INTERFACE = *mut _PCI_EXPRESS_LINK_QUIESCENT_INTERFACE;
pub type PPCI_EXPRESS_ROOT_PORT_READ_CONFIG_SPACE = ::core::option::Option<
    unsafe extern "C" fn(Context: PVOID, Buffer: PVOID, Offset: ULONG, Length: ULONG) -> ULONG,
>;
pub type PPCI_EXPRESS_ROOT_PORT_WRITE_CONFIG_SPACE = ::core::option::Option<
    unsafe extern "C" fn(Context: PVOID, Buffer: PVOID, Offset: ULONG, Length: ULONG) -> ULONG,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_ROOT_PORT_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub ReadConfigSpace: PPCI_EXPRESS_ROOT_PORT_READ_CONFIG_SPACE,
    pub WriteConfigSpace: PPCI_EXPRESS_ROOT_PORT_WRITE_CONFIG_SPACE,
}
pub type PCI_EXPRESS_ROOT_PORT_INTERFACE = _PCI_EXPRESS_ROOT_PORT_INTERFACE;
pub type PPCI_EXPRESS_ROOT_PORT_INTERFACE = *mut _PCI_EXPRESS_ROOT_PORT_INTERFACE;
pub type PCI_MSIX_SET_ENTRY = ::core::option::Option<
    unsafe extern "C" fn(Context: PVOID, TableEntry: ULONG, MessageNumber: ULONG) -> NTSTATUS,
>;
pub type PPCI_MSIX_SET_ENTRY = PCI_MSIX_SET_ENTRY;
pub type PCI_MSIX_MASKUNMASK_ENTRY =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, TableEntry: ULONG) -> NTSTATUS>;
pub type PPCI_MSIX_MASKUNMASK_ENTRY = PCI_MSIX_MASKUNMASK_ENTRY;
pub type PCI_MSIX_GET_ENTRY = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        TableEntry: ULONG,
        MessageNumber: PULONG,
        Masked: PBOOLEAN,
    ) -> NTSTATUS,
>;
pub type PPCI_MSIX_GET_ENTRY = PCI_MSIX_GET_ENTRY;
pub type PCI_MSIX_GET_TABLE_SIZE =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, TableSize: PULONG) -> NTSTATUS>;
pub type PPCI_MSIX_GET_TABLE_SIZE = PCI_MSIX_GET_TABLE_SIZE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_MSIX_TABLE_CONFIG_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub SetTableEntry: PPCI_MSIX_SET_ENTRY,
    pub MaskTableEntry: PPCI_MSIX_MASKUNMASK_ENTRY,
    pub UnmaskTableEntry: PPCI_MSIX_MASKUNMASK_ENTRY,
    pub GetTableEntry: PPCI_MSIX_GET_ENTRY,
    pub GetTableSize: PPCI_MSIX_GET_TABLE_SIZE,
}
pub type PCI_MSIX_TABLE_CONFIG_INTERFACE = _PCI_MSIX_TABLE_CONFIG_INTERFACE;
pub type PPCI_MSIX_TABLE_CONFIG_INTERFACE = *mut _PCI_MSIX_TABLE_CONFIG_INTERFACE;
unsafe extern "C" {
    pub fn ZwCreateFile(
        FileHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        AllocationSize: PLARGE_INTEGER,
        FileAttributes: ULONG,
        ShareAccess: ULONG,
        CreateDisposition: ULONG,
        CreateOptions: ULONG,
        EaBuffer: PVOID,
        EaLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwOpenFile(
        FileHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        ShareAccess: ULONG,
        OpenOptions: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwLoadDriver(DriverServiceName: PUNICODE_STRING) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwUnloadDriver(DriverServiceName: PUNICODE_STRING) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwQueryInformationFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FileInformation: PVOID,
        Length: ULONG,
        FileInformationClass: FILE_INFORMATION_CLASS,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwSetInformationFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FileInformation: PVOID,
        Length: ULONG,
        FileInformationClass: FILE_INFORMATION_CLASS,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwReadFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Buffer: PVOID,
        Length: ULONG,
        ByteOffset: PLARGE_INTEGER,
        Key: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwWriteFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Buffer: PVOID,
        Length: ULONG,
        ByteOffset: PLARGE_INTEGER,
        Key: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwClose(Handle: HANDLE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwCreateDirectoryObject(
        DirectoryHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwMakeTemporaryObject(Handle: HANDLE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwCreateSection(
        SectionHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        MaximumSize: PLARGE_INTEGER,
        SectionPageProtection: ULONG,
        AllocationAttributes: ULONG,
        FileHandle: HANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwOpenSection(
        SectionHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwMapViewOfSection(
        SectionHandle: HANDLE,
        ProcessHandle: HANDLE,
        BaseAddress: *mut PVOID,
        ZeroBits: ULONG_PTR,
        CommitSize: SIZE_T,
        SectionOffset: PLARGE_INTEGER,
        ViewSize: PSIZE_T,
        InheritDisposition: SECTION_INHERIT,
        AllocationType: ULONG,
        Win32Protect: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwUnmapViewOfSection(ProcessHandle: HANDLE, BaseAddress: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwCreateKey(
        KeyHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        TitleIndex: ULONG,
        Class: PUNICODE_STRING,
        CreateOptions: ULONG,
        Disposition: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwCreateKeyTransacted(
        KeyHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        TitleIndex: ULONG,
        Class: PUNICODE_STRING,
        CreateOptions: ULONG,
        TransactionHandle: HANDLE,
        Disposition: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwCreateRegistryTransaction(
        TransactionHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        CreateOptions: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtOpenRegistryTransaction(
        TransactionHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwCommitRegistryTransaction(TransactionHandle: HANDLE, Flags: ULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtRollbackRegistryTransaction(TransactionHandle: HANDLE, Flags: ULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwOpenKey(
        KeyHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwOpenKeyEx(
        KeyHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        OpenOptions: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwOpenKeyTransacted(
        KeyHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        TransactionHandle: HANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwOpenKeyTransactedEx(
        KeyHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        OpenOptions: ULONG,
        TransactionHandle: HANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwDeleteKey(KeyHandle: HANDLE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwDeleteValueKey(KeyHandle: HANDLE, ValueName: PUNICODE_STRING) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwEnumerateKey(
        KeyHandle: HANDLE,
        Index: ULONG,
        KeyInformationClass: KEY_INFORMATION_CLASS,
        KeyInformation: PVOID,
        Length: ULONG,
        ResultLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwEnumerateValueKey(
        KeyHandle: HANDLE,
        Index: ULONG,
        KeyValueInformationClass: KEY_VALUE_INFORMATION_CLASS,
        KeyValueInformation: PVOID,
        Length: ULONG,
        ResultLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwFlushKey(KeyHandle: HANDLE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwQueryKey(
        KeyHandle: HANDLE,
        KeyInformationClass: KEY_INFORMATION_CLASS,
        KeyInformation: PVOID,
        Length: ULONG,
        ResultLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwQueryValueKey(
        KeyHandle: HANDLE,
        ValueName: PUNICODE_STRING,
        KeyValueInformationClass: KEY_VALUE_INFORMATION_CLASS,
        KeyValueInformation: PVOID,
        Length: ULONG,
        ResultLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwRenameKey(KeyHandle: HANDLE, NewName: PUNICODE_STRING) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwSaveKey(KeyHandle: HANDLE, FileHandle: HANDLE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwSaveKeyEx(KeyHandle: HANDLE, FileHandle: HANDLE, Format: ULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwRestoreKey(KeyHandle: HANDLE, FileHandle: HANDLE, Flags: ULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwSetInformationKey(
        KeyHandle: HANDLE,
        KeySetInformationClass: KEY_SET_INFORMATION_CLASS,
        KeySetInformation: PVOID,
        KeySetInformationLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwSetValueKey(
        KeyHandle: HANDLE,
        ValueName: PUNICODE_STRING,
        TitleIndex: ULONG,
        Type: ULONG,
        Data: PVOID,
        DataSize: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwOpenSymbolicLinkObject(
        LinkHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwQuerySymbolicLinkObject(
        LinkHandle: HANDLE,
        LinkTarget: PUNICODE_STRING,
        ReturnedLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwCreateTransactionManager(
        TmHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        LogFileName: PUNICODE_STRING,
        CreateOptions: ULONG,
        CommitStrength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwOpenTransactionManager(
        TmHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        LogFileName: PUNICODE_STRING,
        TmIdentity: LPGUID,
        OpenOptions: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwRollforwardTransactionManager(
        TransactionManagerHandle: HANDLE,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwRecoverTransactionManager(TransactionManagerHandle: HANDLE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwQueryInformationTransactionManager(
        TransactionManagerHandle: HANDLE,
        TransactionManagerInformationClass: TRANSACTIONMANAGER_INFORMATION_CLASS,
        TransactionManagerInformation: PVOID,
        TransactionManagerInformationLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwSetInformationTransactionManager(
        TmHandle: HANDLE,
        TransactionManagerInformationClass: TRANSACTIONMANAGER_INFORMATION_CLASS,
        TransactionManagerInformation: PVOID,
        TransactionManagerInformationLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwEnumerateTransactionObject(
        RootObjectHandle: HANDLE,
        QueryType: KTMOBJECT_TYPE,
        ObjectCursor: PKTMOBJECT_CURSOR,
        ObjectCursorLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwCreateTransaction(
        TransactionHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        Uow: LPGUID,
        TmHandle: HANDLE,
        CreateOptions: ULONG,
        IsolationLevel: ULONG,
        IsolationFlags: ULONG,
        Timeout: PLARGE_INTEGER,
        Description: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwOpenTransaction(
        TransactionHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        Uow: LPGUID,
        TmHandle: HANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwQueryInformationTransaction(
        TransactionHandle: HANDLE,
        TransactionInformationClass: TRANSACTION_INFORMATION_CLASS,
        TransactionInformation: PVOID,
        TransactionInformationLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwSetInformationTransaction(
        TransactionHandle: HANDLE,
        TransactionInformationClass: TRANSACTION_INFORMATION_CLASS,
        TransactionInformation: PVOID,
        TransactionInformationLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwCommitTransaction(TransactionHandle: HANDLE, Wait: BOOLEAN) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwRollbackTransaction(TransactionHandle: HANDLE, Wait: BOOLEAN) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwCreateResourceManager(
        ResourceManagerHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        TmHandle: HANDLE,
        ResourceManagerGuid: LPGUID,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        CreateOptions: ULONG,
        Description: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwOpenResourceManager(
        ResourceManagerHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        TmHandle: HANDLE,
        ResourceManagerGuid: LPGUID,
        ObjectAttributes: POBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwRecoverResourceManager(ResourceManagerHandle: HANDLE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwGetNotificationResourceManager(
        ResourceManagerHandle: HANDLE,
        TransactionNotification: PTRANSACTION_NOTIFICATION,
        NotificationLength: ULONG,
        Timeout: PLARGE_INTEGER,
        ReturnLength: PULONG,
        Asynchronous: ULONG,
        AsynchronousContext: ULONG_PTR,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwQueryInformationResourceManager(
        ResourceManagerHandle: HANDLE,
        ResourceManagerInformationClass: RESOURCEMANAGER_INFORMATION_CLASS,
        ResourceManagerInformation: PVOID,
        ResourceManagerInformationLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwSetInformationResourceManager(
        ResourceManagerHandle: HANDLE,
        ResourceManagerInformationClass: RESOURCEMANAGER_INFORMATION_CLASS,
        ResourceManagerInformation: PVOID,
        ResourceManagerInformationLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwCreateEnlistment(
        EnlistmentHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ResourceManagerHandle: HANDLE,
        TransactionHandle: HANDLE,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        CreateOptions: ULONG,
        NotificationMask: NOTIFICATION_MASK,
        EnlistmentKey: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwOpenEnlistment(
        EnlistmentHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        RmHandle: HANDLE,
        EnlistmentGuid: LPGUID,
        ObjectAttributes: POBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwQueryInformationEnlistment(
        EnlistmentHandle: HANDLE,
        EnlistmentInformationClass: ENLISTMENT_INFORMATION_CLASS,
        EnlistmentInformation: PVOID,
        EnlistmentInformationLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwSetInformationEnlistment(
        EnlistmentHandle: HANDLE,
        EnlistmentInformationClass: ENLISTMENT_INFORMATION_CLASS,
        EnlistmentInformation: PVOID,
        EnlistmentInformationLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwRecoverEnlistment(EnlistmentHandle: HANDLE, EnlistmentKey: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwPrePrepareEnlistment(
        EnlistmentHandle: HANDLE,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwPrepareEnlistment(
        EnlistmentHandle: HANDLE,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwCommitEnlistment(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER)
                              -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwRollbackEnlistment(
        EnlistmentHandle: HANDLE,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwPrePrepareComplete(
        EnlistmentHandle: HANDLE,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwPrepareComplete(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwCommitComplete(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwReadOnlyEnlistment(
        EnlistmentHandle: HANDLE,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwRollbackComplete(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER)
                              -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwSinglePhaseReject(
        EnlistmentHandle: HANDLE,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwOpenEvent(
        EventHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwQueryInformationByName(
        ObjectAttributes: POBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FileInformation: PVOID,
        Length: ULONG,
        FileInformationClass: FILE_INFORMATION_CLASS,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwQueryFullAttributesFile(
        ObjectAttributes: POBJECT_ATTRIBUTES,
        FileInformation: PFILE_NETWORK_OPEN_INFORMATION,
    ) -> NTSTATUS;
}
pub type CLFS_CONTAINER_ID = ULONG;
pub type PCLFS_CONTAINER_ID = *mut CLFS_CONTAINER_ID;
pub type PPCLFS_CONTAINER_ID = *mut *mut CLFS_CONTAINER_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLS_LSN {
    pub Internal: ULONGLONG,
}
pub type CLS_LSN = _CLS_LSN;
pub type PCLS_LSN = *mut _CLS_LSN;
pub type PPCLS_LSN = *mut *mut _CLS_LSN;
pub type CLFS_LSN = CLS_LSN;
pub type PCLFS_LSN = *mut CLFS_LSN;
pub type PPCLFS_LSN = *mut *mut CLFS_LSN;
unsafe extern "C" {
    pub static CLFS_LSN_INVALID: CLFS_LSN;
}
unsafe extern "C" {
    pub static CLFS_LSN_NULL: CLFS_LSN;
}
pub type CLS_RECORD_TYPE = UCHAR;
pub type PCLS_RECORD_TYPE = *mut UCHAR;
pub type PPCLS_RECORD_TYPE = *mut *mut UCHAR;
pub type CLFS_RECORD_TYPE = CLS_RECORD_TYPE;
pub type PCLFS_RECORD_TYPE = *mut CLS_RECORD_TYPE;
pub type PPCLFS_RECORD_TYPE = *mut *mut CLS_RECORD_TYPE;
pub const _CLS_CONTEXT_MODE_ClsContextNone: _CLS_CONTEXT_MODE = 0;
pub const _CLS_CONTEXT_MODE_ClsContextUndoNext: _CLS_CONTEXT_MODE = 1;
pub const _CLS_CONTEXT_MODE_ClsContextPrevious: _CLS_CONTEXT_MODE = 2;
pub const _CLS_CONTEXT_MODE_ClsContextForward: _CLS_CONTEXT_MODE = 3;
pub type _CLS_CONTEXT_MODE = core::ffi::c_int;
pub use self::_CLS_CONTEXT_MODE as CLS_CONTEXT_MODE;
pub type PCLS_CONTEXT_MODE = *mut _CLS_CONTEXT_MODE;
pub type PPCLS_CONTEXT_MODE = *mut *mut _CLS_CONTEXT_MODE;
pub const _CLFS_CONTEXT_MODE_ClfsContextNone: _CLFS_CONTEXT_MODE = 0;
pub const _CLFS_CONTEXT_MODE_ClfsContextUndoNext: _CLFS_CONTEXT_MODE = 1;
pub const _CLFS_CONTEXT_MODE_ClfsContextPrevious: _CLFS_CONTEXT_MODE = 2;
pub const _CLFS_CONTEXT_MODE_ClfsContextForward: _CLFS_CONTEXT_MODE = 3;
pub type _CLFS_CONTEXT_MODE = core::ffi::c_int;
pub use self::_CLFS_CONTEXT_MODE as CLFS_CONTEXT_MODE;
pub type PCLFS_CONTEXT_MODE = *mut _CLFS_CONTEXT_MODE;
pub type PPCLFS_CONTEXT_MODE = *mut *mut _CLFS_CONTEXT_MODE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLFS_NODE_ID {
    pub cType: ULONG,
    pub cbNode: ULONG,
}
pub type CLFS_NODE_ID = _CLFS_NODE_ID;
pub type PCLFS_NODE_ID = *mut _CLFS_NODE_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLS_WRITE_ENTRY {
    pub Buffer: PVOID,
    pub ByteLength: ULONG,
}
pub type CLS_WRITE_ENTRY = _CLS_WRITE_ENTRY;
pub type PCLS_WRITE_ENTRY = *mut _CLS_WRITE_ENTRY;
pub type PPCLS_WRITE_ENTRY = *mut *mut _CLS_WRITE_ENTRY;
pub type CLFS_WRITE_ENTRY = CLS_WRITE_ENTRY;
pub type PCLFS_WRITE_ENTRY = *mut CLFS_WRITE_ENTRY;
pub type PPCLFS_WRITE_ENTRY = *mut *mut CLFS_WRITE_ENTRY;
pub type CLFS_LOG_ID = GUID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLS_INFORMATION {
    pub TotalAvailable: LONGLONG,
    pub CurrentAvailable: LONGLONG,
    pub TotalReservation: LONGLONG,
    pub BaseFileSize: ULONGLONG,
    pub ContainerSize: ULONGLONG,
    pub TotalContainers: ULONG,
    pub FreeContainers: ULONG,
    pub TotalClients: ULONG,
    pub Attributes: ULONG,
    pub FlushThreshold: ULONG,
    pub SectorSize: ULONG,
    pub MinArchiveTailLsn: CLS_LSN,
    pub BaseLsn: CLS_LSN,
    pub LastFlushedLsn: CLS_LSN,
    pub LastLsn: CLS_LSN,
    pub RestartLsn: CLS_LSN,
    pub Identity: GUID,
}
pub type CLS_INFORMATION = _CLS_INFORMATION;
pub type PCLS_INFORMATION = *mut _CLS_INFORMATION;
pub type PPCLS_INFORMATION = *mut _CLS_INFORMATION;
pub type CLFS_INFORMATION = CLS_INFORMATION;
pub type PCLFS_INFORMATION = *mut CLFS_INFORMATION;
pub type PPCLFS_INFORMATION = *mut CLFS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLFS_LOG_NAME_INFORMATION {
    pub NameLengthInBytes: USHORT,
    pub Name: [WCHAR; 1usize],
}
pub type CLFS_LOG_NAME_INFORMATION = _CLFS_LOG_NAME_INFORMATION;
pub type PCLFS_LOG_NAME_INFORMATION = *mut _CLFS_LOG_NAME_INFORMATION;
pub type PPCLFS_LOG_NAME_INFORMATION = *mut *mut _CLFS_LOG_NAME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLFS_STREAM_ID_INFORMATION {
    pub StreamIdentifier: UCHAR,
}
pub type CLFS_STREAM_ID_INFORMATION = _CLFS_STREAM_ID_INFORMATION;
pub type PCLFS_STREAM_ID_INFORMATION = *mut _CLFS_STREAM_ID_INFORMATION;
pub type PPCLFS_STREAM_ID_INFORMATION = *mut *mut _CLFS_STREAM_ID_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLFS_PHYSICAL_LSN_INFORMATION {
    pub StreamIdentifier: UCHAR,
    pub VirtualLsn: CLFS_LSN,
    pub PhysicalLsn: CLFS_LSN,
}
pub type CLFS_PHYSICAL_LSN_INFORMATION = _CLFS_PHYSICAL_LSN_INFORMATION;
pub type PCLFS_PHYSICAL_LSN_INFORMATION = *mut _CLFS_PHYSICAL_LSN_INFORMATION;
pub type CLS_CONTAINER_STATE = UINT32;
pub type PCLS_CONTAINER_STATE = *mut UINT32;
pub type PPCLS_CONTAINER_STATE = *mut UINT32;
pub type CLFS_CONTAINER_STATE = CLS_CONTAINER_STATE;
pub type PCLFS_CONTAINER_STATE = *mut CLS_CONTAINER_STATE;
pub type PPCLFS_CONTAINER_STATE = *mut CLS_CONTAINER_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLS_CONTAINER_INFORMATION {
    pub FileAttributes: ULONG,
    pub CreationTime: ULONGLONG,
    pub LastAccessTime: ULONGLONG,
    pub LastWriteTime: ULONGLONG,
    pub ContainerSize: LONGLONG,
    pub FileNameActualLength: ULONG,
    pub FileNameLength: ULONG,
    pub FileName: [WCHAR; 256usize],
    pub State: CLFS_CONTAINER_STATE,
    pub PhysicalContainerId: CLFS_CONTAINER_ID,
    pub LogicalContainerId: CLFS_CONTAINER_ID,
}
pub type CLS_CONTAINER_INFORMATION = _CLS_CONTAINER_INFORMATION;
pub type PCLS_CONTAINER_INFORMATION = *mut _CLS_CONTAINER_INFORMATION;
pub type PPCLS_CONTAINER_INFORMATION = *mut *mut _CLS_CONTAINER_INFORMATION;
pub type CLFS_CONTAINER_INFORMATION = CLS_CONTAINER_INFORMATION;
pub type PCLFS_CONTAINER_INFORMATION = *mut CLFS_CONTAINER_INFORMATION;
pub type PPCLFS_CONTAINER_INFORMATION = *mut *mut CLFS_CONTAINER_INFORMATION;
pub const _CLS_LOG_INFORMATION_CLASS_ClfsLogBasicInformation: _CLS_LOG_INFORMATION_CLASS = 0;
pub const _CLS_LOG_INFORMATION_CLASS_ClfsLogBasicInformationPhysical: _CLS_LOG_INFORMATION_CLASS =
    1;
pub const _CLS_LOG_INFORMATION_CLASS_ClfsLogPhysicalNameInformation: _CLS_LOG_INFORMATION_CLASS = 2;
pub const _CLS_LOG_INFORMATION_CLASS_ClfsLogStreamIdentifierInformation:
_CLS_LOG_INFORMATION_CLASS = 3;
pub const _CLS_LOG_INFORMATION_CLASS_ClfsLogSystemMarkingInformation: _CLS_LOG_INFORMATION_CLASS =
    4;
pub const _CLS_LOG_INFORMATION_CLASS_ClfsLogPhysicalLsnInformation: _CLS_LOG_INFORMATION_CLASS = 5;
pub type _CLS_LOG_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_CLS_LOG_INFORMATION_CLASS as CLS_LOG_INFORMATION_CLASS;
pub type PCLS_LOG_INFORMATION_CLASS = *mut _CLS_LOG_INFORMATION_CLASS;
pub type PPCLS_LOG_INFORMATION_CLASS = *mut *mut _CLS_LOG_INFORMATION_CLASS;
pub use self::CLS_LOG_INFORMATION_CLASS as CLFS_LOG_INFORMATION_CLASS;
pub type PCLFS_LOG_INFORMATION_CLASS = *mut CLFS_LOG_INFORMATION_CLASS;
pub type PPCLFS_LOG_INFORMATION_CLASS = *mut *mut CLFS_LOG_INFORMATION_CLASS;
pub const _CLS_IOSTATS_CLASS_ClsIoStatsDefault: _CLS_IOSTATS_CLASS = 0;
pub const _CLS_IOSTATS_CLASS_ClsIoStatsMax: _CLS_IOSTATS_CLASS = 65535;
pub type _CLS_IOSTATS_CLASS = core::ffi::c_int;
pub use self::_CLS_IOSTATS_CLASS as CLS_IOSTATS_CLASS;
pub type PCLS_IOSTATS_CLASS = *mut _CLS_IOSTATS_CLASS;
pub type PPCLS_IOSTATS_CLASS = *mut *mut _CLS_IOSTATS_CLASS;
pub const _CLFS_IOSTATS_CLASS_ClfsIoStatsDefault: _CLFS_IOSTATS_CLASS = 0;
pub const _CLFS_IOSTATS_CLASS_ClfsIoStatsMax: _CLFS_IOSTATS_CLASS = 65535;
pub type _CLFS_IOSTATS_CLASS = core::ffi::c_int;
pub use self::_CLFS_IOSTATS_CLASS as CLFS_IOSTATS_CLASS;
pub type PCLFS_IOSTATS_CLASS = *mut _CLFS_IOSTATS_CLASS;
pub type PPCLFS_IOSTATS_CLASS = *mut *mut _CLFS_IOSTATS_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLS_IO_STATISTICS_HEADER {
    pub ubMajorVersion: UCHAR,
    pub ubMinorVersion: UCHAR,
    pub eStatsClass: CLFS_IOSTATS_CLASS,
    pub cbLength: USHORT,
    pub coffData: ULONG,
}
pub type CLS_IO_STATISTICS_HEADER = _CLS_IO_STATISTICS_HEADER;
pub type PCLS_IO_STATISTICS_HEADER = *mut _CLS_IO_STATISTICS_HEADER;
pub type PPCLS_IO_STATISTICS_HEADER = *mut *mut _CLS_IO_STATISTICS_HEADER;
pub type CLFS_IO_STATISTICS_HEADER = CLS_IO_STATISTICS_HEADER;
pub type PCLFS_IO_STATISTICS_HEADER = *mut CLFS_IO_STATISTICS_HEADER;
pub type PPCLFS_IO_STATISTICS_HEADER = *mut *mut CLFS_IO_STATISTICS_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLS_IO_STATISTICS {
    pub hdrIoStats: CLS_IO_STATISTICS_HEADER,
    pub cFlush: ULONGLONG,
    pub cbFlush: ULONGLONG,
    pub cMetaFlush: ULONGLONG,
    pub cbMetaFlush: ULONGLONG,
}
pub type CLS_IO_STATISTICS = _CLS_IO_STATISTICS;
pub type PCLS_IO_STATISTICS = *mut _CLS_IO_STATISTICS;
pub type PPCLS_IO_STATISTICS = *mut *mut _CLS_IO_STATISTICS;
pub type CLFS_IO_STATISTICS = CLS_IO_STATISTICS;
pub type PCLFS_IO_STATISTICS = *mut CLFS_IO_STATISTICS;
pub type PPCLFS_IO_STATISTICS = *mut *mut CLFS_IO_STATISTICS;
pub type CLFS_SCAN_MODE = UCHAR;
pub type PCLFS_SCAN_MODE = *mut UCHAR;
pub type LOG_FILE_OBJECT = FILE_OBJECT;
pub type PLOG_FILE_OBJECT = *mut FILE_OBJECT;
pub type PPLOG_FILE_OBJECT = *mut *mut FILE_OBJECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLS_SCAN_CONTEXT {
    pub cidNode: CLFS_NODE_ID,
    pub plfoLog: PLOG_FILE_OBJECT,
    pub cIndex: ULONG,
    pub __bindgen_padding_0: u32,
    pub cContainers: ULONG,
    pub __bindgen_padding_1: u32,
    pub cContainersReturned: ULONG,
    pub __bindgen_padding_2: [u8; 4usize],
    pub eScanMode: CLFS_SCAN_MODE,
    pub pinfoContainer: PCLS_CONTAINER_INFORMATION,
}
pub type CLS_SCAN_CONTEXT = _CLS_SCAN_CONTEXT;
pub type PCLS_SCAN_CONTEXT = *mut _CLS_SCAN_CONTEXT;
pub type PPCLS_SCAN_CONTEXT = *mut *mut _CLS_SCAN_CONTEXT;
pub type CLFS_SCAN_CONTEXT = CLS_SCAN_CONTEXT;
pub type PCLFS_SCAN_CONTEXT = *mut CLFS_SCAN_CONTEXT;
pub type PPCLFS_SCAN_CONTEXT = *mut *mut CLFS_SCAN_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLS_ARCHIVE_DESCRIPTOR {
    pub coffLow: ULONGLONG,
    pub coffHigh: ULONGLONG,
    pub infoContainer: CLS_CONTAINER_INFORMATION,
}
pub type CLS_ARCHIVE_DESCRIPTOR = _CLS_ARCHIVE_DESCRIPTOR;
pub type PCLS_ARCHIVE_DESCRIPTOR = *mut _CLS_ARCHIVE_DESCRIPTOR;
pub type PPCLS_ARCHIVE_DESCRIPTOR = *mut *mut _CLS_ARCHIVE_DESCRIPTOR;
pub type CLFS_ARCHIVE_DESCRIPTOR = CLS_ARCHIVE_DESCRIPTOR;
pub type PCLFS_ARCHIVE_DESCRIPTOR = *mut CLFS_ARCHIVE_DESCRIPTOR;
pub type PPCLFS_ARCHIVE_DESCRIPTOR = *mut *mut CLFS_ARCHIVE_DESCRIPTOR;
pub type CLFS_BLOCK_ALLOCATION = ::core::option::Option<
    unsafe extern "C" fn(cbBufferLength: ULONG, pvUserContext: PVOID) -> PVOID,
>;
pub type CLFS_BLOCK_DEALLOCATION =
::core::option::Option<unsafe extern "C" fn(pvBuffer: PVOID, pvUserContext: PVOID)>;
pub const _CLFS_LOG_ARCHIVE_MODE_ClfsLogArchiveEnabled: _CLFS_LOG_ARCHIVE_MODE = 1;
pub const _CLFS_LOG_ARCHIVE_MODE_ClfsLogArchiveDisabled: _CLFS_LOG_ARCHIVE_MODE = 2;
pub type _CLFS_LOG_ARCHIVE_MODE = core::ffi::c_int;
pub use self::_CLFS_LOG_ARCHIVE_MODE as CLFS_LOG_ARCHIVE_MODE;
pub type PCLFS_LOG_ARCHIVE_MODE = *mut _CLFS_LOG_ARCHIVE_MODE;
unsafe extern "C" {
    pub fn ClfsLsnEqual(plsn1: *const CLFS_LSN, plsn2: *const CLFS_LSN) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ClfsLsnLess(plsn1: *const CLFS_LSN, plsn2: *const CLFS_LSN) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ClfsLsnGreater(plsn1: *const CLFS_LSN, plsn2: *const CLFS_LSN) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ClfsLsnNull(plsn: *const CLFS_LSN) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ClfsLsnContainer(plsn: *const CLFS_LSN) -> CLFS_CONTAINER_ID;
}
unsafe extern "C" {
    pub fn ClfsLsnCreate(
        cidContainer: CLFS_CONTAINER_ID,
        offBlock: ULONG,
        cRecord: ULONG,
    ) -> CLFS_LSN;
}
unsafe extern "C" {
    pub fn ClfsLsnBlockOffset(plsn: *const CLFS_LSN) -> ULONG;
}
unsafe extern "C" {
    pub fn ClfsLsnRecordSequence(plsn: *const CLFS_LSN) -> ULONG;
}
unsafe extern "C" {
    pub fn ClfsLsnInvalid(plsn: *const CLFS_LSN) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ClfsLsnIncrement(plsn: PCLFS_LSN) -> CLFS_LSN;
}
pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyMaximumSize: _CLFS_MGMT_POLICY_TYPE = 0;
pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyMinimumSize: _CLFS_MGMT_POLICY_TYPE = 1;
pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyNewContainerSize: _CLFS_MGMT_POLICY_TYPE = 2;
pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyGrowthRate: _CLFS_MGMT_POLICY_TYPE = 3;
pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyLogTail: _CLFS_MGMT_POLICY_TYPE = 4;
pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyAutoShrink: _CLFS_MGMT_POLICY_TYPE = 5;
pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyAutoGrow: _CLFS_MGMT_POLICY_TYPE = 6;
pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyNewContainerPrefix: _CLFS_MGMT_POLICY_TYPE = 7;
pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyNewContainerSuffix: _CLFS_MGMT_POLICY_TYPE = 8;
pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyNewContainerExtension: _CLFS_MGMT_POLICY_TYPE = 9;
pub const _CLFS_MGMT_POLICY_TYPE_ClfsMgmtPolicyInvalid: _CLFS_MGMT_POLICY_TYPE = 10;
pub type _CLFS_MGMT_POLICY_TYPE = core::ffi::c_int;
pub use self::_CLFS_MGMT_POLICY_TYPE as CLFS_MGMT_POLICY_TYPE;
pub type PCLFS_MGMT_POLICY_TYPE = *mut _CLFS_MGMT_POLICY_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CLFS_MGMT_POLICY {
    pub Version: ULONG,
    pub LengthInBytes: ULONG,
    pub PolicyFlags: ULONG,
    pub PolicyType: CLFS_MGMT_POLICY_TYPE,
    pub PolicyParameters: _CLFS_MGMT_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CLFS_MGMT_POLICY__bindgen_ty_1 {
    pub MaximumSize: _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_1,
    pub MinimumSize: _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_2,
    pub NewContainerSize: _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_3,
    pub GrowthRate: _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_4,
    pub LogTail: _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_5,
    pub AutoShrink: _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_6,
    pub AutoGrow: _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_7,
    pub NewContainerPrefix: _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_8,
    pub NewContainerSuffix: _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_9,
    pub NewContainerExtension: _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_10,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub Containers: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_2 {
    pub Containers: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_3 {
    pub SizeInBytes: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_4 {
    pub AbsoluteGrowthInContainers: ULONG,
    pub RelativeGrowthPercentage: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_5 {
    pub MinimumAvailablePercentage: ULONG,
    pub MinimumAvailableContainers: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_6 {
    pub Percentage: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_7 {
    pub Enabled: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_8 {
    pub PrefixLengthInBytes: USHORT,
    pub PrefixString: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_9 {
    pub NextContainerSuffix: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLFS_MGMT_POLICY__bindgen_ty_1__bindgen_ty_10 {
    pub ExtensionLengthInBytes: USHORT,
    pub ExtensionString: [WCHAR; 1usize],
}
pub type CLFS_MGMT_POLICY = _CLFS_MGMT_POLICY;
pub type PCLFS_MGMT_POLICY = *mut _CLFS_MGMT_POLICY;
pub const _CLFS_MGMT_NOTIFICATION_TYPE_ClfsMgmtAdvanceTailNotification:
_CLFS_MGMT_NOTIFICATION_TYPE = 0;
pub const _CLFS_MGMT_NOTIFICATION_TYPE_ClfsMgmtLogFullHandlerNotification:
_CLFS_MGMT_NOTIFICATION_TYPE = 1;
pub const _CLFS_MGMT_NOTIFICATION_TYPE_ClfsMgmtLogUnpinnedNotification:
_CLFS_MGMT_NOTIFICATION_TYPE = 2;
pub const _CLFS_MGMT_NOTIFICATION_TYPE_ClfsMgmtLogWriteNotification: _CLFS_MGMT_NOTIFICATION_TYPE =
    3;
pub type _CLFS_MGMT_NOTIFICATION_TYPE = core::ffi::c_int;
pub use self::_CLFS_MGMT_NOTIFICATION_TYPE as CLFS_MGMT_NOTIFICATION_TYPE;
pub type PCLFS_MGMT_NOTIFICATION_TYPE = *mut _CLFS_MGMT_NOTIFICATION_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLFS_MGMT_NOTIFICATION {
    pub Notification: CLFS_MGMT_NOTIFICATION_TYPE,
    pub Lsn: CLFS_LSN,
    pub LogIsPinned: USHORT,
}
pub type CLFS_MGMT_NOTIFICATION = _CLFS_MGMT_NOTIFICATION;
pub type PCLFS_MGMT_NOTIFICATION = *mut _CLFS_MGMT_NOTIFICATION;
pub type PCLFS_CLIENT_ADVANCE_TAIL_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        LogFile: PLOG_FILE_OBJECT,
        TargetLsn: PCLFS_LSN,
        ClientData: PVOID,
    ) -> NTSTATUS,
>;
pub type PCLFS_CLIENT_LFF_HANDLER_COMPLETE_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        LogFile: PLOG_FILE_OBJECT,
        OperationStatus: NTSTATUS,
        LogIsPinned: BOOLEAN,
        ClientData: PVOID,
    ),
>;
pub type PCLFS_CLIENT_LOG_UNPINNED_CALLBACK =
::core::option::Option<unsafe extern "C" fn(LogFile: PLOG_FILE_OBJECT, ClientData: PVOID)>;
pub type PCLFS_SET_LOG_SIZE_COMPLETE_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(LogFile: PLOG_FILE_OBJECT, OperationStatus: NTSTATUS, ClientData: PVOID),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLFS_MGMT_CLIENT_REGISTRATION {
    pub Version: ULONG,
    pub AdvanceTailCallback: PCLFS_CLIENT_ADVANCE_TAIL_CALLBACK,
    pub AdvanceTailCallbackData: PVOID,
    pub LogGrowthCompleteCallback: PCLFS_CLIENT_LFF_HANDLER_COMPLETE_CALLBACK,
    pub LogGrowthCompleteCallbackData: PVOID,
    pub LogUnpinnedCallback: PCLFS_CLIENT_LOG_UNPINNED_CALLBACK,
    pub LogUnpinnedCallbackData: PVOID,
}
pub type CLFS_MGMT_CLIENT_REGISTRATION = _CLFS_MGMT_CLIENT_REGISTRATION;
pub type PCLFS_MGMT_CLIENT_REGISTRATION = *mut _CLFS_MGMT_CLIENT_REGISTRATION;
pub type CLFS_MGMT_CLIENT = PVOID;
pub type PCLFS_MGMT_CLIENT = *mut PVOID;
unsafe extern "C" {
    pub fn ClfsMgmtRegisterManagedClient(
        LogFile: PLOG_FILE_OBJECT,
        RegistrationData: PCLFS_MGMT_CLIENT_REGISTRATION,
        ClientCookie: PCLFS_MGMT_CLIENT,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsMgmtDeregisterManagedClient(ClientCookie: CLFS_MGMT_CLIENT) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsMgmtTailAdvanceFailure(Client: CLFS_MGMT_CLIENT, Reason: NTSTATUS) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsMgmtHandleLogFileFull(Client: CLFS_MGMT_CLIENT) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsMgmtInstallPolicy(
        LogFile: PLOG_FILE_OBJECT,
        Policy: PCLFS_MGMT_POLICY,
        PolicyLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsMgmtQueryPolicy(
        LogFile: PLOG_FILE_OBJECT,
        PolicyType: CLFS_MGMT_POLICY_TYPE,
        Policy: PCLFS_MGMT_POLICY,
        PolicyLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsMgmtRemovePolicy(
        LogFile: PLOG_FILE_OBJECT,
        PolicyType: CLFS_MGMT_POLICY_TYPE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsMgmtSetLogFileSize(
        LogFile: PLOG_FILE_OBJECT,
        NewSizeInContainers: PULONGLONG,
        ResultingSizeInContainers: PULONGLONG,
        CompletionRoutine: PCLFS_SET_LOG_SIZE_COMPLETE_CALLBACK,
        CompletionRoutineData: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsMgmtSetLogFileSizeAsClient(
        LogFile: PLOG_FILE_OBJECT,
        ClientCookie: PCLFS_MGMT_CLIENT,
        NewSizeInContainers: PULONGLONG,
        ResultingSizeInContainers: PULONGLONG,
        CompletionRoutine: PCLFS_SET_LOG_SIZE_COMPLETE_CALLBACK,
        CompletionRoutineData: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsInitialize() -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsFinalize();
}
unsafe extern "C" {
    pub fn ClfsCreateLogFile(
        pplfoLog: PPLOG_FILE_OBJECT,
        puszLogFileName: PUNICODE_STRING,
        fDesiredAccess: ACCESS_MASK,
        dwShareMode: ULONG,
        psdLogFile: PSECURITY_DESCRIPTOR,
        fCreateDisposition: ULONG,
        fCreateOptions: ULONG,
        fFlagsAndAttributes: ULONG,
        fLogOptionFlag: ULONG,
        pvContext: PVOID,
        cbContext: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsDeleteLogByPointer(plfoLog: PLOG_FILE_OBJECT) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsDeleteLogFile(
        puszLogFileName: PUNICODE_STRING,
        pvReserved: PVOID,
        fLogOptionFlag: ULONG,
        pvContext: PVOID,
        cbContext: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsAddLogContainer(
        plfoLog: PLOG_FILE_OBJECT,
        pcbContainer: PULONGLONG,
        puszContainerPath: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsAddLogContainerSet(
        plfoLog: PLOG_FILE_OBJECT,
        cContainers: USHORT,
        pcbContainer: PULONGLONG,
        rguszContainerPath: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsRemoveLogContainer(
        plfoLog: PLOG_FILE_OBJECT,
        puszContainerPath: PUNICODE_STRING,
        fForce: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsRemoveLogContainerSet(
        plfoLog: PLOG_FILE_OBJECT,
        cContainers: USHORT,
        rgwszContainerPath: PUNICODE_STRING,
        fForce: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsSetArchiveTail(plfoLog: PLOG_FILE_OBJECT, plsnArchiveTail: PCLFS_LSN) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsSetEndOfLog(plfoLog: PLOG_FILE_OBJECT, plsnEnd: PCLFS_LSN) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsCreateScanContext(
        plfoLog: PLOG_FILE_OBJECT,
        cFromContainer: ULONG,
        cContainers: ULONG,
        eScanMode: CLFS_SCAN_MODE,
        pcxScan: PCLFS_SCAN_CONTEXT,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsScanLogContainers(
        pcxScan: PCLFS_SCAN_CONTEXT,
        eScanMode: CLFS_SCAN_MODE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsGetContainerName(
        plfoLog: PLOG_FILE_OBJECT,
        cidLogicalContainer: CLFS_CONTAINER_ID,
        puszContainerName: PUNICODE_STRING,
        pcActualLenContainerName: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsGetLogFileInformation(
        plfoLog: PLOG_FILE_OBJECT,
        pinfoBuffer: PCLFS_INFORMATION,
        pcbInfoBuffer: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsQueryLogFileInformation(
        plfoLog: PLOG_FILE_OBJECT,
        eInformationClass: CLFS_LOG_INFORMATION_CLASS,
        pinfoInputBuffer: PVOID,
        cbinfoInputBuffer: ULONG,
        pinfoBuffer: PVOID,
        pcbInfoBuffer: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsSetLogFileInformation(
        plfoLog: PLOG_FILE_OBJECT,
        eInformationClass: CLFS_LOG_INFORMATION_CLASS,
        pinfoBuffer: PVOID,
        cbBuffer: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsReadRestartArea(
        pvMarshalContext: PVOID,
        ppvRestartBuffer: *mut PVOID,
        pcbRestartBuffer: PULONG,
        plsn: PCLFS_LSN,
        ppvReadContext: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsReadPreviousRestartArea(
        pvReadContext: PVOID,
        ppvRestartBuffer: *mut PVOID,
        pcbRestartBuffer: PULONG,
        plsnRestart: PCLFS_LSN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsWriteRestartArea(
        pvMarshalContext: PVOID,
        pvRestartBuffer: PVOID,
        cbRestartBuffer: ULONG,
        plsnBase: PCLFS_LSN,
        fFlags: ULONG,
        pcbWritten: PULONG,
        plsnNext: PCLFS_LSN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsAdvanceLogBase(
        pvMarshalContext: PVOID,
        plsnBase: PCLFS_LSN,
        fFlags: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsCloseAndResetLogFile(plfoLog: PLOG_FILE_OBJECT) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsCloseLogFileObject(plfoLog: PLOG_FILE_OBJECT) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsCreateMarshallingArea(
        plfoLog: PLOG_FILE_OBJECT,
        ePoolType: POOL_TYPE,
        pfnAllocBuffer: PALLOCATE_FUNCTION,
        pfnFreeBuffer: PFREE_FUNCTION,
        cbMarshallingBuffer: ULONG,
        cMaxWriteBuffers: ULONG,
        cMaxReadBuffers: ULONG,
        ppvMarshalContext: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsCreateMarshallingAreaEx(
        plfoLog: PLOG_FILE_OBJECT,
        ePoolType: POOL_TYPE,
        pfnAllocBuffer: PALLOCATE_FUNCTION,
        pfnFreeBuffer: PFREE_FUNCTION,
        cbMarshallingBuffer: ULONG,
        cMaxWriteBuffers: ULONG,
        cMaxReadBuffers: ULONG,
        cAlignmentSize: ULONG,
        fFlags: ULONGLONG,
        ppvMarshalContext: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsDeleteMarshallingArea(pvMarshalContext: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsReserveAndAppendLog(
        pvMarshalContext: PVOID,
        rgWriteEntries: PCLFS_WRITE_ENTRY,
        cWriteEntries: ULONG,
        plsnUndoNext: PCLFS_LSN,
        plsnPrevious: PCLFS_LSN,
        cReserveRecords: ULONG,
        rgcbReservation: PLONGLONG,
        fFlags: ULONG,
        plsn: PCLFS_LSN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsReserveAndAppendLogAligned(
        pvMarshalContext: PVOID,
        rgWriteEntries: PCLFS_WRITE_ENTRY,
        cWriteEntries: ULONG,
        cbEntryAlignment: ULONG,
        plsnUndoNext: PCLFS_LSN,
        plsnPrevious: PCLFS_LSN,
        cReserveRecords: ULONG,
        rgcbReservation: PLONGLONG,
        fFlags: ULONG,
        plsn: PCLFS_LSN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsAlignReservedLog(
        pvMarshalContext: PVOID,
        cRecords: ULONG,
        rgcbReservation: *mut LONGLONG,
        pcbAlignReservation: PLONGLONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsAllocReservedLog(
        pvMarshalContext: PVOID,
        cRecords: ULONG,
        pcbAdjustment: PLONGLONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsFreeReservedLog(
        pvMarshalContext: PVOID,
        cRecords: ULONG,
        pcbAdjustment: PLONGLONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsFlushBuffers(pvMarshalContext: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsFlushToLsn(
        pvMarshalContext: PVOID,
        plsnFlush: PCLFS_LSN,
        plsnLastFlushed: PCLFS_LSN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsReadLogRecord(
        pvMarshalContext: PVOID,
        plsnFirst: PCLFS_LSN,
        peContextMode: CLFS_CONTEXT_MODE,
        ppvReadBuffer: *mut PVOID,
        pcbReadBuffer: PULONG,
        peRecordType: PCLFS_RECORD_TYPE,
        plsnUndoNext: PCLFS_LSN,
        plsnPrevious: PCLFS_LSN,
        ppvReadContext: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsReadNextLogRecord(
        pvReadContext: PVOID,
        ppvBuffer: *mut PVOID,
        pcbBuffer: PULONG,
        peRecordType: PCLFS_RECORD_TYPE,
        plsnUser: PCLFS_LSN,
        plsnUndoNext: PCLFS_LSN,
        plsnPrevious: PCLFS_LSN,
        plsnRecord: PCLFS_LSN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsTerminateReadLog(pvCursorContext: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsGetLastLsn(plfoLog: PLOG_FILE_OBJECT, plsnLast: PCLFS_LSN) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsGetIoStatistics(
        plfoLog: PLOG_FILE_OBJECT,
        pvStatsBuffer: PVOID,
        cbStatsBuffer: ULONG,
        eStatsClass: CLFS_IOSTATS_CLASS,
        pcbStatsWritten: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsLaterLsn(plsn: PCLFS_LSN) -> CLFS_LSN;
}
unsafe extern "C" {
    pub fn ClfsEarlierLsn(plsn: PCLFS_LSN) -> CLFS_LSN;
}
unsafe extern "C" {
    pub fn ClfsLsnDifference(
        plsnStart: PCLFS_LSN,
        plsnFinish: PCLFS_LSN,
        cbContainer: ULONG,
        cbMaxBlock: ULONG,
        pcbDifference: PLONGLONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ClfsValidTopLevelContext(pirpTopLevelContext: PIRP) -> BOOLEAN;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTRANSACTION {
    _unused: [u8; 0],
}
pub type KTRANSACTION = _KTRANSACTION;
pub type PKTRANSACTION = *mut _KTRANSACTION;
pub type PRKTRANSACTION = *mut _KTRANSACTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KENLISTMENT {
    _unused: [u8; 0],
}
pub type KENLISTMENT = _KENLISTMENT;
pub type PKENLISTMENT = *mut _KENLISTMENT;
pub type PRKENLISTMENT = *mut _KENLISTMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KRESOURCEMANAGER {
    _unused: [u8; 0],
}
pub type KRESOURCEMANAGER = _KRESOURCEMANAGER;
pub type PKRESOURCEMANAGER = *mut _KRESOURCEMANAGER;
pub type PRKRESOURCEMANAGER = *mut _KRESOURCEMANAGER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTM {
    _unused: [u8; 0],
}
pub type KTM = _KTM;
pub type PKTM = *mut _KTM;
pub type PRKTM = *mut _KTM;
pub type PGUID = *mut GUID;
pub type PTM_RM_NOTIFICATION = ::core::option::Option<
    unsafe extern "C" fn(
        EnlistmentObject: PKENLISTMENT,
        RMContext: PVOID,
        TransactionContext: PVOID,
        TransactionNotification: ULONG,
        TmVirtualClock: PLARGE_INTEGER,
        ArgumentLength: ULONG,
        Argument: PVOID,
    ) -> NTSTATUS,
>;
pub type KCRM_PROTOCOL_ID = GUID;
pub type PKCRM_PROTOCOL_ID = *mut GUID;
pub type PTM_PROPAGATE_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(
        PropagationCookie: PVOID,
        CallbackData: PVOID,
        PropagationStatus: NTSTATUS,
        TransactionGuid: GUID,
    ) -> NTSTATUS,
>;
unsafe extern "C" {
    pub fn TmInitializeTransactionManager(
        TransactionManager: PRKTM,
        LogFileName: PCUNICODE_STRING,
        TmId: PGUID,
        CreateOptions: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmRenameTransactionManager(
        LogFileName: PUNICODE_STRING,
        ExistingTransactionManagerGuid: LPGUID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmRecoverTransactionManager(Tm: PKTM, TargetVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmCommitTransaction(Transaction: PKTRANSACTION, Wait: BOOLEAN) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmRollbackTransaction(Transaction: PKTRANSACTION, Wait: BOOLEAN) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmCreateEnlistment(
        EnlistmentHandle: PHANDLE,
        PreviousMode: KPROCESSOR_MODE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        ResourceManager: PRKRESOURCEMANAGER,
        Transaction: PKTRANSACTION,
        CreateOptions: ULONG,
        NotificationMask: NOTIFICATION_MASK,
        EnlistmentKey: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmRecoverEnlistment(Enlistment: PKENLISTMENT, EnlistmentKey: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmPrePrepareEnlistment(
        Enlistment: PKENLISTMENT,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmPrepareEnlistment(
        Enlistment: PKENLISTMENT,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmCommitEnlistment(Enlistment: PKENLISTMENT, TmVirtualClock: PLARGE_INTEGER)
                              -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmRollbackEnlistment(
        Enlistment: PKENLISTMENT,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmPrePrepareComplete(
        Enlistment: PKENLISTMENT,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmPrepareComplete(Enlistment: PKENLISTMENT, TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmReadOnlyEnlistment(
        Enlistment: PKENLISTMENT,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmCommitComplete(Enlistment: PKENLISTMENT, TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmRollbackComplete(Enlistment: PKENLISTMENT, TmVirtualClock: PLARGE_INTEGER)
                              -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmReferenceEnlistmentKey(Enlistment: PKENLISTMENT, Key: *mut PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmDereferenceEnlistmentKey(
        Enlistment: PKENLISTMENT,
        LastReference: PBOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmSinglePhaseReject(
        Enlistment: PKENLISTMENT,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmRequestOutcomeEnlistment(
        Enlistment: PKENLISTMENT,
        TmVirtualClock: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmEnableCallbacks(
        ResourceManager: PKRESOURCEMANAGER,
        CallbackRoutine: PTM_RM_NOTIFICATION,
        RMKey: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmRecoverResourceManager(ResourceManager: PKRESOURCEMANAGER) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmPropagationComplete(
        ResourceManager: PKRESOURCEMANAGER,
        RequestCookie: ULONG,
        BufferLength: ULONG,
        Buffer: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmPropagationFailed(
        ResourceManager: PKRESOURCEMANAGER,
        RequestCookie: ULONG,
        Status: NTSTATUS,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn TmGetTransactionId(Transaction: PKTRANSACTION, TransactionId: PUOW);
}
unsafe extern "C" {
    pub fn TmIsTransactionActive(Transaction: PKTRANSACTION) -> BOOLEAN;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCW_INSTANCE {
    _unused: [u8; 0],
}
pub type PPCW_INSTANCE = *mut _PCW_INSTANCE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCW_REGISTRATION {
    _unused: [u8; 0],
}
pub type PPCW_REGISTRATION = *mut _PCW_REGISTRATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCW_BUFFER {
    _unused: [u8; 0],
}
pub type PPCW_BUFFER = *mut _PCW_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCW_COUNTER_DESCRIPTOR {
    pub Id: USHORT,
    pub StructIndex: USHORT,
    pub Offset: USHORT,
    pub Size: USHORT,
}
pub type PCW_COUNTER_DESCRIPTOR = _PCW_COUNTER_DESCRIPTOR;
pub type PPCW_COUNTER_DESCRIPTOR = *mut _PCW_COUNTER_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCW_DATA {
    pub Data: *const core::ffi::c_void,
    pub Size: ULONG,
}
pub type PCW_DATA = _PCW_DATA;
pub type PPCW_DATA = *mut _PCW_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCW_COUNTER_INFORMATION {
    pub CounterMask: ULONG64,
    pub InstanceMask: PCUNICODE_STRING,
}
pub type PCW_COUNTER_INFORMATION = _PCW_COUNTER_INFORMATION;
pub type PPCW_COUNTER_INFORMATION = *mut _PCW_COUNTER_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCW_MASK_INFORMATION {
    pub CounterMask: ULONG64,
    pub InstanceMask: PCUNICODE_STRING,
    pub InstanceId: ULONG,
    pub CollectMultiple: BOOLEAN,
    pub Buffer: PPCW_BUFFER,
    pub CancelEvent: PKEVENT,
}
pub type PCW_MASK_INFORMATION = _PCW_MASK_INFORMATION;
pub type PPCW_MASK_INFORMATION = *mut _PCW_MASK_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCW_CALLBACK_INFORMATION {
    pub AddCounter: PCW_COUNTER_INFORMATION,
    pub RemoveCounter: PCW_COUNTER_INFORMATION,
    pub EnumerateInstances: PCW_MASK_INFORMATION,
    pub CollectData: PCW_MASK_INFORMATION,
}
pub type PCW_CALLBACK_INFORMATION = _PCW_CALLBACK_INFORMATION;
pub type PPCW_CALLBACK_INFORMATION = *mut _PCW_CALLBACK_INFORMATION;
pub const _PCW_CALLBACK_TYPE_PcwCallbackAddCounter: _PCW_CALLBACK_TYPE = 0;
pub const _PCW_CALLBACK_TYPE_PcwCallbackRemoveCounter: _PCW_CALLBACK_TYPE = 1;
pub const _PCW_CALLBACK_TYPE_PcwCallbackEnumerateInstances: _PCW_CALLBACK_TYPE = 2;
pub const _PCW_CALLBACK_TYPE_PcwCallbackCollectData: _PCW_CALLBACK_TYPE = 3;
pub type _PCW_CALLBACK_TYPE = core::ffi::c_int;
pub use self::_PCW_CALLBACK_TYPE as PCW_CALLBACK_TYPE;
pub type PPCW_CALLBACK_TYPE = *mut _PCW_CALLBACK_TYPE;
pub type PPCW_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: PCW_CALLBACK_TYPE,
        arg2: PPCW_CALLBACK_INFORMATION,
        arg3: PVOID,
    ) -> NTSTATUS,
>;
pub const PCW_REGISTRATION_FLAGS_PcwRegistrationNone: PCW_REGISTRATION_FLAGS = 0;
pub const PCW_REGISTRATION_FLAGS_PcwRegistrationSiloNeutral: PCW_REGISTRATION_FLAGS = 1;
pub type PCW_REGISTRATION_FLAGS = core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCW_REGISTRATION_INFORMATION {
    pub Version: ULONG,
    pub Name: PCUNICODE_STRING,
    pub CounterCount: ULONG,
    pub Counters: PPCW_COUNTER_DESCRIPTOR,
    pub Callback: PPCW_CALLBACK,
    pub CallbackContext: PVOID,
    pub Flags: PCW_REGISTRATION_FLAGS,
}
pub type PCW_REGISTRATION_INFORMATION = _PCW_REGISTRATION_INFORMATION;
pub type PPCW_REGISTRATION_INFORMATION = *mut _PCW_REGISTRATION_INFORMATION;
unsafe extern "C" {
    pub fn PcwRegister(
        Registration: *mut PPCW_REGISTRATION,
        Info: PPCW_REGISTRATION_INFORMATION,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PcwUnregister(Registration: PPCW_REGISTRATION);
}
unsafe extern "C" {
    pub fn PcwCreateInstance(
        Instance: *mut PPCW_INSTANCE,
        Registration: PPCW_REGISTRATION,
        Name: PCUNICODE_STRING,
        Count: ULONG,
        Data: PPCW_DATA,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PcwCloseInstance(Instance: PPCW_INSTANCE);
}
unsafe extern "C" {
    pub fn PcwAddInstance(
        Buffer: PPCW_BUFFER,
        Name: PCUNICODE_STRING,
        Id: ULONG,
        Count: ULONG,
        Data: PPCW_DATA,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn VslCreateSecureSection(
        Handle: PHANDLE,
        TargetProcess: PEPROCESS,
        Mdl: PMDL,
        DevicePageProtection: ULONG,
        Attributes: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn VslDeleteSecureSection(GlobalHandle: HANDLE) -> NTSTATUS;
}
pub const _DRIVER_RUNTIME_INIT_FLAGS_DrvRtPoolNxOptIn: _DRIVER_RUNTIME_INIT_FLAGS = 1;
pub const _DRIVER_RUNTIME_INIT_FLAGS_LastDrvRtFlag: _DRIVER_RUNTIME_INIT_FLAGS = 2;
pub type _DRIVER_RUNTIME_INIT_FLAGS = core::ffi::c_int;
pub use self::_DRIVER_RUNTIME_INIT_FLAGS as DRIVER_RUNTIME_INIT_FLAGS;
pub type PDRIVER_RUNTIME_INIT_FLAGS = *mut _DRIVER_RUNTIME_INIT_FLAGS;
pub type PCDRIVER_RUNTIME_INIT_FLAGS = *const _DRIVER_RUNTIME_INIT_FLAGS;
unsafe extern "C" {
    pub static mut CmKeyObjectType: *mut POBJECT_TYPE;
}
unsafe extern "C" {
    pub static mut IoFileObjectType: *mut POBJECT_TYPE;
}
unsafe extern "C" {
    pub static mut ExEventObjectType: *mut POBJECT_TYPE;
}
unsafe extern "C" {
    pub static mut ExSemaphoreObjectType: *mut POBJECT_TYPE;
}
unsafe extern "C" {
    pub static mut TmTransactionManagerObjectType: *mut POBJECT_TYPE;
}
unsafe extern "C" {
    pub static mut TmResourceManagerObjectType: *mut POBJECT_TYPE;
}
unsafe extern "C" {
    pub static mut TmEnlistmentObjectType: *mut POBJECT_TYPE;
}
unsafe extern "C" {
    pub static mut TmTransactionObjectType: *mut POBJECT_TYPE;
}
unsafe extern "C" {
    pub static mut PsProcessType: *mut POBJECT_TYPE;
}
unsafe extern "C" {
    pub static mut PsThreadType: *mut POBJECT_TYPE;
}
unsafe extern "C" {
    pub static mut PsJobType: *mut POBJECT_TYPE;
}
unsafe extern "C" {
    pub static mut SeTokenObjectType: *mut POBJECT_TYPE;
}
unsafe extern "C" {
    pub static mut ExDesktopObjectType: *mut POBJECT_TYPE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BUS_HANDLER {
    _unused: [u8; 0],
}
pub type PBUS_HANDLER = *mut _BUS_HANDLER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_HANDLER_OBJECT {
    _unused: [u8; 0],
}
pub type PDEVICE_HANDLER_OBJECT = *mut _DEVICE_HANDLER_OBJECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EJOB {
    _unused: [u8; 0],
}
pub type PEJOB = *mut _EJOB;
pub type PESILO = *mut _EJOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SILO_MONITOR {
    _unused: [u8; 0],
}
pub type PSILO_MONITOR = *mut _SILO_MONITOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PEB {
    _unused: [u8; 0],
}
pub type PPEB = *mut _PEB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_NT_HEADERS {
    _unused: [u8; 0],
}
pub type PIMAGE_NT_HEADERS32 = *mut _IMAGE_NT_HEADERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_NT_HEADERS64 {
    _unused: [u8; 0],
}
pub type PIMAGE_NT_HEADERS64 = *mut _IMAGE_NT_HEADERS64;
pub type PIMAGE_NT_HEADERS = PIMAGE_NT_HEADERS64;
unsafe extern "C" {
    pub static mut PsSiloContextPagedType: *mut POBJECT_TYPE;
}
unsafe extern "C" {
    pub static mut PsSiloContextNonPagedType: *mut POBJECT_TYPE;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _CONTEXT {
    pub P1Home: ULONG64,
    pub P2Home: ULONG64,
    pub P3Home: ULONG64,
    pub P4Home: ULONG64,
    pub P5Home: ULONG64,
    pub P6Home: ULONG64,
    pub ContextFlags: ULONG,
    pub MxCsr: ULONG,
    pub SegCs: USHORT,
    pub SegDs: USHORT,
    pub SegEs: USHORT,
    pub SegFs: USHORT,
    pub SegGs: USHORT,
    pub SegSs: USHORT,
    pub EFlags: ULONG,
    pub Dr0: ULONG64,
    pub Dr1: ULONG64,
    pub Dr2: ULONG64,
    pub Dr3: ULONG64,
    pub Dr6: ULONG64,
    pub Dr7: ULONG64,
    pub Rax: ULONG64,
    pub Rcx: ULONG64,
    pub Rdx: ULONG64,
    pub Rbx: ULONG64,
    pub Rsp: ULONG64,
    pub Rbp: ULONG64,
    pub Rsi: ULONG64,
    pub Rdi: ULONG64,
    pub R8: ULONG64,
    pub R9: ULONG64,
    pub R10: ULONG64,
    pub R11: ULONG64,
    pub R12: ULONG64,
    pub R13: ULONG64,
    pub R14: ULONG64,
    pub R15: ULONG64,
    pub Rip: ULONG64,
    pub __bindgen_anon_1: _CONTEXT__bindgen_ty_1,
    pub VectorRegister: [M128A; 26usize],
    pub VectorControl: ULONG64,
    pub DebugControl: ULONG64,
    pub LastBranchToRip: ULONG64,
    pub LastBranchFromRip: ULONG64,
    pub LastExceptionToRip: ULONG64,
    pub LastExceptionFromRip: ULONG64,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _CONTEXT__bindgen_ty_1 {
    pub FltSave: XMM_SAVE_AREA32,
    pub __bindgen_anon_1: _CONTEXT__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    pub Header: [M128A; 2usize],
    pub Legacy: [M128A; 8usize],
    pub Xmm0: M128A,
    pub Xmm1: M128A,
    pub Xmm2: M128A,
    pub Xmm3: M128A,
    pub Xmm4: M128A,
    pub Xmm5: M128A,
    pub Xmm6: M128A,
    pub Xmm7: M128A,
    pub Xmm8: M128A,
    pub Xmm9: M128A,
    pub Xmm10: M128A,
    pub Xmm11: M128A,
    pub Xmm12: M128A,
    pub Xmm13: M128A,
    pub Xmm14: M128A,
    pub Xmm15: M128A,
}
pub type CONTEXT = _CONTEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ARM64_NT_NEON128 {
    pub __bindgen_anon_1: _ARM64_NT_NEON128__bindgen_ty_1,
    pub D: [f64; 2usize],
    pub S: [f32; 4usize],
    pub H: [USHORT; 8usize],
    pub B: [UCHAR; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ARM64_NT_NEON128__bindgen_ty_1 {
    pub Low: ULONGLONG,
    pub High: LONGLONG,
}
pub type ARM64_NT_NEON128 = _ARM64_NT_NEON128;
pub type PARM64_NT_NEON128 = *mut _ARM64_NT_NEON128;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _ARM64_NT_CONTEXT {
    pub ContextFlags: ULONG,
    pub Cpsr: ULONG,
    pub __bindgen_anon_1: _ARM64_NT_CONTEXT__bindgen_ty_1,
    pub Sp: ULONG64,
    pub Pc: ULONG64,
    pub V: [ARM64_NT_NEON128; 32usize],
    pub Fpcr: ULONG,
    pub Fpsr: ULONG,
    pub Bcr: [ULONG; 8usize],
    pub Bvr: [ULONG64; 8usize],
    pub Wcr: [ULONG; 2usize],
    pub Wvr: [ULONG64; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ARM64_NT_CONTEXT__bindgen_ty_1 {
    pub __bindgen_anon_1: _ARM64_NT_CONTEXT__bindgen_ty_1__bindgen_ty_1,
    pub X: [ULONG64; 31usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ARM64_NT_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    pub X0: ULONG64,
    pub X1: ULONG64,
    pub X2: ULONG64,
    pub X3: ULONG64,
    pub X4: ULONG64,
    pub X5: ULONG64,
    pub X6: ULONG64,
    pub X7: ULONG64,
    pub X8: ULONG64,
    pub X9: ULONG64,
    pub X10: ULONG64,
    pub X11: ULONG64,
    pub X12: ULONG64,
    pub X13: ULONG64,
    pub X14: ULONG64,
    pub X15: ULONG64,
    pub X16: ULONG64,
    pub X17: ULONG64,
    pub X18: ULONG64,
    pub X19: ULONG64,
    pub X20: ULONG64,
    pub X21: ULONG64,
    pub X22: ULONG64,
    pub X23: ULONG64,
    pub X24: ULONG64,
    pub X25: ULONG64,
    pub X26: ULONG64,
    pub X27: ULONG64,
    pub X28: ULONG64,
    pub Fp: ULONG64,
    pub Lr: ULONG64,
}
pub type ARM64_NT_CONTEXT = _ARM64_NT_CONTEXT;
pub type PARM64_NT_CONTEXT = *mut _ARM64_NT_CONTEXT;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _ARM64EC_NT_CONTEXT {
    pub __bindgen_anon_1: _ARM64EC_NT_CONTEXT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ARM64EC_NT_CONTEXT__bindgen_ty_1 {
    pub __bindgen_anon_1: _ARM64EC_NT_CONTEXT__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ARM64EC_NT_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    pub AMD64_P1Home: ULONG64,
    pub AMD64_P2Home: ULONG64,
    pub AMD64_P3Home: ULONG64,
    pub AMD64_P4Home: ULONG64,
    pub AMD64_P5Home: ULONG64,
    pub AMD64_P6Home: ULONG64,
    pub ContextFlags: ULONG,
    pub AMD64_MxCsr_copy: ULONG,
    pub AMD64_SegCs: USHORT,
    pub AMD64_SegDs: USHORT,
    pub AMD64_SegEs: USHORT,
    pub AMD64_SegFs: USHORT,
    pub AMD64_SegGs: USHORT,
    pub AMD64_SegSs: USHORT,
    pub AMD64_EFlags: ULONG,
    pub AMD64_Dr0: ULONG64,
    pub AMD64_Dr1: ULONG64,
    pub AMD64_Dr2: ULONG64,
    pub AMD64_Dr3: ULONG64,
    pub AMD64_Dr6: ULONG64,
    pub AMD64_Dr7: ULONG64,
    pub X8: ULONG64,
    pub X0: ULONG64,
    pub X1: ULONG64,
    pub X27: ULONG64,
    pub Sp: ULONG64,
    pub Fp: ULONG64,
    pub X25: ULONG64,
    pub X26: ULONG64,
    pub X2: ULONG64,
    pub X3: ULONG64,
    pub X4: ULONG64,
    pub X5: ULONG64,
    pub X19: ULONG64,
    pub X20: ULONG64,
    pub X21: ULONG64,
    pub X22: ULONG64,
    pub Pc: ULONG64,
    pub __bindgen_anon_1: _ARM64EC_NT_CONTEXT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub AMD64_VectorRegister: [ARM64_NT_NEON128; 26usize],
    pub AMD64_VectorControl: ULONG64,
    pub AMD64_DebugControl: ULONG64,
    pub AMD64_LastBranchToRip: ULONG64,
    pub AMD64_LastBranchFromRip: ULONG64,
    pub AMD64_LastExceptionToRip: ULONG64,
    pub AMD64_LastExceptionFromRip: ULONG64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ARM64EC_NT_CONTEXT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub AMD64_ControlWord: USHORT,
    pub AMD64_StatusWord: USHORT,
    pub AMD64_TagWord: UCHAR,
    pub AMD64_Reserved1: UCHAR,
    pub AMD64_ErrorOpcode: USHORT,
    pub AMD64_ErrorOffset: ULONG,
    pub AMD64_ErrorSelector: USHORT,
    pub AMD64_Reserved2: USHORT,
    pub AMD64_DataOffset: ULONG,
    pub AMD64_DataSelector: USHORT,
    pub AMD64_Reserved3: USHORT,
    pub AMD64_MxCsr: ULONG,
    pub AMD64_MxCsr_Mask: ULONG,
    pub Lr: ULONG64,
    pub X16_0: USHORT,
    pub AMD64_St0_Reserved1: USHORT,
    pub AMD64_St0_Reserved2: ULONG,
    pub X6: ULONG64,
    pub X16_1: USHORT,
    pub AMD64_St1_Reserved1: USHORT,
    pub AMD64_St1_Reserved2: ULONG,
    pub X7: ULONG64,
    pub X16_2: USHORT,
    pub AMD64_St2_Reserved1: USHORT,
    pub AMD64_St2_Reserved2: ULONG,
    pub X9: ULONG64,
    pub X16_3: USHORT,
    pub AMD64_St3_Reserved1: USHORT,
    pub AMD64_St3_Reserved2: ULONG,
    pub X10: ULONG64,
    pub X17_0: USHORT,
    pub AMD64_St4_Reserved1: USHORT,
    pub AMD64_St4_Reserved2: ULONG,
    pub X11: ULONG64,
    pub X17_1: USHORT,
    pub AMD64_St5_Reserved1: USHORT,
    pub AMD64_St5_Reserved2: ULONG,
    pub X12: ULONG64,
    pub X17_2: USHORT,
    pub AMD64_St6_Reserved1: USHORT,
    pub AMD64_St6_Reserved2: ULONG,
    pub X15: ULONG64,
    pub X17_3: USHORT,
    pub AMD64_St7_Reserved1: USHORT,
    pub AMD64_St7_Reserved2: ULONG,
    pub V: [ARM64_NT_NEON128; 16usize],
    pub AMD64_XSAVE_FORMAT_Reserved4: [UCHAR; 96usize],
}
pub type ARM64EC_NT_CONTEXT = _ARM64EC_NT_CONTEXT;
pub type PARM64EC_NT_CONTEXT = *mut _ARM64EC_NT_CONTEXT;
pub const WELL_KNOWN_SID_TYPE_WinNullSid: WELL_KNOWN_SID_TYPE = 0;
pub const WELL_KNOWN_SID_TYPE_WinWorldSid: WELL_KNOWN_SID_TYPE = 1;
pub const WELL_KNOWN_SID_TYPE_WinLocalSid: WELL_KNOWN_SID_TYPE = 2;
pub const WELL_KNOWN_SID_TYPE_WinCreatorOwnerSid: WELL_KNOWN_SID_TYPE = 3;
pub const WELL_KNOWN_SID_TYPE_WinCreatorGroupSid: WELL_KNOWN_SID_TYPE = 4;
pub const WELL_KNOWN_SID_TYPE_WinCreatorOwnerServerSid: WELL_KNOWN_SID_TYPE = 5;
pub const WELL_KNOWN_SID_TYPE_WinCreatorGroupServerSid: WELL_KNOWN_SID_TYPE = 6;
pub const WELL_KNOWN_SID_TYPE_WinNtAuthoritySid: WELL_KNOWN_SID_TYPE = 7;
pub const WELL_KNOWN_SID_TYPE_WinDialupSid: WELL_KNOWN_SID_TYPE = 8;
pub const WELL_KNOWN_SID_TYPE_WinNetworkSid: WELL_KNOWN_SID_TYPE = 9;
pub const WELL_KNOWN_SID_TYPE_WinBatchSid: WELL_KNOWN_SID_TYPE = 10;
pub const WELL_KNOWN_SID_TYPE_WinInteractiveSid: WELL_KNOWN_SID_TYPE = 11;
pub const WELL_KNOWN_SID_TYPE_WinServiceSid: WELL_KNOWN_SID_TYPE = 12;
pub const WELL_KNOWN_SID_TYPE_WinAnonymousSid: WELL_KNOWN_SID_TYPE = 13;
pub const WELL_KNOWN_SID_TYPE_WinProxySid: WELL_KNOWN_SID_TYPE = 14;
pub const WELL_KNOWN_SID_TYPE_WinEnterpriseControllersSid: WELL_KNOWN_SID_TYPE = 15;
pub const WELL_KNOWN_SID_TYPE_WinSelfSid: WELL_KNOWN_SID_TYPE = 16;
pub const WELL_KNOWN_SID_TYPE_WinAuthenticatedUserSid: WELL_KNOWN_SID_TYPE = 17;
pub const WELL_KNOWN_SID_TYPE_WinRestrictedCodeSid: WELL_KNOWN_SID_TYPE = 18;
pub const WELL_KNOWN_SID_TYPE_WinTerminalServerSid: WELL_KNOWN_SID_TYPE = 19;
pub const WELL_KNOWN_SID_TYPE_WinRemoteLogonIdSid: WELL_KNOWN_SID_TYPE = 20;
pub const WELL_KNOWN_SID_TYPE_WinLogonIdsSid: WELL_KNOWN_SID_TYPE = 21;
pub const WELL_KNOWN_SID_TYPE_WinLocalSystemSid: WELL_KNOWN_SID_TYPE = 22;
pub const WELL_KNOWN_SID_TYPE_WinLocalServiceSid: WELL_KNOWN_SID_TYPE = 23;
pub const WELL_KNOWN_SID_TYPE_WinNetworkServiceSid: WELL_KNOWN_SID_TYPE = 24;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinDomainSid: WELL_KNOWN_SID_TYPE = 25;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinAdministratorsSid: WELL_KNOWN_SID_TYPE = 26;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinUsersSid: WELL_KNOWN_SID_TYPE = 27;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinGuestsSid: WELL_KNOWN_SID_TYPE = 28;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinPowerUsersSid: WELL_KNOWN_SID_TYPE = 29;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinAccountOperatorsSid: WELL_KNOWN_SID_TYPE = 30;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinSystemOperatorsSid: WELL_KNOWN_SID_TYPE = 31;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinPrintOperatorsSid: WELL_KNOWN_SID_TYPE = 32;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinBackupOperatorsSid: WELL_KNOWN_SID_TYPE = 33;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinReplicatorSid: WELL_KNOWN_SID_TYPE = 34;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinPreWindows2000CompatibleAccessSid: WELL_KNOWN_SID_TYPE = 35;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinRemoteDesktopUsersSid: WELL_KNOWN_SID_TYPE = 36;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinNetworkConfigurationOperatorsSid: WELL_KNOWN_SID_TYPE = 37;
pub const WELL_KNOWN_SID_TYPE_WinAccountAdministratorSid: WELL_KNOWN_SID_TYPE = 38;
pub const WELL_KNOWN_SID_TYPE_WinAccountGuestSid: WELL_KNOWN_SID_TYPE = 39;
pub const WELL_KNOWN_SID_TYPE_WinAccountKrbtgtSid: WELL_KNOWN_SID_TYPE = 40;
pub const WELL_KNOWN_SID_TYPE_WinAccountDomainAdminsSid: WELL_KNOWN_SID_TYPE = 41;
pub const WELL_KNOWN_SID_TYPE_WinAccountDomainUsersSid: WELL_KNOWN_SID_TYPE = 42;
pub const WELL_KNOWN_SID_TYPE_WinAccountDomainGuestsSid: WELL_KNOWN_SID_TYPE = 43;
pub const WELL_KNOWN_SID_TYPE_WinAccountComputersSid: WELL_KNOWN_SID_TYPE = 44;
pub const WELL_KNOWN_SID_TYPE_WinAccountControllersSid: WELL_KNOWN_SID_TYPE = 45;
pub const WELL_KNOWN_SID_TYPE_WinAccountCertAdminsSid: WELL_KNOWN_SID_TYPE = 46;
pub const WELL_KNOWN_SID_TYPE_WinAccountSchemaAdminsSid: WELL_KNOWN_SID_TYPE = 47;
pub const WELL_KNOWN_SID_TYPE_WinAccountEnterpriseAdminsSid: WELL_KNOWN_SID_TYPE = 48;
pub const WELL_KNOWN_SID_TYPE_WinAccountPolicyAdminsSid: WELL_KNOWN_SID_TYPE = 49;
pub const WELL_KNOWN_SID_TYPE_WinAccountRasAndIasServersSid: WELL_KNOWN_SID_TYPE = 50;
pub const WELL_KNOWN_SID_TYPE_WinNTLMAuthenticationSid: WELL_KNOWN_SID_TYPE = 51;
pub const WELL_KNOWN_SID_TYPE_WinDigestAuthenticationSid: WELL_KNOWN_SID_TYPE = 52;
pub const WELL_KNOWN_SID_TYPE_WinSChannelAuthenticationSid: WELL_KNOWN_SID_TYPE = 53;
pub const WELL_KNOWN_SID_TYPE_WinThisOrganizationSid: WELL_KNOWN_SID_TYPE = 54;
pub const WELL_KNOWN_SID_TYPE_WinOtherOrganizationSid: WELL_KNOWN_SID_TYPE = 55;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinIncomingForestTrustBuildersSid: WELL_KNOWN_SID_TYPE = 56;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinPerfMonitoringUsersSid: WELL_KNOWN_SID_TYPE = 57;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinPerfLoggingUsersSid: WELL_KNOWN_SID_TYPE = 58;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinAuthorizationAccessSid: WELL_KNOWN_SID_TYPE = 59;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinTerminalServerLicenseServersSid: WELL_KNOWN_SID_TYPE = 60;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinDCOMUsersSid: WELL_KNOWN_SID_TYPE = 61;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinIUsersSid: WELL_KNOWN_SID_TYPE = 62;
pub const WELL_KNOWN_SID_TYPE_WinIUserSid: WELL_KNOWN_SID_TYPE = 63;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinCryptoOperatorsSid: WELL_KNOWN_SID_TYPE = 64;
pub const WELL_KNOWN_SID_TYPE_WinUntrustedLabelSid: WELL_KNOWN_SID_TYPE = 65;
pub const WELL_KNOWN_SID_TYPE_WinLowLabelSid: WELL_KNOWN_SID_TYPE = 66;
pub const WELL_KNOWN_SID_TYPE_WinMediumLabelSid: WELL_KNOWN_SID_TYPE = 67;
pub const WELL_KNOWN_SID_TYPE_WinHighLabelSid: WELL_KNOWN_SID_TYPE = 68;
pub const WELL_KNOWN_SID_TYPE_WinSystemLabelSid: WELL_KNOWN_SID_TYPE = 69;
pub const WELL_KNOWN_SID_TYPE_WinWriteRestrictedCodeSid: WELL_KNOWN_SID_TYPE = 70;
pub const WELL_KNOWN_SID_TYPE_WinCreatorOwnerRightsSid: WELL_KNOWN_SID_TYPE = 71;
pub const WELL_KNOWN_SID_TYPE_WinCacheablePrincipalsGroupSid: WELL_KNOWN_SID_TYPE = 72;
pub const WELL_KNOWN_SID_TYPE_WinNonCacheablePrincipalsGroupSid: WELL_KNOWN_SID_TYPE = 73;
pub const WELL_KNOWN_SID_TYPE_WinEnterpriseReadonlyControllersSid: WELL_KNOWN_SID_TYPE = 74;
pub const WELL_KNOWN_SID_TYPE_WinAccountReadonlyControllersSid: WELL_KNOWN_SID_TYPE = 75;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinEventLogReadersGroup: WELL_KNOWN_SID_TYPE = 76;
pub const WELL_KNOWN_SID_TYPE_WinNewEnterpriseReadonlyControllersSid: WELL_KNOWN_SID_TYPE = 77;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinCertSvcDComAccessGroup: WELL_KNOWN_SID_TYPE = 78;
pub const WELL_KNOWN_SID_TYPE_WinMediumPlusLabelSid: WELL_KNOWN_SID_TYPE = 79;
pub const WELL_KNOWN_SID_TYPE_WinLocalLogonSid: WELL_KNOWN_SID_TYPE = 80;
pub const WELL_KNOWN_SID_TYPE_WinConsoleLogonSid: WELL_KNOWN_SID_TYPE = 81;
pub const WELL_KNOWN_SID_TYPE_WinThisOrganizationCertificateSid: WELL_KNOWN_SID_TYPE = 82;
pub const WELL_KNOWN_SID_TYPE_WinApplicationPackageAuthoritySid: WELL_KNOWN_SID_TYPE = 83;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinAnyPackageSid: WELL_KNOWN_SID_TYPE = 84;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityInternetClientSid: WELL_KNOWN_SID_TYPE = 85;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityInternetClientServerSid: WELL_KNOWN_SID_TYPE = 86;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityPrivateNetworkClientServerSid: WELL_KNOWN_SID_TYPE = 87;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityPicturesLibrarySid: WELL_KNOWN_SID_TYPE = 88;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityVideosLibrarySid: WELL_KNOWN_SID_TYPE = 89;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityMusicLibrarySid: WELL_KNOWN_SID_TYPE = 90;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityDocumentsLibrarySid: WELL_KNOWN_SID_TYPE = 91;
pub const WELL_KNOWN_SID_TYPE_WinCapabilitySharedUserCertificatesSid: WELL_KNOWN_SID_TYPE = 92;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityEnterpriseAuthenticationSid: WELL_KNOWN_SID_TYPE = 93;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityRemovableStorageSid: WELL_KNOWN_SID_TYPE = 94;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinRDSRemoteAccessServersSid: WELL_KNOWN_SID_TYPE = 95;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinRDSEndpointServersSid: WELL_KNOWN_SID_TYPE = 96;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinRDSManagementServersSid: WELL_KNOWN_SID_TYPE = 97;
pub const WELL_KNOWN_SID_TYPE_WinUserModeDriversSid: WELL_KNOWN_SID_TYPE = 98;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinHyperVAdminsSid: WELL_KNOWN_SID_TYPE = 99;
pub const WELL_KNOWN_SID_TYPE_WinAccountCloneableControllersSid: WELL_KNOWN_SID_TYPE = 100;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinAccessControlAssistanceOperatorsSid: WELL_KNOWN_SID_TYPE =
    101;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinRemoteManagementUsersSid: WELL_KNOWN_SID_TYPE = 102;
pub const WELL_KNOWN_SID_TYPE_WinAuthenticationAuthorityAssertedSid: WELL_KNOWN_SID_TYPE = 103;
pub const WELL_KNOWN_SID_TYPE_WinAuthenticationServiceAssertedSid: WELL_KNOWN_SID_TYPE = 104;
pub const WELL_KNOWN_SID_TYPE_WinLocalAccountSid: WELL_KNOWN_SID_TYPE = 105;
pub const WELL_KNOWN_SID_TYPE_WinLocalAccountAndAdministratorSid: WELL_KNOWN_SID_TYPE = 106;
pub const WELL_KNOWN_SID_TYPE_WinAccountProtectedUsersSid: WELL_KNOWN_SID_TYPE = 107;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityAppointmentsSid: WELL_KNOWN_SID_TYPE = 108;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityContactsSid: WELL_KNOWN_SID_TYPE = 109;
pub const WELL_KNOWN_SID_TYPE_WinAccountDefaultSystemManagedSid: WELL_KNOWN_SID_TYPE = 110;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinDefaultSystemManagedGroupSid: WELL_KNOWN_SID_TYPE = 111;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinStorageReplicaAdminsSid: WELL_KNOWN_SID_TYPE = 112;
pub const WELL_KNOWN_SID_TYPE_WinAccountKeyAdminsSid: WELL_KNOWN_SID_TYPE = 113;
pub const WELL_KNOWN_SID_TYPE_WinAccountEnterpriseKeyAdminsSid: WELL_KNOWN_SID_TYPE = 114;
pub const WELL_KNOWN_SID_TYPE_WinAuthenticationKeyTrustSid: WELL_KNOWN_SID_TYPE = 115;
pub const WELL_KNOWN_SID_TYPE_WinAuthenticationKeyPropertyMFASid: WELL_KNOWN_SID_TYPE = 116;
pub const WELL_KNOWN_SID_TYPE_WinAuthenticationKeyPropertyAttestationSid: WELL_KNOWN_SID_TYPE = 117;
pub const WELL_KNOWN_SID_TYPE_WinAuthenticationFreshKeyAuthSid: WELL_KNOWN_SID_TYPE = 118;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinDeviceOwnersSid: WELL_KNOWN_SID_TYPE = 119;
pub type WELL_KNOWN_SID_TYPE = core::ffi::c_int;
pub type SE_SIGNING_LEVEL = UCHAR;
pub type PSE_SIGNING_LEVEL = *mut UCHAR;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureNone: _SE_IMAGE_SIGNATURE_TYPE = 0;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureEmbedded: _SE_IMAGE_SIGNATURE_TYPE = 1;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureCache: _SE_IMAGE_SIGNATURE_TYPE = 2;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureCatalogCached: _SE_IMAGE_SIGNATURE_TYPE = 3;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureCatalogNotCached: _SE_IMAGE_SIGNATURE_TYPE = 4;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureCatalogHint: _SE_IMAGE_SIGNATURE_TYPE = 5;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignaturePackageCatalog: _SE_IMAGE_SIGNATURE_TYPE = 6;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignaturePplMitigated: _SE_IMAGE_SIGNATURE_TYPE = 7;
pub type _SE_IMAGE_SIGNATURE_TYPE = core::ffi::c_int;
pub use self::_SE_IMAGE_SIGNATURE_TYPE as SE_IMAGE_SIGNATURE_TYPE;
pub type PSE_IMAGE_SIGNATURE_TYPE = *mut _SE_IMAGE_SIGNATURE_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_RUN_ONCE {
    pub Ptr: PVOID,
}
pub type RTL_RUN_ONCE = _RTL_RUN_ONCE;
pub type PRTL_RUN_ONCE = *mut _RTL_RUN_ONCE;
pub type PRTL_RUN_ONCE_INIT_FN = ::core::option::Option<
    unsafe extern "C" fn(arg1: PRTL_RUN_ONCE, arg2: PVOID, arg3: *mut PVOID) -> ULONG,
>;
unsafe extern "C" {
    pub fn RtlRunOnceInitialize(RunOnce: PRTL_RUN_ONCE);
}
unsafe extern "C" {
    pub fn RtlRunOnceExecuteOnce(
        RunOnce: PRTL_RUN_ONCE,
        InitFn: PRTL_RUN_ONCE_INIT_FN,
        Parameter: PVOID,
        Context: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlRunOnceBeginInitialize(
        RunOnce: PRTL_RUN_ONCE,
        Flags: ULONG,
        Context: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlRunOnceComplete(RunOnce: PRTL_RUN_ONCE, Flags: ULONG, Context: PVOID) -> NTSTATUS;
}
pub const _TABLE_SEARCH_RESULT_TableEmptyTree: _TABLE_SEARCH_RESULT = 0;
pub const _TABLE_SEARCH_RESULT_TableFoundNode: _TABLE_SEARCH_RESULT = 1;
pub const _TABLE_SEARCH_RESULT_TableInsertAsLeft: _TABLE_SEARCH_RESULT = 2;
pub const _TABLE_SEARCH_RESULT_TableInsertAsRight: _TABLE_SEARCH_RESULT = 3;
pub type _TABLE_SEARCH_RESULT = core::ffi::c_int;
pub use self::_TABLE_SEARCH_RESULT as TABLE_SEARCH_RESULT;
pub const _RTL_GENERIC_COMPARE_RESULTS_GenericLessThan: _RTL_GENERIC_COMPARE_RESULTS = 0;
pub const _RTL_GENERIC_COMPARE_RESULTS_GenericGreaterThan: _RTL_GENERIC_COMPARE_RESULTS = 1;
pub const _RTL_GENERIC_COMPARE_RESULTS_GenericEqual: _RTL_GENERIC_COMPARE_RESULTS = 2;
pub type _RTL_GENERIC_COMPARE_RESULTS = core::ffi::c_int;
pub use self::_RTL_GENERIC_COMPARE_RESULTS as RTL_GENERIC_COMPARE_RESULTS;
pub type PRTL_AVL_COMPARE_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut _RTL_AVL_TABLE,
        arg2: PVOID,
        arg3: PVOID,
    ) -> RTL_GENERIC_COMPARE_RESULTS,
>;
pub type PRTL_AVL_ALLOCATE_ROUTINE =
::core::option::Option<unsafe extern "C" fn(arg1: *mut _RTL_AVL_TABLE, arg2: CLONG) -> PVOID>;
pub type PRTL_AVL_FREE_ROUTINE =
::core::option::Option<unsafe extern "C" fn(arg1: *mut _RTL_AVL_TABLE, arg2: PVOID)>;
pub type PRTL_AVL_MATCH_FUNCTION = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut _RTL_AVL_TABLE, arg2: PVOID, arg3: PVOID) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_BALANCED_LINKS {
    pub Parent: *mut _RTL_BALANCED_LINKS,
    pub LeftChild: *mut _RTL_BALANCED_LINKS,
    pub RightChild: *mut _RTL_BALANCED_LINKS,
    pub Balance: CHAR,
    pub Reserved: [UCHAR; 3usize],
}
pub type RTL_BALANCED_LINKS = _RTL_BALANCED_LINKS;
pub type PRTL_BALANCED_LINKS = *mut RTL_BALANCED_LINKS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_AVL_TABLE {
    pub BalancedRoot: RTL_BALANCED_LINKS,
    pub OrderedPointer: PVOID,
    pub WhichOrderedElement: ULONG,
    pub NumberGenericTableElements: ULONG,
    pub DepthOfTree: ULONG,
    pub RestartKey: PRTL_BALANCED_LINKS,
    pub DeleteCount: ULONG,
    pub CompareRoutine: PRTL_AVL_COMPARE_ROUTINE,
    pub AllocateRoutine: PRTL_AVL_ALLOCATE_ROUTINE,
    pub FreeRoutine: PRTL_AVL_FREE_ROUTINE,
    pub TableContext: PVOID,
}
pub type RTL_AVL_TABLE = _RTL_AVL_TABLE;
pub type PRTL_AVL_TABLE = *mut RTL_AVL_TABLE;
unsafe extern "C" {
    pub fn RtlInitializeGenericTableAvl(
        Table: PRTL_AVL_TABLE,
        CompareRoutine: PRTL_AVL_COMPARE_ROUTINE,
        AllocateRoutine: PRTL_AVL_ALLOCATE_ROUTINE,
        FreeRoutine: PRTL_AVL_FREE_ROUTINE,
        TableContext: PVOID,
    );
}
unsafe extern "C" {
    pub fn RtlInsertElementGenericTableAvl(
        Table: PRTL_AVL_TABLE,
        Buffer: PVOID,
        BufferSize: CLONG,
        NewElement: PBOOLEAN,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn RtlInsertElementGenericTableFullAvl(
        Table: PRTL_AVL_TABLE,
        Buffer: PVOID,
        BufferSize: CLONG,
        NewElement: PBOOLEAN,
        NodeOrParent: PVOID,
        SearchResult: TABLE_SEARCH_RESULT,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn RtlDeleteElementGenericTableAvl(Table: PRTL_AVL_TABLE, Buffer: PVOID) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlDeleteElementGenericTableAvlEx(Table: PRTL_AVL_TABLE, NodeOrParent: PVOID);
}
unsafe extern "C" {
    pub fn RtlLookupElementGenericTableAvl(Table: PRTL_AVL_TABLE, Buffer: PVOID) -> PVOID;
}
unsafe extern "C" {
    pub fn RtlLookupElementGenericTableFullAvl(
        Table: PRTL_AVL_TABLE,
        Buffer: PVOID,
        NodeOrParent: *mut PVOID,
        SearchResult: *mut TABLE_SEARCH_RESULT,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn RtlEnumerateGenericTableAvl(Table: PRTL_AVL_TABLE, Restart: BOOLEAN) -> PVOID;
}
unsafe extern "C" {
    pub fn RtlEnumerateGenericTableWithoutSplayingAvl(
        Table: PRTL_AVL_TABLE,
        RestartKey: *mut PVOID,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn RtlLookupFirstMatchingElementGenericTableAvl(
        Table: PRTL_AVL_TABLE,
        Buffer: PVOID,
        RestartKey: *mut PVOID,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn RtlEnumerateGenericTableLikeADirectory(
        Table: PRTL_AVL_TABLE,
        MatchFunction: PRTL_AVL_MATCH_FUNCTION,
        MatchData: PVOID,
        NextFlag: ULONG,
        RestartKey: *mut PVOID,
        DeleteCount: PULONG,
        Buffer: PVOID,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn RtlGetElementGenericTableAvl(Table: PRTL_AVL_TABLE, I: ULONG) -> PVOID;
}
unsafe extern "C" {
    pub fn RtlNumberGenericTableElementsAvl(Table: PRTL_AVL_TABLE) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlIsGenericTableEmptyAvl(Table: PRTL_AVL_TABLE) -> BOOLEAN;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_SPLAY_LINKS {
    pub Parent: *mut _RTL_SPLAY_LINKS,
    pub LeftChild: *mut _RTL_SPLAY_LINKS,
    pub RightChild: *mut _RTL_SPLAY_LINKS,
}
pub type RTL_SPLAY_LINKS = _RTL_SPLAY_LINKS;
pub type PRTL_SPLAY_LINKS = *mut RTL_SPLAY_LINKS;
unsafe extern "C" {
    pub fn RtlSplay(Links: PRTL_SPLAY_LINKS) -> PRTL_SPLAY_LINKS;
}
unsafe extern "C" {
    pub fn RtlDelete(Links: PRTL_SPLAY_LINKS) -> PRTL_SPLAY_LINKS;
}
unsafe extern "C" {
    pub fn RtlDeleteNoSplay(Links: PRTL_SPLAY_LINKS, Root: *mut PRTL_SPLAY_LINKS);
}
unsafe extern "C" {
    pub fn RtlSubtreeSuccessor(Links: PRTL_SPLAY_LINKS) -> PRTL_SPLAY_LINKS;
}
unsafe extern "C" {
    pub fn RtlSubtreePredecessor(Links: PRTL_SPLAY_LINKS) -> PRTL_SPLAY_LINKS;
}
unsafe extern "C" {
    pub fn RtlRealSuccessor(Links: PRTL_SPLAY_LINKS) -> PRTL_SPLAY_LINKS;
}
unsafe extern "C" {
    pub fn RtlRealPredecessor(Links: PRTL_SPLAY_LINKS) -> PRTL_SPLAY_LINKS;
}
pub type PRTL_GENERIC_COMPARE_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut _RTL_GENERIC_TABLE,
        arg2: PVOID,
        arg3: PVOID,
    ) -> RTL_GENERIC_COMPARE_RESULTS,
>;
pub type PRTL_GENERIC_ALLOCATE_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut _RTL_GENERIC_TABLE, arg2: CLONG) -> PVOID,
>;
pub type PRTL_GENERIC_FREE_ROUTINE =
::core::option::Option<unsafe extern "C" fn(arg1: *mut _RTL_GENERIC_TABLE, arg2: PVOID)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_GENERIC_TABLE {
    pub TableRoot: PRTL_SPLAY_LINKS,
    pub InsertOrderList: LIST_ENTRY,
    pub OrderedPointer: PLIST_ENTRY,
    pub WhichOrderedElement: ULONG,
    pub NumberGenericTableElements: ULONG,
    pub CompareRoutine: PRTL_GENERIC_COMPARE_ROUTINE,
    pub AllocateRoutine: PRTL_GENERIC_ALLOCATE_ROUTINE,
    pub FreeRoutine: PRTL_GENERIC_FREE_ROUTINE,
    pub TableContext: PVOID,
}
pub type RTL_GENERIC_TABLE = _RTL_GENERIC_TABLE;
pub type PRTL_GENERIC_TABLE = *mut RTL_GENERIC_TABLE;
unsafe extern "C" {
    pub fn RtlInitializeGenericTable(
        Table: PRTL_GENERIC_TABLE,
        CompareRoutine: PRTL_GENERIC_COMPARE_ROUTINE,
        AllocateRoutine: PRTL_GENERIC_ALLOCATE_ROUTINE,
        FreeRoutine: PRTL_GENERIC_FREE_ROUTINE,
        TableContext: PVOID,
    );
}
unsafe extern "C" {
    pub fn RtlInsertElementGenericTable(
        Table: PRTL_GENERIC_TABLE,
        Buffer: PVOID,
        BufferSize: CLONG,
        NewElement: PBOOLEAN,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn RtlInsertElementGenericTableFull(
        Table: PRTL_GENERIC_TABLE,
        Buffer: PVOID,
        BufferSize: CLONG,
        NewElement: PBOOLEAN,
        NodeOrParent: PVOID,
        SearchResult: TABLE_SEARCH_RESULT,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn RtlDeleteElementGenericTable(Table: PRTL_GENERIC_TABLE, Buffer: PVOID) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlLookupElementGenericTable(Table: PRTL_GENERIC_TABLE, Buffer: PVOID) -> PVOID;
}
unsafe extern "C" {
    pub fn RtlLookupElementGenericTableFull(
        Table: PRTL_GENERIC_TABLE,
        Buffer: PVOID,
        NodeOrParent: *mut PVOID,
        SearchResult: *mut TABLE_SEARCH_RESULT,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn RtlEnumerateGenericTable(Table: PRTL_GENERIC_TABLE, Restart: BOOLEAN) -> PVOID;
}
unsafe extern "C" {
    pub fn RtlEnumerateGenericTableWithoutSplaying(
        Table: PRTL_GENERIC_TABLE,
        RestartKey: *mut PVOID,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn RtlGetElementGenericTable(Table: PRTL_GENERIC_TABLE, I: ULONG) -> PVOID;
}
unsafe extern "C" {
    pub fn RtlNumberGenericTableElements(Table: PRTL_GENERIC_TABLE) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlIsGenericTableEmpty(Table: PRTL_GENERIC_TABLE) -> BOOLEAN;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_DYNAMIC_HASH_TABLE_ENTRY {
    pub Linkage: LIST_ENTRY,
    pub Signature: ULONG_PTR,
}
pub type RTL_DYNAMIC_HASH_TABLE_ENTRY = _RTL_DYNAMIC_HASH_TABLE_ENTRY;
pub type PRTL_DYNAMIC_HASH_TABLE_ENTRY = *mut _RTL_DYNAMIC_HASH_TABLE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_DYNAMIC_HASH_TABLE_CONTEXT {
    pub ChainHead: PLIST_ENTRY,
    pub PrevLinkage: PLIST_ENTRY,
    pub Signature: ULONG_PTR,
}
pub type RTL_DYNAMIC_HASH_TABLE_CONTEXT = _RTL_DYNAMIC_HASH_TABLE_CONTEXT;
pub type PRTL_DYNAMIC_HASH_TABLE_CONTEXT = *mut _RTL_DYNAMIC_HASH_TABLE_CONTEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR {
    pub __bindgen_anon_1: _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR__bindgen_ty_1,
    pub ChainHead: PLIST_ENTRY,
    pub BucketIndex: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR__bindgen_ty_1 {
    pub HashEntry: RTL_DYNAMIC_HASH_TABLE_ENTRY,
    pub CurEntry: PLIST_ENTRY,
}
pub type RTL_DYNAMIC_HASH_TABLE_ENUMERATOR = _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR;
pub type PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR = *mut _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_DYNAMIC_HASH_TABLE {
    pub Flags: ULONG,
    pub Shift: ULONG,
    pub TableSize: ULONG,
    pub Pivot: ULONG,
    pub DivisorMask: ULONG,
    pub NumEntries: ULONG,
    pub NonEmptyBuckets: ULONG,
    pub NumEnumerators: ULONG,
    pub Directory: PVOID,
}
pub type RTL_DYNAMIC_HASH_TABLE = _RTL_DYNAMIC_HASH_TABLE;
pub type PRTL_DYNAMIC_HASH_TABLE = *mut _RTL_DYNAMIC_HASH_TABLE;
unsafe extern "C" {
    pub fn RtlCreateHashTable(
        HashTable: *mut PRTL_DYNAMIC_HASH_TABLE,
        Shift: ULONG,
        Flags: ULONG,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlCreateHashTableEx(
        HashTable: *mut PRTL_DYNAMIC_HASH_TABLE,
        InitialSize: ULONG,
        Shift: ULONG,
        Flags: ULONG,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlDeleteHashTable(HashTable: PRTL_DYNAMIC_HASH_TABLE);
}
unsafe extern "C" {
    pub fn RtlInsertEntryHashTable(
        HashTable: PRTL_DYNAMIC_HASH_TABLE,
        Entry: PRTL_DYNAMIC_HASH_TABLE_ENTRY,
        Signature: ULONG_PTR,
        Context: PRTL_DYNAMIC_HASH_TABLE_CONTEXT,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlRemoveEntryHashTable(
        HashTable: PRTL_DYNAMIC_HASH_TABLE,
        Entry: PRTL_DYNAMIC_HASH_TABLE_ENTRY,
        Context: PRTL_DYNAMIC_HASH_TABLE_CONTEXT,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlLookupEntryHashTable(
        HashTable: PRTL_DYNAMIC_HASH_TABLE,
        Signature: ULONG_PTR,
        Context: PRTL_DYNAMIC_HASH_TABLE_CONTEXT,
    ) -> PRTL_DYNAMIC_HASH_TABLE_ENTRY;
}
unsafe extern "C" {
    pub fn RtlGetNextEntryHashTable(
        HashTable: PRTL_DYNAMIC_HASH_TABLE,
        Context: PRTL_DYNAMIC_HASH_TABLE_CONTEXT,
    ) -> PRTL_DYNAMIC_HASH_TABLE_ENTRY;
}
unsafe extern "C" {
    pub fn RtlInitEnumerationHashTable(
        HashTable: PRTL_DYNAMIC_HASH_TABLE,
        Enumerator: PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlEnumerateEntryHashTable(
        HashTable: PRTL_DYNAMIC_HASH_TABLE,
        Enumerator: PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR,
    ) -> PRTL_DYNAMIC_HASH_TABLE_ENTRY;
}
unsafe extern "C" {
    pub fn RtlEndEnumerationHashTable(
        HashTable: PRTL_DYNAMIC_HASH_TABLE,
        Enumerator: PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR,
    );
}
unsafe extern "C" {
    pub fn RtlInitWeakEnumerationHashTable(
        HashTable: PRTL_DYNAMIC_HASH_TABLE,
        Enumerator: PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlWeaklyEnumerateEntryHashTable(
        HashTable: PRTL_DYNAMIC_HASH_TABLE,
        Enumerator: PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR,
    ) -> PRTL_DYNAMIC_HASH_TABLE_ENTRY;
}
unsafe extern "C" {
    pub fn RtlEndWeakEnumerationHashTable(
        HashTable: PRTL_DYNAMIC_HASH_TABLE,
        Enumerator: PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR,
    );
}
unsafe extern "C" {
    pub fn RtlInitStrongEnumerationHashTable(
        HashTable: PRTL_DYNAMIC_HASH_TABLE,
        Enumerator: PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlStronglyEnumerateEntryHashTable(
        HashTable: PRTL_DYNAMIC_HASH_TABLE,
        Enumerator: PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR,
    ) -> PRTL_DYNAMIC_HASH_TABLE_ENTRY;
}
unsafe extern "C" {
    pub fn RtlEndStrongEnumerationHashTable(
        HashTable: PRTL_DYNAMIC_HASH_TABLE,
        Enumerator: PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR,
    );
}
unsafe extern "C" {
    pub fn RtlExpandHashTable(HashTable: PRTL_DYNAMIC_HASH_TABLE) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlContractHashTable(HashTable: PRTL_DYNAMIC_HASH_TABLE) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn _ReturnAddress() -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn RtlGetCallersAddress(CallersAddress: *mut PVOID, CallersCaller: *mut PVOID);
}
unsafe extern "C" {
    pub fn RtlWalkFrameChain(Callers: *mut PVOID, Count: ULONG, Flags: ULONG) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlGetEnabledExtendedFeatures(FeatureMask: ULONG64) -> ULONG64;
}
unsafe extern "C" {
    pub fn RtlCharToInteger(String: PCSZ, Base: ULONG, Value: PULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlCopyString(DestinationString: PSTRING, SourceString: *const STRING);
}
unsafe extern "C" {
    pub fn RtlUpperChar(Character: CHAR) -> CHAR;
}
unsafe extern "C" {
    pub fn RtlCompareString(
        String1: *const STRING,
        String2: *const STRING,
        CaseInSensitive: BOOLEAN,
    ) -> LONG;
}
unsafe extern "C" {
    pub fn RtlEqualString(
        String1: *const STRING,
        String2: *const STRING,
        CaseInSensitive: BOOLEAN,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlUpperString(DestinationString: PSTRING, SourceString: *const STRING);
}
unsafe extern "C" {
    pub fn RtlPrefixUnicodeString(
        String1: PCUNICODE_STRING,
        String2: PCUNICODE_STRING,
        CaseInSensitive: BOOLEAN,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlSuffixUnicodeString(
        String1: PCUNICODE_STRING,
        String2: PCUNICODE_STRING,
        CaseInSensitive: BOOLEAN,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlUpcaseUnicodeString(
        DestinationString: PUNICODE_STRING,
        SourceString: PCUNICODE_STRING,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlQueryRegistryValueWithFallback(
        PrimaryHandle: HANDLE,
        FallbackHandle: HANDLE,
        ValueName: PUNICODE_STRING,
        ValueLength: ULONG,
        ValueType: PULONG,
        ValueData: PVOID,
        ResultLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlMapGenericMask(AccessMask: PACCESS_MASK, GenericMapping: *const GENERIC_MAPPING);
}
unsafe extern "C" {
    pub fn RtlVolumeDeviceToDosName(
        VolumeDeviceObject: PVOID,
        DosName: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn DbgPrompt(Prompt: PCCH, Response: PCH, Length: ULONG) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlGetProductInfo(
        OSMajorVersion: ULONG,
        OSMinorVersion: ULONG,
        SpMajorVersion: ULONG,
        SpMinorVersion: ULONG,
        ReturnedProductType: PULONG,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlGetActiveConsoleId() -> ULONG;
}
unsafe extern "C" {
    pub fn RtlGetConsoleSessionForegroundProcessId() -> ULONGLONG;
}
unsafe extern "C" {
    pub fn RtlGetSuiteMask() -> ULONG;
}
unsafe extern "C" {
    pub fn RtlIsMultiSessionSku() -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlIsStateSeparationEnabled() -> BOOLEAN;
}
pub const _STATE_LOCATION_TYPE_LocationTypeRegistry: _STATE_LOCATION_TYPE = 0;
pub const _STATE_LOCATION_TYPE_LocationTypeFileSystem: _STATE_LOCATION_TYPE = 1;
pub const _STATE_LOCATION_TYPE_LocationTypeMaximum: _STATE_LOCATION_TYPE = 2;
pub type _STATE_LOCATION_TYPE = core::ffi::c_int;
pub use self::_STATE_LOCATION_TYPE as STATE_LOCATION_TYPE;
unsafe extern "C" {
    pub fn RtlGetPersistedStateLocation(
        SourceID: PCWSTR,
        CustomValue: PCWSTR,
        DefaultPath: PCWSTR,
        StateLocationType: STATE_LOCATION_TYPE,
        TargetPath: PWCHAR,
        BufferLengthIn: ULONG,
        BufferLengthOut: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlIsApiSetImplemented(apiSetName: PCSTR) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlIsMultiUsersInSessionSku() -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlGetNtProductType(NtProductType: PNT_PRODUCT_TYPE) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlGetNtSystemRoot() -> PCWSTR;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_MEMORY_RANGE {
    pub BaseAddress: *mut core::ffi::c_void,
    pub Length: SIZE_T,
}
pub type NV_MEMORY_RANGE = _NV_MEMORY_RANGE;
pub type PNV_MEMORY_RANGE = *mut _NV_MEMORY_RANGE;
unsafe extern "C" {
    pub fn RtlGetNonVolatileToken(NvBuffer: PVOID, Size: SIZE_T, NvToken: *mut PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlFreeNonVolatileToken(NvToken: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlFlushNonVolatileMemory(
        NvToken: PVOID,
        NvBuffer: PVOID,
        Size: SIZE_T,
        Flags: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlDrainNonVolatileFlush(NvToken: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlWriteNonVolatileMemory(
        NvToken: PVOID,
        NvDestination: *mut core::ffi::c_void,
        Source: *const core::ffi::c_void,
        Size: SIZE_T,
        Flags: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlFillNonVolatileMemory(
        NvToken: PVOID,
        NvDestination: *mut core::ffi::c_void,
        Size: SIZE_T,
        Value: UCHAR,
        Flags: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlFlushNonVolatileMemoryRanges(
        NvToken: PVOID,
        NvRanges: PNV_MEMORY_RANGE,
        NumRanges: SIZE_T,
        Flags: ULONG,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CORRELATION_VECTOR {
    pub Version: CHAR,
    pub Vector: [CHAR; 129usize],
}
pub type PCORRELATION_VECTOR = *mut CORRELATION_VECTOR;
unsafe extern "C" {
    pub fn RtlInitializeCorrelationVector(
        CorrelationVector: PCORRELATION_VECTOR,
        Version: core::ffi::c_int,
        Guid: *const GUID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlIncrementCorrelationVector(CorrelationVector: PCORRELATION_VECTOR) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlExtendCorrelationVector(CorrelationVector: PCORRELATION_VECTOR) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlValidateCorrelationVector(Vector: PCORRELATION_VECTOR) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG {
    pub Size: ULONG,
    pub TriggerId: PCWSTR,
}
pub type CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG = _CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG;
pub type PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG = *mut _CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG;
unsafe extern "C" {
    pub fn RtlRaiseCustomSystemEventTrigger(
        TriggerConfig: PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlIsZeroMemory(Buffer: PVOID, Length: SIZE_T) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlNormalizeSecurityDescriptor(
        SecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
        SecurityDescriptorLength: ULONG,
        NewSecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
        NewSecurityDescriptorLength: PULONG,
        CheckOnly: BOOLEAN,
    ) -> BOOLEAN;
}
pub const _RTL_SYSTEM_GLOBAL_DATA_ID_GlobalDataIdUnknown: _RTL_SYSTEM_GLOBAL_DATA_ID = 0;
pub const _RTL_SYSTEM_GLOBAL_DATA_ID_GlobalDataIdRngSeedVersion: _RTL_SYSTEM_GLOBAL_DATA_ID = 1;
pub const _RTL_SYSTEM_GLOBAL_DATA_ID_GlobalDataIdInterruptTime: _RTL_SYSTEM_GLOBAL_DATA_ID = 2;
pub const _RTL_SYSTEM_GLOBAL_DATA_ID_GlobalDataIdTimeZoneBias: _RTL_SYSTEM_GLOBAL_DATA_ID = 3;
pub const _RTL_SYSTEM_GLOBAL_DATA_ID_GlobalDataIdImageNumberLow: _RTL_SYSTEM_GLOBAL_DATA_ID = 4;
pub const _RTL_SYSTEM_GLOBAL_DATA_ID_GlobalDataIdImageNumberHigh: _RTL_SYSTEM_GLOBAL_DATA_ID = 5;
pub const _RTL_SYSTEM_GLOBAL_DATA_ID_GlobalDataIdTimeZoneId: _RTL_SYSTEM_GLOBAL_DATA_ID = 6;
pub const _RTL_SYSTEM_GLOBAL_DATA_ID_GlobalDataIdNtMajorVersion: _RTL_SYSTEM_GLOBAL_DATA_ID = 7;
pub const _RTL_SYSTEM_GLOBAL_DATA_ID_GlobalDataIdNtMinorVersion: _RTL_SYSTEM_GLOBAL_DATA_ID = 8;
pub const _RTL_SYSTEM_GLOBAL_DATA_ID_GlobalDataIdSystemExpirationDate: _RTL_SYSTEM_GLOBAL_DATA_ID =
    9;
pub const _RTL_SYSTEM_GLOBAL_DATA_ID_GlobalDataIdKdDebuggerEnabled: _RTL_SYSTEM_GLOBAL_DATA_ID = 10;
pub const _RTL_SYSTEM_GLOBAL_DATA_ID_GlobalDataIdCyclesPerYield: _RTL_SYSTEM_GLOBAL_DATA_ID = 11;
pub const _RTL_SYSTEM_GLOBAL_DATA_ID_GlobalDataIdSafeBootMode: _RTL_SYSTEM_GLOBAL_DATA_ID = 12;
pub const _RTL_SYSTEM_GLOBAL_DATA_ID_GlobalDataIdLastSystemRITEventTickCount:
_RTL_SYSTEM_GLOBAL_DATA_ID = 13;
pub const _RTL_SYSTEM_GLOBAL_DATA_ID_GlobalDataIdConsoleSharedDataFlags:
_RTL_SYSTEM_GLOBAL_DATA_ID = 14;
pub const _RTL_SYSTEM_GLOBAL_DATA_ID_GlobalDataIdNtSystemRootDrive: _RTL_SYSTEM_GLOBAL_DATA_ID = 15;
pub const _RTL_SYSTEM_GLOBAL_DATA_ID_GlobalDataIdQpcShift: _RTL_SYSTEM_GLOBAL_DATA_ID = 16;
pub const _RTL_SYSTEM_GLOBAL_DATA_ID_GlobalDataIdQpcBypassEnabled: _RTL_SYSTEM_GLOBAL_DATA_ID = 17;
pub const _RTL_SYSTEM_GLOBAL_DATA_ID_GlobalDataIdQpcData: _RTL_SYSTEM_GLOBAL_DATA_ID = 18;
pub const _RTL_SYSTEM_GLOBAL_DATA_ID_GlobalDataIdQpcBias: _RTL_SYSTEM_GLOBAL_DATA_ID = 19;
pub type _RTL_SYSTEM_GLOBAL_DATA_ID = core::ffi::c_int;
pub use self::_RTL_SYSTEM_GLOBAL_DATA_ID as RTL_SYSTEM_GLOBAL_DATA_ID;
pub type PRTL_SYSTEM_GLOBAL_DATA_ID = *mut _RTL_SYSTEM_GLOBAL_DATA_ID;
unsafe extern "C" {
    pub fn RtlGetSystemGlobalData(
        DataId: RTL_SYSTEM_GLOBAL_DATA_ID,
        Buffer: PVOID,
        Size: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlSetSystemGlobalData(
        DataId: RTL_SYSTEM_GLOBAL_DATA_ID,
        Buffer: PVOID,
        Size: ULONG,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_ALIGNMENT_INFORMATION {
    pub AlignmentRequirement: ULONG,
}
pub type FILE_ALIGNMENT_INFORMATION = _FILE_ALIGNMENT_INFORMATION;
pub type PFILE_ALIGNMENT_INFORMATION = *mut _FILE_ALIGNMENT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_NAME_INFORMATION {
    pub FileNameLength: ULONG,
    pub FileName: [WCHAR; 1usize],
}
pub type FILE_NAME_INFORMATION = _FILE_NAME_INFORMATION;
pub type PFILE_NAME_INFORMATION = *mut _FILE_NAME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_ATTRIBUTE_TAG_INFORMATION {
    pub FileAttributes: ULONG,
    pub ReparseTag: ULONG,
}
pub type FILE_ATTRIBUTE_TAG_INFORMATION = _FILE_ATTRIBUTE_TAG_INFORMATION;
pub type PFILE_ATTRIBUTE_TAG_INFORMATION = *mut _FILE_ATTRIBUTE_TAG_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_DISPOSITION_INFORMATION {
    pub DeleteFile: BOOLEAN,
}
pub type FILE_DISPOSITION_INFORMATION = _FILE_DISPOSITION_INFORMATION;
pub type PFILE_DISPOSITION_INFORMATION = *mut _FILE_DISPOSITION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_DISPOSITION_INFORMATION_EX {
    pub Flags: ULONG,
}
pub type FILE_DISPOSITION_INFORMATION_EX = _FILE_DISPOSITION_INFORMATION_EX;
pub type PFILE_DISPOSITION_INFORMATION_EX = *mut _FILE_DISPOSITION_INFORMATION_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_END_OF_FILE_INFORMATION {
    pub EndOfFile: LARGE_INTEGER,
}
pub type FILE_END_OF_FILE_INFORMATION = _FILE_END_OF_FILE_INFORMATION;
pub type PFILE_END_OF_FILE_INFORMATION = *mut _FILE_END_OF_FILE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_VALID_DATA_LENGTH_INFORMATION {
    pub ValidDataLength: LARGE_INTEGER,
}
pub type FILE_VALID_DATA_LENGTH_INFORMATION = _FILE_VALID_DATA_LENGTH_INFORMATION;
pub type PFILE_VALID_DATA_LENGTH_INFORMATION = *mut _FILE_VALID_DATA_LENGTH_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FS_LABEL_INFORMATION {
    pub VolumeLabelLength: ULONG,
    pub VolumeLabel: [WCHAR; 1usize],
}
pub type FILE_FS_LABEL_INFORMATION = _FILE_FS_LABEL_INFORMATION;
pub type PFILE_FS_LABEL_INFORMATION = *mut _FILE_FS_LABEL_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FS_VOLUME_INFORMATION {
    pub VolumeCreationTime: LARGE_INTEGER,
    pub VolumeSerialNumber: ULONG,
    pub VolumeLabelLength: ULONG,
    pub SupportsObjects: BOOLEAN,
    pub VolumeLabel: [WCHAR; 1usize],
}
pub type FILE_FS_VOLUME_INFORMATION = _FILE_FS_VOLUME_INFORMATION;
pub type PFILE_FS_VOLUME_INFORMATION = *mut _FILE_FS_VOLUME_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FS_SIZE_INFORMATION {
    pub TotalAllocationUnits: LARGE_INTEGER,
    pub AvailableAllocationUnits: LARGE_INTEGER,
    pub SectorsPerAllocationUnit: ULONG,
    pub BytesPerSector: ULONG,
}
pub type FILE_FS_SIZE_INFORMATION = _FILE_FS_SIZE_INFORMATION;
pub type PFILE_FS_SIZE_INFORMATION = *mut _FILE_FS_SIZE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FS_FULL_SIZE_INFORMATION {
    pub TotalAllocationUnits: LARGE_INTEGER,
    pub CallerAvailableAllocationUnits: LARGE_INTEGER,
    pub ActualAvailableAllocationUnits: LARGE_INTEGER,
    pub SectorsPerAllocationUnit: ULONG,
    pub BytesPerSector: ULONG,
}
pub type FILE_FS_FULL_SIZE_INFORMATION = _FILE_FS_FULL_SIZE_INFORMATION;
pub type PFILE_FS_FULL_SIZE_INFORMATION = *mut _FILE_FS_FULL_SIZE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FS_FULL_SIZE_INFORMATION_EX {
    pub ActualTotalAllocationUnits: ULONGLONG,
    pub ActualAvailableAllocationUnits: ULONGLONG,
    pub ActualPoolUnavailableAllocationUnits: ULONGLONG,
    pub CallerTotalAllocationUnits: ULONGLONG,
    pub CallerAvailableAllocationUnits: ULONGLONG,
    pub CallerPoolUnavailableAllocationUnits: ULONGLONG,
    pub UsedAllocationUnits: ULONGLONG,
    pub TotalReservedAllocationUnits: ULONGLONG,
    pub VolumeStorageReserveAllocationUnits: ULONGLONG,
    pub AvailableCommittedAllocationUnits: ULONGLONG,
    pub PoolAvailableAllocationUnits: ULONGLONG,
    pub SectorsPerAllocationUnit: ULONG,
    pub BytesPerSector: ULONG,
}
pub type FILE_FS_FULL_SIZE_INFORMATION_EX = _FILE_FS_FULL_SIZE_INFORMATION_EX;
pub type PFILE_FS_FULL_SIZE_INFORMATION_EX = *mut _FILE_FS_FULL_SIZE_INFORMATION_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FS_METADATA_SIZE_INFORMATION {
    pub TotalMetadataAllocationUnits: LARGE_INTEGER,
    pub SectorsPerAllocationUnit: ULONG,
    pub BytesPerSector: ULONG,
}
pub type FILE_FS_METADATA_SIZE_INFORMATION = _FILE_FS_METADATA_SIZE_INFORMATION;
pub type PFILE_FS_METADATA_SIZE_INFORMATION = *mut _FILE_FS_METADATA_SIZE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FS_SECTOR_SIZE_INFORMATION {
    pub LogicalBytesPerSector: ULONG,
    pub PhysicalBytesPerSectorForAtomicity: ULONG,
    pub PhysicalBytesPerSectorForPerformance: ULONG,
    pub FileSystemEffectivePhysicalBytesPerSectorForAtomicity: ULONG,
    pub Flags: ULONG,
    pub ByteOffsetForSectorAlignment: ULONG,
    pub ByteOffsetForPartitionAlignment: ULONG,
}
pub type FILE_FS_SECTOR_SIZE_INFORMATION = _FILE_FS_SECTOR_SIZE_INFORMATION;
pub type PFILE_FS_SECTOR_SIZE_INFORMATION = *mut _FILE_FS_SECTOR_SIZE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FS_OBJECTID_INFORMATION {
    pub ObjectId: [UCHAR; 16usize],
    pub ExtendedInfo: [UCHAR; 48usize],
}
pub type FILE_FS_OBJECTID_INFORMATION = _FILE_FS_OBJECTID_INFORMATION;
pub type PFILE_FS_OBJECTID_INFORMATION = *mut _FILE_FS_OBJECTID_INFORMATION;
pub const _BUS_DATA_TYPE_ConfigurationSpaceUndefined: _BUS_DATA_TYPE = -1;
pub const _BUS_DATA_TYPE_Cmos: _BUS_DATA_TYPE = 0;
pub const _BUS_DATA_TYPE_EisaConfiguration: _BUS_DATA_TYPE = 1;
pub const _BUS_DATA_TYPE_Pos: _BUS_DATA_TYPE = 2;
pub const _BUS_DATA_TYPE_CbusConfiguration: _BUS_DATA_TYPE = 3;
pub const _BUS_DATA_TYPE_PCIConfiguration: _BUS_DATA_TYPE = 4;
pub const _BUS_DATA_TYPE_VMEConfiguration: _BUS_DATA_TYPE = 5;
pub const _BUS_DATA_TYPE_NuBusConfiguration: _BUS_DATA_TYPE = 6;
pub const _BUS_DATA_TYPE_PCMCIAConfiguration: _BUS_DATA_TYPE = 7;
pub const _BUS_DATA_TYPE_MPIConfiguration: _BUS_DATA_TYPE = 8;
pub const _BUS_DATA_TYPE_MPSAConfiguration: _BUS_DATA_TYPE = 9;
pub const _BUS_DATA_TYPE_PNPISAConfiguration: _BUS_DATA_TYPE = 10;
pub const _BUS_DATA_TYPE_SgiInternalConfiguration: _BUS_DATA_TYPE = 11;
pub const _BUS_DATA_TYPE_MaximumBusDataType: _BUS_DATA_TYPE = 12;
pub type _BUS_DATA_TYPE = core::ffi::c_int;
pub use self::_BUS_DATA_TYPE as BUS_DATA_TYPE;
pub type PBUS_DATA_TYPE = *mut _BUS_DATA_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KEY_NAME_INFORMATION {
    pub NameLength: ULONG,
    pub Name: [WCHAR; 1usize],
}
pub type KEY_NAME_INFORMATION = _KEY_NAME_INFORMATION;
pub type PKEY_NAME_INFORMATION = *mut _KEY_NAME_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KEY_CACHED_INFORMATION {
    pub LastWriteTime: LARGE_INTEGER,
    pub TitleIndex: ULONG,
    pub SubKeys: ULONG,
    pub MaxNameLen: ULONG,
    pub Values: ULONG,
    pub MaxValueNameLen: ULONG,
    pub MaxValueDataLen: ULONG,
    pub NameLength: ULONG,
}
pub type KEY_CACHED_INFORMATION = _KEY_CACHED_INFORMATION;
pub type PKEY_CACHED_INFORMATION = *mut _KEY_CACHED_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KEY_VIRTUALIZATION_INFORMATION {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KEY_VIRTUALIZATION_INFORMATION {
    #[inline]
    pub fn VirtualizationCandidate(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VirtualizationCandidate(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VirtualizationCandidate_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VirtualizationCandidate_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VirtualizationEnabled(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VirtualizationEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VirtualizationEnabled_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VirtualizationEnabled_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VirtualTarget(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VirtualTarget(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VirtualTarget_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VirtualTarget_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VirtualStore(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VirtualStore(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VirtualStore_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VirtualStore_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VirtualSource(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VirtualSource(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VirtualSource_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VirtualSource_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                27u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                27u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        VirtualizationCandidate: ULONG,
        VirtualizationEnabled: ULONG,
        VirtualTarget: ULONG,
        VirtualStore: ULONG,
        VirtualSource: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let VirtualizationCandidate: u32 =
                unsafe { ::core::mem::transmute(VirtualizationCandidate) };
            VirtualizationCandidate as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let VirtualizationEnabled: u32 =
                unsafe { ::core::mem::transmute(VirtualizationEnabled) };
            VirtualizationEnabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let VirtualTarget: u32 = unsafe { ::core::mem::transmute(VirtualTarget) };
            VirtualTarget as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let VirtualStore: u32 = unsafe { ::core::mem::transmute(VirtualStore) };
            VirtualStore as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let VirtualSource: u32 = unsafe { ::core::mem::transmute(VirtualSource) };
            VirtualSource as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type KEY_VIRTUALIZATION_INFORMATION = _KEY_VIRTUALIZATION_INFORMATION;
pub type PKEY_VIRTUALIZATION_INFORMATION = *mut _KEY_VIRTUALIZATION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KEY_LAYER_INFORMATION {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KEY_LAYER_INFORMATION {
    #[inline]
    pub fn IsTombstone(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsTombstone(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IsTombstone_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IsTombstone_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IsSupersedeLocal(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsSupersedeLocal(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IsSupersedeLocal_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IsSupersedeLocal_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IsSupersedeTree(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsSupersedeTree(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IsSupersedeTree_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IsSupersedeTree_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ClassIsInherited(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ClassIsInherited(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ClassIsInherited_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ClassIsInherited_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                28u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                28u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        IsTombstone: ULONG,
        IsSupersedeLocal: ULONG,
        IsSupersedeTree: ULONG,
        ClassIsInherited: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let IsTombstone: u32 = unsafe { ::core::mem::transmute(IsTombstone) };
            IsTombstone as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let IsSupersedeLocal: u32 = unsafe { ::core::mem::transmute(IsSupersedeLocal) };
            IsSupersedeLocal as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let IsSupersedeTree: u32 = unsafe { ::core::mem::transmute(IsSupersedeTree) };
            IsSupersedeTree as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ClassIsInherited: u32 = unsafe { ::core::mem::transmute(ClassIsInherited) };
            ClassIsInherited as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type KEY_LAYER_INFORMATION = _KEY_LAYER_INFORMATION;
pub type PKEY_LAYER_INFORMATION = *mut _KEY_LAYER_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_REGISTRATION_RECORD {
    pub Next: *mut _EXCEPTION_REGISTRATION_RECORD,
    pub Handler: PEXCEPTION_ROUTINE,
}
pub type EXCEPTION_REGISTRATION_RECORD = _EXCEPTION_REGISTRATION_RECORD;
pub type PEXCEPTION_REGISTRATION_RECORD = *mut EXCEPTION_REGISTRATION_RECORD;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NT_TIB {
    pub ExceptionList: *mut _EXCEPTION_REGISTRATION_RECORD,
    pub StackBase: PVOID,
    pub StackLimit: PVOID,
    pub SubSystemTib: PVOID,
    pub __bindgen_anon_1: _NT_TIB__bindgen_ty_1,
    pub ArbitraryUserPointer: PVOID,
    pub Self_: *mut _NT_TIB,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NT_TIB__bindgen_ty_1 {
    pub FiberData: PVOID,
    pub Version: ULONG,
}
pub type NT_TIB = _NT_TIB;
pub type PNT_TIB = *mut NT_TIB;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NT_TIB32 {
    pub ExceptionList: ULONG,
    pub StackBase: ULONG,
    pub StackLimit: ULONG,
    pub SubSystemTib: ULONG,
    pub __bindgen_anon_1: _NT_TIB32__bindgen_ty_1,
    pub ArbitraryUserPointer: ULONG,
    pub Self_: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NT_TIB32__bindgen_ty_1 {
    pub FiberData: ULONG,
    pub Version: ULONG,
}
pub type NT_TIB32 = _NT_TIB32;
pub type PNT_TIB32 = *mut _NT_TIB32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NT_TIB64 {
    pub ExceptionList: ULONG64,
    pub StackBase: ULONG64,
    pub StackLimit: ULONG64,
    pub SubSystemTib: ULONG64,
    pub __bindgen_anon_1: _NT_TIB64__bindgen_ty_1,
    pub ArbitraryUserPointer: ULONG64,
    pub Self_: ULONG64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NT_TIB64__bindgen_ty_1 {
    pub FiberData: ULONG64,
    pub Version: ULONG,
}
pub type NT_TIB64 = _NT_TIB64;
pub type PNT_TIB64 = *mut _NT_TIB64;
pub const _PROCESSINFOCLASS_ProcessBasicInformation: _PROCESSINFOCLASS = 0;
pub const _PROCESSINFOCLASS_ProcessQuotaLimits: _PROCESSINFOCLASS = 1;
pub const _PROCESSINFOCLASS_ProcessIoCounters: _PROCESSINFOCLASS = 2;
pub const _PROCESSINFOCLASS_ProcessVmCounters: _PROCESSINFOCLASS = 3;
pub const _PROCESSINFOCLASS_ProcessTimes: _PROCESSINFOCLASS = 4;
pub const _PROCESSINFOCLASS_ProcessBasePriority: _PROCESSINFOCLASS = 5;
pub const _PROCESSINFOCLASS_ProcessRaisePriority: _PROCESSINFOCLASS = 6;
pub const _PROCESSINFOCLASS_ProcessDebugPort: _PROCESSINFOCLASS = 7;
pub const _PROCESSINFOCLASS_ProcessExceptionPort: _PROCESSINFOCLASS = 8;
pub const _PROCESSINFOCLASS_ProcessAccessToken: _PROCESSINFOCLASS = 9;
pub const _PROCESSINFOCLASS_ProcessLdtInformation: _PROCESSINFOCLASS = 10;
pub const _PROCESSINFOCLASS_ProcessLdtSize: _PROCESSINFOCLASS = 11;
pub const _PROCESSINFOCLASS_ProcessDefaultHardErrorMode: _PROCESSINFOCLASS = 12;
pub const _PROCESSINFOCLASS_ProcessIoPortHandlers: _PROCESSINFOCLASS = 13;
pub const _PROCESSINFOCLASS_ProcessPooledUsageAndLimits: _PROCESSINFOCLASS = 14;
pub const _PROCESSINFOCLASS_ProcessWorkingSetWatch: _PROCESSINFOCLASS = 15;
pub const _PROCESSINFOCLASS_ProcessUserModeIOPL: _PROCESSINFOCLASS = 16;
pub const _PROCESSINFOCLASS_ProcessEnableAlignmentFaultFixup: _PROCESSINFOCLASS = 17;
pub const _PROCESSINFOCLASS_ProcessPriorityClass: _PROCESSINFOCLASS = 18;
pub const _PROCESSINFOCLASS_ProcessWx86Information: _PROCESSINFOCLASS = 19;
pub const _PROCESSINFOCLASS_ProcessHandleCount: _PROCESSINFOCLASS = 20;
pub const _PROCESSINFOCLASS_ProcessAffinityMask: _PROCESSINFOCLASS = 21;
pub const _PROCESSINFOCLASS_ProcessPriorityBoost: _PROCESSINFOCLASS = 22;
pub const _PROCESSINFOCLASS_ProcessDeviceMap: _PROCESSINFOCLASS = 23;
pub const _PROCESSINFOCLASS_ProcessSessionInformation: _PROCESSINFOCLASS = 24;
pub const _PROCESSINFOCLASS_ProcessForegroundInformation: _PROCESSINFOCLASS = 25;
pub const _PROCESSINFOCLASS_ProcessWow64Information: _PROCESSINFOCLASS = 26;
pub const _PROCESSINFOCLASS_ProcessImageFileName: _PROCESSINFOCLASS = 27;
pub const _PROCESSINFOCLASS_ProcessLUIDDeviceMapsEnabled: _PROCESSINFOCLASS = 28;
pub const _PROCESSINFOCLASS_ProcessBreakOnTermination: _PROCESSINFOCLASS = 29;
pub const _PROCESSINFOCLASS_ProcessDebugObjectHandle: _PROCESSINFOCLASS = 30;
pub const _PROCESSINFOCLASS_ProcessDebugFlags: _PROCESSINFOCLASS = 31;
pub const _PROCESSINFOCLASS_ProcessHandleTracing: _PROCESSINFOCLASS = 32;
pub const _PROCESSINFOCLASS_ProcessIoPriority: _PROCESSINFOCLASS = 33;
pub const _PROCESSINFOCLASS_ProcessExecuteFlags: _PROCESSINFOCLASS = 34;
pub const _PROCESSINFOCLASS_ProcessTlsInformation: _PROCESSINFOCLASS = 35;
pub const _PROCESSINFOCLASS_ProcessCookie: _PROCESSINFOCLASS = 36;
pub const _PROCESSINFOCLASS_ProcessImageInformation: _PROCESSINFOCLASS = 37;
pub const _PROCESSINFOCLASS_ProcessCycleTime: _PROCESSINFOCLASS = 38;
pub const _PROCESSINFOCLASS_ProcessPagePriority: _PROCESSINFOCLASS = 39;
pub const _PROCESSINFOCLASS_ProcessInstrumentationCallback: _PROCESSINFOCLASS = 40;
pub const _PROCESSINFOCLASS_ProcessThreadStackAllocation: _PROCESSINFOCLASS = 41;
pub const _PROCESSINFOCLASS_ProcessWorkingSetWatchEx: _PROCESSINFOCLASS = 42;
pub const _PROCESSINFOCLASS_ProcessImageFileNameWin32: _PROCESSINFOCLASS = 43;
pub const _PROCESSINFOCLASS_ProcessImageFileMapping: _PROCESSINFOCLASS = 44;
pub const _PROCESSINFOCLASS_ProcessAffinityUpdateMode: _PROCESSINFOCLASS = 45;
pub const _PROCESSINFOCLASS_ProcessMemoryAllocationMode: _PROCESSINFOCLASS = 46;
pub const _PROCESSINFOCLASS_ProcessGroupInformation: _PROCESSINFOCLASS = 47;
pub const _PROCESSINFOCLASS_ProcessTokenVirtualizationEnabled: _PROCESSINFOCLASS = 48;
pub const _PROCESSINFOCLASS_ProcessOwnerInformation: _PROCESSINFOCLASS = 49;
pub const _PROCESSINFOCLASS_ProcessWindowInformation: _PROCESSINFOCLASS = 50;
pub const _PROCESSINFOCLASS_ProcessHandleInformation: _PROCESSINFOCLASS = 51;
pub const _PROCESSINFOCLASS_ProcessMitigationPolicy: _PROCESSINFOCLASS = 52;
pub const _PROCESSINFOCLASS_ProcessDynamicFunctionTableInformation: _PROCESSINFOCLASS = 53;
pub const _PROCESSINFOCLASS_ProcessHandleCheckingMode: _PROCESSINFOCLASS = 54;
pub const _PROCESSINFOCLASS_ProcessKeepAliveCount: _PROCESSINFOCLASS = 55;
pub const _PROCESSINFOCLASS_ProcessRevokeFileHandles: _PROCESSINFOCLASS = 56;
pub const _PROCESSINFOCLASS_ProcessWorkingSetControl: _PROCESSINFOCLASS = 57;
pub const _PROCESSINFOCLASS_ProcessHandleTable: _PROCESSINFOCLASS = 58;
pub const _PROCESSINFOCLASS_ProcessCheckStackExtentsMode: _PROCESSINFOCLASS = 59;
pub const _PROCESSINFOCLASS_ProcessCommandLineInformation: _PROCESSINFOCLASS = 60;
pub const _PROCESSINFOCLASS_ProcessProtectionInformation: _PROCESSINFOCLASS = 61;
pub const _PROCESSINFOCLASS_ProcessMemoryExhaustion: _PROCESSINFOCLASS = 62;
pub const _PROCESSINFOCLASS_ProcessFaultInformation: _PROCESSINFOCLASS = 63;
pub const _PROCESSINFOCLASS_ProcessTelemetryIdInformation: _PROCESSINFOCLASS = 64;
pub const _PROCESSINFOCLASS_ProcessCommitReleaseInformation: _PROCESSINFOCLASS = 65;
pub const _PROCESSINFOCLASS_ProcessReserved1Information: _PROCESSINFOCLASS = 66;
pub const _PROCESSINFOCLASS_ProcessReserved2Information: _PROCESSINFOCLASS = 67;
pub const _PROCESSINFOCLASS_ProcessSubsystemProcess: _PROCESSINFOCLASS = 68;
pub const _PROCESSINFOCLASS_ProcessInPrivate: _PROCESSINFOCLASS = 70;
pub const _PROCESSINFOCLASS_ProcessRaiseUMExceptionOnInvalidHandleClose: _PROCESSINFOCLASS = 71;
pub const _PROCESSINFOCLASS_ProcessSubsystemInformation: _PROCESSINFOCLASS = 75;
pub const _PROCESSINFOCLASS_ProcessWin32kSyscallFilterInformation: _PROCESSINFOCLASS = 79;
pub const _PROCESSINFOCLASS_ProcessEnergyTrackingState: _PROCESSINFOCLASS = 82;
pub const _PROCESSINFOCLASS_MaxProcessInfoClass: _PROCESSINFOCLASS = 83;
pub type _PROCESSINFOCLASS = core::ffi::c_int;
pub use self::_PROCESSINFOCLASS as PROCESSINFOCLASS;
pub const _THREADINFOCLASS_ThreadBasicInformation: _THREADINFOCLASS = 0;
pub const _THREADINFOCLASS_ThreadTimes: _THREADINFOCLASS = 1;
pub const _THREADINFOCLASS_ThreadPriority: _THREADINFOCLASS = 2;
pub const _THREADINFOCLASS_ThreadBasePriority: _THREADINFOCLASS = 3;
pub const _THREADINFOCLASS_ThreadAffinityMask: _THREADINFOCLASS = 4;
pub const _THREADINFOCLASS_ThreadImpersonationToken: _THREADINFOCLASS = 5;
pub const _THREADINFOCLASS_ThreadDescriptorTableEntry: _THREADINFOCLASS = 6;
pub const _THREADINFOCLASS_ThreadEnableAlignmentFaultFixup: _THREADINFOCLASS = 7;
pub const _THREADINFOCLASS_ThreadEventPair_Reusable: _THREADINFOCLASS = 8;
pub const _THREADINFOCLASS_ThreadQuerySetWin32StartAddress: _THREADINFOCLASS = 9;
pub const _THREADINFOCLASS_ThreadZeroTlsCell: _THREADINFOCLASS = 10;
pub const _THREADINFOCLASS_ThreadPerformanceCount: _THREADINFOCLASS = 11;
pub const _THREADINFOCLASS_ThreadAmILastThread: _THREADINFOCLASS = 12;
pub const _THREADINFOCLASS_ThreadIdealProcessor: _THREADINFOCLASS = 13;
pub const _THREADINFOCLASS_ThreadPriorityBoost: _THREADINFOCLASS = 14;
pub const _THREADINFOCLASS_ThreadSetTlsArrayAddress: _THREADINFOCLASS = 15;
pub const _THREADINFOCLASS_ThreadIsIoPending: _THREADINFOCLASS = 16;
pub const _THREADINFOCLASS_ThreadHideFromDebugger: _THREADINFOCLASS = 17;
pub const _THREADINFOCLASS_ThreadBreakOnTermination: _THREADINFOCLASS = 18;
pub const _THREADINFOCLASS_ThreadSwitchLegacyState: _THREADINFOCLASS = 19;
pub const _THREADINFOCLASS_ThreadIsTerminated: _THREADINFOCLASS = 20;
pub const _THREADINFOCLASS_ThreadLastSystemCall: _THREADINFOCLASS = 21;
pub const _THREADINFOCLASS_ThreadIoPriority: _THREADINFOCLASS = 22;
pub const _THREADINFOCLASS_ThreadCycleTime: _THREADINFOCLASS = 23;
pub const _THREADINFOCLASS_ThreadPagePriority: _THREADINFOCLASS = 24;
pub const _THREADINFOCLASS_ThreadActualBasePriority: _THREADINFOCLASS = 25;
pub const _THREADINFOCLASS_ThreadTebInformation: _THREADINFOCLASS = 26;
pub const _THREADINFOCLASS_ThreadCSwitchMon: _THREADINFOCLASS = 27;
pub const _THREADINFOCLASS_ThreadCSwitchPmu: _THREADINFOCLASS = 28;
pub const _THREADINFOCLASS_ThreadWow64Context: _THREADINFOCLASS = 29;
pub const _THREADINFOCLASS_ThreadGroupInformation: _THREADINFOCLASS = 30;
pub const _THREADINFOCLASS_ThreadUmsInformation: _THREADINFOCLASS = 31;
pub const _THREADINFOCLASS_ThreadCounterProfiling: _THREADINFOCLASS = 32;
pub const _THREADINFOCLASS_ThreadIdealProcessorEx: _THREADINFOCLASS = 33;
pub const _THREADINFOCLASS_ThreadCpuAccountingInformation: _THREADINFOCLASS = 34;
pub const _THREADINFOCLASS_ThreadSuspendCount: _THREADINFOCLASS = 35;
pub const _THREADINFOCLASS_ThreadActualGroupAffinity: _THREADINFOCLASS = 41;
pub const _THREADINFOCLASS_ThreadDynamicCodePolicyInfo: _THREADINFOCLASS = 42;
pub const _THREADINFOCLASS_ThreadSubsystemInformation: _THREADINFOCLASS = 45;
pub const _THREADINFOCLASS_MaxThreadInfoClass: _THREADINFOCLASS = 56;
pub type _THREADINFOCLASS = core::ffi::c_int;
pub use self::_THREADINFOCLASS as THREADINFOCLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PAGE_PRIORITY_INFORMATION {
    pub PagePriority: ULONG,
}
pub type PAGE_PRIORITY_INFORMATION = _PAGE_PRIORITY_INFORMATION;
pub type PPAGE_PRIORITY_INFORMATION = *mut _PAGE_PRIORITY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_WS_WATCH_INFORMATION {
    pub FaultingPc: PVOID,
    pub FaultingVa: PVOID,
}
pub type PROCESS_WS_WATCH_INFORMATION = _PROCESS_WS_WATCH_INFORMATION;
pub type PPROCESS_WS_WATCH_INFORMATION = *mut _PROCESS_WS_WATCH_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_BASIC_INFORMATION {
    pub ExitStatus: NTSTATUS,
    pub PebBaseAddress: PPEB,
    pub AffinityMask: ULONG_PTR,
    pub BasePriority: KPRIORITY,
    pub UniqueProcessId: ULONG_PTR,
    pub InheritedFromUniqueProcessId: ULONG_PTR,
}
pub type PROCESS_BASIC_INFORMATION = _PROCESS_BASIC_INFORMATION;
pub type PPROCESS_BASIC_INFORMATION = *mut _PROCESS_BASIC_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_EXTENDED_BASIC_INFORMATION {
    pub Size: SIZE_T,
    pub BasicInfo: PROCESS_BASIC_INFORMATION,
    pub __bindgen_anon_1: _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1 {
    pub Flags: ULONG,
    pub __bindgen_anon_1: _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn IsProtectedProcess(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsProtectedProcess(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IsProtectedProcess_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IsProtectedProcess_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IsWow64Process(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsWow64Process(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IsWow64Process_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IsWow64Process_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IsProcessDeleting(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsProcessDeleting(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IsProcessDeleting_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IsProcessDeleting_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IsCrossSessionCreate(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsCrossSessionCreate(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IsCrossSessionCreate_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IsCrossSessionCreate_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IsFrozen(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsFrozen(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IsFrozen_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IsFrozen_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IsBackground(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsBackground(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IsBackground_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IsBackground_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IsStronglyNamed(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsStronglyNamed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IsStronglyNamed_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IsStronglyNamed_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IsSecureProcess(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsSecureProcess(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IsSecureProcess_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IsSecureProcess_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IsSubsystemProcess(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsSubsystemProcess(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IsSubsystemProcess_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IsSubsystemProcess_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SpareBits(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_SpareBits(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SpareBits_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                23u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SpareBits_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                23u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        IsProtectedProcess: ULONG,
        IsWow64Process: ULONG,
        IsProcessDeleting: ULONG,
        IsCrossSessionCreate: ULONG,
        IsFrozen: ULONG,
        IsBackground: ULONG,
        IsStronglyNamed: ULONG,
        IsSecureProcess: ULONG,
        IsSubsystemProcess: ULONG,
        SpareBits: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let IsProtectedProcess: u32 = unsafe { ::core::mem::transmute(IsProtectedProcess) };
            IsProtectedProcess as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let IsWow64Process: u32 = unsafe { ::core::mem::transmute(IsWow64Process) };
            IsWow64Process as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let IsProcessDeleting: u32 = unsafe { ::core::mem::transmute(IsProcessDeleting) };
            IsProcessDeleting as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let IsCrossSessionCreate: u32 = unsafe { ::core::mem::transmute(IsCrossSessionCreate) };
            IsCrossSessionCreate as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let IsFrozen: u32 = unsafe { ::core::mem::transmute(IsFrozen) };
            IsFrozen as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let IsBackground: u32 = unsafe { ::core::mem::transmute(IsBackground) };
            IsBackground as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let IsStronglyNamed: u32 = unsafe { ::core::mem::transmute(IsStronglyNamed) };
            IsStronglyNamed as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let IsSecureProcess: u32 = unsafe { ::core::mem::transmute(IsSecureProcess) };
            IsSecureProcess as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let IsSubsystemProcess: u32 = unsafe { ::core::mem::transmute(IsSubsystemProcess) };
            IsSubsystemProcess as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let SpareBits: u32 = unsafe { ::core::mem::transmute(SpareBits) };
            SpareBits as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_EXTENDED_BASIC_INFORMATION = _PROCESS_EXTENDED_BASIC_INFORMATION;
pub type PPROCESS_EXTENDED_BASIC_INFORMATION = *mut _PROCESS_EXTENDED_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MEMBERSHIP_INFORMATION {
    pub ServerSiloId: ULONG,
}
pub type PROCESS_MEMBERSHIP_INFORMATION = _PROCESS_MEMBERSHIP_INFORMATION;
pub type PPROCESS_MEMBERSHIP_INFORMATION = *mut _PROCESS_MEMBERSHIP_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_DEVICEMAP_INFORMATION {
    pub __bindgen_anon_1: _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1 {
    pub Set: _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1__bindgen_ty_1,
    pub Query: _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub DirectoryHandle: HANDLE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1__bindgen_ty_2 {
    pub DriveMap: ULONG,
    pub DriveType: [UCHAR; 32usize],
}
pub type PROCESS_DEVICEMAP_INFORMATION = _PROCESS_DEVICEMAP_INFORMATION;
pub type PPROCESS_DEVICEMAP_INFORMATION = *mut _PROCESS_DEVICEMAP_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_DEVICEMAP_INFORMATION_EX {
    pub __bindgen_anon_1: _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1,
    pub Flags: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1 {
    pub Set: _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1__bindgen_ty_1,
    pub Query: _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1__bindgen_ty_1 {
    pub DirectoryHandle: HANDLE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1__bindgen_ty_2 {
    pub DriveMap: ULONG,
    pub DriveType: [UCHAR; 32usize],
}
pub type PROCESS_DEVICEMAP_INFORMATION_EX = _PROCESS_DEVICEMAP_INFORMATION_EX;
pub type PPROCESS_DEVICEMAP_INFORMATION_EX = *mut _PROCESS_DEVICEMAP_INFORMATION_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_SESSION_INFORMATION {
    pub SessionId: ULONG,
}
pub type PROCESS_SESSION_INFORMATION = _PROCESS_SESSION_INFORMATION;
pub type PPROCESS_SESSION_INFORMATION = *mut _PROCESS_SESSION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_HANDLE_TRACING_ENABLE {
    pub Flags: ULONG,
}
pub type PROCESS_HANDLE_TRACING_ENABLE = _PROCESS_HANDLE_TRACING_ENABLE;
pub type PPROCESS_HANDLE_TRACING_ENABLE = *mut _PROCESS_HANDLE_TRACING_ENABLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_HANDLE_TRACING_ENABLE_EX {
    pub Flags: ULONG,
    pub TotalSlots: ULONG,
}
pub type PROCESS_HANDLE_TRACING_ENABLE_EX = _PROCESS_HANDLE_TRACING_ENABLE_EX;
pub type PPROCESS_HANDLE_TRACING_ENABLE_EX = *mut _PROCESS_HANDLE_TRACING_ENABLE_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_HANDLE_TRACING_ENTRY {
    pub Handle: HANDLE,
    pub ClientId: CLIENT_ID,
    pub Type: ULONG,
    pub Stacks: [PVOID; 16usize],
}
pub type PROCESS_HANDLE_TRACING_ENTRY = _PROCESS_HANDLE_TRACING_ENTRY;
pub type PPROCESS_HANDLE_TRACING_ENTRY = *mut _PROCESS_HANDLE_TRACING_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_HANDLE_TRACING_QUERY {
    pub Handle: HANDLE,
    pub TotalTraces: ULONG,
    pub HandleTrace: [PROCESS_HANDLE_TRACING_ENTRY; 1usize],
}
pub type PROCESS_HANDLE_TRACING_QUERY = _PROCESS_HANDLE_TRACING_QUERY;
pub type PPROCESS_HANDLE_TRACING_QUERY = *mut _PROCESS_HANDLE_TRACING_QUERY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_DYNAMIC_EH_CONTINUATION_TARGET {
    pub TargetAddress: ULONG_PTR,
    pub Flags: ULONG_PTR,
}
pub type PROCESS_DYNAMIC_EH_CONTINUATION_TARGET = _PROCESS_DYNAMIC_EH_CONTINUATION_TARGET;
pub type PPROCESS_DYNAMIC_EH_CONTINUATION_TARGET = *mut _PROCESS_DYNAMIC_EH_CONTINUATION_TARGET;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION {
    pub NumberOfTargets: USHORT,
    pub Reserved: USHORT,
    pub Reserved2: ULONG,
    pub Targets: PPROCESS_DYNAMIC_EH_CONTINUATION_TARGET,
}
pub type PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION =
_PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION;
pub type PPROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION =
*mut _PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE {
    pub BaseAddress: ULONG_PTR,
    pub Size: SIZE_T,
    pub Flags: ULONG,
}
pub type PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE = _PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE;
pub type PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE = *mut _PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION {
    pub NumberOfRanges: USHORT,
    pub Reserved: USHORT,
    pub Reserved2: ULONG,
    pub Ranges: PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE,
}
pub type PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION =
_PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION;
pub type PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION =
*mut _PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _QUOTA_LIMITS {
    pub PagedPoolLimit: SIZE_T,
    pub NonPagedPoolLimit: SIZE_T,
    pub MinimumWorkingSetSize: SIZE_T,
    pub MaximumWorkingSetSize: SIZE_T,
    pub PagefileLimit: SIZE_T,
    pub TimeLimit: LARGE_INTEGER,
}
pub type QUOTA_LIMITS = _QUOTA_LIMITS;
pub type PQUOTA_LIMITS = *mut _QUOTA_LIMITS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RATE_QUOTA_LIMIT {
    pub RateData: ULONG,
    pub __bindgen_anon_1: _RATE_QUOTA_LIMIT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RATE_QUOTA_LIMIT__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _RATE_QUOTA_LIMIT__bindgen_ty_1 {
    #[inline]
    pub fn RatePercent(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_RatePercent(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RatePercent_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                7u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RatePercent_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved0(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved0_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                25u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved0_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                25u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RatePercent: ULONG,
        Reserved0: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let RatePercent: u32 = unsafe { ::core::mem::transmute(RatePercent) };
            RatePercent as u64
        });
        __bindgen_bitfield_unit.set(7usize, 25u8, {
            let Reserved0: u32 = unsafe { ::core::mem::transmute(Reserved0) };
            Reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type RATE_QUOTA_LIMIT = _RATE_QUOTA_LIMIT;
pub type PRATE_QUOTA_LIMIT = *mut _RATE_QUOTA_LIMIT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _QUOTA_LIMITS_EX {
    pub PagedPoolLimit: SIZE_T,
    pub NonPagedPoolLimit: SIZE_T,
    pub MinimumWorkingSetSize: SIZE_T,
    pub MaximumWorkingSetSize: SIZE_T,
    pub PagefileLimit: SIZE_T,
    pub TimeLimit: LARGE_INTEGER,
    pub WorkingSetLimit: SIZE_T,
    pub Reserved2: SIZE_T,
    pub Reserved3: SIZE_T,
    pub Reserved4: SIZE_T,
    pub Flags: ULONG,
    pub CpuRateLimit: RATE_QUOTA_LIMIT,
}
pub type QUOTA_LIMITS_EX = _QUOTA_LIMITS_EX;
pub type PQUOTA_LIMITS_EX = *mut _QUOTA_LIMITS_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_COUNTERS {
    pub ReadOperationCount: ULONGLONG,
    pub WriteOperationCount: ULONGLONG,
    pub OtherOperationCount: ULONGLONG,
    pub ReadTransferCount: ULONGLONG,
    pub WriteTransferCount: ULONGLONG,
    pub OtherTransferCount: ULONGLONG,
}
pub type IO_COUNTERS = _IO_COUNTERS;
pub type PIO_COUNTERS = *mut IO_COUNTERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VM_COUNTERS {
    pub PeakVirtualSize: SIZE_T,
    pub VirtualSize: SIZE_T,
    pub PageFaultCount: ULONG,
    pub PeakWorkingSetSize: SIZE_T,
    pub WorkingSetSize: SIZE_T,
    pub QuotaPeakPagedPoolUsage: SIZE_T,
    pub QuotaPagedPoolUsage: SIZE_T,
    pub QuotaPeakNonPagedPoolUsage: SIZE_T,
    pub QuotaNonPagedPoolUsage: SIZE_T,
    pub PagefileUsage: SIZE_T,
    pub PeakPagefileUsage: SIZE_T,
}
pub type VM_COUNTERS = _VM_COUNTERS;
pub type PVM_COUNTERS = *mut VM_COUNTERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VM_COUNTERS_EX {
    pub PeakVirtualSize: SIZE_T,
    pub VirtualSize: SIZE_T,
    pub PageFaultCount: ULONG,
    pub PeakWorkingSetSize: SIZE_T,
    pub WorkingSetSize: SIZE_T,
    pub QuotaPeakPagedPoolUsage: SIZE_T,
    pub QuotaPagedPoolUsage: SIZE_T,
    pub QuotaPeakNonPagedPoolUsage: SIZE_T,
    pub QuotaNonPagedPoolUsage: SIZE_T,
    pub PagefileUsage: SIZE_T,
    pub PeakPagefileUsage: SIZE_T,
    pub PrivateUsage: SIZE_T,
}
pub type VM_COUNTERS_EX = _VM_COUNTERS_EX;
pub type PVM_COUNTERS_EX = *mut VM_COUNTERS_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VM_COUNTERS_EX2 {
    pub CountersEx: VM_COUNTERS_EX,
    pub PrivateWorkingSetSize: SIZE_T,
    pub SharedCommitUsage: ULONGLONG,
}
pub type VM_COUNTERS_EX2 = _VM_COUNTERS_EX2;
pub type PVM_COUNTERS_EX2 = *mut _VM_COUNTERS_EX2;
pub const _HARDWARE_COUNTER_TYPE_PMCCounter: _HARDWARE_COUNTER_TYPE = 0;
pub const _HARDWARE_COUNTER_TYPE_MaxHardwareCounterType: _HARDWARE_COUNTER_TYPE = 1;
pub type _HARDWARE_COUNTER_TYPE = core::ffi::c_int;
pub use self::_HARDWARE_COUNTER_TYPE as HARDWARE_COUNTER_TYPE;
pub type PHARDWARE_COUNTER_TYPE = *mut _HARDWARE_COUNTER_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HARDWARE_COUNTER {
    pub Type: HARDWARE_COUNTER_TYPE,
    pub Reserved: ULONG,
    pub Index: ULONG64,
}
pub type HARDWARE_COUNTER = _HARDWARE_COUNTER;
pub type PHARDWARE_COUNTER = *mut _HARDWARE_COUNTER;
pub const _PROCESS_MITIGATION_POLICY_ProcessDEPPolicy: _PROCESS_MITIGATION_POLICY = 0;
pub const _PROCESS_MITIGATION_POLICY_ProcessASLRPolicy: _PROCESS_MITIGATION_POLICY = 1;
pub const _PROCESS_MITIGATION_POLICY_ProcessDynamicCodePolicy: _PROCESS_MITIGATION_POLICY = 2;
pub const _PROCESS_MITIGATION_POLICY_ProcessStrictHandleCheckPolicy: _PROCESS_MITIGATION_POLICY = 3;
pub const _PROCESS_MITIGATION_POLICY_ProcessSystemCallDisablePolicy: _PROCESS_MITIGATION_POLICY = 4;
pub const _PROCESS_MITIGATION_POLICY_ProcessMitigationOptionsMask: _PROCESS_MITIGATION_POLICY = 5;
pub const _PROCESS_MITIGATION_POLICY_ProcessExtensionPointDisablePolicy:
_PROCESS_MITIGATION_POLICY = 6;
pub const _PROCESS_MITIGATION_POLICY_ProcessControlFlowGuardPolicy: _PROCESS_MITIGATION_POLICY = 7;
pub const _PROCESS_MITIGATION_POLICY_ProcessSignaturePolicy: _PROCESS_MITIGATION_POLICY = 8;
pub const _PROCESS_MITIGATION_POLICY_ProcessFontDisablePolicy: _PROCESS_MITIGATION_POLICY = 9;
pub const _PROCESS_MITIGATION_POLICY_ProcessImageLoadPolicy: _PROCESS_MITIGATION_POLICY = 10;
pub const _PROCESS_MITIGATION_POLICY_ProcessSystemCallFilterPolicy: _PROCESS_MITIGATION_POLICY = 11;
pub const _PROCESS_MITIGATION_POLICY_ProcessPayloadRestrictionPolicy: _PROCESS_MITIGATION_POLICY =
    12;
pub const _PROCESS_MITIGATION_POLICY_ProcessChildProcessPolicy: _PROCESS_MITIGATION_POLICY = 13;
pub const _PROCESS_MITIGATION_POLICY_ProcessSideChannelIsolationPolicy: _PROCESS_MITIGATION_POLICY =
    14;
pub const _PROCESS_MITIGATION_POLICY_ProcessUserShadowStackPolicy: _PROCESS_MITIGATION_POLICY = 15;
pub const _PROCESS_MITIGATION_POLICY_ProcessRedirectionTrustPolicy: _PROCESS_MITIGATION_POLICY = 16;
pub const _PROCESS_MITIGATION_POLICY_ProcessUserPointerAuthPolicy: _PROCESS_MITIGATION_POLICY = 17;
pub const _PROCESS_MITIGATION_POLICY_ProcessSEHOPPolicy: _PROCESS_MITIGATION_POLICY = 18;
pub const _PROCESS_MITIGATION_POLICY_ProcessActivationContextTrustPolicy:
_PROCESS_MITIGATION_POLICY = 19;
pub const _PROCESS_MITIGATION_POLICY_MaxProcessMitigationPolicy: _PROCESS_MITIGATION_POLICY = 20;
pub type _PROCESS_MITIGATION_POLICY = core::ffi::c_int;
pub use self::_PROCESS_MITIGATION_POLICY as PROCESS_MITIGATION_POLICY;
pub type PPROCESS_MITIGATION_POLICY = *mut _PROCESS_MITIGATION_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_ASLR_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1 {
    pub Flags: ULONG,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn EnableBottomUpRandomization(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableBottomUpRandomization(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EnableBottomUpRandomization_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_EnableBottomUpRandomization_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EnableForceRelocateImages(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableForceRelocateImages(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EnableForceRelocateImages_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_EnableForceRelocateImages_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EnableHighEntropy(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableHighEntropy(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EnableHighEntropy_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_EnableHighEntropy_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DisallowStrippedImages(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisallowStrippedImages(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DisallowStrippedImages_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DisallowStrippedImages_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReservedFlags_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                28u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                28u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EnableBottomUpRandomization: ULONG,
        EnableForceRelocateImages: ULONG,
        EnableHighEntropy: ULONG,
        DisallowStrippedImages: ULONG,
        ReservedFlags: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EnableBottomUpRandomization: u32 =
                unsafe { ::core::mem::transmute(EnableBottomUpRandomization) };
            EnableBottomUpRandomization as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let EnableForceRelocateImages: u32 =
                unsafe { ::core::mem::transmute(EnableForceRelocateImages) };
            EnableForceRelocateImages as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let EnableHighEntropy: u32 = unsafe { ::core::mem::transmute(EnableHighEntropy) };
            EnableHighEntropy as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DisallowStrippedImages: u32 =
                unsafe { ::core::mem::transmute(DisallowStrippedImages) };
            DisallowStrippedImages as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_ASLR_POLICY = _PROCESS_MITIGATION_ASLR_POLICY;
pub type PPROCESS_MITIGATION_ASLR_POLICY = *mut _PROCESS_MITIGATION_ASLR_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_DEP_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1,
    pub Permanent: BOOLEAN,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1 {
    pub Flags: ULONG,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Enable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Enable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Enable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Enable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DisableAtlThunkEmulation(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableAtlThunkEmulation(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DisableAtlThunkEmulation_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DisableAtlThunkEmulation_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReservedFlags_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Enable: ULONG,
        DisableAtlThunkEmulation: ULONG,
        ReservedFlags: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Enable: u32 = unsafe { ::core::mem::transmute(Enable) };
            Enable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DisableAtlThunkEmulation: u32 =
                unsafe { ::core::mem::transmute(DisableAtlThunkEmulation) };
            DisableAtlThunkEmulation as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_DEP_POLICY = _PROCESS_MITIGATION_DEP_POLICY;
pub type PPROCESS_MITIGATION_DEP_POLICY = *mut _PROCESS_MITIGATION_DEP_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_SEHOP_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1 {
    pub Flags: ULONG,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn EnableSehop(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableSehop(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EnableSehop_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_EnableSehop_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReservedFlags_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EnableSehop: ULONG,
        ReservedFlags: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EnableSehop: u32 = unsafe { ::core::mem::transmute(EnableSehop) };
            EnableSehop as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_SEHOP_POLICY = _PROCESS_MITIGATION_SEHOP_POLICY;
pub type PPROCESS_MITIGATION_SEHOP_POLICY = *mut _PROCESS_MITIGATION_SEHOP_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1 {
    pub Flags: ULONG,
    pub __bindgen_anon_1:
        _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn RaiseExceptionOnInvalidHandleReference(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RaiseExceptionOnInvalidHandleReference(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RaiseExceptionOnInvalidHandleReference_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RaiseExceptionOnInvalidHandleReference_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn HandleExceptionsPermanentlyEnabled(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HandleExceptionsPermanentlyEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn HandleExceptionsPermanentlyEnabled_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_HandleExceptionsPermanentlyEnabled_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReservedFlags_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RaiseExceptionOnInvalidHandleReference: ULONG,
        HandleExceptionsPermanentlyEnabled: ULONG,
        ReservedFlags: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let RaiseExceptionOnInvalidHandleReference: u32 =
                unsafe { ::core::mem::transmute(RaiseExceptionOnInvalidHandleReference) };
            RaiseExceptionOnInvalidHandleReference as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let HandleExceptionsPermanentlyEnabled: u32 =
                unsafe { ::core::mem::transmute(HandleExceptionsPermanentlyEnabled) };
            HandleExceptionsPermanentlyEnabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY =
_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY;
pub type PPROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY =
*mut _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1 {
    pub Flags: ULONG,
    pub __bindgen_anon_1:
        _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn DisallowWin32kSystemCalls(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisallowWin32kSystemCalls(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DisallowWin32kSystemCalls_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DisallowWin32kSystemCalls_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AuditDisallowWin32kSystemCalls(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditDisallowWin32kSystemCalls(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AuditDisallowWin32kSystemCalls_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AuditDisallowWin32kSystemCalls_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DisallowFsctlSystemCalls(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisallowFsctlSystemCalls(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DisallowFsctlSystemCalls_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DisallowFsctlSystemCalls_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AuditDisallowFsctlSystemCalls(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditDisallowFsctlSystemCalls(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AuditDisallowFsctlSystemCalls_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AuditDisallowFsctlSystemCalls_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReservedFlags_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                28u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                28u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DisallowWin32kSystemCalls: ULONG,
        AuditDisallowWin32kSystemCalls: ULONG,
        DisallowFsctlSystemCalls: ULONG,
        AuditDisallowFsctlSystemCalls: ULONG,
        ReservedFlags: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DisallowWin32kSystemCalls: u32 =
                unsafe { ::core::mem::transmute(DisallowWin32kSystemCalls) };
            DisallowWin32kSystemCalls as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AuditDisallowWin32kSystemCalls: u32 =
                unsafe { ::core::mem::transmute(AuditDisallowWin32kSystemCalls) };
            AuditDisallowWin32kSystemCalls as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DisallowFsctlSystemCalls: u32 =
                unsafe { ::core::mem::transmute(DisallowFsctlSystemCalls) };
            DisallowFsctlSystemCalls as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AuditDisallowFsctlSystemCalls: u32 =
                unsafe { ::core::mem::transmute(AuditDisallowFsctlSystemCalls) };
            AuditDisallowFsctlSystemCalls as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY =
_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY;
pub type PPROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY =
*mut _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1 {
    pub Flags: ULONG,
    pub __bindgen_anon_1:
        _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn DisableExtensionPoints(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableExtensionPoints(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DisableExtensionPoints_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DisableExtensionPoints_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReservedFlags_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DisableExtensionPoints: ULONG,
        ReservedFlags: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DisableExtensionPoints: u32 =
                unsafe { ::core::mem::transmute(DisableExtensionPoints) };
            DisableExtensionPoints as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY =
_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY;
pub type PPROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY =
*mut _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1 {
    pub Flags: ULONG,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ProhibitDynamicCode(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProhibitDynamicCode(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ProhibitDynamicCode_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ProhibitDynamicCode_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AllowThreadOptOut(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AllowThreadOptOut(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AllowThreadOptOut_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AllowThreadOptOut_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AllowRemoteDowngrade(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AllowRemoteDowngrade(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AllowRemoteDowngrade_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AllowRemoteDowngrade_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AuditProhibitDynamicCode(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditProhibitDynamicCode(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AuditProhibitDynamicCode_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AuditProhibitDynamicCode_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReservedFlags_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                28u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                28u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ProhibitDynamicCode: ULONG,
        AllowThreadOptOut: ULONG,
        AllowRemoteDowngrade: ULONG,
        AuditProhibitDynamicCode: ULONG,
        ReservedFlags: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ProhibitDynamicCode: u32 = unsafe { ::core::mem::transmute(ProhibitDynamicCode) };
            ProhibitDynamicCode as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AllowThreadOptOut: u32 = unsafe { ::core::mem::transmute(AllowThreadOptOut) };
            AllowThreadOptOut as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let AllowRemoteDowngrade: u32 = unsafe { ::core::mem::transmute(AllowRemoteDowngrade) };
            AllowRemoteDowngrade as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AuditProhibitDynamicCode: u32 =
                unsafe { ::core::mem::transmute(AuditProhibitDynamicCode) };
            AuditProhibitDynamicCode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_DYNAMIC_CODE_POLICY = _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY;
pub type PPROCESS_MITIGATION_DYNAMIC_CODE_POLICY = *mut _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1 {
    pub Flags: ULONG,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn EnableControlFlowGuard(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableControlFlowGuard(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EnableControlFlowGuard_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_EnableControlFlowGuard_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EnableExportSuppression(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableExportSuppression(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EnableExportSuppression_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_EnableExportSuppression_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn StrictMode(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_StrictMode(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn StrictMode_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_StrictMode_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EnableXfg(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableXfg(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EnableXfg_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_EnableXfg_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EnableXfgAuditMode(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableXfgAuditMode(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EnableXfgAuditMode_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_EnableXfgAuditMode_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReservedFlags_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                27u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                27u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EnableControlFlowGuard: ULONG,
        EnableExportSuppression: ULONG,
        StrictMode: ULONG,
        EnableXfg: ULONG,
        EnableXfgAuditMode: ULONG,
        ReservedFlags: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EnableControlFlowGuard: u32 =
                unsafe { ::core::mem::transmute(EnableControlFlowGuard) };
            EnableControlFlowGuard as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let EnableExportSuppression: u32 =
                unsafe { ::core::mem::transmute(EnableExportSuppression) };
            EnableExportSuppression as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let StrictMode: u32 = unsafe { ::core::mem::transmute(StrictMode) };
            StrictMode as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let EnableXfg: u32 = unsafe { ::core::mem::transmute(EnableXfg) };
            EnableXfg as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let EnableXfgAuditMode: u32 = unsafe { ::core::mem::transmute(EnableXfgAuditMode) };
            EnableXfgAuditMode as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY =
_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY;
pub type PPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY =
*mut _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1 {
    pub Flags: ULONG,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn MicrosoftSignedOnly(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MicrosoftSignedOnly(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MicrosoftSignedOnly_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MicrosoftSignedOnly_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn StoreSignedOnly(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_StoreSignedOnly(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn StoreSignedOnly_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_StoreSignedOnly_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MitigationOptIn(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MitigationOptIn(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MitigationOptIn_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MitigationOptIn_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AuditMicrosoftSignedOnly(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditMicrosoftSignedOnly(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AuditMicrosoftSignedOnly_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AuditMicrosoftSignedOnly_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AuditStoreSignedOnly(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditStoreSignedOnly(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AuditStoreSignedOnly_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AuditStoreSignedOnly_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReservedFlags_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                27u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                27u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MicrosoftSignedOnly: ULONG,
        StoreSignedOnly: ULONG,
        MitigationOptIn: ULONG,
        AuditMicrosoftSignedOnly: ULONG,
        AuditStoreSignedOnly: ULONG,
        ReservedFlags: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let MicrosoftSignedOnly: u32 = unsafe { ::core::mem::transmute(MicrosoftSignedOnly) };
            MicrosoftSignedOnly as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let StoreSignedOnly: u32 = unsafe { ::core::mem::transmute(StoreSignedOnly) };
            StoreSignedOnly as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let MitigationOptIn: u32 = unsafe { ::core::mem::transmute(MitigationOptIn) };
            MitigationOptIn as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AuditMicrosoftSignedOnly: u32 =
                unsafe { ::core::mem::transmute(AuditMicrosoftSignedOnly) };
            AuditMicrosoftSignedOnly as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let AuditStoreSignedOnly: u32 = unsafe { ::core::mem::transmute(AuditStoreSignedOnly) };
            AuditStoreSignedOnly as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY = _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY;
pub type PPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY =
*mut _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_FONT_DISABLE_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1 {
    pub Flags: ULONG,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn DisableNonSystemFonts(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableNonSystemFonts(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DisableNonSystemFonts_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DisableNonSystemFonts_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AuditNonSystemFontLoading(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditNonSystemFontLoading(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AuditNonSystemFontLoading_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AuditNonSystemFontLoading_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReservedFlags_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DisableNonSystemFonts: ULONG,
        AuditNonSystemFontLoading: ULONG,
        ReservedFlags: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DisableNonSystemFonts: u32 =
                unsafe { ::core::mem::transmute(DisableNonSystemFonts) };
            DisableNonSystemFonts as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AuditNonSystemFontLoading: u32 =
                unsafe { ::core::mem::transmute(AuditNonSystemFontLoading) };
            AuditNonSystemFontLoading as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_FONT_DISABLE_POLICY = _PROCESS_MITIGATION_FONT_DISABLE_POLICY;
pub type PPROCESS_MITIGATION_FONT_DISABLE_POLICY = *mut _PROCESS_MITIGATION_FONT_DISABLE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_IMAGE_LOAD_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1 {
    pub Flags: ULONG,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn NoRemoteImages(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoRemoteImages(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NoRemoteImages_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NoRemoteImages_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NoLowMandatoryLabelImages(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoLowMandatoryLabelImages(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NoLowMandatoryLabelImages_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NoLowMandatoryLabelImages_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PreferSystem32Images(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PreferSystem32Images(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PreferSystem32Images_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PreferSystem32Images_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AuditNoRemoteImages(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditNoRemoteImages(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AuditNoRemoteImages_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AuditNoRemoteImages_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AuditNoLowMandatoryLabelImages(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditNoLowMandatoryLabelImages(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AuditNoLowMandatoryLabelImages_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AuditNoLowMandatoryLabelImages_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReservedFlags_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                27u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                27u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NoRemoteImages: ULONG,
        NoLowMandatoryLabelImages: ULONG,
        PreferSystem32Images: ULONG,
        AuditNoRemoteImages: ULONG,
        AuditNoLowMandatoryLabelImages: ULONG,
        ReservedFlags: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let NoRemoteImages: u32 = unsafe { ::core::mem::transmute(NoRemoteImages) };
            NoRemoteImages as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let NoLowMandatoryLabelImages: u32 =
                unsafe { ::core::mem::transmute(NoLowMandatoryLabelImages) };
            NoLowMandatoryLabelImages as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PreferSystem32Images: u32 = unsafe { ::core::mem::transmute(PreferSystem32Images) };
            PreferSystem32Images as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AuditNoRemoteImages: u32 = unsafe { ::core::mem::transmute(AuditNoRemoteImages) };
            AuditNoRemoteImages as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let AuditNoLowMandatoryLabelImages: u32 =
                unsafe { ::core::mem::transmute(AuditNoLowMandatoryLabelImages) };
            AuditNoLowMandatoryLabelImages as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_IMAGE_LOAD_POLICY = _PROCESS_MITIGATION_IMAGE_LOAD_POLICY;
pub type PPROCESS_MITIGATION_IMAGE_LOAD_POLICY = *mut _PROCESS_MITIGATION_IMAGE_LOAD_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1 {
    pub Flags: ULONG,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn FilterId(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_FilterId(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FilterId_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FilterId_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReservedFlags_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                28u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                28u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FilterId: ULONG,
        ReservedFlags: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let FilterId: u32 = unsafe { ::core::mem::transmute(FilterId) };
            FilterId as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY =
_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY;
pub type PPROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY =
*mut _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1 {
    pub Flags: ULONG,
    pub __bindgen_anon_1:
        _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn EnableExportAddressFilter(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableExportAddressFilter(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EnableExportAddressFilter_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_EnableExportAddressFilter_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AuditExportAddressFilter(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditExportAddressFilter(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AuditExportAddressFilter_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AuditExportAddressFilter_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EnableExportAddressFilterPlus(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableExportAddressFilterPlus(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EnableExportAddressFilterPlus_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_EnableExportAddressFilterPlus_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AuditExportAddressFilterPlus(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditExportAddressFilterPlus(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AuditExportAddressFilterPlus_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AuditExportAddressFilterPlus_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EnableImportAddressFilter(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableImportAddressFilter(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EnableImportAddressFilter_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_EnableImportAddressFilter_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AuditImportAddressFilter(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditImportAddressFilter(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AuditImportAddressFilter_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AuditImportAddressFilter_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EnableRopStackPivot(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableRopStackPivot(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EnableRopStackPivot_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_EnableRopStackPivot_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AuditRopStackPivot(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditRopStackPivot(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AuditRopStackPivot_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AuditRopStackPivot_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EnableRopCallerCheck(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableRopCallerCheck(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EnableRopCallerCheck_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_EnableRopCallerCheck_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AuditRopCallerCheck(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditRopCallerCheck(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AuditRopCallerCheck_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AuditRopCallerCheck_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EnableRopSimExec(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableRopSimExec(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EnableRopSimExec_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_EnableRopSimExec_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AuditRopSimExec(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditRopSimExec(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AuditRopSimExec_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AuditRopSimExec_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReservedFlags_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                20u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                20u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EnableExportAddressFilter: ULONG,
        AuditExportAddressFilter: ULONG,
        EnableExportAddressFilterPlus: ULONG,
        AuditExportAddressFilterPlus: ULONG,
        EnableImportAddressFilter: ULONG,
        AuditImportAddressFilter: ULONG,
        EnableRopStackPivot: ULONG,
        AuditRopStackPivot: ULONG,
        EnableRopCallerCheck: ULONG,
        AuditRopCallerCheck: ULONG,
        EnableRopSimExec: ULONG,
        AuditRopSimExec: ULONG,
        ReservedFlags: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EnableExportAddressFilter: u32 =
                unsafe { ::core::mem::transmute(EnableExportAddressFilter) };
            EnableExportAddressFilter as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AuditExportAddressFilter: u32 =
                unsafe { ::core::mem::transmute(AuditExportAddressFilter) };
            AuditExportAddressFilter as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let EnableExportAddressFilterPlus: u32 =
                unsafe { ::core::mem::transmute(EnableExportAddressFilterPlus) };
            EnableExportAddressFilterPlus as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AuditExportAddressFilterPlus: u32 =
                unsafe { ::core::mem::transmute(AuditExportAddressFilterPlus) };
            AuditExportAddressFilterPlus as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let EnableImportAddressFilter: u32 =
                unsafe { ::core::mem::transmute(EnableImportAddressFilter) };
            EnableImportAddressFilter as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let AuditImportAddressFilter: u32 =
                unsafe { ::core::mem::transmute(AuditImportAddressFilter) };
            AuditImportAddressFilter as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let EnableRopStackPivot: u32 = unsafe { ::core::mem::transmute(EnableRopStackPivot) };
            EnableRopStackPivot as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let AuditRopStackPivot: u32 = unsafe { ::core::mem::transmute(AuditRopStackPivot) };
            AuditRopStackPivot as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let EnableRopCallerCheck: u32 = unsafe { ::core::mem::transmute(EnableRopCallerCheck) };
            EnableRopCallerCheck as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let AuditRopCallerCheck: u32 = unsafe { ::core::mem::transmute(AuditRopCallerCheck) };
            AuditRopCallerCheck as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let EnableRopSimExec: u32 = unsafe { ::core::mem::transmute(EnableRopSimExec) };
            EnableRopSimExec as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let AuditRopSimExec: u32 = unsafe { ::core::mem::transmute(AuditRopSimExec) };
            AuditRopSimExec as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY =
_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY;
pub type PPROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY =
*mut _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_CHILD_PROCESS_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1 {
    pub Flags: ULONG,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn NoChildProcessCreation(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoChildProcessCreation(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NoChildProcessCreation_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NoChildProcessCreation_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AuditNoChildProcessCreation(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditNoChildProcessCreation(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AuditNoChildProcessCreation_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AuditNoChildProcessCreation_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AllowSecureProcessCreation(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AllowSecureProcessCreation(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AllowSecureProcessCreation_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AllowSecureProcessCreation_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReservedFlags_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                29u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                29u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NoChildProcessCreation: ULONG,
        AuditNoChildProcessCreation: ULONG,
        AllowSecureProcessCreation: ULONG,
        ReservedFlags: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let NoChildProcessCreation: u32 =
                unsafe { ::core::mem::transmute(NoChildProcessCreation) };
            NoChildProcessCreation as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AuditNoChildProcessCreation: u32 =
                unsafe { ::core::mem::transmute(AuditNoChildProcessCreation) };
            AuditNoChildProcessCreation as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let AllowSecureProcessCreation: u32 =
                unsafe { ::core::mem::transmute(AllowSecureProcessCreation) };
            AllowSecureProcessCreation as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_CHILD_PROCESS_POLICY = _PROCESS_MITIGATION_CHILD_PROCESS_POLICY;
pub type PPROCESS_MITIGATION_CHILD_PROCESS_POLICY = *mut _PROCESS_MITIGATION_CHILD_PROCESS_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1 {
    pub Flags: ULONG,
    pub __bindgen_anon_1:
        _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn SmtBranchTargetIsolation(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SmtBranchTargetIsolation(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SmtBranchTargetIsolation_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SmtBranchTargetIsolation_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IsolateSecurityDomain(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsolateSecurityDomain(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IsolateSecurityDomain_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IsolateSecurityDomain_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DisablePageCombine(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisablePageCombine(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DisablePageCombine_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DisablePageCombine_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SpeculativeStoreBypassDisable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SpeculativeStoreBypassDisable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SpeculativeStoreBypassDisable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SpeculativeStoreBypassDisable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RestrictCoreSharing(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RestrictCoreSharing(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RestrictCoreSharing_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RestrictCoreSharing_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReservedFlags_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                27u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                27u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SmtBranchTargetIsolation: ULONG,
        IsolateSecurityDomain: ULONG,
        DisablePageCombine: ULONG,
        SpeculativeStoreBypassDisable: ULONG,
        RestrictCoreSharing: ULONG,
        ReservedFlags: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SmtBranchTargetIsolation: u32 =
                unsafe { ::core::mem::transmute(SmtBranchTargetIsolation) };
            SmtBranchTargetIsolation as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let IsolateSecurityDomain: u32 =
                unsafe { ::core::mem::transmute(IsolateSecurityDomain) };
            IsolateSecurityDomain as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DisablePageCombine: u32 = unsafe { ::core::mem::transmute(DisablePageCombine) };
            DisablePageCombine as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SpeculativeStoreBypassDisable: u32 =
                unsafe { ::core::mem::transmute(SpeculativeStoreBypassDisable) };
            SpeculativeStoreBypassDisable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let RestrictCoreSharing: u32 = unsafe { ::core::mem::transmute(RestrictCoreSharing) };
            RestrictCoreSharing as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY =
_PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY;
pub type PPROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY =
*mut _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1 {
    pub Flags: ULONG,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn EnableUserShadowStack(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableUserShadowStack(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EnableUserShadowStack_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_EnableUserShadowStack_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AuditUserShadowStack(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditUserShadowStack(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AuditUserShadowStack_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AuditUserShadowStack_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SetContextIpValidation(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SetContextIpValidation(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SetContextIpValidation_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SetContextIpValidation_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AuditSetContextIpValidation(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditSetContextIpValidation(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AuditSetContextIpValidation_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AuditSetContextIpValidation_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EnableUserShadowStackStrictMode(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableUserShadowStackStrictMode(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EnableUserShadowStackStrictMode_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_EnableUserShadowStackStrictMode_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn BlockNonCetBinaries(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BlockNonCetBinaries(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn BlockNonCetBinaries_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_BlockNonCetBinaries_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn BlockNonCetBinariesNonEhcont(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BlockNonCetBinariesNonEhcont(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn BlockNonCetBinariesNonEhcont_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_BlockNonCetBinariesNonEhcont_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AuditBlockNonCetBinaries(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditBlockNonCetBinaries(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AuditBlockNonCetBinaries_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AuditBlockNonCetBinaries_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CetDynamicApisOutOfProcOnly(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CetDynamicApisOutOfProcOnly(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CetDynamicApisOutOfProcOnly_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CetDynamicApisOutOfProcOnly_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SetContextIpValidationRelaxedMode(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SetContextIpValidationRelaxedMode(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SetContextIpValidationRelaxedMode_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SetContextIpValidationRelaxedMode_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReservedFlags_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                22u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                22u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EnableUserShadowStack: ULONG,
        AuditUserShadowStack: ULONG,
        SetContextIpValidation: ULONG,
        AuditSetContextIpValidation: ULONG,
        EnableUserShadowStackStrictMode: ULONG,
        BlockNonCetBinaries: ULONG,
        BlockNonCetBinariesNonEhcont: ULONG,
        AuditBlockNonCetBinaries: ULONG,
        CetDynamicApisOutOfProcOnly: ULONG,
        SetContextIpValidationRelaxedMode: ULONG,
        ReservedFlags: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EnableUserShadowStack: u32 =
                unsafe { ::core::mem::transmute(EnableUserShadowStack) };
            EnableUserShadowStack as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AuditUserShadowStack: u32 = unsafe { ::core::mem::transmute(AuditUserShadowStack) };
            AuditUserShadowStack as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SetContextIpValidation: u32 =
                unsafe { ::core::mem::transmute(SetContextIpValidation) };
            SetContextIpValidation as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AuditSetContextIpValidation: u32 =
                unsafe { ::core::mem::transmute(AuditSetContextIpValidation) };
            AuditSetContextIpValidation as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let EnableUserShadowStackStrictMode: u32 =
                unsafe { ::core::mem::transmute(EnableUserShadowStackStrictMode) };
            EnableUserShadowStackStrictMode as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let BlockNonCetBinaries: u32 = unsafe { ::core::mem::transmute(BlockNonCetBinaries) };
            BlockNonCetBinaries as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let BlockNonCetBinariesNonEhcont: u32 =
                unsafe { ::core::mem::transmute(BlockNonCetBinariesNonEhcont) };
            BlockNonCetBinariesNonEhcont as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let AuditBlockNonCetBinaries: u32 =
                unsafe { ::core::mem::transmute(AuditBlockNonCetBinaries) };
            AuditBlockNonCetBinaries as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let CetDynamicApisOutOfProcOnly: u32 =
                unsafe { ::core::mem::transmute(CetDynamicApisOutOfProcOnly) };
            CetDynamicApisOutOfProcOnly as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let SetContextIpValidationRelaxedMode: u32 =
                unsafe { ::core::mem::transmute(SetContextIpValidationRelaxedMode) };
            SetContextIpValidationRelaxedMode as u64
        });
        __bindgen_bitfield_unit.set(10usize, 22u8, {
            let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY = _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY;
pub type PPROCESS_MITIGATION_USER_SHADOW_STACK_POLICY =
*mut _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1 {
    pub Flags: ULONG,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn EnablePointerAuthUserIp(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnablePointerAuthUserIp(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EnablePointerAuthUserIp_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_EnablePointerAuthUserIp_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReservedFlags_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EnablePointerAuthUserIp: ULONG,
        ReservedFlags: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EnablePointerAuthUserIp: u32 =
                unsafe { ::core::mem::transmute(EnablePointerAuthUserIp) };
            EnablePointerAuthUserIp as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY = _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY;
pub type PPROCESS_MITIGATION_USER_POINTER_AUTH_POLICY =
*mut _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1 {
    pub Flags: ULONG,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn EnforceRedirectionTrust(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnforceRedirectionTrust(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EnforceRedirectionTrust_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_EnforceRedirectionTrust_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AuditRedirectionTrust(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditRedirectionTrust(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AuditRedirectionTrust_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AuditRedirectionTrust_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReservedFlags_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EnforceRedirectionTrust: ULONG,
        AuditRedirectionTrust: ULONG,
        ReservedFlags: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EnforceRedirectionTrust: u32 =
                unsafe { ::core::mem::transmute(EnforceRedirectionTrust) };
            EnforceRedirectionTrust as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AuditRedirectionTrust: u32 =
                unsafe { ::core::mem::transmute(AuditRedirectionTrust) };
            AuditRedirectionTrust as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY = _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY;
pub type PPROCESS_MITIGATION_REDIRECTION_TRUST_POLICY =
*mut _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_ACTIVATION_CONTEXT_TRUST_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_ACTIVATION_CONTEXT_TRUST_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_ACTIVATION_CONTEXT_TRUST_POLICY__bindgen_ty_1 {
    pub Flags: ULONG,
    pub __bindgen_anon_1:
        _PROCESS_MITIGATION_ACTIVATION_CONTEXT_TRUST_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_ACTIVATION_CONTEXT_TRUST_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_ACTIVATION_CONTEXT_TRUST_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn AssemblyManifestRedirectionTrust(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AssemblyManifestRedirectionTrust(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AssemblyManifestRedirectionTrust_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AssemblyManifestRedirectionTrust_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReservedFlags_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AssemblyManifestRedirectionTrust: ULONG,
        ReservedFlags: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let AssemblyManifestRedirectionTrust: u32 =
                unsafe { ::core::mem::transmute(AssemblyManifestRedirectionTrust) };
            AssemblyManifestRedirectionTrust as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_ACTIVATION_CONTEXT_TRUST_POLICY =
_PROCESS_MITIGATION_ACTIVATION_CONTEXT_TRUST_POLICY;
pub type PPROCESS_MITIGATION_ACTIVATION_CONTEXT_TRUST_POLICY =
*mut _PROCESS_MITIGATION_ACTIVATION_CONTEXT_TRUST_POLICY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_KEEPALIVE_COUNT_INFORMATION {
    pub WakeCount: ULONG,
    pub NoWakeCount: ULONG,
}
pub type PROCESS_KEEPALIVE_COUNT_INFORMATION = _PROCESS_KEEPALIVE_COUNT_INFORMATION;
pub type PPROCESS_KEEPALIVE_COUNT_INFORMATION = *mut _PROCESS_KEEPALIVE_COUNT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_REVOKE_FILE_HANDLES_INFORMATION {
    pub TargetDevicePath: UNICODE_STRING,
}
pub type PROCESS_REVOKE_FILE_HANDLES_INFORMATION = _PROCESS_REVOKE_FILE_HANDLES_INFORMATION;
pub type PPROCESS_REVOKE_FILE_HANDLES_INFORMATION = *mut _PROCESS_REVOKE_FILE_HANDLES_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POOLED_USAGE_AND_LIMITS {
    pub PeakPagedPoolUsage: SIZE_T,
    pub PagedPoolUsage: SIZE_T,
    pub PagedPoolLimit: SIZE_T,
    pub PeakNonPagedPoolUsage: SIZE_T,
    pub NonPagedPoolUsage: SIZE_T,
    pub NonPagedPoolLimit: SIZE_T,
    pub PeakPagefileUsage: SIZE_T,
    pub PagefileUsage: SIZE_T,
    pub PagefileLimit: SIZE_T,
}
pub type POOLED_USAGE_AND_LIMITS = _POOLED_USAGE_AND_LIMITS;
pub type PPOOLED_USAGE_AND_LIMITS = *mut POOLED_USAGE_AND_LIMITS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_ACCESS_TOKEN {
    pub Token: HANDLE,
    pub Thread: HANDLE,
}
pub type PROCESS_ACCESS_TOKEN = _PROCESS_ACCESS_TOKEN;
pub type PPROCESS_ACCESS_TOKEN = *mut _PROCESS_ACCESS_TOKEN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_EXCEPTION_PORT {
    pub ExceptionPortHandle: HANDLE,
    pub StateFlags: ULONG,
}
pub type PROCESS_EXCEPTION_PORT = _PROCESS_EXCEPTION_PORT;
pub type PPROCESS_EXCEPTION_PORT = *mut _PROCESS_EXCEPTION_PORT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KERNEL_USER_TIMES {
    pub CreateTime: LARGE_INTEGER,
    pub ExitTime: LARGE_INTEGER,
    pub KernelTime: LARGE_INTEGER,
    pub UserTime: LARGE_INTEGER,
}
pub type KERNEL_USER_TIMES = _KERNEL_USER_TIMES;
pub type PKERNEL_USER_TIMES = *mut KERNEL_USER_TIMES;
pub const _SUBSYSTEM_INFORMATION_TYPE_SubsystemInformationTypeWin32: _SUBSYSTEM_INFORMATION_TYPE =
    0;
pub const _SUBSYSTEM_INFORMATION_TYPE_SubsystemInformationTypeWSL: _SUBSYSTEM_INFORMATION_TYPE = 1;
pub const _SUBSYSTEM_INFORMATION_TYPE_MaxSubsystemInformationType: _SUBSYSTEM_INFORMATION_TYPE = 2;
pub type _SUBSYSTEM_INFORMATION_TYPE = core::ffi::c_int;
pub use self::_SUBSYSTEM_INFORMATION_TYPE as SUBSYSTEM_INFORMATION_TYPE;
pub type PSUBSYSTEM_INFORMATION_TYPE = *mut _SUBSYSTEM_INFORMATION_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_THROTTLING_PROCESS_STATE {
    pub Version: ULONG,
    pub ControlMask: ULONG,
    pub StateMask: ULONG,
}
pub type POWER_THROTTLING_PROCESS_STATE = _POWER_THROTTLING_PROCESS_STATE;
pub type PPOWER_THROTTLING_PROCESS_STATE = *mut _POWER_THROTTLING_PROCESS_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_THROTTLING_THREAD_STATE {
    pub Version: ULONG,
    pub ControlMask: ULONG,
    pub StateMask: ULONG,
}
pub type POWER_THROTTLING_THREAD_STATE = _POWER_THROTTLING_THREAD_STATE;
pub type PPOWER_THROTTLING_THREAD_STATE = *mut _POWER_THROTTLING_THREAD_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_SYSCALL_PROVIDER_INFORMATION {
    pub ProviderId: GUID,
    pub Level: UCHAR,
}
pub type PROCESS_SYSCALL_PROVIDER_INFORMATION = _PROCESS_SYSCALL_PROVIDER_INFORMATION;
pub type PPROCESS_SYSCALL_PROVIDER_INFORMATION = *mut _PROCESS_SYSCALL_PROVIDER_INFORMATION;
unsafe extern "C" {
    pub fn NtOpenProcess(
        ProcessHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        ClientId: PCLIENT_ID,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KPCR {
    pub __bindgen_anon_1: _KPCR__bindgen_ty_1,
    pub IdtBase: *mut _KIDTENTRY64,
    pub Unused: [ULONG64; 2usize],
    pub Irql: KIRQL,
    pub SecondLevelCacheAssociativity: UCHAR,
    pub ObsoleteNumber: UCHAR,
    pub Fill0: UCHAR,
    pub Unused0: [ULONG; 3usize],
    pub MajorVersion: USHORT,
    pub MinorVersion: USHORT,
    pub StallScaleFactor: ULONG,
    pub Unused1: [PVOID; 3usize],
    pub KernelReserved: [ULONG; 15usize],
    pub SecondLevelCacheSize: ULONG,
    pub HalReserved: [ULONG; 16usize],
    pub Unused2: ULONG,
    pub KdVersionBlock: PVOID,
    pub Unused3: PVOID,
    pub PcrAlign1: [ULONG; 24usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KPCR__bindgen_ty_1 {
    pub NtTib: NT_TIB,
    pub __bindgen_anon_1: _KPCR__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KPCR__bindgen_ty_1__bindgen_ty_1 {
    pub GdtBase: *mut _KGDTENTRY64,
    pub TssBase: *mut _KTSS64,
    pub UserRsp: ULONG64,
    pub Self_: *mut _KPCR,
    pub CurrentPrcb: *mut _KPRCB,
    pub LockArray: PKSPIN_LOCK_QUEUE,
    pub Used_Self: PVOID,
}
pub type KPCR = _KPCR;
pub type PKPCR = *mut _KPCR;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _KEXCEPTION_FRAME {
    pub P1Home: ULONG64,
    pub P2Home: ULONG64,
    pub P3Home: ULONG64,
    pub P4Home: ULONG64,
    pub P5: ULONG64,
    pub Spare1: ULONG64,
    pub Xmm6: M128A,
    pub Xmm7: M128A,
    pub Xmm8: M128A,
    pub Xmm9: M128A,
    pub Xmm10: M128A,
    pub Xmm11: M128A,
    pub Xmm12: M128A,
    pub Xmm13: M128A,
    pub Xmm14: M128A,
    pub Xmm15: M128A,
    pub TrapFrame: ULONG64,
    pub OutputBuffer: ULONG64,
    pub OutputLength: ULONG64,
    pub Spare2: ULONG64,
    pub MxCsr: ULONG64,
    pub Rbp: ULONG64,
    pub Rbx: ULONG64,
    pub Rdi: ULONG64,
    pub Rsi: ULONG64,
    pub R12: ULONG64,
    pub R13: ULONG64,
    pub R14: ULONG64,
    pub R15: ULONG64,
    pub Return: ULONG64,
}
pub type KEXCEPTION_FRAME = _KEXCEPTION_FRAME;
pub type PKEXCEPTION_FRAME = *mut _KEXCEPTION_FRAME;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _KTRAP_FRAME {
    pub P1Home: ULONG64,
    pub P2Home: ULONG64,
    pub P3Home: ULONG64,
    pub P4Home: ULONG64,
    pub P5: ULONG64,
    pub PreviousMode: KPROCESSOR_MODE,
    pub PreviousIrql: KIRQL,
    pub FaultIndicator: UCHAR,
    pub ExceptionActive: UCHAR,
    pub MxCsr: ULONG,
    pub Rax: ULONG64,
    pub Rcx: ULONG64,
    pub Rdx: ULONG64,
    pub R8: ULONG64,
    pub R9: ULONG64,
    pub R10: ULONG64,
    pub R11: ULONG64,
    pub __bindgen_anon_1: _KTRAP_FRAME__bindgen_ty_1,
    pub Xmm0: M128A,
    pub Xmm1: M128A,
    pub Xmm2: M128A,
    pub Xmm3: M128A,
    pub Xmm4: M128A,
    pub Xmm5: M128A,
    pub __bindgen_anon_2: _KTRAP_FRAME__bindgen_ty_2,
    pub __bindgen_anon_3: _KTRAP_FRAME__bindgen_ty_3,
    pub __bindgen_anon_4: _KTRAP_FRAME__bindgen_ty_4,
    pub SegDs: USHORT,
    pub SegEs: USHORT,
    pub SegFs: USHORT,
    pub SegGs: USHORT,
    pub TrapFrame: ULONG64,
    pub Rbx: ULONG64,
    pub Rdi: ULONG64,
    pub Rsi: ULONG64,
    pub Rbp: ULONG64,
    pub __bindgen_anon_5: _KTRAP_FRAME__bindgen_ty_5,
    pub Rip: ULONG64,
    pub SegCs: USHORT,
    pub Fill0: UCHAR,
    pub Logging: UCHAR,
    pub Fill1: [USHORT; 2usize],
    pub EFlags: ULONG,
    pub Fill2: ULONG,
    pub Rsp: ULONG64,
    pub SegSs: USHORT,
    pub Fill3: USHORT,
    pub Fill4: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTRAP_FRAME__bindgen_ty_1 {
    pub GsBase: ULONG64,
    pub GsSwap: ULONG64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTRAP_FRAME__bindgen_ty_2 {
    pub FaultAddress: ULONG64,
    pub ContextRecord: ULONG64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTRAP_FRAME__bindgen_ty_3 {
    pub __bindgen_anon_1: _KTRAP_FRAME__bindgen_ty_3__bindgen_ty_1,
    pub __bindgen_anon_2: _KTRAP_FRAME__bindgen_ty_3__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTRAP_FRAME__bindgen_ty_3__bindgen_ty_1 {
    pub Dr0: ULONG64,
    pub Dr1: ULONG64,
    pub Dr2: ULONG64,
    pub Dr3: ULONG64,
    pub Dr6: ULONG64,
    pub Dr7: ULONG64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTRAP_FRAME__bindgen_ty_3__bindgen_ty_2 {
    pub ShadowStackFrame: ULONG64,
    pub Spare: [ULONG64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTRAP_FRAME__bindgen_ty_4 {
    pub DebugControl: ULONG64,
    pub LastBranchToRip: ULONG64,
    pub LastBranchFromRip: ULONG64,
    pub LastExceptionToRip: ULONG64,
    pub LastExceptionFromRip: ULONG64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KTRAP_FRAME__bindgen_ty_5 {
    pub ErrorCode: ULONG64,
    pub ExceptionFrame: ULONG64,
}
pub type KTRAP_FRAME = _KTRAP_FRAME;
pub type PKTRAP_FRAME = *mut _KTRAP_FRAME;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KUMS_CONTEXT_HEADER {
    pub P1Home: ULONG64,
    pub P2Home: ULONG64,
    pub P3Home: ULONG64,
    pub P4Home: ULONG64,
    pub StackTop: PVOID,
    pub StackSize: ULONG64,
    pub RspOffset: ULONG64,
    pub Rip: ULONG64,
    pub FltSave: PXMM_SAVE_AREA32,
    pub __bindgen_anon_1: _KUMS_CONTEXT_HEADER__bindgen_ty_1,
    pub TrapFrame: PKTRAP_FRAME,
    pub ExceptionFrame: PKEXCEPTION_FRAME,
    pub SourceThread: *mut _KTHREAD,
    pub Return: ULONG64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KUMS_CONTEXT_HEADER__bindgen_ty_1 {
    pub __bindgen_anon_1: _KUMS_CONTEXT_HEADER__bindgen_ty_1__bindgen_ty_1,
    pub Flags: ULONG64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KUMS_CONTEXT_HEADER__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _KUMS_CONTEXT_HEADER__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Volatile(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Volatile(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Volatile_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Volatile_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 63u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 63u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                63u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                63u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Volatile: ULONG64,
        Reserved: ULONG64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Volatile: u64 = unsafe { ::core::mem::transmute(Volatile) };
            Volatile as u64
        });
        __bindgen_bitfield_unit.set(1usize, 63u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type KUMS_CONTEXT_HEADER = _KUMS_CONTEXT_HEADER;
pub type PKUMS_CONTEXT_HEADER = *mut _KUMS_CONTEXT_HEADER;
unsafe extern "C" {
    pub static mut KeLastBranchMSR: ULONG;
}
unsafe extern "C" {
    pub static MmHighestUserAddress: PVOID;
}
unsafe extern "C" {
    pub static MmSystemRangeStart: PVOID;
}
unsafe extern "C" {
    pub static MmUserProbeAddress: ULONG64;
}
pub const _INTERLOCKED_RESULT_ResultNegative: _INTERLOCKED_RESULT = 1;
pub const _INTERLOCKED_RESULT_ResultZero: _INTERLOCKED_RESULT = 0;
pub const _INTERLOCKED_RESULT_ResultPositive: _INTERLOCKED_RESULT = 2;
pub type _INTERLOCKED_RESULT = core::ffi::c_int;
pub use self::_INTERLOCKED_RESULT as INTERLOCKED_RESULT;
pub const _SYSTEM_FIRMWARE_TABLE_ACTION_SystemFirmwareTable_Enumerate:
_SYSTEM_FIRMWARE_TABLE_ACTION = 0;
pub const _SYSTEM_FIRMWARE_TABLE_ACTION_SystemFirmwareTable_Get: _SYSTEM_FIRMWARE_TABLE_ACTION = 1;
pub type _SYSTEM_FIRMWARE_TABLE_ACTION = core::ffi::c_int;
pub use self::_SYSTEM_FIRMWARE_TABLE_ACTION as SYSTEM_FIRMWARE_TABLE_ACTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_FIRMWARE_TABLE_INFORMATION {
    pub ProviderSignature: ULONG,
    pub Action: SYSTEM_FIRMWARE_TABLE_ACTION,
    pub TableID: ULONG,
    pub TableBufferLength: ULONG,
    pub TableBuffer: [UCHAR; 1usize],
}
pub type SYSTEM_FIRMWARE_TABLE_INFORMATION = _SYSTEM_FIRMWARE_TABLE_INFORMATION;
pub type PSYSTEM_FIRMWARE_TABLE_INFORMATION = *mut _SYSTEM_FIRMWARE_TABLE_INFORMATION;
pub type PFNFTH = ::core::option::Option<
    unsafe extern "C" fn(SystemFirmwareTableInfo: PSYSTEM_FIRMWARE_TABLE_INFORMATION) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_FIRMWARE_TABLE_HANDLER {
    pub ProviderSignature: ULONG,
    pub Register: BOOLEAN,
    pub FirmwareTableHandler: PFNFTH,
    pub DriverObject: PVOID,
}
pub type SYSTEM_FIRMWARE_TABLE_HANDLER = _SYSTEM_FIRMWARE_TABLE_HANDLER;
pub type PSYSTEM_FIRMWARE_TABLE_HANDLER = *mut _SYSTEM_FIRMWARE_TABLE_HANDLER;
pub type PTIMER_APC_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(TimerContext: PVOID, TimerLowValue: ULONG, TimerHighValue: LONG),
>;
pub const _TIMER_SET_INFORMATION_CLASS_TimerSetCoalescableTimer: _TIMER_SET_INFORMATION_CLASS = 0;
pub const _TIMER_SET_INFORMATION_CLASS_MaxTimerInfoClass: _TIMER_SET_INFORMATION_CLASS = 1;
pub type _TIMER_SET_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_TIMER_SET_INFORMATION_CLASS as TIMER_SET_INFORMATION_CLASS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TIMER_SET_COALESCABLE_TIMER_INFO {
    pub DueTime: LARGE_INTEGER,
    pub TimerApcRoutine: PTIMER_APC_ROUTINE,
    pub TimerContext: PVOID,
    pub WakeContext: *mut _COUNTED_REASON_CONTEXT,
    pub Period: ULONG,
    pub TolerableDelay: ULONG,
    pub PreviousState: PBOOLEAN,
}
pub type TIMER_SET_COALESCABLE_TIMER_INFO = _TIMER_SET_COALESCABLE_TIMER_INFO;
pub type PTIMER_SET_COALESCABLE_TIMER_INFO = *mut _TIMER_SET_COALESCABLE_TIMER_INFO;
pub type PDRIVER_VERIFIER_THUNK_ROUTINE =
::core::option::Option<unsafe extern "C" fn(Context: PVOID) -> ULONG_PTR>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVER_VERIFIER_THUNK_PAIRS {
    pub PristineRoutine: PDRIVER_VERIFIER_THUNK_ROUTINE,
    pub NewRoutine: PDRIVER_VERIFIER_THUNK_ROUTINE,
}
pub type DRIVER_VERIFIER_THUNK_PAIRS = _DRIVER_VERIFIER_THUNK_PAIRS;
pub type PDRIVER_VERIFIER_THUNK_PAIRS = *mut _DRIVER_VERIFIER_THUNK_PAIRS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XSTATE_FEATURE {
    pub Offset: ULONG,
    pub Size: ULONG,
}
pub type XSTATE_FEATURE = _XSTATE_FEATURE;
pub type PXSTATE_FEATURE = *mut _XSTATE_FEATURE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XSTATE_CONFIGURATION {
    pub EnabledFeatures: ULONG64,
    pub EnabledVolatileFeatures: ULONG64,
    pub Size: ULONG,
    pub __bindgen_anon_1: _XSTATE_CONFIGURATION__bindgen_ty_1,
    pub Features: [XSTATE_FEATURE; 64usize],
    pub EnabledSupervisorFeatures: ULONG64,
    pub AlignedFeatures: ULONG64,
    pub AllFeatureSize: ULONG,
    pub AllFeatures: [ULONG; 64usize],
    pub EnabledUserVisibleSupervisorFeatures: ULONG64,
    pub ExtendedFeatureDisableFeatures: ULONG64,
    pub AllNonLargeFeatureSize: ULONG,
    pub Spare: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _XSTATE_CONFIGURATION__bindgen_ty_1 {
    pub ControlFlags: ULONG,
    pub __bindgen_anon_1: _XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn OptimizedSave(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OptimizedSave(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn OptimizedSave_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_OptimizedSave_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CompactionEnabled(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CompactionEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CompactionEnabled_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CompactionEnabled_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ExtendedFeatureDisable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExtendedFeatureDisable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ExtendedFeatureDisable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ExtendedFeatureDisable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OptimizedSave: ULONG,
        CompactionEnabled: ULONG,
        ExtendedFeatureDisable: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let OptimizedSave: u32 = unsafe { ::core::mem::transmute(OptimizedSave) };
            OptimizedSave as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CompactionEnabled: u32 = unsafe { ::core::mem::transmute(CompactionEnabled) };
            CompactionEnabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ExtendedFeatureDisable: u32 =
                unsafe { ::core::mem::transmute(ExtendedFeatureDisable) };
            ExtendedFeatureDisable as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type XSTATE_CONFIGURATION = _XSTATE_CONFIGURATION;
pub type PXSTATE_CONFIGURATION = *mut _XSTATE_CONFIGURATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KUSER_SHARED_DATA {
    pub TickCountLowDeprecated: ULONG,
    pub TickCountMultiplier: ULONG,
    pub InterruptTime: KSYSTEM_TIME,
    pub SystemTime: KSYSTEM_TIME,
    pub TimeZoneBias: KSYSTEM_TIME,
    pub ImageNumberLow: USHORT,
    pub ImageNumberHigh: USHORT,
    pub NtSystemRoot: [WCHAR; 260usize],
    pub MaxStackTraceDepth: ULONG,
    pub CryptoExponent: ULONG,
    pub TimeZoneId: ULONG,
    pub LargePageMinimum: ULONG,
    pub AitSamplingValue: ULONG,
    pub AppCompatFlag: ULONG,
    pub RNGSeedVersion: ULONGLONG,
    pub GlobalValidationRunlevel: ULONG,
    pub TimeZoneBiasStamp: LONG,
    pub NtBuildNumber: ULONG,
    pub NtProductType: NT_PRODUCT_TYPE,
    pub ProductTypeIsValid: BOOLEAN,
    pub Reserved0: [BOOLEAN; 1usize],
    pub NativeProcessorArchitecture: USHORT,
    pub NtMajorVersion: ULONG,
    pub NtMinorVersion: ULONG,
    pub ProcessorFeatures: [BOOLEAN; 64usize],
    pub Reserved1: ULONG,
    pub Reserved3: ULONG,
    pub TimeSlip: ULONG,
    pub AlternativeArchitecture: ALTERNATIVE_ARCHITECTURE_TYPE,
    pub BootId: ULONG,
    pub SystemExpirationDate: LARGE_INTEGER,
    pub SuiteMask: ULONG,
    pub KdDebuggerEnabled: BOOLEAN,
    pub __bindgen_anon_1: _KUSER_SHARED_DATA__bindgen_ty_1,
    pub CyclesPerYield: USHORT,
    pub ActiveConsoleId: ULONG,
    pub DismountCount: ULONG,
    pub ComPlusPackage: ULONG,
    pub LastSystemRITEventTickCount: ULONG,
    pub NumberOfPhysicalPages: ULONG,
    pub SafeBootMode: BOOLEAN,
    pub __bindgen_anon_2: _KUSER_SHARED_DATA__bindgen_ty_2,
    pub Reserved12: [UCHAR; 2usize],
    pub __bindgen_anon_3: _KUSER_SHARED_DATA__bindgen_ty_3,
    pub DataFlagsPad: [ULONG; 1usize],
    pub TestRetInstruction: ULONGLONG,
    pub QpcFrequency: LONGLONG,
    pub SystemCall: ULONG,
    pub Reserved2: ULONG,
    pub SystemCallPad: [ULONGLONG; 2usize],
    pub __bindgen_anon_4: _KUSER_SHARED_DATA__bindgen_ty_4,
    pub Cookie: ULONG,
    pub CookiePad: [ULONG; 1usize],
    pub ConsoleSessionForegroundProcessId: LONGLONG,
    pub TimeUpdateLock: ULONGLONG,
    pub BaselineSystemTimeQpc: ULONGLONG,
    pub BaselineInterruptTimeQpc: ULONGLONG,
    pub QpcSystemTimeIncrement: ULONGLONG,
    pub QpcInterruptTimeIncrement: ULONGLONG,
    pub QpcSystemTimeIncrementShift: UCHAR,
    pub QpcInterruptTimeIncrementShift: UCHAR,
    pub UnparkedProcessorCount: USHORT,
    pub EnclaveFeatureMask: [ULONG; 4usize],
    pub TelemetryCoverageRound: ULONG,
    pub UserModeGlobalLogger: [USHORT; 16usize],
    pub ImageFileExecutionOptions: ULONG,
    pub LangGenerationCount: ULONG,
    pub Reserved4: ULONGLONG,
    pub InterruptTimeBias: ULONGLONG,
    pub QpcBias: ULONGLONG,
    pub ActiveProcessorCount: ULONG,
    pub ActiveGroupCount: UCHAR,
    pub Reserved9: UCHAR,
    pub __bindgen_anon_5: _KUSER_SHARED_DATA__bindgen_ty_5,
    pub TimeZoneBiasEffectiveStart: LARGE_INTEGER,
    pub TimeZoneBiasEffectiveEnd: LARGE_INTEGER,
    pub XState: XSTATE_CONFIGURATION,
    pub FeatureConfigurationChangeStamp: KSYSTEM_TIME,
    pub Spare: ULONG,
    pub UserPointerAuthMask: ULONG64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KUSER_SHARED_DATA__bindgen_ty_1 {
    pub MitigationPolicies: UCHAR,
    pub __bindgen_anon_1: _KUSER_SHARED_DATA__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KUSER_SHARED_DATA__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _KUSER_SHARED_DATA__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn NXSupportPolicy(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_NXSupportPolicy(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NXSupportPolicy_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_NXSupportPolicy_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SEHValidationPolicy(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_SEHValidationPolicy(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SEHValidationPolicy_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_SEHValidationPolicy_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CurDirDevicesSkippedForDlls(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_CurDirDevicesSkippedForDlls(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CurDirDevicesSkippedForDlls_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_CurDirDevicesSkippedForDlls_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NXSupportPolicy: UCHAR,
        SEHValidationPolicy: UCHAR,
        CurDirDevicesSkippedForDlls: UCHAR,
        Reserved: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let NXSupportPolicy: u8 = unsafe { ::core::mem::transmute(NXSupportPolicy) };
            NXSupportPolicy as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let SEHValidationPolicy: u8 = unsafe { ::core::mem::transmute(SEHValidationPolicy) };
            SEHValidationPolicy as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let CurDirDevicesSkippedForDlls: u8 =
                unsafe { ::core::mem::transmute(CurDirDevicesSkippedForDlls) };
            CurDirDevicesSkippedForDlls as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let Reserved: u8 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KUSER_SHARED_DATA__bindgen_ty_2 {
    pub VirtualizationFlags: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KUSER_SHARED_DATA__bindgen_ty_3 {
    pub SharedDataFlags: ULONG,
    pub __bindgen_anon_1: _KUSER_SHARED_DATA__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KUSER_SHARED_DATA__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KUSER_SHARED_DATA__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn DbgErrorPortPresent(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgErrorPortPresent(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DbgErrorPortPresent_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DbgErrorPortPresent_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DbgElevationEnabled(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgElevationEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DbgElevationEnabled_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DbgElevationEnabled_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DbgVirtEnabled(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgVirtEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DbgVirtEnabled_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DbgVirtEnabled_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DbgInstallerDetectEnabled(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgInstallerDetectEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DbgInstallerDetectEnabled_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DbgInstallerDetectEnabled_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DbgLkgEnabled(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgLkgEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DbgLkgEnabled_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DbgLkgEnabled_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DbgDynProcessorEnabled(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgDynProcessorEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DbgDynProcessorEnabled_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DbgDynProcessorEnabled_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DbgConsoleBrokerEnabled(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgConsoleBrokerEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DbgConsoleBrokerEnabled_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DbgConsoleBrokerEnabled_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DbgSecureBootEnabled(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgSecureBootEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DbgSecureBootEnabled_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DbgSecureBootEnabled_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DbgMultiSessionSku(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgMultiSessionSku(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DbgMultiSessionSku_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DbgMultiSessionSku_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DbgMultiUsersInSessionSku(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgMultiUsersInSessionSku(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DbgMultiUsersInSessionSku_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DbgMultiUsersInSessionSku_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DbgStateSeparationEnabled(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DbgStateSeparationEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DbgStateSeparationEnabled_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DbgStateSeparationEnabled_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SpareBits(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_SpareBits(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SpareBits_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                21u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SpareBits_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                21u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DbgErrorPortPresent: ULONG,
        DbgElevationEnabled: ULONG,
        DbgVirtEnabled: ULONG,
        DbgInstallerDetectEnabled: ULONG,
        DbgLkgEnabled: ULONG,
        DbgDynProcessorEnabled: ULONG,
        DbgConsoleBrokerEnabled: ULONG,
        DbgSecureBootEnabled: ULONG,
        DbgMultiSessionSku: ULONG,
        DbgMultiUsersInSessionSku: ULONG,
        DbgStateSeparationEnabled: ULONG,
        SpareBits: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DbgErrorPortPresent: u32 = unsafe { ::core::mem::transmute(DbgErrorPortPresent) };
            DbgErrorPortPresent as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DbgElevationEnabled: u32 = unsafe { ::core::mem::transmute(DbgElevationEnabled) };
            DbgElevationEnabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DbgVirtEnabled: u32 = unsafe { ::core::mem::transmute(DbgVirtEnabled) };
            DbgVirtEnabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DbgInstallerDetectEnabled: u32 =
                unsafe { ::core::mem::transmute(DbgInstallerDetectEnabled) };
            DbgInstallerDetectEnabled as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let DbgLkgEnabled: u32 = unsafe { ::core::mem::transmute(DbgLkgEnabled) };
            DbgLkgEnabled as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DbgDynProcessorEnabled: u32 =
                unsafe { ::core::mem::transmute(DbgDynProcessorEnabled) };
            DbgDynProcessorEnabled as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let DbgConsoleBrokerEnabled: u32 =
                unsafe { ::core::mem::transmute(DbgConsoleBrokerEnabled) };
            DbgConsoleBrokerEnabled as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let DbgSecureBootEnabled: u32 = unsafe { ::core::mem::transmute(DbgSecureBootEnabled) };
            DbgSecureBootEnabled as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let DbgMultiSessionSku: u32 = unsafe { ::core::mem::transmute(DbgMultiSessionSku) };
            DbgMultiSessionSku as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let DbgMultiUsersInSessionSku: u32 =
                unsafe { ::core::mem::transmute(DbgMultiUsersInSessionSku) };
            DbgMultiUsersInSessionSku as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let DbgStateSeparationEnabled: u32 =
                unsafe { ::core::mem::transmute(DbgStateSeparationEnabled) };
            DbgStateSeparationEnabled as u64
        });
        __bindgen_bitfield_unit.set(11usize, 21u8, {
            let SpareBits: u32 = unsafe { ::core::mem::transmute(SpareBits) };
            SpareBits as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KUSER_SHARED_DATA__bindgen_ty_4 {
    pub TickCount: KSYSTEM_TIME,
    pub TickCountQuad: ULONG64,
    pub __bindgen_anon_1: _KUSER_SHARED_DATA__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KUSER_SHARED_DATA__bindgen_ty_4__bindgen_ty_1 {
    pub ReservedTickCountOverlay: [ULONG; 3usize],
    pub TickCountPad: [ULONG; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KUSER_SHARED_DATA__bindgen_ty_5 {
    pub QpcData: USHORT,
    pub __bindgen_anon_1: _KUSER_SHARED_DATA__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KUSER_SHARED_DATA__bindgen_ty_5__bindgen_ty_1 {
    pub QpcBypassEnabled: UCHAR,
    pub QpcShift: UCHAR,
}
pub type KUSER_SHARED_DATA = _KUSER_SHARED_DATA;
pub type PKUSER_SHARED_DATA = *mut _KUSER_SHARED_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PCCARD_DEVICE_DATA {
    pub Flags: UCHAR,
    pub ErrorCode: UCHAR,
    pub Reserved: USHORT,
    pub BusData: ULONG,
    pub DeviceId: ULONG,
    pub LegacyBaseAddress: ULONG,
    pub IRQMap: [UCHAR; 16usize],
}
pub type CM_PCCARD_DEVICE_DATA = _CM_PCCARD_DEVICE_DATA;
pub type PCM_PCCARD_DEVICE_DATA = *mut _CM_PCCARD_DEVICE_DATA;
pub const _CONFIGURATION_TYPE_ArcSystem: _CONFIGURATION_TYPE = 0;
pub const _CONFIGURATION_TYPE_CentralProcessor: _CONFIGURATION_TYPE = 1;
pub const _CONFIGURATION_TYPE_FloatingPointProcessor: _CONFIGURATION_TYPE = 2;
pub const _CONFIGURATION_TYPE_PrimaryIcache: _CONFIGURATION_TYPE = 3;
pub const _CONFIGURATION_TYPE_PrimaryDcache: _CONFIGURATION_TYPE = 4;
pub const _CONFIGURATION_TYPE_SecondaryIcache: _CONFIGURATION_TYPE = 5;
pub const _CONFIGURATION_TYPE_SecondaryDcache: _CONFIGURATION_TYPE = 6;
pub const _CONFIGURATION_TYPE_SecondaryCache: _CONFIGURATION_TYPE = 7;
pub const _CONFIGURATION_TYPE_EisaAdapter: _CONFIGURATION_TYPE = 8;
pub const _CONFIGURATION_TYPE_TcAdapter: _CONFIGURATION_TYPE = 9;
pub const _CONFIGURATION_TYPE_ScsiAdapter: _CONFIGURATION_TYPE = 10;
pub const _CONFIGURATION_TYPE_DtiAdapter: _CONFIGURATION_TYPE = 11;
pub const _CONFIGURATION_TYPE_MultiFunctionAdapter: _CONFIGURATION_TYPE = 12;
pub const _CONFIGURATION_TYPE_DiskController: _CONFIGURATION_TYPE = 13;
pub const _CONFIGURATION_TYPE_TapeController: _CONFIGURATION_TYPE = 14;
pub const _CONFIGURATION_TYPE_CdromController: _CONFIGURATION_TYPE = 15;
pub const _CONFIGURATION_TYPE_WormController: _CONFIGURATION_TYPE = 16;
pub const _CONFIGURATION_TYPE_SerialController: _CONFIGURATION_TYPE = 17;
pub const _CONFIGURATION_TYPE_NetworkController: _CONFIGURATION_TYPE = 18;
pub const _CONFIGURATION_TYPE_DisplayController: _CONFIGURATION_TYPE = 19;
pub const _CONFIGURATION_TYPE_ParallelController: _CONFIGURATION_TYPE = 20;
pub const _CONFIGURATION_TYPE_PointerController: _CONFIGURATION_TYPE = 21;
pub const _CONFIGURATION_TYPE_KeyboardController: _CONFIGURATION_TYPE = 22;
pub const _CONFIGURATION_TYPE_AudioController: _CONFIGURATION_TYPE = 23;
pub const _CONFIGURATION_TYPE_OtherController: _CONFIGURATION_TYPE = 24;
pub const _CONFIGURATION_TYPE_DiskPeripheral: _CONFIGURATION_TYPE = 25;
pub const _CONFIGURATION_TYPE_FloppyDiskPeripheral: _CONFIGURATION_TYPE = 26;
pub const _CONFIGURATION_TYPE_TapePeripheral: _CONFIGURATION_TYPE = 27;
pub const _CONFIGURATION_TYPE_ModemPeripheral: _CONFIGURATION_TYPE = 28;
pub const _CONFIGURATION_TYPE_MonitorPeripheral: _CONFIGURATION_TYPE = 29;
pub const _CONFIGURATION_TYPE_PrinterPeripheral: _CONFIGURATION_TYPE = 30;
pub const _CONFIGURATION_TYPE_PointerPeripheral: _CONFIGURATION_TYPE = 31;
pub const _CONFIGURATION_TYPE_KeyboardPeripheral: _CONFIGURATION_TYPE = 32;
pub const _CONFIGURATION_TYPE_TerminalPeripheral: _CONFIGURATION_TYPE = 33;
pub const _CONFIGURATION_TYPE_OtherPeripheral: _CONFIGURATION_TYPE = 34;
pub const _CONFIGURATION_TYPE_LinePeripheral: _CONFIGURATION_TYPE = 35;
pub const _CONFIGURATION_TYPE_NetworkPeripheral: _CONFIGURATION_TYPE = 36;
pub const _CONFIGURATION_TYPE_SystemMemory: _CONFIGURATION_TYPE = 37;
pub const _CONFIGURATION_TYPE_DockingInformation: _CONFIGURATION_TYPE = 38;
pub const _CONFIGURATION_TYPE_RealModeIrqRoutingTable: _CONFIGURATION_TYPE = 39;
pub const _CONFIGURATION_TYPE_RealModePCIEnumeration: _CONFIGURATION_TYPE = 40;
pub const _CONFIGURATION_TYPE_MaximumType: _CONFIGURATION_TYPE = 41;
pub type _CONFIGURATION_TYPE = core::ffi::c_int;
pub use self::_CONFIGURATION_TYPE as CONFIGURATION_TYPE;
pub type PCONFIGURATION_TYPE = *mut _CONFIGURATION_TYPE;
unsafe extern "C" {
    pub fn KePulseEvent(Event: PRKEVENT, Increment: KPRIORITY, Wait: BOOLEAN) -> LONG;
}
pub type PEXPAND_STACK_CALLOUT = ::core::option::Option<unsafe extern "C" fn(arg1: PVOID)>;
unsafe extern "C" {
    pub fn KeExpandKernelStackAndCallout(
        Callout: PEXPAND_STACK_CALLOUT,
        Parameter: PVOID,
        Size: SIZE_T,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KeExpandKernelStackAndCalloutEx(
        Callout: PEXPAND_STACK_CALLOUT,
        Parameter: PVOID,
        Size: SIZE_T,
        Wait: BOOLEAN,
        Context: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KeSetBasePriorityThread(Thread: PKTHREAD, Increment: LONG) -> LONG;
}
unsafe extern "C" {
    pub fn KeBugCheck(BugCheckCode: ULONG) -> !;
}
unsafe extern "C" {
    pub fn KeInvalidateAllCaches() -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeInvalidateRangeAllCaches(BaseAddress: PVOID, Length: ULONG);
}
unsafe extern "C" {
    pub fn KeSetHardwareCounterConfiguration(
        CounterArray: PHARDWARE_COUNTER,
        Count: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn KeQueryHardwareCounterConfiguration(
        CounterArray: PHARDWARE_COUNTER,
        MaximumCount: ULONG,
        Count: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ExRaiseDatatypeMisalignment() -> !;
}
unsafe extern "C" {
    pub fn ExRaiseAccessViolation() -> !;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ZONE_SEGMENT_HEADER {
    pub SegmentList: SINGLE_LIST_ENTRY,
    pub Reserved: PVOID,
}
pub type ZONE_SEGMENT_HEADER = _ZONE_SEGMENT_HEADER;
pub type PZONE_SEGMENT_HEADER = *mut _ZONE_SEGMENT_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ZONE_HEADER {
    pub FreeList: SINGLE_LIST_ENTRY,
    pub SegmentList: SINGLE_LIST_ENTRY,
    pub BlockSize: ULONG,
    pub TotalSegmentSize: ULONG,
}
pub type ZONE_HEADER = _ZONE_HEADER;
pub type PZONE_HEADER = *mut _ZONE_HEADER;
unsafe extern "C" {
    pub fn ExInitializeZone(
        Zone: PZONE_HEADER,
        BlockSize: ULONG,
        InitialSegment: PVOID,
        InitialSegmentSize: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ExExtendZone(Zone: PZONE_HEADER, Segment: PVOID, SegmentSize: ULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ExInterlockedExtendZone(
        Zone: PZONE_HEADER,
        Segment: PVOID,
        SegmentSize: ULONG,
        Lock: PKSPIN_LOCK,
    ) -> NTSTATUS;
}
pub type UUID = GUID;
unsafe extern "C" {
    pub fn ExUuidCreate(Uuid: *mut UUID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmIsThisAnNtAsSystem() -> BOOLEAN;
}
unsafe extern "C" {
    pub fn MmMapUserAddressesToPage(
        BaseAddress: PVOID,
        NumberOfBytes: SIZE_T,
        PageAddress: PVOID,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PHYSICAL_MEMORY_RANGE {
    pub BaseAddress: PHYSICAL_ADDRESS,
    pub NumberOfBytes: LARGE_INTEGER,
}
pub type PHYSICAL_MEMORY_RANGE = _PHYSICAL_MEMORY_RANGE;
pub type PPHYSICAL_MEMORY_RANGE = *mut _PHYSICAL_MEMORY_RANGE;
unsafe extern "C" {
    pub fn MmAddPhysicalMemory(
        StartAddress: PPHYSICAL_ADDRESS,
        NumberOfBytes: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
pub type PMM_ROTATE_COPY_CALLBACK_FUNCTION = ::core::option::Option<
    unsafe extern "C" fn(DestinationMdl: PMDL, SourceMdl: PMDL, Context: PVOID) -> NTSTATUS,
>;
pub const _MM_ROTATE_DIRECTION_MmToFrameBuffer: _MM_ROTATE_DIRECTION = 0;
pub const _MM_ROTATE_DIRECTION_MmToFrameBufferNoCopy: _MM_ROTATE_DIRECTION = 1;
pub const _MM_ROTATE_DIRECTION_MmToRegularMemory: _MM_ROTATE_DIRECTION = 2;
pub const _MM_ROTATE_DIRECTION_MmToRegularMemoryNoCopy: _MM_ROTATE_DIRECTION = 3;
pub const _MM_ROTATE_DIRECTION_MmMaximumRotateDirection: _MM_ROTATE_DIRECTION = 4;
pub type _MM_ROTATE_DIRECTION = core::ffi::c_int;
pub use self::_MM_ROTATE_DIRECTION as MM_ROTATE_DIRECTION;
pub type PMM_ROTATE_DIRECTION = *mut _MM_ROTATE_DIRECTION;
unsafe extern "C" {
    pub fn MmRotatePhysicalView(
        VirtualAddress: PVOID,
        NumberOfBytes: PSIZE_T,
        NewMdl: PMDL,
        Direction: MM_ROTATE_DIRECTION,
        CopyFunction: PMM_ROTATE_COPY_CALLBACK_FUNCTION,
        Context: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmRemovePhysicalMemory(
        StartAddress: PPHYSICAL_ADDRESS,
        NumberOfBytes: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmGetPhysicalMemoryRanges() -> PPHYSICAL_MEMORY_RANGE;
}
unsafe extern "C" {
    pub fn MmGetPhysicalMemoryRangesEx(PartitionObject: PVOID) -> PPHYSICAL_MEMORY_RANGE;
}
unsafe extern "C" {
    pub fn MmGetPhysicalMemoryRangesEx2(
        PartitionObject: PVOID,
        Flags: ULONG,
    ) -> PPHYSICAL_MEMORY_RANGE;
}
unsafe extern "C" {
    pub fn MmMapVideoDisplay(
        PhysicalAddress: PHYSICAL_ADDRESS,
        NumberOfBytes: SIZE_T,
        CacheType: MEMORY_CACHING_TYPE,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn MmUnmapVideoDisplay(BaseAddress: PVOID, NumberOfBytes: SIZE_T);
}
unsafe extern "C" {
    pub fn MmGetPhysicalAddress(BaseAddress: PVOID) -> PHYSICAL_ADDRESS;
}
unsafe extern "C" {
    pub fn MmGetCacheAttribute(
        PhysicalAddress: PHYSICAL_ADDRESS,
        CacheType: *mut MEMORY_CACHING_TYPE,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MM_COPY_ADDRESS {
    pub __bindgen_anon_1: _MM_COPY_ADDRESS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MM_COPY_ADDRESS__bindgen_ty_1 {
    pub VirtualAddress: PVOID,
    pub PhysicalAddress: PHYSICAL_ADDRESS,
}
pub type MM_COPY_ADDRESS = _MM_COPY_ADDRESS;
pub type PMMCOPY_ADDRESS = *mut _MM_COPY_ADDRESS;
unsafe extern "C" {
    pub fn MmCopyMemory(
        TargetAddress: PVOID,
        SourceAddress: MM_COPY_ADDRESS,
        NumberOfBytes: SIZE_T,
        Flags: ULONG,
        NumberOfBytesTransferred: PSIZE_T,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmGetCacheAttributeEx(
        PhysicalAddress: PHYSICAL_ADDRESS,
        Flags: ULONG,
        CacheType: *mut MEMORY_CACHING_TYPE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmGetVirtualForPhysical(PhysicalAddress: PHYSICAL_ADDRESS) -> PVOID;
}
unsafe extern "C" {
    pub fn MmAllocateNonCachedMemory(NumberOfBytes: SIZE_T) -> PVOID;
}
unsafe extern "C" {
    pub fn MmFreeNonCachedMemory(BaseAddress: PVOID, NumberOfBytes: SIZE_T);
}
unsafe extern "C" {
    pub fn MmIsAddressValid(VirtualAddress: PVOID) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn MmIsNonPagedSystemAddressValid(VirtualAddress: PVOID) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn MmLockPagableSectionByHandle(ImageSectionHandle: PVOID);
}
unsafe extern "C" {
    pub fn MmSecureVirtualMemory(Address: PVOID, Size: SIZE_T, ProbeMode: ULONG) -> HANDLE;
}
unsafe extern "C" {
    pub fn MmSecureVirtualMemoryEx(
        Address: PVOID,
        Size: SIZE_T,
        ProbeMode: ULONG,
        Flags: ULONG,
    ) -> HANDLE;
}
unsafe extern "C" {
    pub fn MmUnsecureVirtualMemory(SecureHandle: HANDLE);
}
unsafe extern "C" {
    pub fn MmMapViewInSystemSpaceEx(
        Section: PVOID,
        MappedBase: *mut PVOID,
        ViewSize: PSIZE_T,
        SectionOffset: PLARGE_INTEGER,
        Flags: ULONG_PTR,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmMapViewInSystemSpace(
        Section: PVOID,
        MappedBase: *mut PVOID,
        ViewSize: PSIZE_T,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmUnmapViewInSystemSpace(MappedBase: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmMapViewInSessionSpaceEx(
        Section: PVOID,
        MappedBase: *mut PVOID,
        ViewSize: PSIZE_T,
        SectionOffset: PLARGE_INTEGER,
        Flags: ULONG_PTR,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmMapViewInSessionSpace(
        Section: PVOID,
        MappedBase: *mut PVOID,
        ViewSize: PSIZE_T,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmUnmapViewInSessionSpace(MappedBase: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmCreateMirror() -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeSinglePrivilegeCheck(PrivilegeValue: LUID, PreviousMode: KPROCESSOR_MODE) -> BOOLEAN;
}
unsafe extern "C" {
    pub static mut PsInitialSystemProcess: PEPROCESS;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_CREATE_NOTIFY_INFO {
    pub Size: SIZE_T,
    pub __bindgen_anon_1: _PS_CREATE_NOTIFY_INFO__bindgen_ty_1,
    pub ParentProcessId: HANDLE,
    pub CreatingThreadId: CLIENT_ID,
    pub FileObject: *mut _FILE_OBJECT,
    pub ImageFileName: PCUNICODE_STRING,
    pub CommandLine: PCUNICODE_STRING,
    pub CreationStatus: NTSTATUS,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PS_CREATE_NOTIFY_INFO__bindgen_ty_1 {
    pub Flags: ULONG,
    pub __bindgen_anon_1: _PS_CREATE_NOTIFY_INFO__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PS_CREATE_NOTIFY_INFO__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PS_CREATE_NOTIFY_INFO__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn FileOpenNameAvailable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FileOpenNameAvailable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FileOpenNameAvailable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FileOpenNameAvailable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IsSubsystemProcess(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsSubsystemProcess(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IsSubsystemProcess_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IsSubsystemProcess_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FileOpenNameAvailable: ULONG,
        IsSubsystemProcess: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let FileOpenNameAvailable: u32 =
                unsafe { ::core::mem::transmute(FileOpenNameAvailable) };
            FileOpenNameAvailable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let IsSubsystemProcess: u32 = unsafe { ::core::mem::transmute(IsSubsystemProcess) };
            IsSubsystemProcess as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PS_CREATE_NOTIFY_INFO = _PS_CREATE_NOTIFY_INFO;
pub type PPS_CREATE_NOTIFY_INFO = *mut _PS_CREATE_NOTIFY_INFO;
pub type PCREATE_PROCESS_NOTIFY_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(ParentId: HANDLE, ProcessId: HANDLE, Create: BOOLEAN),
>;
unsafe extern "C" {
    pub fn PsSetCreateProcessNotifyRoutine(
        NotifyRoutine: PCREATE_PROCESS_NOTIFY_ROUTINE,
        Remove: BOOLEAN,
    ) -> NTSTATUS;
}
pub type PCREATE_PROCESS_NOTIFY_ROUTINE_EX = ::core::option::Option<
    unsafe extern "C" fn(Process: PEPROCESS, ProcessId: HANDLE, CreateInfo: PPS_CREATE_NOTIFY_INFO),
>;
unsafe extern "C" {
    pub fn PsSetCreateProcessNotifyRoutineEx(
        NotifyRoutine: PCREATE_PROCESS_NOTIFY_ROUTINE_EX,
        Remove: BOOLEAN,
    ) -> NTSTATUS;
}
pub const _PSCREATEPROCESSNOTIFYTYPE_PsCreateProcessNotifySubsystems: _PSCREATEPROCESSNOTIFYTYPE =
    0;
pub type _PSCREATEPROCESSNOTIFYTYPE = core::ffi::c_int;
pub use self::_PSCREATEPROCESSNOTIFYTYPE as PSCREATEPROCESSNOTIFYTYPE;
unsafe extern "C" {
    pub fn PsSetCreateProcessNotifyRoutineEx2(
        NotifyType: PSCREATEPROCESSNOTIFYTYPE,
        NotifyInformation: PVOID,
        Remove: BOOLEAN,
    ) -> NTSTATUS;
}
pub type PCREATE_THREAD_NOTIFY_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(ProcessId: HANDLE, ThreadId: HANDLE, Create: BOOLEAN),
>;
unsafe extern "C" {
    pub fn PsSetCreateThreadNotifyRoutine(NotifyRoutine: PCREATE_THREAD_NOTIFY_ROUTINE)
                                          -> NTSTATUS;
}
pub const _PSCREATETHREADNOTIFYTYPE_PsCreateThreadNotifyNonSystem: _PSCREATETHREADNOTIFYTYPE = 0;
pub const _PSCREATETHREADNOTIFYTYPE_PsCreateThreadNotifySubsystems: _PSCREATETHREADNOTIFYTYPE = 1;
pub type _PSCREATETHREADNOTIFYTYPE = core::ffi::c_int;
pub use self::_PSCREATETHREADNOTIFYTYPE as PSCREATETHREADNOTIFYTYPE;
unsafe extern "C" {
    pub fn PsSetCreateThreadNotifyRoutineEx(
        NotifyType: PSCREATETHREADNOTIFYTYPE,
        NotifyInformation: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsRemoveCreateThreadNotifyRoutine(
        NotifyRoutine: PCREATE_THREAD_NOTIFY_ROUTINE,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_INFO {
    pub __bindgen_anon_1: _IMAGE_INFO__bindgen_ty_1,
    pub ImageBase: PVOID,
    pub ImageSelector: ULONG,
    pub ImageSize: SIZE_T,
    pub ImageSectionNumber: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_INFO__bindgen_ty_1 {
    pub Properties: ULONG,
    pub __bindgen_anon_1: _IMAGE_INFO__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_INFO__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _IMAGE_INFO__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ImageAddressingMode(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ImageAddressingMode(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ImageAddressingMode_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ImageAddressingMode_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SystemModeImage(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SystemModeImage(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SystemModeImage_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SystemModeImage_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ImageMappedToAllPids(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ImageMappedToAllPids(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ImageMappedToAllPids_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ImageMappedToAllPids_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ExtendedInfoPresent(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExtendedInfoPresent(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ExtendedInfoPresent_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ExtendedInfoPresent_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MachineTypeMismatch(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MachineTypeMismatch(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MachineTypeMismatch_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MachineTypeMismatch_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ImageSignatureLevel(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ImageSignatureLevel(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ImageSignatureLevel_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ImageSignatureLevel_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ImageSignatureType(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ImageSignatureType(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ImageSignatureType_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ImageSignatureType_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ImagePartialMap(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ImagePartialMap(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ImagePartialMap_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ImagePartialMap_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                12u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ImageAddressingMode: ULONG,
        SystemModeImage: ULONG,
        ImageMappedToAllPids: ULONG,
        ExtendedInfoPresent: ULONG,
        MachineTypeMismatch: ULONG,
        ImageSignatureLevel: ULONG,
        ImageSignatureType: ULONG,
        ImagePartialMap: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let ImageAddressingMode: u32 = unsafe { ::core::mem::transmute(ImageAddressingMode) };
            ImageAddressingMode as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let SystemModeImage: u32 = unsafe { ::core::mem::transmute(SystemModeImage) };
            SystemModeImage as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let ImageMappedToAllPids: u32 = unsafe { ::core::mem::transmute(ImageMappedToAllPids) };
            ImageMappedToAllPids as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let ExtendedInfoPresent: u32 = unsafe { ::core::mem::transmute(ExtendedInfoPresent) };
            ExtendedInfoPresent as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let MachineTypeMismatch: u32 = unsafe { ::core::mem::transmute(MachineTypeMismatch) };
            MachineTypeMismatch as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let ImageSignatureLevel: u32 = unsafe { ::core::mem::transmute(ImageSignatureLevel) };
            ImageSignatureLevel as u64
        });
        __bindgen_bitfield_unit.set(16usize, 3u8, {
            let ImageSignatureType: u32 = unsafe { ::core::mem::transmute(ImageSignatureType) };
            ImageSignatureType as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ImagePartialMap: u32 = unsafe { ::core::mem::transmute(ImagePartialMap) };
            ImagePartialMap as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type IMAGE_INFO = _IMAGE_INFO;
pub type PIMAGE_INFO = *mut _IMAGE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_INFO_EX {
    pub Size: SIZE_T,
    pub ImageInfo: IMAGE_INFO,
    pub FileObject: *mut _FILE_OBJECT,
}
pub type IMAGE_INFO_EX = _IMAGE_INFO_EX;
pub type PIMAGE_INFO_EX = *mut _IMAGE_INFO_EX;
pub type PLOAD_IMAGE_NOTIFY_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(FullImageName: PUNICODE_STRING, ProcessId: HANDLE, ImageInfo: PIMAGE_INFO),
>;
unsafe extern "C" {
    pub fn PsSetLoadImageNotifyRoutine(NotifyRoutine: PLOAD_IMAGE_NOTIFY_ROUTINE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsSetLoadImageNotifyRoutineEx(
        NotifyRoutine: PLOAD_IMAGE_NOTIFY_ROUTINE,
        Flags: ULONG_PTR,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsRemoveLoadImageNotifyRoutine(NotifyRoutine: PLOAD_IMAGE_NOTIFY_ROUTINE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsGetCurrentProcessId() -> HANDLE;
}
unsafe extern "C" {
    pub fn PsGetCurrentThreadId() -> HANDLE;
}
unsafe extern "C" {
    pub fn PsSetCurrentThreadPrefetching(Prefetching: BOOLEAN) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn PsIsCurrentThreadPrefetching() -> BOOLEAN;
}
unsafe extern "C" {
    pub fn PsGetProcessCreateTimeQuadPart(Process: PEPROCESS) -> LONGLONG;
}
unsafe extern "C" {
    pub fn PsGetProcessStartKey(Process: PEPROCESS) -> ULONGLONG;
}
unsafe extern "C" {
    pub fn PsGetProcessExitStatus(Process: PEPROCESS) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsGetThreadExitStatus(Thread: PETHREAD) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsGetProcessId(Process: PEPROCESS) -> HANDLE;
}
unsafe extern "C" {
    pub fn PsGetThreadId(Thread: PETHREAD) -> HANDLE;
}
unsafe extern "C" {
    pub fn PsGetThreadProperty(Thread: PETHREAD, Key: ULONG_PTR, Flags: ULONG) -> PVOID;
}
unsafe extern "C" {
    pub fn PsGetThreadProcessId(Thread: PETHREAD) -> HANDLE;
}
unsafe extern "C" {
    pub fn PsGetThreadCreateTime(Thread: PETHREAD) -> LONGLONG;
}
unsafe extern "C" {
    pub fn PsGetCurrentThreadTeb() -> PVOID;
}
pub type SILO_CONTEXT_CLEANUP_CALLBACK =
::core::option::Option<unsafe extern "C" fn(SiloContext: PVOID)>;
pub type SILO_MONITOR_CREATE_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Silo: PESILO) -> NTSTATUS>;
pub type SILO_MONITOR_TERMINATE_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Silo: PESILO)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SILO_MONITOR_REGISTRATION {
    pub Version: UCHAR,
    pub MonitorHost: BOOLEAN,
    pub MonitorExistingSilos: BOOLEAN,
    pub Reserved: [UCHAR; 5usize],
    pub __bindgen_anon_1: _SILO_MONITOR_REGISTRATION__bindgen_ty_1,
    pub CreateCallback: SILO_MONITOR_CREATE_CALLBACK,
    pub TerminateCallback: SILO_MONITOR_TERMINATE_CALLBACK,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SILO_MONITOR_REGISTRATION__bindgen_ty_1 {
    pub DriverObjectName: PUNICODE_STRING,
    pub ComponentName: PUNICODE_STRING,
}
pub type SILO_MONITOR_REGISTRATION = _SILO_MONITOR_REGISTRATION;
pub type PSILO_MONITOR_REGISTRATION = *mut _SILO_MONITOR_REGISTRATION;
unsafe extern "C" {
    pub fn PsGetJobSilo(Job: PEJOB, Silo: *mut PESILO) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsGetJobServerSilo(Job: PEJOB, ServerSilo: *mut PESILO) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsGetEffectiveServerSilo(Silo: PESILO) -> PESILO;
}
unsafe extern "C" {
    pub fn PsAttachSiloToCurrentThread(Silo: PESILO) -> PESILO;
}
unsafe extern "C" {
    pub fn PsDetachSiloFromCurrentThread(PreviousSilo: PESILO);
}
unsafe extern "C" {
    pub fn PsIsHostSilo(Silo: PESILO) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn PsGetHostSilo() -> PESILO;
}
unsafe extern "C" {
    pub fn PsGetCurrentSilo() -> PESILO;
}
unsafe extern "C" {
    pub fn PsGetCurrentServerSilo() -> PESILO;
}
unsafe extern "C" {
    pub fn PsGetCurrentServerSiloName() -> PUNICODE_STRING;
}
unsafe extern "C" {
    pub fn PsIsCurrentThreadInServerSilo() -> BOOLEAN;
}
unsafe extern "C" {
    pub fn PsAcquireSiloHardReference(Silo: PESILO) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsReleaseSiloHardReference(Silo: PESILO);
}
unsafe extern "C" {
    pub fn PsAllocSiloContextSlot(Reserved: ULONG_PTR, ReturnedContextSlot: *mut ULONG)
                                  -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsFreeSiloContextSlot(ContextSlot: ULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsCreateSiloContext(
        Silo: PESILO,
        Size: ULONG,
        PoolType: POOL_TYPE,
        ContextCleanupCallback: SILO_CONTEXT_CLEANUP_CALLBACK,
        ReturnedSiloContext: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsInsertSiloContext(Silo: PESILO, ContextSlot: ULONG, SiloContext: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsReplaceSiloContext(
        Silo: PESILO,
        ContextSlot: ULONG,
        NewSiloContext: PVOID,
        OldSiloContext: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsGetSiloContext(
        Silo: PESILO,
        ContextSlot: ULONG,
        ReturnedSiloContext: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsRemoveSiloContext(
        Silo: PESILO,
        ContextSlot: ULONG,
        RemovedSiloContext: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsReferenceSiloContext(SiloContext: PVOID);
}
unsafe extern "C" {
    pub fn PsDereferenceSiloContext(SiloContext: PVOID);
}
unsafe extern "C" {
    pub fn PsInsertPermanentSiloContext(
        Silo: PESILO,
        ContextSlot: ULONG,
        SiloContext: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsMakeSiloContextPermanent(Silo: PESILO, ContextSlot: ULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsGetPermanentSiloContext(
        Silo: PESILO,
        ContextSlot: ULONG,
        ReturnedSiloContext: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsRegisterSiloMonitor(
        Registration: PSILO_MONITOR_REGISTRATION,
        ReturnedMonitor: *mut PSILO_MONITOR,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsStartSiloMonitor(Monitor: PSILO_MONITOR) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsGetSiloMonitorContextSlot(Monitor: PSILO_MONITOR) -> ULONG;
}
unsafe extern "C" {
    pub fn PsUnregisterSiloMonitor(Monitor: PSILO_MONITOR);
}
unsafe extern "C" {
    pub fn PsGetServerSiloServiceSessionId(Silo: PESILO) -> ULONG;
}
unsafe extern "C" {
    pub fn PsGetServerSiloActiveConsoleId(Silo: PESILO) -> ULONG;
}
unsafe extern "C" {
    pub fn PsTerminateServerSilo(ServerSilo: PESILO, ExitStatus: NTSTATUS);
}
unsafe extern "C" {
    pub fn PsGetParentSilo(Job: PEJOB) -> PESILO;
}
unsafe extern "C" {
    pub fn PsGetThreadServerSilo(Thread: PETHREAD) -> PESILO;
}
unsafe extern "C" {
    pub fn PsGetSiloContainerId(Silo: PESILO) -> *mut GUID;
}
pub type PIO_QUERY_DEVICE_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        PathName: PUNICODE_STRING,
        BusType: INTERFACE_TYPE,
        BusNumber: ULONG,
        BusInformation: *mut PKEY_VALUE_FULL_INFORMATION,
        ControllerType: CONFIGURATION_TYPE,
        ControllerNumber: ULONG,
        ControllerInformation: *mut PKEY_VALUE_FULL_INFORMATION,
        PeripheralType: CONFIGURATION_TYPE,
        PeripheralNumber: ULONG,
        PeripheralInformation: *mut PKEY_VALUE_FULL_INFORMATION,
    ) -> NTSTATUS,
>;
pub const _IO_QUERY_DEVICE_DATA_FORMAT_IoQueryDeviceIdentifier: _IO_QUERY_DEVICE_DATA_FORMAT = 0;
pub const _IO_QUERY_DEVICE_DATA_FORMAT_IoQueryDeviceConfigurationData:
_IO_QUERY_DEVICE_DATA_FORMAT = 1;
pub const _IO_QUERY_DEVICE_DATA_FORMAT_IoQueryDeviceComponentInformation:
_IO_QUERY_DEVICE_DATA_FORMAT = 2;
pub const _IO_QUERY_DEVICE_DATA_FORMAT_IoQueryDeviceMaxData: _IO_QUERY_DEVICE_DATA_FORMAT = 3;
pub type _IO_QUERY_DEVICE_DATA_FORMAT = core::ffi::c_int;
pub use self::_IO_QUERY_DEVICE_DATA_FORMAT as IO_QUERY_DEVICE_DATA_FORMAT;
pub type PIO_QUERY_DEVICE_DATA_FORMAT = *mut _IO_QUERY_DEVICE_DATA_FORMAT;
pub type DRIVER_REINITIALIZE = ::core::option::Option<
    unsafe extern "C" fn(DriverObject: *mut _DRIVER_OBJECT, Context: PVOID, Count: ULONG),
>;
pub type PDRIVER_REINITIALIZE = DRIVER_REINITIALIZE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CONTROLLER_OBJECT {
    pub Type: CSHORT,
    pub Size: CSHORT,
    pub ControllerExtension: PVOID,
    pub DeviceWaitQueue: KDEVICE_QUEUE,
    pub Spare1: ULONG,
    pub Spare2: LARGE_INTEGER,
}
pub type CONTROLLER_OBJECT = _CONTROLLER_OBJECT;
pub type PCONTROLLER_OBJECT = *mut _CONTROLLER_OBJECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CONFIGURATION_INFORMATION {
    pub DiskCount: ULONG,
    pub FloppyCount: ULONG,
    pub CdRomCount: ULONG,
    pub TapeCount: ULONG,
    pub ScsiPortCount: ULONG,
    pub SerialCount: ULONG,
    pub ParallelCount: ULONG,
    pub AtDiskPrimaryAddressClaimed: BOOLEAN,
    pub AtDiskSecondaryAddressClaimed: BOOLEAN,
    pub Version: ULONG,
    pub MediumChangerCount: ULONG,
}
pub type CONFIGURATION_INFORMATION = _CONFIGURATION_INFORMATION;
pub type PCONFIGURATION_INFORMATION = *mut _CONFIGURATION_INFORMATION;
unsafe extern "C" {
    pub fn IoAllocateController(
        ControllerObject: PCONTROLLER_OBJECT,
        DeviceObject: PDEVICE_OBJECT,
        ExecutionRoutine: PDRIVER_CONTROL,
        Context: PVOID,
    );
}
unsafe extern "C" {
    pub fn IoAssignResources(
        RegistryPath: PUNICODE_STRING,
        DriverClassName: PUNICODE_STRING,
        DriverObject: PDRIVER_OBJECT,
        DeviceObject: PDEVICE_OBJECT,
        RequestedResources: PIO_RESOURCE_REQUIREMENTS_LIST,
        AllocatedResources: *mut PCM_RESOURCE_LIST,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoAttachDeviceByPointer(
        SourceDevice: PDEVICE_OBJECT,
        TargetDevice: PDEVICE_OBJECT,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoCreateController(Size: ULONG) -> PCONTROLLER_OBJECT;
}
unsafe extern "C" {
    pub fn IoDeleteController(ControllerObject: PCONTROLLER_OBJECT);
}
unsafe extern "C" {
    pub fn IoFreeController(ControllerObject: PCONTROLLER_OBJECT);
}
unsafe extern "C" {
    pub fn IoGetConfigurationInformation() -> PCONFIGURATION_INFORMATION;
}
unsafe extern "C" {
    pub fn IoGetFileObjectGenericMapping() -> PGENERIC_MAPPING;
}
unsafe extern "C" {
    pub fn IoCancelFileOpen(DeviceObject: PDEVICE_OBJECT, FileObject: PFILE_OBJECT);
}
unsafe extern "C" {
    pub fn IoMakeAssociatedIrp(Irp: PIRP, StackSize: CCHAR) -> PIRP;
}
unsafe extern "C" {
    pub fn IoMakeAssociatedIrpEx(Irp: PIRP, DeviceObject: PDEVICE_OBJECT, StackSize: CCHAR)
                                 -> PIRP;
}
unsafe extern "C" {
    pub fn IoQueryDeviceDescription(
        BusType: PINTERFACE_TYPE,
        BusNumber: PULONG,
        ControllerType: PCONFIGURATION_TYPE,
        ControllerNumber: PULONG,
        PeripheralType: PCONFIGURATION_TYPE,
        PeripheralNumber: PULONG,
        CalloutRoutine: PIO_QUERY_DEVICE_ROUTINE,
        Context: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoRaiseHardError(Irp: PIRP, Vpb: PVPB, RealDeviceObject: PDEVICE_OBJECT);
}
unsafe extern "C" {
    pub fn IoRaiseInformationalHardError(
        ErrorStatus: NTSTATUS,
        String: PUNICODE_STRING,
        Thread: PKTHREAD,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn IoSetThreadHardErrorMode(EnableHardErrors: BOOLEAN) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn IoRegisterBootDriverReinitialization(
        DriverObject: PDRIVER_OBJECT,
        DriverReinitializationRoutine: PDRIVER_REINITIALIZE,
        Context: PVOID,
    );
}
unsafe extern "C" {
    pub fn IoRegisterDriverReinitialization(
        DriverObject: PDRIVER_OBJECT,
        DriverReinitializationRoutine: PDRIVER_REINITIALIZE,
        Context: PVOID,
    );
}
unsafe extern "C" {
    pub fn IoReportResourceUsage(
        DriverClassName: PUNICODE_STRING,
        DriverObject: PDRIVER_OBJECT,
        DriverList: PCM_RESOURCE_LIST,
        DriverListSize: ULONG,
        DeviceObject: PDEVICE_OBJECT,
        DeviceList: PCM_RESOURCE_LIST,
        DeviceListSize: ULONG,
        OverrideConflict: BOOLEAN,
        ConflictDetected: PBOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoTranslateBusAddress(
        InterfaceType: INTERFACE_TYPE,
        BusNumber: ULONG,
        BusAddress: PHYSICAL_ADDRESS,
        AddressSpace: PULONG,
        TranslatedAddress: PPHYSICAL_ADDRESS,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn IoSetHardErrorOrVerifyDevice(Irp: PIRP, DeviceObject: PDEVICE_OBJECT);
}
unsafe extern "C" {
    pub fn HalExamineMBR(
        DeviceObject: PDEVICE_OBJECT,
        SectorSize: ULONG,
        MBRTypeIdentifier: ULONG,
        Buffer: *mut PVOID,
    );
}
unsafe extern "C" {
    pub fn IoReadPartitionTable(
        DeviceObject: PDEVICE_OBJECT,
        SectorSize: ULONG,
        ReturnRecognizedPartitions: BOOLEAN,
        PartitionBuffer: *mut *mut _DRIVE_LAYOUT_INFORMATION,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoSetPartitionInformation(
        DeviceObject: PDEVICE_OBJECT,
        SectorSize: ULONG,
        PartitionNumber: ULONG,
        PartitionType: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoWritePartitionTable(
        DeviceObject: PDEVICE_OBJECT,
        SectorSize: ULONG,
        SectorsPerTrack: ULONG,
        NumberOfHeads: ULONG,
        PartitionBuffer: *mut _DRIVE_LAYOUT_INFORMATION,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoCreateDisk(
        DeviceObject: PDEVICE_OBJECT,
        Disk: *mut __BindgenOpaqueArray<u8, 0usize>,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoReadPartitionTableEx(
        DeviceObject: PDEVICE_OBJECT,
        DriveLayout: *mut *mut __BindgenOpaqueArray<u8, 0usize>,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoWritePartitionTableEx(
        DeviceObject: PDEVICE_OBJECT,
        DriveLayout: *mut __BindgenOpaqueArray<u8, 0usize>,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoSetPartitionInformationEx(
        DeviceObject: PDEVICE_OBJECT,
        PartitionNumber: ULONG,
        PartitionInfo: *mut __BindgenOpaqueArray<u8, 0usize>,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoVerifyPartitionTable(DeviceObject: PDEVICE_OBJECT, FixErrors: BOOLEAN) -> NTSTATUS;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISK_SIGNATURE {
    pub PartitionStyle: ULONG,
    pub __bindgen_anon_1: _DISK_SIGNATURE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISK_SIGNATURE__bindgen_ty_1 {
    pub Mbr: _DISK_SIGNATURE__bindgen_ty_1__bindgen_ty_1,
    pub Gpt: _DISK_SIGNATURE__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISK_SIGNATURE__bindgen_ty_1__bindgen_ty_1 {
    pub Signature: ULONG,
    pub CheckSum: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISK_SIGNATURE__bindgen_ty_1__bindgen_ty_2 {
    pub DiskId: GUID,
}
pub type DISK_SIGNATURE = _DISK_SIGNATURE;
pub type PDISK_SIGNATURE = *mut _DISK_SIGNATURE;
unsafe extern "C" {
    pub fn IoReadDiskSignature(
        DeviceObject: PDEVICE_OBJECT,
        BytesPerSector: ULONG,
        Signature: PDISK_SIGNATURE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoVolumeDeviceToDosName(VolumeDeviceObject: PVOID, DosName: PUNICODE_STRING)
                                   -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoVolumeDeviceToGuidPath(
        VolumeDeviceObject: PVOID,
        GuidPath: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoVolumeDeviceToGuid(VolumeDeviceObject: PVOID, Guid: *mut GUID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoVolumeDeviceNameToGuid(VolumeDeviceName: PUNICODE_STRING, Guid: *mut GUID)
                                    -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoVolumeDeviceNameToGuidPath(
        VolumeDeviceName: PUNICODE_STRING,
        GuidPath: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoSetSystemPartition(VolumeNameString: PUNICODE_STRING) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoCreateFileSpecifyDeviceObjectHint(
        FileHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        AllocationSize: PLARGE_INTEGER,
        FileAttributes: ULONG,
        ShareAccess: ULONG,
        Disposition: ULONG,
        CreateOptions: ULONG,
        EaBuffer: PVOID,
        EaLength: ULONG,
        CreateFileType: CREATE_FILE_TYPE,
        InternalParameters: PVOID,
        Options: ULONG,
        DeviceObject: PVOID,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_FOEXT_SILO_PARAMETERS {
    pub Length: ULONG,
    pub __bindgen_anon_1: _IO_FOEXT_SILO_PARAMETERS__bindgen_ty_1,
    pub SiloContext: PESILO,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_FOEXT_SILO_PARAMETERS__bindgen_ty_1 {
    pub __bindgen_anon_1: _IO_FOEXT_SILO_PARAMETERS__bindgen_ty_1__bindgen_ty_1,
    pub Flags: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FOEXT_SILO_PARAMETERS__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _IO_FOEXT_SILO_PARAMETERS__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn HasHardReference(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HasHardReference(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn HasHardReference_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_HasHardReference_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SpareFlags(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_SpareFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SpareFlags_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SpareFlags_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        HasHardReference: ULONG,
        SpareFlags: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let HasHardReference: u32 = unsafe { ::core::mem::transmute(HasHardReference) };
            HasHardReference as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let SpareFlags: u32 = unsafe { ::core::mem::transmute(SpareFlags) };
            SpareFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type IO_FOEXT_SILO_PARAMETERS = _IO_FOEXT_SILO_PARAMETERS;
pub type PIO_FOEXT_SILO_PARAMETERS = *mut _IO_FOEXT_SILO_PARAMETERS;
unsafe extern "C" {
    pub fn IoGetSiloParameters(FileObject: PFILE_OBJECT) -> PIO_FOEXT_SILO_PARAMETERS;
}
unsafe extern "C" {
    pub fn IoGetSilo(FileObject: PFILE_OBJECT) -> PESILO;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TXN_PARAMETER_BLOCK {
    pub Length: USHORT,
    pub TxFsContext: USHORT,
    pub TransactionObject: PVOID,
}
pub type TXN_PARAMETER_BLOCK = _TXN_PARAMETER_BLOCK;
pub type PTXN_PARAMETER_BLOCK = *mut _TXN_PARAMETER_BLOCK;
unsafe extern "C" {
    pub fn IoGetTransactionParameterBlock(FileObject: PFILE_OBJECT) -> PTXN_PARAMETER_BLOCK;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CREATE_USER_PROCESS_ECP_CONTEXT {
    pub Size: USHORT,
    pub Reserved: USHORT,
    pub AccessToken: PACCESS_TOKEN,
}
pub type CREATE_USER_PROCESS_ECP_CONTEXT = _CREATE_USER_PROCESS_ECP_CONTEXT;
pub type PCREATE_USER_PROCESS_ECP_CONTEXT = *mut _CREATE_USER_PROCESS_ECP_CONTEXT;
unsafe extern "C" {
    pub static GUID_ECP_CREATE_USER_PROCESS: GUID;
}
pub type POPLOCK_KEY_ECP_CONTEXT = *mut _OPLOCK_KEY_ECP_CONTEXT;
unsafe extern "C" {
    pub fn IoGetOplockKeyContext(FileObject: PFILE_OBJECT) -> POPLOCK_KEY_ECP_CONTEXT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OPLOCK_KEY_CONTEXT {
    pub Version: USHORT,
    pub Flags: USHORT,
    pub ParentOplockKey: GUID,
    pub TargetOplockKey: GUID,
    pub Reserved: ULONG,
}
pub type OPLOCK_KEY_CONTEXT = _OPLOCK_KEY_CONTEXT;
pub type POPLOCK_KEY_CONTEXT = *mut _OPLOCK_KEY_CONTEXT;
unsafe extern "C" {
    pub fn IoGetOplockKeyContextEx(FileObject: PFILE_OBJECT) -> POPLOCK_KEY_CONTEXT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_DRIVER_CREATE_CONTEXT {
    pub Size: CSHORT,
    pub ExtraCreateParameter: *mut _ECP_LIST,
    pub DeviceObjectHint: PVOID,
    pub TxnParameters: PTXN_PARAMETER_BLOCK,
    pub SiloContext: PESILO,
}
pub type IO_DRIVER_CREATE_CONTEXT = _IO_DRIVER_CREATE_CONTEXT;
pub type PIO_DRIVER_CREATE_CONTEXT = *mut _IO_DRIVER_CREATE_CONTEXT;
unsafe extern "C" {
    pub fn IoCreateFileEx(
        FileHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        AllocationSize: PLARGE_INTEGER,
        FileAttributes: ULONG,
        ShareAccess: ULONG,
        Disposition: ULONG,
        CreateOptions: ULONG,
        EaBuffer: PVOID,
        EaLength: ULONG,
        CreateFileType: CREATE_FILE_TYPE,
        InternalParameters: PVOID,
        Options: ULONG,
        DriverContext: PIO_DRIVER_CREATE_CONTEXT,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoSetIrpExtraCreateParameter(
        Irp: PIRP,
        ExtraCreateParameter: *mut _ECP_LIST,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoClearIrpExtraCreateParameter(Irp: PIRP);
}
unsafe extern "C" {
    pub fn IoGetIrpExtraCreateParameter(
        Irp: PIRP,
        ExtraCreateParameter: *mut *mut _ECP_LIST,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoQueryInformationByName(
        ObjectAttributes: POBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FileInformation: PVOID,
        Length: ULONG,
        FileInformationClass: FILE_INFORMATION_CLASS,
        Options: ULONG,
        DriverContext: PIO_DRIVER_CREATE_CONTEXT,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoAttachDeviceToDeviceStackSafe(
        SourceDevice: PDEVICE_OBJECT,
        TargetDevice: PDEVICE_OBJECT,
        AttachedToDeviceObject: *mut PDEVICE_OBJECT,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoIsFileOriginRemote(FileObject: PFILE_OBJECT) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn IoSetFileOrigin(FileObject: PFILE_OBJECT, Remote: BOOLEAN) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoIsFileObjectIgnoringSharing(FileObject: PFILE_OBJECT) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn IoSetFileObjectIgnoreSharing(FileObject: PFILE_OBJECT) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoGetPagingIoPriority(Irp: PIRP) -> IO_PAGING_PRIORITY;
}
pub const _BDCB_CALLBACK_TYPE_BdCbStatusUpdate: _BDCB_CALLBACK_TYPE = 0;
pub const _BDCB_CALLBACK_TYPE_BdCbInitializeImage: _BDCB_CALLBACK_TYPE = 1;
pub type _BDCB_CALLBACK_TYPE = core::ffi::c_int;
pub use self::_BDCB_CALLBACK_TYPE as BDCB_CALLBACK_TYPE;
pub type PBDCB_CALLBACK_TYPE = *mut _BDCB_CALLBACK_TYPE;
pub const _BDCB_CLASSIFICATION_BdCbClassificationUnknownImage: _BDCB_CLASSIFICATION = 0;
pub const _BDCB_CLASSIFICATION_BdCbClassificationKnownGoodImage: _BDCB_CLASSIFICATION = 1;
pub const _BDCB_CLASSIFICATION_BdCbClassificationKnownBadImage: _BDCB_CLASSIFICATION = 2;
pub const _BDCB_CLASSIFICATION_BdCbClassificationKnownBadImageBootCritical: _BDCB_CLASSIFICATION =
    3;
pub const _BDCB_CLASSIFICATION_BdCbClassificationEnd: _BDCB_CLASSIFICATION = 4;
pub type _BDCB_CLASSIFICATION = core::ffi::c_int;
pub use self::_BDCB_CLASSIFICATION as BDCB_CLASSIFICATION;
pub type PBDCB_CLASSIFICATION = *mut _BDCB_CLASSIFICATION;
pub const _BDCB_STATUS_UPDATE_TYPE_BdCbStatusPrepareForDependencyLoad: _BDCB_STATUS_UPDATE_TYPE = 0;
pub const _BDCB_STATUS_UPDATE_TYPE_BdCbStatusPrepareForDriverLoad: _BDCB_STATUS_UPDATE_TYPE = 1;
pub const _BDCB_STATUS_UPDATE_TYPE_BdCbStatusPrepareForUnload: _BDCB_STATUS_UPDATE_TYPE = 2;
pub type _BDCB_STATUS_UPDATE_TYPE = core::ffi::c_int;
pub use self::_BDCB_STATUS_UPDATE_TYPE as BDCB_STATUS_UPDATE_TYPE;
pub type PBDCB_STATUS_UPDATE_TYPE = *mut _BDCB_STATUS_UPDATE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BDCB_STATUS_UPDATE_CONTEXT {
    pub StatusType: BDCB_STATUS_UPDATE_TYPE,
}
pub type BDCB_STATUS_UPDATE_CONTEXT = _BDCB_STATUS_UPDATE_CONTEXT;
pub type PBDCB_STATUS_UPDATE_CONTEXT = *mut _BDCB_STATUS_UPDATE_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BDCB_IMAGE_INFORMATION {
    pub Classification: BDCB_CLASSIFICATION,
    pub ImageFlags: ULONG,
    pub ImageName: UNICODE_STRING,
    pub RegistryPath: UNICODE_STRING,
    pub CertificatePublisher: UNICODE_STRING,
    pub CertificateIssuer: UNICODE_STRING,
    pub ImageHash: PVOID,
    pub CertificateThumbprint: PVOID,
    pub ImageHashAlgorithm: ULONG,
    pub ThumbprintHashAlgorithm: ULONG,
    pub ImageHashLength: ULONG,
    pub CertificateThumbprintLength: ULONG,
}
pub type BDCB_IMAGE_INFORMATION = _BDCB_IMAGE_INFORMATION;
pub type BOOT_DRIVER_CALLBACK_FUNCTION = ::core::option::Option<
    unsafe extern "C" fn(
        CallbackContext: PVOID,
        Classification: BDCB_CALLBACK_TYPE,
        ImageInformation: PBDCB_IMAGE_INFORMATION,
    ),
>;
pub type PBOOT_DRIVER_CALLBACK_FUNCTION = BOOT_DRIVER_CALLBACK_FUNCTION;
unsafe extern "C" {
    pub fn IoRegisterBootDriverCallback(
        CallbackFunction: PBOOT_DRIVER_CALLBACK_FUNCTION,
        CallbackContext: PVOID,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn IoUnregisterBootDriverCallback(CallbackHandle: PVOID);
}
unsafe extern "C" {
    pub fn IoGetActivityIdIrp(Irp: PIRP, Guid: LPGUID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoSetActivityIdIrp(Irp: PIRP, Guid: LPCGUID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoPropagateActivityIdToThread(
        Irp: PIRP,
        PropagatedId: LPGUID,
        OriginalId: *mut LPCGUID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoSetActivityIdThread(ActivityId: LPCGUID) -> LPCGUID;
}
unsafe extern "C" {
    pub fn IoClearActivityIdThread(OriginalId: LPCGUID);
}
unsafe extern "C" {
    pub fn IoGetActivityIdThread() -> LPCGUID;
}
unsafe extern "C" {
    pub fn IoTransferActivityId(ActivityId: LPCGUID, RelatedActivityId: LPCGUID);
}
unsafe extern "C" {
    pub fn IoGetFsZeroingOffset(Irp: PIRP, ZeroingOffset: PULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoSetFsZeroingOffsetRequired(Irp: PIRP) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoSetFsZeroingOffset(Irp: PIRP, ZeroingOffset: ULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoIsValidIrpStatus(Status: NTSTATUS) -> LOGICAL;
}
unsafe extern "C" {
    pub fn IoIncrementKeepAliveCount(FileObject: PFILE_OBJECT, Process: PEPROCESS) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoDecrementKeepAliveCount(FileObject: PFILE_OBJECT, Process: PEPROCESS) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoGetInitiatorProcess(FileObject: PFILE_OBJECT) -> PEPROCESS;
}
unsafe extern "C" {
    pub fn IoSetMasterIrpStatus(MasterIrp: PIRP, Status: NTSTATUS);
}
unsafe extern "C" {
    pub fn IoQueryFullDriverPath(
        DriverObject: PDRIVER_OBJECT,
        FullPath: PUNICODE_STRING,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AGP_TARGET_BUS_INTERFACE_STANDARD {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub SetBusData: PGET_SET_DEVICE_DATA,
    pub GetBusData: PGET_SET_DEVICE_DATA,
    pub CapabilityID: UCHAR,
}
pub type AGP_TARGET_BUS_INTERFACE_STANDARD = _AGP_TARGET_BUS_INTERFACE_STANDARD;
pub type PAGP_TARGET_BUS_INTERFACE_STANDARD = *mut _AGP_TARGET_BUS_INTERFACE_STANDARD;
unsafe extern "C" {
    pub fn IoReportDetectedDevice(
        DriverObject: PDRIVER_OBJECT,
        LegacyBusType: INTERFACE_TYPE,
        BusNumber: ULONG,
        SlotNumber: ULONG,
        ResourceList: PCM_RESOURCE_LIST,
        ResourceRequirements: PIO_RESOURCE_REQUIREMENTS_LIST,
        ResourceAssigned: BOOLEAN,
        DeviceObject: *mut PDEVICE_OBJECT,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoReportRootDevice(DriverObject: PDRIVER_OBJECT) -> NTSTATUS;
}
pub type PGET_LOCATION_STRING = ::core::option::Option<
    unsafe extern "C" fn(Context: PVOID, LocationStrings: *mut PZZWSTR) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PNP_LOCATION_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub GetLocationString: PGET_LOCATION_STRING,
}
pub type PNP_LOCATION_INTERFACE = _PNP_LOCATION_INTERFACE;
pub type PPNP_LOCATION_INTERFACE = *mut _PNP_LOCATION_INTERFACE;
pub const _ARBITER_ACTION_ArbiterActionTestAllocation: _ARBITER_ACTION = 0;
pub const _ARBITER_ACTION_ArbiterActionRetestAllocation: _ARBITER_ACTION = 1;
pub const _ARBITER_ACTION_ArbiterActionCommitAllocation: _ARBITER_ACTION = 2;
pub const _ARBITER_ACTION_ArbiterActionRollbackAllocation: _ARBITER_ACTION = 3;
pub const _ARBITER_ACTION_ArbiterActionQueryAllocatedResources: _ARBITER_ACTION = 4;
pub const _ARBITER_ACTION_ArbiterActionWriteReservedResources: _ARBITER_ACTION = 5;
pub const _ARBITER_ACTION_ArbiterActionQueryConflict: _ARBITER_ACTION = 6;
pub const _ARBITER_ACTION_ArbiterActionQueryArbitrate: _ARBITER_ACTION = 7;
pub const _ARBITER_ACTION_ArbiterActionAddReserved: _ARBITER_ACTION = 8;
pub const _ARBITER_ACTION_ArbiterActionBootAllocation: _ARBITER_ACTION = 9;
pub type _ARBITER_ACTION = core::ffi::c_int;
pub use self::_ARBITER_ACTION as ARBITER_ACTION;
pub type PARBITER_ACTION = *mut _ARBITER_ACTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ARBITER_CONFLICT_INFO {
    pub OwningObject: PDEVICE_OBJECT,
    pub Start: ULONGLONG,
    pub End: ULONGLONG,
}
pub type ARBITER_CONFLICT_INFO = _ARBITER_CONFLICT_INFO;
pub type PARBITER_CONFLICT_INFO = *mut _ARBITER_CONFLICT_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ARBITER_TEST_ALLOCATION_PARAMETERS {
    pub ArbitrationList: PLIST_ENTRY,
    pub AllocateFromCount: ULONG,
    pub AllocateFrom: PCM_PARTIAL_RESOURCE_DESCRIPTOR,
}
pub type ARBITER_TEST_ALLOCATION_PARAMETERS = _ARBITER_TEST_ALLOCATION_PARAMETERS;
pub type PARBITER_TEST_ALLOCATION_PARAMETERS = *mut _ARBITER_TEST_ALLOCATION_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ARBITER_RETEST_ALLOCATION_PARAMETERS {
    pub ArbitrationList: PLIST_ENTRY,
    pub AllocateFromCount: ULONG,
    pub AllocateFrom: PCM_PARTIAL_RESOURCE_DESCRIPTOR,
}
pub type ARBITER_RETEST_ALLOCATION_PARAMETERS = _ARBITER_RETEST_ALLOCATION_PARAMETERS;
pub type PARBITER_RETEST_ALLOCATION_PARAMETERS = *mut _ARBITER_RETEST_ALLOCATION_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ARBITER_BOOT_ALLOCATION_PARAMETERS {
    pub ArbitrationList: PLIST_ENTRY,
}
pub type ARBITER_BOOT_ALLOCATION_PARAMETERS = _ARBITER_BOOT_ALLOCATION_PARAMETERS;
pub type PARBITER_BOOT_ALLOCATION_PARAMETERS = *mut _ARBITER_BOOT_ALLOCATION_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS {
    pub AllocatedResources: *mut PCM_PARTIAL_RESOURCE_LIST,
}
pub type ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS =
_ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS;
pub type PARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS =
*mut _ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ARBITER_QUERY_CONFLICT_PARAMETERS {
    pub PhysicalDeviceObject: PDEVICE_OBJECT,
    pub ConflictingResource: PIO_RESOURCE_DESCRIPTOR,
    pub ConflictCount: PULONG,
    pub Conflicts: *mut PARBITER_CONFLICT_INFO,
}
pub type ARBITER_QUERY_CONFLICT_PARAMETERS = _ARBITER_QUERY_CONFLICT_PARAMETERS;
pub type PARBITER_QUERY_CONFLICT_PARAMETERS = *mut _ARBITER_QUERY_CONFLICT_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ARBITER_QUERY_ARBITRATE_PARAMETERS {
    pub ArbitrationList: PLIST_ENTRY,
}
pub type ARBITER_QUERY_ARBITRATE_PARAMETERS = _ARBITER_QUERY_ARBITRATE_PARAMETERS;
pub type PARBITER_QUERY_ARBITRATE_PARAMETERS = *mut _ARBITER_QUERY_ARBITRATE_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ARBITER_ADD_RESERVED_PARAMETERS {
    pub ReserveDevice: PDEVICE_OBJECT,
}
pub type ARBITER_ADD_RESERVED_PARAMETERS = _ARBITER_ADD_RESERVED_PARAMETERS;
pub type PARBITER_ADD_RESERVED_PARAMETERS = *mut _ARBITER_ADD_RESERVED_PARAMETERS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ARBITER_PARAMETERS {
    pub Parameters: _ARBITER_PARAMETERS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ARBITER_PARAMETERS__bindgen_ty_1 {
    pub TestAllocation: ARBITER_TEST_ALLOCATION_PARAMETERS,
    pub RetestAllocation: ARBITER_RETEST_ALLOCATION_PARAMETERS,
    pub BootAllocation: ARBITER_BOOT_ALLOCATION_PARAMETERS,
    pub QueryAllocatedResources: ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS,
    pub QueryConflict: ARBITER_QUERY_CONFLICT_PARAMETERS,
    pub QueryArbitrate: ARBITER_QUERY_ARBITRATE_PARAMETERS,
    pub AddReserved: ARBITER_ADD_RESERVED_PARAMETERS,
}
pub type ARBITER_PARAMETERS = _ARBITER_PARAMETERS;
pub type PARBITER_PARAMETERS = *mut _ARBITER_PARAMETERS;
pub const _ARBITER_REQUEST_SOURCE_ArbiterRequestUndefined: _ARBITER_REQUEST_SOURCE = -1;
pub const _ARBITER_REQUEST_SOURCE_ArbiterRequestLegacyReported: _ARBITER_REQUEST_SOURCE = 0;
pub const _ARBITER_REQUEST_SOURCE_ArbiterRequestHalReported: _ARBITER_REQUEST_SOURCE = 1;
pub const _ARBITER_REQUEST_SOURCE_ArbiterRequestLegacyAssigned: _ARBITER_REQUEST_SOURCE = 2;
pub const _ARBITER_REQUEST_SOURCE_ArbiterRequestPnpDetected: _ARBITER_REQUEST_SOURCE = 3;
pub const _ARBITER_REQUEST_SOURCE_ArbiterRequestPnpEnumerated: _ARBITER_REQUEST_SOURCE = 4;
pub type _ARBITER_REQUEST_SOURCE = core::ffi::c_int;
pub use self::_ARBITER_REQUEST_SOURCE as ARBITER_REQUEST_SOURCE;
pub const _ARBITER_RESULT_ArbiterResultUndefined: _ARBITER_RESULT = -1;
pub const _ARBITER_RESULT_ArbiterResultSuccess: _ARBITER_RESULT = 0;
pub const _ARBITER_RESULT_ArbiterResultExternalConflict: _ARBITER_RESULT = 1;
pub const _ARBITER_RESULT_ArbiterResultNullRequest: _ARBITER_RESULT = 2;
pub type _ARBITER_RESULT = core::ffi::c_int;
pub use self::_ARBITER_RESULT as ARBITER_RESULT;
unsafe extern "C" {
    pub fn IoReportResourceForDetection(
        DriverObject: PDRIVER_OBJECT,
        DriverList: PCM_RESOURCE_LIST,
        DriverListSize: ULONG,
        DeviceObject: PDEVICE_OBJECT,
        DeviceList: PCM_RESOURCE_LIST,
        DeviceListSize: ULONG,
        ConflictDetected: PBOOLEAN,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ARBITER_LIST_ENTRY {
    pub ListEntry: LIST_ENTRY,
    pub AlternativeCount: ULONG,
    pub Alternatives: PIO_RESOURCE_DESCRIPTOR,
    pub PhysicalDeviceObject: PDEVICE_OBJECT,
    pub RequestSource: ARBITER_REQUEST_SOURCE,
    pub Flags: ULONG,
    pub WorkSpace: LONG_PTR,
    pub InterfaceType: INTERFACE_TYPE,
    pub SlotNumber: ULONG,
    pub BusNumber: ULONG,
    pub Assignment: PCM_PARTIAL_RESOURCE_DESCRIPTOR,
    pub SelectedAlternative: PIO_RESOURCE_DESCRIPTOR,
    pub Result: ARBITER_RESULT,
}
pub type ARBITER_LIST_ENTRY = _ARBITER_LIST_ENTRY;
pub type PARBITER_LIST_ENTRY = *mut _ARBITER_LIST_ENTRY;
pub type PARBITER_HANDLER = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        Action: ARBITER_ACTION,
        Parameters: PARBITER_PARAMETERS,
    ) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ARBITER_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub ArbiterHandler: PARBITER_HANDLER,
    pub Flags: ULONG,
}
pub type ARBITER_INTERFACE = _ARBITER_INTERFACE;
pub type PARBITER_INTERFACE = *mut _ARBITER_INTERFACE;
pub const _RESOURCE_TRANSLATION_DIRECTION_TranslateChildToParent: _RESOURCE_TRANSLATION_DIRECTION =
    0;
pub const _RESOURCE_TRANSLATION_DIRECTION_TranslateParentToChild: _RESOURCE_TRANSLATION_DIRECTION =
    1;
pub type _RESOURCE_TRANSLATION_DIRECTION = core::ffi::c_int;
pub use self::_RESOURCE_TRANSLATION_DIRECTION as RESOURCE_TRANSLATION_DIRECTION;
pub type PTRANSLATE_RESOURCE_HANDLER = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        Source: PCM_PARTIAL_RESOURCE_DESCRIPTOR,
        Direction: RESOURCE_TRANSLATION_DIRECTION,
        AlternativesCount: ULONG,
        Alternatives: *mut IO_RESOURCE_DESCRIPTOR,
        PhysicalDeviceObject: PDEVICE_OBJECT,
        Target: PCM_PARTIAL_RESOURCE_DESCRIPTOR,
    ) -> NTSTATUS,
>;
pub type PTRANSLATE_RESOURCE_REQUIREMENTS_HANDLER = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        Source: PIO_RESOURCE_DESCRIPTOR,
        PhysicalDeviceObject: PDEVICE_OBJECT,
        TargetCount: PULONG,
        Target: *mut PIO_RESOURCE_DESCRIPTOR,
    ) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSLATOR_INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub TranslateResources: PTRANSLATE_RESOURCE_HANDLER,
    pub TranslateResourceRequirements: PTRANSLATE_RESOURCE_REQUIREMENTS_HANDLER,
}
pub type TRANSLATOR_INTERFACE = _TRANSLATOR_INTERFACE;
pub type PTRANSLATOR_INTERFACE = *mut _TRANSLATOR_INTERFACE;
pub type PHAL_RESET_DISPLAY_PARAMETERS =
::core::option::Option<unsafe extern "C" fn(Columns: ULONG, Rows: ULONG) -> BOOLEAN>;
unsafe extern "C" {
    pub fn HalAcquireDisplayOwnership(ResetDisplayParameters: PHAL_RESET_DISPLAY_PARAMETERS);
}
unsafe extern "C" {
    pub fn HalSetBusDataByOffset(
        BusDataType: BUS_DATA_TYPE,
        BusNumber: ULONG,
        SlotNumber: ULONG,
        Buffer: PVOID,
        Offset: ULONG,
        Length: ULONG,
    ) -> ULONG;
}
unsafe extern "C" {
    pub fn HalTranslateBusAddress(
        InterfaceType: INTERFACE_TYPE,
        BusNumber: ULONG,
        BusAddress: PHYSICAL_ADDRESS,
        AddressSpace: PULONG,
        TranslatedAddress: PPHYSICAL_ADDRESS,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn HalAllocateCrashDumpRegisters(
        AdapterObject: PADAPTER_OBJECT,
        NumberOfMapRegisters: PULONG,
    ) -> PVOID;
}
pub const _HAL_DMA_CRASH_DUMP_REGISTER_TYPE_HalDmaCrashDumpRegisterSet1:
_HAL_DMA_CRASH_DUMP_REGISTER_TYPE = 0;
pub const _HAL_DMA_CRASH_DUMP_REGISTER_TYPE_HalDmaCrashDumpRegisterSet2:
_HAL_DMA_CRASH_DUMP_REGISTER_TYPE = 1;
pub const _HAL_DMA_CRASH_DUMP_REGISTER_TYPE_HalDmaCrashDumpRegisterSetMax:
_HAL_DMA_CRASH_DUMP_REGISTER_TYPE = 2;
pub type _HAL_DMA_CRASH_DUMP_REGISTER_TYPE = core::ffi::c_int;
pub use self::_HAL_DMA_CRASH_DUMP_REGISTER_TYPE as HAL_DMA_CRASH_DUMP_REGISTER_TYPE;
pub type PHAL_DMA_CRASH_DUMP_REGISTER_TYPE = *mut _HAL_DMA_CRASH_DUMP_REGISTER_TYPE;
unsafe extern "C" {
    pub fn HalDmaAllocateCrashDumpRegistersEx(
        Adapter: PADAPTER_OBJECT,
        NumberOfMapRegisters: ULONG,
        Type: HAL_DMA_CRASH_DUMP_REGISTER_TYPE,
        MapRegisterBase: *mut PVOID,
        MapRegistersAvailable: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn HalDmaFreeCrashDumpRegistersEx(
        Adapter: PADAPTER_OBJECT,
        Type: HAL_DMA_CRASH_DUMP_REGISTER_TYPE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn HalGetBusDataByOffset(
        BusDataType: BUS_DATA_TYPE,
        BusNumber: ULONG,
        SlotNumber: ULONG,
        Buffer: PVOID,
        Offset: ULONG,
        Length: ULONG,
    ) -> ULONG;
}
unsafe extern "C" {
    pub fn HalGetAdapter(
        DeviceDescription: PDEVICE_DESCRIPTION,
        NumberOfMapRegisters: PULONG,
    ) -> PADAPTER_OBJECT;
}
pub type pHalHandlerForBus = ::core::option::Option<
    unsafe extern "C" fn(InterfaceType: INTERFACE_TYPE, BusNumber: ULONG) -> PBUS_HANDLER,
>;
pub type pHalReferenceBusHandler =
::core::option::Option<unsafe extern "C" fn(BusHandler: PBUS_HANDLER)>;
pub const _HAL_QUERY_INFORMATION_CLASS_HalInstalledBusInformation: _HAL_QUERY_INFORMATION_CLASS = 0;
pub const _HAL_QUERY_INFORMATION_CLASS_HalProfileSourceInformation: _HAL_QUERY_INFORMATION_CLASS =
    1;
pub const _HAL_QUERY_INFORMATION_CLASS_HalInformationClassUnused1: _HAL_QUERY_INFORMATION_CLASS = 2;
pub const _HAL_QUERY_INFORMATION_CLASS_HalPowerInformation: _HAL_QUERY_INFORMATION_CLASS = 3;
pub const _HAL_QUERY_INFORMATION_CLASS_HalProcessorSpeedInformation: _HAL_QUERY_INFORMATION_CLASS =
    4;
pub const _HAL_QUERY_INFORMATION_CLASS_HalCallbackInformation: _HAL_QUERY_INFORMATION_CLASS = 5;
pub const _HAL_QUERY_INFORMATION_CLASS_HalMapRegisterInformation: _HAL_QUERY_INFORMATION_CLASS = 6;
pub const _HAL_QUERY_INFORMATION_CLASS_HalMcaLogInformation: _HAL_QUERY_INFORMATION_CLASS = 7;
pub const _HAL_QUERY_INFORMATION_CLASS_HalFrameBufferCachingInformation:
_HAL_QUERY_INFORMATION_CLASS = 8;
pub const _HAL_QUERY_INFORMATION_CLASS_HalDisplayBiosInformation: _HAL_QUERY_INFORMATION_CLASS = 9;
pub const _HAL_QUERY_INFORMATION_CLASS_HalProcessorFeatureInformation:
_HAL_QUERY_INFORMATION_CLASS = 10;
pub const _HAL_QUERY_INFORMATION_CLASS_HalNumaTopologyInterface: _HAL_QUERY_INFORMATION_CLASS = 11;
pub const _HAL_QUERY_INFORMATION_CLASS_HalErrorInformation: _HAL_QUERY_INFORMATION_CLASS = 12;
pub const _HAL_QUERY_INFORMATION_CLASS_HalCmcLogInformation: _HAL_QUERY_INFORMATION_CLASS = 13;
pub const _HAL_QUERY_INFORMATION_CLASS_HalCpeLogInformation: _HAL_QUERY_INFORMATION_CLASS = 14;
pub const _HAL_QUERY_INFORMATION_CLASS_HalQueryMcaInterface: _HAL_QUERY_INFORMATION_CLASS = 15;
pub const _HAL_QUERY_INFORMATION_CLASS_HalQueryAMLIIllegalIOPortAddresses:
_HAL_QUERY_INFORMATION_CLASS = 16;
pub const _HAL_QUERY_INFORMATION_CLASS_HalQueryMaxHotPlugMemoryAddress:
_HAL_QUERY_INFORMATION_CLASS = 17;
pub const _HAL_QUERY_INFORMATION_CLASS_HalPartitionIpiInterface: _HAL_QUERY_INFORMATION_CLASS = 18;
pub const _HAL_QUERY_INFORMATION_CLASS_HalPlatformInformation: _HAL_QUERY_INFORMATION_CLASS = 19;
pub const _HAL_QUERY_INFORMATION_CLASS_HalQueryProfileSourceList: _HAL_QUERY_INFORMATION_CLASS = 20;
pub const _HAL_QUERY_INFORMATION_CLASS_HalInitLogInformation: _HAL_QUERY_INFORMATION_CLASS = 21;
pub const _HAL_QUERY_INFORMATION_CLASS_HalFrequencyInformation: _HAL_QUERY_INFORMATION_CLASS = 22;
pub const _HAL_QUERY_INFORMATION_CLASS_HalProcessorBrandString: _HAL_QUERY_INFORMATION_CLASS = 23;
pub const _HAL_QUERY_INFORMATION_CLASS_HalHypervisorInformation: _HAL_QUERY_INFORMATION_CLASS = 24;
pub const _HAL_QUERY_INFORMATION_CLASS_HalPlatformTimerInformation: _HAL_QUERY_INFORMATION_CLASS =
    25;
pub const _HAL_QUERY_INFORMATION_CLASS_HalAcpiAuditInformation: _HAL_QUERY_INFORMATION_CLASS = 26;
pub const _HAL_QUERY_INFORMATION_CLASS_HalIrtInformation: _HAL_QUERY_INFORMATION_CLASS = 27;
pub const _HAL_QUERY_INFORMATION_CLASS_HalSecondaryInterruptInformation:
_HAL_QUERY_INFORMATION_CLASS = 28;
pub const _HAL_QUERY_INFORMATION_CLASS_HalParkingPageInformation: _HAL_QUERY_INFORMATION_CLASS = 29;
pub const _HAL_QUERY_INFORMATION_CLASS_HalNumaRangeTableInformation: _HAL_QUERY_INFORMATION_CLASS =
    30;
pub const _HAL_QUERY_INFORMATION_CLASS_HalChannelTopologyInformation: _HAL_QUERY_INFORMATION_CLASS =
    31;
pub const _HAL_QUERY_INFORMATION_CLASS_HalExternalCacheInformation: _HAL_QUERY_INFORMATION_CLASS =
    32;
pub const _HAL_QUERY_INFORMATION_CLASS_HalQueryDebuggerInformation: _HAL_QUERY_INFORMATION_CLASS =
    33;
pub const _HAL_QUERY_INFORMATION_CLASS_HalFwBootPerformanceInformation:
_HAL_QUERY_INFORMATION_CLASS = 34;
pub const _HAL_QUERY_INFORMATION_CLASS_HalFwS3PerformanceInformation: _HAL_QUERY_INFORMATION_CLASS =
    35;
pub const _HAL_QUERY_INFORMATION_CLASS_HalGetChannelPowerInformation: _HAL_QUERY_INFORMATION_CLASS =
    36;
pub const _HAL_QUERY_INFORMATION_CLASS_HalQueryStateElementInformation:
_HAL_QUERY_INFORMATION_CLASS = 37;
pub const _HAL_QUERY_INFORMATION_CLASS_HalPsciInformation: _HAL_QUERY_INFORMATION_CLASS = 38;
pub const _HAL_QUERY_INFORMATION_CLASS_HalInterruptControllerInformation:
_HAL_QUERY_INFORMATION_CLASS = 39;
pub const _HAL_QUERY_INFORMATION_CLASS_HalQueryIommuReservedRegionInformation:
_HAL_QUERY_INFORMATION_CLASS = 40;
pub const _HAL_QUERY_INFORMATION_CLASS_HalQueryArmErrataInformation: _HAL_QUERY_INFORMATION_CLASS =
    41;
pub const _HAL_QUERY_INFORMATION_CLASS_HalQueryProcessorEfficiencyInformation:
_HAL_QUERY_INFORMATION_CLASS = 42;
pub const _HAL_QUERY_INFORMATION_CLASS_HalQueryAcpiWakeAlarmSystemPowerStateInformation:
_HAL_QUERY_INFORMATION_CLASS = 43;
pub const _HAL_QUERY_INFORMATION_CLASS_HalQueryProfileNumberOfCounters:
_HAL_QUERY_INFORMATION_CLASS = 44;
pub const _HAL_QUERY_INFORMATION_CLASS_HalQueryHyperlaunchEntrypoint: _HAL_QUERY_INFORMATION_CLASS =
    45;
pub const _HAL_QUERY_INFORMATION_CLASS_HalHardwareWatchdogInformation:
_HAL_QUERY_INFORMATION_CLASS = 46;
pub const _HAL_QUERY_INFORMATION_CLASS_HalDmaRemappingInformation: _HAL_QUERY_INFORMATION_CLASS =
    47;
pub const _HAL_QUERY_INFORMATION_CLASS_HalQueryUnused0001: _HAL_QUERY_INFORMATION_CLASS = 48;
pub const _HAL_QUERY_INFORMATION_CLASS_HalHeterogeneousMemoryAttributesInterface:
_HAL_QUERY_INFORMATION_CLASS = 49;
pub const _HAL_QUERY_INFORMATION_CLASS_HalQueryPerDeviceMsiLimitInformation:
_HAL_QUERY_INFORMATION_CLASS = 50;
pub const _HAL_QUERY_INFORMATION_CLASS_HalQueryProfileCorruptionStatus:
_HAL_QUERY_INFORMATION_CLASS = 51;
pub const _HAL_QUERY_INFORMATION_CLASS_HalQueryProfileCounterOwnership:
_HAL_QUERY_INFORMATION_CLASS = 52;
pub type _HAL_QUERY_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_HAL_QUERY_INFORMATION_CLASS as HAL_QUERY_INFORMATION_CLASS;
pub type PHAL_QUERY_INFORMATION_CLASS = *mut _HAL_QUERY_INFORMATION_CLASS;
pub const _HAL_SET_INFORMATION_CLASS_HalProfileSourceInterval: _HAL_SET_INFORMATION_CLASS = 0;
pub const _HAL_SET_INFORMATION_CLASS_HalProfileSourceInterruptHandler: _HAL_SET_INFORMATION_CLASS =
    1;
pub const _HAL_SET_INFORMATION_CLASS_HalMcaRegisterDriver: _HAL_SET_INFORMATION_CLASS = 2;
pub const _HAL_SET_INFORMATION_CLASS_HalKernelErrorHandler: _HAL_SET_INFORMATION_CLASS = 3;
pub const _HAL_SET_INFORMATION_CLASS_HalCmcRegisterDriver: _HAL_SET_INFORMATION_CLASS = 4;
pub const _HAL_SET_INFORMATION_CLASS_HalCpeRegisterDriver: _HAL_SET_INFORMATION_CLASS = 5;
pub const _HAL_SET_INFORMATION_CLASS_HalMcaLog: _HAL_SET_INFORMATION_CLASS = 6;
pub const _HAL_SET_INFORMATION_CLASS_HalCmcLog: _HAL_SET_INFORMATION_CLASS = 7;
pub const _HAL_SET_INFORMATION_CLASS_HalCpeLog: _HAL_SET_INFORMATION_CLASS = 8;
pub const _HAL_SET_INFORMATION_CLASS_HalGenerateCmcInterrupt: _HAL_SET_INFORMATION_CLASS = 9;
pub const _HAL_SET_INFORMATION_CLASS_HalProfileSourceTimerHandler: _HAL_SET_INFORMATION_CLASS = 10;
pub const _HAL_SET_INFORMATION_CLASS_HalEnlightenment: _HAL_SET_INFORMATION_CLASS = 11;
pub const _HAL_SET_INFORMATION_CLASS_HalProfileDpgoSourceInterruptHandler:
_HAL_SET_INFORMATION_CLASS = 12;
pub const _HAL_SET_INFORMATION_CLASS_HalRegisterSecondaryInterruptInterface:
_HAL_SET_INFORMATION_CLASS = 13;
pub const _HAL_SET_INFORMATION_CLASS_HalSetChannelPowerInformation: _HAL_SET_INFORMATION_CLASS = 14;
pub const _HAL_SET_INFORMATION_CLASS_HalI386ExceptionChainTerminatorInformation:
_HAL_SET_INFORMATION_CLASS = 15;
pub const _HAL_SET_INFORMATION_CLASS_HalSetResetParkDisposition: _HAL_SET_INFORMATION_CLASS = 16;
pub const _HAL_SET_INFORMATION_CLASS_HalSetPsciSuspendMode: _HAL_SET_INFORMATION_CLASS = 17;
pub const _HAL_SET_INFORMATION_CLASS_HalSetHvciEnabled: _HAL_SET_INFORMATION_CLASS = 18;
pub const _HAL_SET_INFORMATION_CLASS_HalSetProcessorTraceInterruptHandler:
_HAL_SET_INFORMATION_CLASS = 19;
pub const _HAL_SET_INFORMATION_CLASS_HalProfileSourceAdd: _HAL_SET_INFORMATION_CLASS = 20;
pub const _HAL_SET_INFORMATION_CLASS_HalProfileSourceRemove: _HAL_SET_INFORMATION_CLASS = 21;
pub const _HAL_SET_INFORMATION_CLASS_HalSetSwInterruptHandler: _HAL_SET_INFORMATION_CLASS = 22;
pub const _HAL_SET_INFORMATION_CLASS_HalSetClockTimerMinimumInterval: _HAL_SET_INFORMATION_CLASS =
    23;
pub type _HAL_SET_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_HAL_SET_INFORMATION_CLASS as HAL_SET_INFORMATION_CLASS;
pub type PHAL_SET_INFORMATION_CLASS = *mut _HAL_SET_INFORMATION_CLASS;
pub type pHalQuerySystemInformation = ::core::option::Option<
    unsafe extern "C" fn(
        InformationClass: HAL_QUERY_INFORMATION_CLASS,
        BufferSize: ULONG,
        Buffer: PVOID,
        ReturnedLength: PULONG,
    ) -> NTSTATUS,
>;
pub type pHalSetSystemInformation = ::core::option::Option<
    unsafe extern "C" fn(
        InformationClass: HAL_SET_INFORMATION_CLASS,
        BufferSize: ULONG,
        Buffer: PVOID,
    ) -> NTSTATUS,
>;
pub type pHalExamineMBR = ::core::option::Option<
    unsafe extern "C" fn(
        DeviceObject: PDEVICE_OBJECT,
        SectorSize: ULONG,
        MBRTypeIdentifier: ULONG,
        Buffer: *mut PVOID,
    ),
>;
pub type pHalIoReadPartitionTable = ::core::option::Option<
    unsafe extern "C" fn(
        DeviceObject: PDEVICE_OBJECT,
        SectorSize: ULONG,
        ReturnRecognizedPartitions: BOOLEAN,
        PartitionBuffer: *mut *mut _DRIVE_LAYOUT_INFORMATION,
    ) -> NTSTATUS,
>;
pub type pHalIoSetPartitionInformation = ::core::option::Option<
    unsafe extern "C" fn(
        DeviceObject: PDEVICE_OBJECT,
        SectorSize: ULONG,
        PartitionNumber: ULONG,
        PartitionType: ULONG,
    ) -> NTSTATUS,
>;
pub type pHalIoWritePartitionTable = ::core::option::Option<
    unsafe extern "C" fn(
        DeviceObject: PDEVICE_OBJECT,
        SectorSize: ULONG,
        SectorsPerTrack: ULONG,
        NumberOfHeads: ULONG,
        PartitionBuffer: *mut _DRIVE_LAYOUT_INFORMATION,
    ) -> NTSTATUS,
>;
pub type pHalQueryBusSlots = ::core::option::Option<
    unsafe extern "C" fn(
        BusHandler: PBUS_HANDLER,
        BufferSize: ULONG,
        SlotNumbers: PULONG,
        ReturnedLength: PULONG,
    ) -> NTSTATUS,
>;
pub type pHalInitPnpDriver = ::core::option::Option<unsafe extern "C" fn() -> NTSTATUS>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PM_DISPATCH_TABLE {
    pub Signature: ULONG,
    pub Version: ULONG,
    pub Function: [PVOID; 1usize],
}
pub type PM_DISPATCH_TABLE = _PM_DISPATCH_TABLE;
pub type PPM_DISPATCH_TABLE = *mut _PM_DISPATCH_TABLE;
pub type pHalInitPowerManagement = ::core::option::Option<
    unsafe extern "C" fn(
        PmDriverDispatchTable: PPM_DISPATCH_TABLE,
        PmHalDispatchTable: *mut PPM_DISPATCH_TABLE,
    ) -> NTSTATUS,
>;
pub type pHalGetDmaAdapter = ::core::option::Option<
    unsafe extern "C" fn(
        PhysicalDeviceObject: PVOID,
        DeviceDescriptor: *mut _DEVICE_DESCRIPTION,
        NumberOfMapRegisters: PULONG,
    ) -> *mut _DMA_ADAPTER,
>;
pub type pHalGetInterruptTranslator = ::core::option::Option<
    unsafe extern "C" fn(
        ParentInterfaceType: INTERFACE_TYPE,
        ParentBusNumber: ULONG,
        BridgeInterfaceType: INTERFACE_TYPE,
        Size: USHORT,
        Version: USHORT,
        Translator: PTRANSLATOR_INTERFACE,
        BridgeBusNumber: PULONG,
    ) -> NTSTATUS,
>;
pub type pHalTranslateBusAddress = ::core::option::Option<
    unsafe extern "C" fn(
        InterfaceType: INTERFACE_TYPE,
        BusNumber: ULONG,
        BusAddress: PHYSICAL_ADDRESS,
        AddressSpace: PULONG,
        TranslatedAddress: PPHYSICAL_ADDRESS,
    ) -> BOOLEAN,
>;
pub type pHalAssignSlotResources = ::core::option::Option<
    unsafe extern "C" fn(
        RegistryPath: PUNICODE_STRING,
        DriverClassName: PUNICODE_STRING,
        DriverObject: PDRIVER_OBJECT,
        DeviceObject: PDEVICE_OBJECT,
        BusType: INTERFACE_TYPE,
        BusNumber: ULONG,
        SlotNumber: ULONG,
        AllocatedResources: *mut PCM_RESOURCE_LIST,
    ) -> NTSTATUS,
>;
pub type pHalHaltSystem = ::core::option::Option<unsafe extern "C" fn()>;
pub type pHalResetDisplay = ::core::option::Option<unsafe extern "C" fn() -> BOOLEAN>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MAP_REGISTER_ENTRY {
    pub MapRegister: PVOID,
    pub WriteToDevice: BOOLEAN,
}
pub type MAP_REGISTER_ENTRY = _MAP_REGISTER_ENTRY;
pub type PMAP_REGISTER_ENTRY = *mut _MAP_REGISTER_ENTRY;
pub type pHalVectorToIDTEntry =
::core::option::Option<unsafe extern "C" fn(Vector: ULONG) -> UCHAR>;
pub type pHalFindBusAddressTranslation = ::core::option::Option<
    unsafe extern "C" fn(
        BusAddress: PHYSICAL_ADDRESS,
        AddressSpace: PULONG,
        TranslatedAddress: PPHYSICAL_ADDRESS,
        Context: PULONG_PTR,
        NextBus: BOOLEAN,
    ) -> BOOLEAN,
>;
pub type pHalStartMirroring = ::core::option::Option<unsafe extern "C" fn() -> NTSTATUS>;
pub type pHalEndMirroring =
::core::option::Option<unsafe extern "C" fn(PassNumber: ULONG) -> NTSTATUS>;
pub type pHalMirrorPhysicalMemory = ::core::option::Option<
    unsafe extern "C" fn(
        PhysicalAddress: PHYSICAL_ADDRESS,
        NumberOfBytes: LARGE_INTEGER,
    ) -> NTSTATUS,
>;
pub type pHalMirrorVerify = ::core::option::Option<
    unsafe extern "C" fn(
        PhysicalAddress: PHYSICAL_ADDRESS,
        NumberOfBytes: LARGE_INTEGER,
    ) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DEBUG_DEVICE_ADDRESS {
    pub Type: UCHAR,
    pub Valid: BOOLEAN,
    pub __bindgen_anon_1: DEBUG_DEVICE_ADDRESS__bindgen_ty_1,
    pub TranslatedAddress: PUCHAR,
    pub Length: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DEBUG_DEVICE_ADDRESS__bindgen_ty_1 {
    pub Reserved: [UCHAR; 2usize],
    pub __bindgen_anon_1: DEBUG_DEVICE_ADDRESS__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DEBUG_DEVICE_ADDRESS__bindgen_ty_1__bindgen_ty_1 {
    pub BitWidth: UCHAR,
    pub AccessSize: UCHAR,
}
pub type PDEBUG_DEVICE_ADDRESS = *mut DEBUG_DEVICE_ADDRESS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DEBUG_MEMORY_REQUIREMENTS {
    pub Start: PHYSICAL_ADDRESS,
    pub MaxEnd: PHYSICAL_ADDRESS,
    pub VirtualAddress: PVOID,
    pub Length: ULONG,
    pub Cached: BOOLEAN,
    pub Aligned: BOOLEAN,
}
pub type PDEBUG_MEMORY_REQUIREMENTS = *mut DEBUG_MEMORY_REQUIREMENTS;
pub const KD_NAMESPACE_ENUM_KdNameSpacePCI: KD_NAMESPACE_ENUM = 0;
pub const KD_NAMESPACE_ENUM_KdNameSpaceACPI: KD_NAMESPACE_ENUM = 1;
pub const KD_NAMESPACE_ENUM_KdNameSpaceAny: KD_NAMESPACE_ENUM = 2;
pub const KD_NAMESPACE_ENUM_KdNameSpaceNone: KD_NAMESPACE_ENUM = 3;
pub const KD_NAMESPACE_ENUM_KdNameSpaceMax: KD_NAMESPACE_ENUM = 4;
pub type KD_NAMESPACE_ENUM = core::ffi::c_int;
pub type PKD_NAMESPACE_ENUM = *mut KD_NAMESPACE_ENUM;
pub const KD_CALLBACK_ACTION_KdConfigureDeviceAndContinue: KD_CALLBACK_ACTION = 0;
pub const KD_CALLBACK_ACTION_KdSkipDeviceAndContinue: KD_CALLBACK_ACTION = 1;
pub const KD_CALLBACK_ACTION_KdConfigureDeviceAndStop: KD_CALLBACK_ACTION = 2;
pub const KD_CALLBACK_ACTION_KdSkipDeviceAndStop: KD_CALLBACK_ACTION = 3;
pub type KD_CALLBACK_ACTION = core::ffi::c_int;
pub type PKD_CALLBACK_ACTION = *mut KD_CALLBACK_ACTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEBUG_TRANSPORT_DATA {
    pub HwContextSize: ULONG,
    pub SharedVisibleDataSize: ULONG,
    pub UseSerialFraming: BOOLEAN,
    pub ValidUSBCoreId: BOOLEAN,
    pub USBCoreId: UCHAR,
}
pub type DEBUG_TRANSPORT_DATA = _DEBUG_TRANSPORT_DATA;
pub type PDEBUG_TRANSPORT_DATA = *mut _DEBUG_TRANSPORT_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEBUG_IOMMU_EFI_DATA {
    pub PciIoProtocolHandle: PVOID,
    pub Mapping: PVOID,
}
pub type DEBUG_EFI_IOMMU_DATA = _DEBUG_IOMMU_EFI_DATA;
pub type PDEBUG_EFI_IOMMU_DATA = *mut _DEBUG_IOMMU_EFI_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DEBUG_DEVICE_DESCRIPTOR {
    pub Bus: ULONG,
    pub Slot: ULONG,
    pub Segment: USHORT,
    pub VendorID: USHORT,
    pub DeviceID: USHORT,
    pub BaseClass: UCHAR,
    pub SubClass: UCHAR,
    pub ProgIf: UCHAR,
    pub __bindgen_anon_1: _DEBUG_DEVICE_DESCRIPTOR__bindgen_ty_1,
    pub Initialized: BOOLEAN,
    pub Configured: BOOLEAN,
    pub BaseAddress: [DEBUG_DEVICE_ADDRESS; 6usize],
    pub Memory: DEBUG_MEMORY_REQUIREMENTS,
    pub Dbg2TableIndex: ULONG,
    pub PortType: USHORT,
    pub PortSubtype: USHORT,
    pub OemData: PVOID,
    pub OemDataLength: ULONG,
    pub NameSpace: KD_NAMESPACE_ENUM,
    pub NameSpacePath: PWCHAR,
    pub NameSpacePathLength: ULONG,
    pub TransportType: ULONG,
    pub TransportData: DEBUG_TRANSPORT_DATA,
    pub EfiIoMmuData: DEBUG_EFI_IOMMU_DATA,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DEBUG_DEVICE_DESCRIPTOR__bindgen_ty_1 {
    pub Flags: UCHAR,
    pub __bindgen_anon_1: _DEBUG_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEBUG_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _DEBUG_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn DbgHalScratchAllocated(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DbgHalScratchAllocated(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DbgHalScratchAllocated_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_DbgHalScratchAllocated_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DbgBarsMapped(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DbgBarsMapped(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DbgBarsMapped_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_DbgBarsMapped_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DbgScratchAllocated(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DbgScratchAllocated(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DbgScratchAllocated_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_DbgScratchAllocated_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DbgUncachedMemory(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DbgUncachedMemory(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DbgUncachedMemory_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_DbgUncachedMemory_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DbgSynthetic(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DbgSynthetic(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DbgSynthetic_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_DbgSynthetic_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DbgHalScratchAllocated: UCHAR,
        DbgBarsMapped: UCHAR,
        DbgScratchAllocated: UCHAR,
        DbgUncachedMemory: UCHAR,
        DbgSynthetic: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DbgHalScratchAllocated: u8 =
                unsafe { ::core::mem::transmute(DbgHalScratchAllocated) };
            DbgHalScratchAllocated as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DbgBarsMapped: u8 = unsafe { ::core::mem::transmute(DbgBarsMapped) };
            DbgBarsMapped as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DbgScratchAllocated: u8 = unsafe { ::core::mem::transmute(DbgScratchAllocated) };
            DbgScratchAllocated as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DbgUncachedMemory: u8 = unsafe { ::core::mem::transmute(DbgUncachedMemory) };
            DbgUncachedMemory as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let DbgSynthetic: u8 = unsafe { ::core::mem::transmute(DbgSynthetic) };
            DbgSynthetic as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type DEBUG_DEVICE_DESCRIPTOR = _DEBUG_DEVICE_DESCRIPTOR;
pub type PDEBUG_DEVICE_DESCRIPTOR = *mut _DEBUG_DEVICE_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_DEBUGGING_DEVICE_IN_USE {
    pub Segment: USHORT,
    pub Bus: ULONG,
    pub Slot: ULONG,
}
pub type PCI_DEBUGGING_DEVICE_IN_USE = _PCI_DEBUGGING_DEVICE_IN_USE;
pub type PPCI_DEBUGGING_DEVICE_IN_USE = *mut _PCI_DEBUGGING_DEVICE_IN_USE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACPI_DEBUGGING_DEVICE_IN_USE {
    pub NameSpacePathLength: ULONG,
    pub NameSpacePath: [WCHAR; 1usize],
}
pub type ACPI_DEBUGGING_DEVICE_IN_USE = _ACPI_DEBUGGING_DEVICE_IN_USE;
pub type PACPI_DEBUGGING_DEVICE_IN_USE = *mut _ACPI_DEBUGGING_DEVICE_IN_USE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DEBUGGING_DEVICE_IN_USE {
    pub NameSpace: KD_NAMESPACE_ENUM,
    pub StructureLength: ULONG,
    pub __bindgen_anon_1: _DEBUGGING_DEVICE_IN_USE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DEBUGGING_DEVICE_IN_USE__bindgen_ty_1 {
    pub AcpiDevice: ACPI_DEBUGGING_DEVICE_IN_USE,
    pub PciDevice: PCI_DEBUGGING_DEVICE_IN_USE,
}
pub type DEBUGGING_DEVICE_IN_USE = _DEBUGGING_DEVICE_IN_USE;
pub type PDEBUGGING_DEVICE_IN_USE = *mut _DEBUGGING_DEVICE_IN_USE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DEBUGGING_DEVICE_IN_USE_INFORMATION {
    pub DeviceCount: ULONG,
    pub Device: [DEBUGGING_DEVICE_IN_USE; 1usize],
}
pub type DEBUGGING_DEVICE_IN_USE_INFORMATION = _DEBUGGING_DEVICE_IN_USE_INFORMATION;
pub type PDEBUGGING_DEVICE_IN_USE_INFORMATION = *mut _DEBUGGING_DEVICE_IN_USE_INFORMATION;
pub type PDEBUG_DEVICE_FOUND_FUNCTION = ::core::option::Option<
    unsafe extern "C" fn(Device: PDEBUG_DEVICE_DESCRIPTOR) -> KD_CALLBACK_ACTION,
>;
pub type pKdEnumerateDebuggingDevices = ::core::option::Option<
    unsafe extern "C" fn(
        LoaderBlock: PVOID,
        Device: PDEBUG_DEVICE_DESCRIPTOR,
        Callback: PDEBUG_DEVICE_FOUND_FUNCTION,
    ) -> NTSTATUS,
>;
pub type pKdSetupPciDeviceForDebugging = ::core::option::Option<
    unsafe extern "C" fn(LoaderBlock: PVOID, PciDevice: PDEBUG_DEVICE_DESCRIPTOR) -> NTSTATUS,
>;
pub type pKdReleasePciDeviceForDebugging =
::core::option::Option<unsafe extern "C" fn(PciDevice: PDEBUG_DEVICE_DESCRIPTOR) -> NTSTATUS>;
pub type pKdSetupIntegratedDeviceForDebugging = ::core::option::Option<
    unsafe extern "C" fn(
        LoaderBlock: PVOID,
        IntegratedDevice: PDEBUG_DEVICE_DESCRIPTOR,
    ) -> NTSTATUS,
>;
pub type pKdReleaseIntegratedDeviceForDebugging = ::core::option::Option<
    unsafe extern "C" fn(IntegratedDevice: PDEBUG_DEVICE_DESCRIPTOR) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LOADER_PARAMETER_BLOCK {
    _unused: [u8; 0],
}
pub type pKdGetAcpiTablePhase0 = ::core::option::Option<
    unsafe extern "C" fn(LoaderBlock: *mut _LOADER_PARAMETER_BLOCK, Signature: ULONG) -> PVOID,
>;
pub type pKdCheckPowerButton = ::core::option::Option<unsafe extern "C" fn()>;
pub type pHalEndOfBoot = ::core::option::Option<unsafe extern "C" fn()>;
pub type pKdMapPhysicalMemory64 = ::core::option::Option<
    unsafe extern "C" fn(
        PhysicalAddress: PHYSICAL_ADDRESS,
        NumberPages: ULONG,
        FlushCurrentTLB: BOOLEAN,
    ) -> PVOID,
>;
pub type pKdUnmapVirtualAddress = ::core::option::Option<
    unsafe extern "C" fn(VirtualAddress: PVOID, NumberPages: ULONG, FlushCurrentTLB: BOOLEAN),
>;
pub type pKdGetPciDataByOffset = ::core::option::Option<
    unsafe extern "C" fn(
        BusNumber: ULONG,
        SlotNumber: ULONG,
        Buffer: PVOID,
        Offset: ULONG,
        Length: ULONG,
    ) -> ULONG,
>;
pub type pKdSetPciDataByOffset = ::core::option::Option<
    unsafe extern "C" fn(
        BusNumber: ULONG,
        SlotNumber: ULONG,
        Buffer: PVOID,
        Offset: ULONG,
        Length: ULONG,
    ) -> ULONG,
>;
pub type pHalGetAcpiTable = ::core::option::Option<
    unsafe extern "C" fn(Signature: ULONG, OemId: PCSTR, OemTableId: PCSTR) -> PVOID,
>;
pub type PCI_ERROR_HANDLER_CALLBACK = ::core::option::Option<unsafe extern "C" fn()>;
pub type pHalSetPciErrorHandlerCallback =
::core::option::Option<unsafe extern "C" fn(Callback: PCI_ERROR_HANDLER_CALLBACK)>;
pub type pHalGetPrmCache = ::core::option::Option<
    unsafe extern "C" fn(FirmwareList: *mut PLIST_ENTRY, UpdateList: *mut PLIST_ENTRY),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAL_DISPATCH {
    pub Version: ULONG,
    pub HalQuerySystemInformation: pHalQuerySystemInformation,
    pub HalSetSystemInformation: pHalSetSystemInformation,
    pub HalQueryBusSlots: pHalQueryBusSlots,
    pub Spare1: ULONG,
    pub HalExamineMBR: pHalExamineMBR,
    pub HalIoReadPartitionTable: pHalIoReadPartitionTable,
    pub HalIoSetPartitionInformation: pHalIoSetPartitionInformation,
    pub HalIoWritePartitionTable: pHalIoWritePartitionTable,
    pub HalReferenceHandlerForBus: pHalHandlerForBus,
    pub HalReferenceBusHandler: pHalReferenceBusHandler,
    pub HalDereferenceBusHandler: pHalReferenceBusHandler,
    pub HalInitPnpDriver: pHalInitPnpDriver,
    pub HalInitPowerManagement: pHalInitPowerManagement,
    pub HalGetDmaAdapter: pHalGetDmaAdapter,
    pub HalGetInterruptTranslator: pHalGetInterruptTranslator,
    pub HalStartMirroring: pHalStartMirroring,
    pub HalEndMirroring: pHalEndMirroring,
    pub HalMirrorPhysicalMemory: pHalMirrorPhysicalMemory,
    pub HalEndOfBoot: pHalEndOfBoot,
    pub HalMirrorVerify: pHalMirrorVerify,
    pub HalGetCachedAcpiTable: pHalGetAcpiTable,
    pub HalSetPciErrorHandlerCallback: pHalSetPciErrorHandlerCallback,
    pub HalGetPrmCache: pHalGetPrmCache,
}
pub type PHAL_DISPATCH = *mut HAL_DISPATCH;
unsafe extern "C" {
    pub static mut HalDispatchTable: PHAL_DISPATCH;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HAL_BUS_INFORMATION {
    pub BusType: INTERFACE_TYPE,
    pub ConfigurationType: BUS_DATA_TYPE,
    pub BusNumber: ULONG,
    pub Reserved: ULONG,
}
pub type HAL_BUS_INFORMATION = _HAL_BUS_INFORMATION;
pub type PHAL_BUS_INFORMATION = *mut _HAL_BUS_INFORMATION;
pub const _HAL_DISPLAY_BIOS_INFORMATION_HalDisplayInt10Bios: _HAL_DISPLAY_BIOS_INFORMATION = 0;
pub const _HAL_DISPLAY_BIOS_INFORMATION_HalDisplayEmulatedBios: _HAL_DISPLAY_BIOS_INFORMATION = 1;
pub const _HAL_DISPLAY_BIOS_INFORMATION_HalDisplayNoBios: _HAL_DISPLAY_BIOS_INFORMATION = 2;
pub type _HAL_DISPLAY_BIOS_INFORMATION = core::ffi::c_int;
pub use self::_HAL_DISPLAY_BIOS_INFORMATION as HAL_DISPLAY_BIOS_INFORMATION;
pub type PHAL_DISPLAY_BIOS_INFORMATION = *mut _HAL_DISPLAY_BIOS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HAL_POWER_INFORMATION {
    pub TBD: ULONG,
}
pub type HAL_POWER_INFORMATION = _HAL_POWER_INFORMATION;
pub type PHAL_POWER_INFORMATION = *mut _HAL_POWER_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HAL_PROCESSOR_SPEED_INFO {
    pub ProcessorSpeed: ULONG,
}
pub type HAL_PROCESSOR_SPEED_INFORMATION = _HAL_PROCESSOR_SPEED_INFO;
pub type PHAL_PROCESSOR_SPEED_INFORMATION = *mut _HAL_PROCESSOR_SPEED_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HAL_CALLBACKS {
    pub SetSystemInformation: PCALLBACK_OBJECT,
    pub BusCheck: PCALLBACK_OBJECT,
}
pub type HAL_CALLBACKS = _HAL_CALLBACKS;
pub type PHAL_CALLBACKS = *mut _HAL_CALLBACKS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HAL_PROCESSOR_FEATURE {
    pub UsableFeatureBits: ULONG,
}
pub type HAL_PROCESSOR_FEATURE = _HAL_PROCESSOR_FEATURE;
pub type PHALIOREADWRITEHANDLER = ::core::option::Option<
    unsafe extern "C" fn(fRead: BOOLEAN, dwAddr: ULONG, dwSize: ULONG, pdwData: PULONG) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HAL_AMLI_BAD_IO_ADDRESS_LIST {
    pub BadAddrBegin: ULONG,
    pub BadAddrSize: ULONG,
    pub OSVersionTrigger: ULONG,
    pub IOHandler: PHALIOREADWRITEHANDLER,
}
pub type HAL_AMLI_BAD_IO_ADDRESS_LIST = _HAL_AMLI_BAD_IO_ADDRESS_LIST;
pub type PHAL_AMLI_BAD_IO_ADDRESS_LIST = *mut _HAL_AMLI_BAD_IO_ADDRESS_LIST;
pub type PHALMCAINTERFACELOCK = ::core::option::Option<unsafe extern "C" fn()>;
pub type PHALMCAINTERFACEUNLOCK = ::core::option::Option<unsafe extern "C" fn()>;
pub type PHALMCAINTERFACEREADREGISTER =
::core::option::Option<unsafe extern "C" fn(BankNumber: UCHAR, Exception: PVOID) -> NTSTATUS>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HAL_MCA_INTERFACE {
    pub Lock: PHALMCAINTERFACELOCK,
    pub Unlock: PHALMCAINTERFACEUNLOCK,
    pub ReadRegister: PHALMCAINTERFACEREADREGISTER,
}
pub type HAL_MCA_INTERFACE = _HAL_MCA_INTERFACE;
pub const HAL_APIC_DESTINATION_MODE_ApicDestinationModePhysical: HAL_APIC_DESTINATION_MODE = 1;
pub const HAL_APIC_DESTINATION_MODE_ApicDestinationModeLogicalFlat: HAL_APIC_DESTINATION_MODE = 2;
pub const HAL_APIC_DESTINATION_MODE_ApicDestinationModeLogicalClustered: HAL_APIC_DESTINATION_MODE =
    3;
pub const HAL_APIC_DESTINATION_MODE_ApicDestinationModeUnknown: HAL_APIC_DESTINATION_MODE = 4;
pub type HAL_APIC_DESTINATION_MODE = core::ffi::c_int;
pub type PHAL_APIC_DESTINATION_MODE = *mut HAL_APIC_DESTINATION_MODE;
pub type PDRIVER_EXCPTN_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        TrapFrame: *mut _KTRAP_FRAME,
        ExceptionFrame: *mut _KEXCEPTION_FRAME,
        Exception: PMCA_EXCEPTION,
    ) -> ERROR_SEVERITY,
>;
pub type PDRIVER_MCA_EXCEPTION_CALLBACK = PDRIVER_EXCPTN_CALLBACK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MCA_DRIVER_INFO {
    pub ExceptionCallback: PDRIVER_MCA_EXCEPTION_CALLBACK,
    pub DpcCallback: PKDEFERRED_ROUTINE,
    pub DeviceContext: PVOID,
}
pub type MCA_DRIVER_INFO = _MCA_DRIVER_INFO;
pub type PMCA_DRIVER_INFO = *mut _MCA_DRIVER_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HAL_ERROR_INFO {
    pub Version: ULONG,
    pub InitMaxSize: ULONG,
    pub McaMaxSize: ULONG,
    pub McaPreviousEventsCount: ULONG,
    pub McaCorrectedEventsCount: ULONG,
    pub McaKernelDeliveryFails: ULONG,
    pub McaDriverDpcQueueFails: ULONG,
    pub McaReserved: ULONG,
    pub CmcMaxSize: ULONG,
    pub CmcPollingInterval: ULONG,
    pub CmcInterruptsCount: ULONG,
    pub CmcKernelDeliveryFails: ULONG,
    pub CmcDriverDpcQueueFails: ULONG,
    pub CmcGetStateFails: ULONG,
    pub CmcClearStateFails: ULONG,
    pub CmcReserved: ULONG,
    pub CmcLogId: ULONGLONG,
    pub CpeMaxSize: ULONG,
    pub CpePollingInterval: ULONG,
    pub CpeInterruptsCount: ULONG,
    pub CpeKernelDeliveryFails: ULONG,
    pub CpeDriverDpcQueueFails: ULONG,
    pub CpeGetStateFails: ULONG,
    pub CpeClearStateFails: ULONG,
    pub CpeInterruptSources: ULONG,
    pub CpeLogId: ULONGLONG,
    pub KernelReserved: [ULONGLONG; 4usize],
}
pub type HAL_ERROR_INFO = _HAL_ERROR_INFO;
pub type PHAL_ERROR_INFO = *mut _HAL_ERROR_INFO;
pub type PDRIVER_CMC_EXCEPTION_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, CmcLog: PCMC_EXCEPTION)>;
pub type PDRIVER_CPE_EXCEPTION_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, CmcLog: PCPE_EXCEPTION)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMC_DRIVER_INFO {
    pub ExceptionCallback: PDRIVER_CMC_EXCEPTION_CALLBACK,
    pub DpcCallback: PKDEFERRED_ROUTINE,
    pub DeviceContext: PVOID,
}
pub type CMC_DRIVER_INFO = _CMC_DRIVER_INFO;
pub type PCMC_DRIVER_INFO = *mut _CMC_DRIVER_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CPE_DRIVER_INFO {
    pub ExceptionCallback: PDRIVER_CPE_EXCEPTION_CALLBACK,
    pub DpcCallback: PKDEFERRED_ROUTINE,
    pub DeviceContext: PVOID,
}
pub type CPE_DRIVER_INFO = _CPE_DRIVER_INFO;
pub type PCPE_DRIVER_INFO = *mut _CPE_DRIVER_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HAL_PLATFORM_INFORMATION {
    pub PlatformFlags: ULONG,
}
pub type HAL_PLATFORM_INFORMATION = _HAL_PLATFORM_INFORMATION;
pub type PHAL_PLATFORM_INFORMATION = *mut _HAL_PLATFORM_INFORMATION;
unsafe extern "C" {
    pub fn HalGetScatterGatherList(
        DmaAdapter: PADAPTER_OBJECT,
        DeviceObject: PDEVICE_OBJECT,
        Mdl: PMDL,
        CurrentVa: PVOID,
        Length: ULONG,
        ExecutionRoutine: PDRIVER_LIST_CONTROL,
        Context: PVOID,
        WriteToDevice: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn HalPutScatterGatherList(
        DmaAdapter: PADAPTER_OBJECT,
        ScatterGather: PSCATTER_GATHER_LIST,
        WriteToDevice: BOOLEAN,
    );
}
unsafe extern "C" {
    pub fn HalPutDmaAdapter(DmaAdapter: PADAPTER_OBJECT);
}
pub type PWHEA_ERROR_SOURCE_DESCRIPTOR = *mut _WHEA_ERROR_SOURCE_DESCRIPTOR;
pub type PWHEA_ERROR_RECORD = *mut _WHEA_ERROR_RECORD;
unsafe extern "C" {
    pub fn HalBugCheckSystem(
        ErrorSource: PWHEA_ERROR_SOURCE_DESCRIPTOR,
        ErrorRecord: PWHEA_ERROR_RECORD,
    );
}
pub const _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE_ResourceTypeSingle:
_PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE = 0;
pub const _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE_ResourceTypeRange:
_PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE = 1;
pub const _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE_ResourceTypeExtendedCounterConfiguration:
_PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE = 2;
pub const _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE_ResourceTypeOverflow:
_PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE = 3;
pub const _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE_ResourceTypeEventBuffer:
_PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE = 4;
pub const _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE_ResourceTypeIdenitificationTag:
_PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE = 5;
pub const _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE_ResourceTypeMax:
_PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE = 6;
pub type _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE = core::ffi::c_int;
pub use self::_PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE as PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE;
pub type PPHYSICAL_COUNTER_OVERFLOW_HANDLER =
::core::option::Option<unsafe extern "C" fn(OverflowBits: ULONGLONG, OwningHandle: HANDLE)>;
pub type PPHYSICAL_COUNTER_EVENT_BUFFER_OVERFLOW_HANDLER = ::core::option::Option<
    unsafe extern "C" fn(
        EventBuffer: PVOID,
        EntrySize: SIZE_T,
        NumberOfEntries: SIZE_T,
        OwningHandle: HANDLE,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PHYSICAL_COUNTER_EVENT_BUFFER_CONFIGURATION {
    pub OverflowHandler: PPHYSICAL_COUNTER_EVENT_BUFFER_OVERFLOW_HANDLER,
    pub CustomEventBufferEntrySize: ULONG,
    pub EventThreshold: ULONG,
}
pub type PHYSICAL_COUNTER_EVENT_BUFFER_CONFIGURATION = _PHYSICAL_COUNTER_EVENT_BUFFER_CONFIGURATION;
pub type PPHYSICAL_COUNTER_EVENT_BUFFER_CONFIGURATION =
*mut _PHYSICAL_COUNTER_EVENT_BUFFER_CONFIGURATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR {
    pub Type: PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR_TYPE,
    pub Flags: ULONG,
    pub u: _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR__bindgen_ty_1 {
    pub CounterIndex: ULONG,
    pub Range: _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
    pub OverflowHandler: PPHYSICAL_COUNTER_OVERFLOW_HANDLER,
    pub EventBufferConfiguration: PHYSICAL_COUNTER_EVENT_BUFFER_CONFIGURATION,
    pub IdentificationTag: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    pub Begin: ULONG,
    pub End: ULONG,
}
pub type PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR = _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR;
pub type PPHYSICAL_COUNTER_RESOURCE_DESCRIPTOR = *mut _PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PHYSICAL_COUNTER_RESOURCE_LIST {
    pub Count: ULONG,
    pub Descriptors: [PHYSICAL_COUNTER_RESOURCE_DESCRIPTOR; 1usize],
}
pub type PHYSICAL_COUNTER_RESOURCE_LIST = _PHYSICAL_COUNTER_RESOURCE_LIST;
pub type PPHYSICAL_COUNTER_RESOURCE_LIST = *mut _PHYSICAL_COUNTER_RESOURCE_LIST;
unsafe extern "C" {
    pub fn HalAllocateHardwareCounters(
        GroupAffinty: PGROUP_AFFINITY,
        GroupCount: ULONG,
        ResourceList: PPHYSICAL_COUNTER_RESOURCE_LIST,
        CounterSetHandle: PHANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn HalFreeHardwareCounters(CounterSetHandle: HANDLE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlIsTotalDeviceFailure(Status: NTSTATUS) -> BOOLEAN;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_AGP_CAPABILITY {
    pub Header: PCI_CAPABILITIES_HEADER,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub AGPStatus: _PCI_AGP_CAPABILITY__PCI_AGP_STATUS,
    pub AGPCommand: _PCI_AGP_CAPABILITY__PCI_AGP_COMMAND,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_AGP_CAPABILITY__PCI_AGP_STATUS {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_AGP_CAPABILITY__PCI_AGP_STATUS {
    #[inline]
    pub fn Rate(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Rate(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rate_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rate_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Agp3Mode(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Agp3Mode(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Agp3Mode_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Agp3Mode_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FastWrite(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FastWrite(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FastWrite_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FastWrite_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FourGB(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FourGB(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FourGB_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FourGB_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn HostTransDisable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HostTransDisable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn HostTransDisable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_HostTransDisable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Gart64(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Gart64(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Gart64_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Gart64_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ITA_Coherent(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ITA_Coherent(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ITA_Coherent_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ITA_Coherent_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SideBandAddressing(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SideBandAddressing(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SideBandAddressing_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SideBandAddressing_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CalibrationCycle(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_CalibrationCycle(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CalibrationCycle_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CalibrationCycle_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AsyncRequestSize(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_AsyncRequestSize(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AsyncRequestSize_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AsyncRequestSize_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Isoch(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Isoch(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Isoch_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Isoch_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RequestQueueDepthMaximum(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_RequestQueueDepthMaximum(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RequestQueueDepthMaximum_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RequestQueueDepthMaximum_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Rate: ULONG,
        Agp3Mode: ULONG,
        FastWrite: ULONG,
        FourGB: ULONG,
        HostTransDisable: ULONG,
        Gart64: ULONG,
        ITA_Coherent: ULONG,
        SideBandAddressing: ULONG,
        CalibrationCycle: ULONG,
        AsyncRequestSize: ULONG,
        Rsvd1: ULONG,
        Isoch: ULONG,
        Rsvd2: ULONG,
        RequestQueueDepthMaximum: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let Rate: u32 = unsafe { ::core::mem::transmute(Rate) };
            Rate as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Agp3Mode: u32 = unsafe { ::core::mem::transmute(Agp3Mode) };
            Agp3Mode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let FastWrite: u32 = unsafe { ::core::mem::transmute(FastWrite) };
            FastWrite as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let FourGB: u32 = unsafe { ::core::mem::transmute(FourGB) };
            FourGB as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let HostTransDisable: u32 = unsafe { ::core::mem::transmute(HostTransDisable) };
            HostTransDisable as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Gart64: u32 = unsafe { ::core::mem::transmute(Gart64) };
            Gart64 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ITA_Coherent: u32 = unsafe { ::core::mem::transmute(ITA_Coherent) };
            ITA_Coherent as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let SideBandAddressing: u32 = unsafe { ::core::mem::transmute(SideBandAddressing) };
            SideBandAddressing as u64
        });
        __bindgen_bitfield_unit.set(10usize, 3u8, {
            let CalibrationCycle: u32 = unsafe { ::core::mem::transmute(CalibrationCycle) };
            CalibrationCycle as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let AsyncRequestSize: u32 = unsafe { ::core::mem::transmute(AsyncRequestSize) };
            AsyncRequestSize as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let Rsvd1: u32 = unsafe { ::core::mem::transmute(Rsvd1) };
            Rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let Isoch: u32 = unsafe { ::core::mem::transmute(Isoch) };
            Isoch as u64
        });
        __bindgen_bitfield_unit.set(18usize, 6u8, {
            let Rsvd2: u32 = unsafe { ::core::mem::transmute(Rsvd2) };
            Rsvd2 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let RequestQueueDepthMaximum: u32 =
                unsafe { ::core::mem::transmute(RequestQueueDepthMaximum) };
            RequestQueueDepthMaximum as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_AGP_CAPABILITY__PCI_AGP_COMMAND {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_AGP_CAPABILITY__PCI_AGP_COMMAND {
    #[inline]
    pub fn Rate(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Rate(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rate_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rate_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FastWriteEnable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FastWriteEnable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FastWriteEnable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FastWriteEnable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FourGBEnable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FourGBEnable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FourGBEnable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FourGBEnable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Gart64(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Gart64(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Gart64_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Gart64_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AGPEnable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AGPEnable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AGPEnable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AGPEnable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SBAEnable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SBAEnable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SBAEnable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SBAEnable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CalibrationCycle(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_CalibrationCycle(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CalibrationCycle_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CalibrationCycle_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AsyncReqSize(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_AsyncReqSize(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AsyncReqSize_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AsyncReqSize_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd3(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd3(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd3_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd3_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RequestQueueDepth(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_RequestQueueDepth(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RequestQueueDepth_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RequestQueueDepth_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Rate: ULONG,
        Rsvd1: ULONG,
        FastWriteEnable: ULONG,
        FourGBEnable: ULONG,
        Rsvd2: ULONG,
        Gart64: ULONG,
        AGPEnable: ULONG,
        SBAEnable: ULONG,
        CalibrationCycle: ULONG,
        AsyncReqSize: ULONG,
        Rsvd3: ULONG,
        RequestQueueDepth: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let Rate: u32 = unsafe { ::core::mem::transmute(Rate) };
            Rate as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Rsvd1: u32 = unsafe { ::core::mem::transmute(Rsvd1) };
            Rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let FastWriteEnable: u32 = unsafe { ::core::mem::transmute(FastWriteEnable) };
            FastWriteEnable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let FourGBEnable: u32 = unsafe { ::core::mem::transmute(FourGBEnable) };
            FourGBEnable as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Rsvd2: u32 = unsafe { ::core::mem::transmute(Rsvd2) };
            Rsvd2 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Gart64: u32 = unsafe { ::core::mem::transmute(Gart64) };
            Gart64 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let AGPEnable: u32 = unsafe { ::core::mem::transmute(AGPEnable) };
            AGPEnable as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let SBAEnable: u32 = unsafe { ::core::mem::transmute(SBAEnable) };
            SBAEnable as u64
        });
        __bindgen_bitfield_unit.set(10usize, 3u8, {
            let CalibrationCycle: u32 = unsafe { ::core::mem::transmute(CalibrationCycle) };
            CalibrationCycle as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let AsyncReqSize: u32 = unsafe { ::core::mem::transmute(AsyncReqSize) };
            AsyncReqSize as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let Rsvd3: u32 = unsafe { ::core::mem::transmute(Rsvd3) };
            Rsvd3 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let RequestQueueDepth: u32 = unsafe { ::core::mem::transmute(RequestQueueDepth) };
            RequestQueueDepth as u64
        });
        __bindgen_bitfield_unit
    }
}
impl _PCI_AGP_CAPABILITY {
    #[inline]
    pub fn Minor(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_Minor(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Minor_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Minor_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Major(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_Major(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Major_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Major_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd1(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd1_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd1_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Minor: USHORT,
        Major: USHORT,
        Rsvd1: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let Minor: u16 = unsafe { ::core::mem::transmute(Minor) };
            Minor as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let Major: u16 = unsafe { ::core::mem::transmute(Major) };
            Major as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let Rsvd1: u16 = unsafe { ::core::mem::transmute(Rsvd1) };
            Rsvd1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_AGP_CAPABILITY = _PCI_AGP_CAPABILITY;
pub type PPCI_AGP_CAPABILITY = *mut _PCI_AGP_CAPABILITY;
pub const _EXTENDED_AGP_REGISTER_IsochStatus: _EXTENDED_AGP_REGISTER = 0;
pub const _EXTENDED_AGP_REGISTER_AgpControl: _EXTENDED_AGP_REGISTER = 1;
pub const _EXTENDED_AGP_REGISTER_ApertureSize: _EXTENDED_AGP_REGISTER = 2;
pub const _EXTENDED_AGP_REGISTER_AperturePageSize: _EXTENDED_AGP_REGISTER = 3;
pub const _EXTENDED_AGP_REGISTER_GartLow: _EXTENDED_AGP_REGISTER = 4;
pub const _EXTENDED_AGP_REGISTER_GartHigh: _EXTENDED_AGP_REGISTER = 5;
pub const _EXTENDED_AGP_REGISTER_IsochCommand: _EXTENDED_AGP_REGISTER = 6;
pub type _EXTENDED_AGP_REGISTER = core::ffi::c_int;
pub use self::_EXTENDED_AGP_REGISTER as EXTENDED_AGP_REGISTER;
pub type PEXTENDED_AGP_REGISTER = *mut _EXTENDED_AGP_REGISTER;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_AGP_ISOCH_STATUS {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_AGP_ISOCH_STATUS {
    #[inline]
    pub fn ErrorCode(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ErrorCode(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ErrorCode_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ErrorCode_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Isoch_L(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Isoch_L(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Isoch_L_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Isoch_L_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Isoch_Y(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Isoch_Y(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Isoch_Y_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Isoch_Y_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Isoch_N(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Isoch_N(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Isoch_N_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Isoch_N_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ErrorCode: ULONG,
        Rsvd1: ULONG,
        Isoch_L: ULONG,
        Isoch_Y: ULONG,
        Isoch_N: ULONG,
        Rsvd2: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let ErrorCode: u32 = unsafe { ::core::mem::transmute(ErrorCode) };
            ErrorCode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Rsvd1: u32 = unsafe { ::core::mem::transmute(Rsvd1) };
            Rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let Isoch_L: u32 = unsafe { ::core::mem::transmute(Isoch_L) };
            Isoch_L as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let Isoch_Y: u32 = unsafe { ::core::mem::transmute(Isoch_Y) };
            Isoch_Y as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let Isoch_N: u32 = unsafe { ::core::mem::transmute(Isoch_N) };
            Isoch_N as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let Rsvd2: u32 = unsafe { ::core::mem::transmute(Rsvd2) };
            Rsvd2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_AGP_ISOCH_STATUS = _PCI_AGP_ISOCH_STATUS;
pub type PPCI_AGP_ISOCH_STATUS = *mut _PCI_AGP_ISOCH_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_AGP_CONTROL {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_AGP_CONTROL {
    #[inline]
    pub fn Rsvd1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                7u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn GTLB_Enable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GTLB_Enable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn GTLB_Enable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_GTLB_Enable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AP_Enable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AP_Enable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AP_Enable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AP_Enable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CAL_Disable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CAL_Disable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CAL_Disable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CAL_Disable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                22u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                22u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Rsvd1: ULONG,
        GTLB_Enable: ULONG,
        AP_Enable: ULONG,
        CAL_Disable: ULONG,
        Rsvd2: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let Rsvd1: u32 = unsafe { ::core::mem::transmute(Rsvd1) };
            Rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let GTLB_Enable: u32 = unsafe { ::core::mem::transmute(GTLB_Enable) };
            GTLB_Enable as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let AP_Enable: u32 = unsafe { ::core::mem::transmute(AP_Enable) };
            AP_Enable as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let CAL_Disable: u32 = unsafe { ::core::mem::transmute(CAL_Disable) };
            CAL_Disable as u64
        });
        __bindgen_bitfield_unit.set(10usize, 22u8, {
            let Rsvd2: u32 = unsafe { ::core::mem::transmute(Rsvd2) };
            Rsvd2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_AGP_CONTROL = _PCI_AGP_CONTROL;
pub type PPCI_AGP_CONTROL = *mut _PCI_AGP_CONTROL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_AGP_APERTURE_PAGE_SIZE {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_AGP_APERTURE_PAGE_SIZE {
    #[inline]
    pub fn PageSizeMask(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 11u8) as u16) }
    }
    #[inline]
    pub fn set_PageSizeMask(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PageSizeMask_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                11u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PageSizeMask_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                11u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd1(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd1_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd1_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PageSizeSelect(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_PageSizeSelect(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PageSizeSelect_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PageSizeSelect_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PageSizeMask: USHORT,
        Rsvd1: USHORT,
        PageSizeSelect: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 11u8, {
            let PageSizeMask: u16 = unsafe { ::core::mem::transmute(PageSizeMask) };
            PageSizeMask as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let Rsvd1: u16 = unsafe { ::core::mem::transmute(Rsvd1) };
            Rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let PageSizeSelect: u16 = unsafe { ::core::mem::transmute(PageSizeSelect) };
            PageSizeSelect as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_AGP_APERTURE_PAGE_SIZE = _PCI_AGP_APERTURE_PAGE_SIZE;
pub type PPCI_AGP_APERTURE_PAGE_SIZE = *mut _PCI_AGP_APERTURE_PAGE_SIZE;
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_AGP_ISOCH_COMMAND {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_AGP_ISOCH_COMMAND {
    #[inline]
    pub fn Rsvd1(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd1_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                6u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd1_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Isoch_Y(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_Isoch_Y(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Isoch_Y_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Isoch_Y_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Isoch_N(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_Isoch_N(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Isoch_N_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Isoch_N_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Rsvd1: USHORT,
        Isoch_Y: USHORT,
        Isoch_N: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let Rsvd1: u16 = unsafe { ::core::mem::transmute(Rsvd1) };
            Rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let Isoch_Y: u16 = unsafe { ::core::mem::transmute(Isoch_Y) };
            Isoch_Y as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let Isoch_N: u16 = unsafe { ::core::mem::transmute(Isoch_N) };
            Isoch_N as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_AGP_ISOCH_COMMAND = _PCI_AGP_ISOCH_COMMAND;
pub type PPCI_AGP_ISOCH_COMMAND = *mut _PCI_AGP_ISOCH_COMMAND;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PCI_AGP_EXTENDED_CAPABILITY {
    pub IsochStatus: PCI_AGP_ISOCH_STATUS,
    pub AgpControl: PCI_AGP_CONTROL,
    pub ApertureSize: USHORT,
    pub AperturePageSize: PCI_AGP_APERTURE_PAGE_SIZE,
    pub GartLow: ULONG,
    pub GartHigh: ULONG,
    pub IsochCommand: PCI_AGP_ISOCH_COMMAND,
}
pub type PPCI_AGP_EXTENDED_CAPABILITY = *mut PCI_AGP_EXTENDED_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCIX_BRIDGE_CAPABILITY {
    pub Header: PCI_CAPABILITIES_HEADER,
    pub SecondaryStatus: _PCIX_BRIDGE_CAPABILITY__bindgen_ty_1,
    pub BridgeStatus: _PCIX_BRIDGE_CAPABILITY__bindgen_ty_2,
    pub UpstreamSplitTransactionCapacity: USHORT,
    pub UpstreamSplitTransactionLimit: USHORT,
    pub DownstreamSplitTransactionCapacity: USHORT,
    pub DownstreamSplitTransactionLimit: USHORT,
    pub EccControlStatus: _PCIX_BRIDGE_CAPABILITY__bindgen_ty_3,
    pub EccFirstAddress: ULONG,
    pub EccSecondAddress: ULONG,
    pub EccAttribute: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCIX_BRIDGE_CAPABILITY__bindgen_ty_1 {
    pub __bindgen_anon_1: _PCIX_BRIDGE_CAPABILITY__bindgen_ty_1__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCIX_BRIDGE_CAPABILITY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCIX_BRIDGE_CAPABILITY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Bus64Bit(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Bus64Bit(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Bus64Bit_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Bus64Bit_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Bus133MHzCapable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Bus133MHzCapable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Bus133MHzCapable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Bus133MHzCapable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SplitCompletionDiscarded(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SplitCompletionDiscarded(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SplitCompletionDiscarded_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_SplitCompletionDiscarded_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UnexpectedSplitCompletion(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UnexpectedSplitCompletion(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UnexpectedSplitCompletion_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_UnexpectedSplitCompletion_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SplitCompletionOverrun(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SplitCompletionOverrun(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SplitCompletionOverrun_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_SplitCompletionOverrun_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SplitRequestDelayed(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SplitRequestDelayed(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SplitRequestDelayed_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_SplitRequestDelayed_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn BusModeFrequency(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_BusModeFrequency(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn BusModeFrequency_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_BusModeFrequency_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Version(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_Version(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Version_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Version_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Bus266MHzCapable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Bus266MHzCapable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Bus266MHzCapable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Bus266MHzCapable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Bus533MHzCapable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Bus533MHzCapable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Bus533MHzCapable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Bus533MHzCapable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Bus64Bit: USHORT,
        Bus133MHzCapable: USHORT,
        SplitCompletionDiscarded: USHORT,
        UnexpectedSplitCompletion: USHORT,
        SplitCompletionOverrun: USHORT,
        SplitRequestDelayed: USHORT,
        BusModeFrequency: USHORT,
        Rsvd: USHORT,
        Version: USHORT,
        Bus266MHzCapable: USHORT,
        Bus533MHzCapable: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Bus64Bit: u16 = unsafe { ::core::mem::transmute(Bus64Bit) };
            Bus64Bit as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Bus133MHzCapable: u16 = unsafe { ::core::mem::transmute(Bus133MHzCapable) };
            Bus133MHzCapable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SplitCompletionDiscarded: u16 =
                unsafe { ::core::mem::transmute(SplitCompletionDiscarded) };
            SplitCompletionDiscarded as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let UnexpectedSplitCompletion: u16 =
                unsafe { ::core::mem::transmute(UnexpectedSplitCompletion) };
            UnexpectedSplitCompletion as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let SplitCompletionOverrun: u16 =
                unsafe { ::core::mem::transmute(SplitCompletionOverrun) };
            SplitCompletionOverrun as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let SplitRequestDelayed: u16 = unsafe { ::core::mem::transmute(SplitRequestDelayed) };
            SplitRequestDelayed as u64
        });
        __bindgen_bitfield_unit.set(6usize, 4u8, {
            let BusModeFrequency: u16 = unsafe { ::core::mem::transmute(BusModeFrequency) };
            BusModeFrequency as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let Rsvd: u16 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let Version: u16 = unsafe { ::core::mem::transmute(Version) };
            Version as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let Bus266MHzCapable: u16 = unsafe { ::core::mem::transmute(Bus266MHzCapable) };
            Bus266MHzCapable as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let Bus533MHzCapable: u16 = unsafe { ::core::mem::transmute(Bus533MHzCapable) };
            Bus533MHzCapable as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCIX_BRIDGE_CAPABILITY__bindgen_ty_2 {
    pub __bindgen_anon_1: _PCIX_BRIDGE_CAPABILITY__bindgen_ty_2__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCIX_BRIDGE_CAPABILITY__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCIX_BRIDGE_CAPABILITY__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn FunctionNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_FunctionNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FunctionNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FunctionNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DeviceNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_DeviceNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DeviceNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DeviceNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn BusNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BusNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn BusNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_BusNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Device64Bit(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Device64Bit(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Device64Bit_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Device64Bit_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Device133MHzCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Device133MHzCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Device133MHzCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Device133MHzCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SplitCompletionDiscarded(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SplitCompletionDiscarded(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SplitCompletionDiscarded_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SplitCompletionDiscarded_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UnexpectedSplitCompletion(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UnexpectedSplitCompletion(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UnexpectedSplitCompletion_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UnexpectedSplitCompletion_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SplitCompletionOverrun(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SplitCompletionOverrun(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SplitCompletionOverrun_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SplitCompletionOverrun_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SplitRequestDelayed(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SplitRequestDelayed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SplitRequestDelayed_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SplitRequestDelayed_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                7u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DIMCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DIMCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DIMCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                29usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DIMCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                29usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Device266MHzCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Device266MHzCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Device266MHzCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Device266MHzCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Device533MHzCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Device533MHzCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Device533MHzCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Device533MHzCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FunctionNumber: ULONG,
        DeviceNumber: ULONG,
        BusNumber: ULONG,
        Device64Bit: ULONG,
        Device133MHzCapable: ULONG,
        SplitCompletionDiscarded: ULONG,
        UnexpectedSplitCompletion: ULONG,
        SplitCompletionOverrun: ULONG,
        SplitRequestDelayed: ULONG,
        Rsvd: ULONG,
        DIMCapable: ULONG,
        Device266MHzCapable: ULONG,
        Device533MHzCapable: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let FunctionNumber: u32 = unsafe { ::core::mem::transmute(FunctionNumber) };
            FunctionNumber as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let DeviceNumber: u32 = unsafe { ::core::mem::transmute(DeviceNumber) };
            DeviceNumber as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let BusNumber: u32 = unsafe { ::core::mem::transmute(BusNumber) };
            BusNumber as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let Device64Bit: u32 = unsafe { ::core::mem::transmute(Device64Bit) };
            Device64Bit as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let Device133MHzCapable: u32 = unsafe { ::core::mem::transmute(Device133MHzCapable) };
            Device133MHzCapable as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let SplitCompletionDiscarded: u32 =
                unsafe { ::core::mem::transmute(SplitCompletionDiscarded) };
            SplitCompletionDiscarded as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let UnexpectedSplitCompletion: u32 =
                unsafe { ::core::mem::transmute(UnexpectedSplitCompletion) };
            UnexpectedSplitCompletion as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let SplitCompletionOverrun: u32 =
                unsafe { ::core::mem::transmute(SplitCompletionOverrun) };
            SplitCompletionOverrun as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let SplitRequestDelayed: u32 = unsafe { ::core::mem::transmute(SplitRequestDelayed) };
            SplitRequestDelayed as u64
        });
        __bindgen_bitfield_unit.set(22usize, 7u8, {
            let Rsvd: u32 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let DIMCapable: u32 = unsafe { ::core::mem::transmute(DIMCapable) };
            DIMCapable as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let Device266MHzCapable: u32 = unsafe { ::core::mem::transmute(Device266MHzCapable) };
            Device266MHzCapable as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let Device533MHzCapable: u32 = unsafe { ::core::mem::transmute(Device533MHzCapable) };
            Device533MHzCapable as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCIX_BRIDGE_CAPABILITY__bindgen_ty_3 {
    pub __bindgen_anon_1: _PCIX_BRIDGE_CAPABILITY__bindgen_ty_3__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCIX_BRIDGE_CAPABILITY__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCIX_BRIDGE_CAPABILITY__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn SelectSecondaryRegisters(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SelectSecondaryRegisters(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SelectSecondaryRegisters_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SelectSecondaryRegisters_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ErrorPresentInOtherBank(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ErrorPresentInOtherBank(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ErrorPresentInOtherBank_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ErrorPresentInOtherBank_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AdditionalCorrectableError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AdditionalCorrectableError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AdditionalCorrectableError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AdditionalCorrectableError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AdditionalUncorrectableError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AdditionalUncorrectableError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AdditionalUncorrectableError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AdditionalUncorrectableError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ErrorPhase(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ErrorPhase(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ErrorPhase_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ErrorPhase_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ErrorCorrected(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ErrorCorrected(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ErrorCorrected_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ErrorCorrected_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Syndrome(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Syndrome(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Syndrome_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Syndrome_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ErrorFirstCommand(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ErrorFirstCommand(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ErrorFirstCommand_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ErrorFirstCommand_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ErrorSecondCommand(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ErrorSecondCommand(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ErrorSecondCommand_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ErrorSecondCommand_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ErrorUpperAttributes(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ErrorUpperAttributes(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ErrorUpperAttributes_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ErrorUpperAttributes_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ControlUpdateEnable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ControlUpdateEnable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ControlUpdateEnable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ControlUpdateEnable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                29usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                29usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DisableSingleBitCorrection(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableSingleBitCorrection(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DisableSingleBitCorrection_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DisableSingleBitCorrection_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EccMode(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EccMode(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EccMode_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_EccMode_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SelectSecondaryRegisters: ULONG,
        ErrorPresentInOtherBank: ULONG,
        AdditionalCorrectableError: ULONG,
        AdditionalUncorrectableError: ULONG,
        ErrorPhase: ULONG,
        ErrorCorrected: ULONG,
        Syndrome: ULONG,
        ErrorFirstCommand: ULONG,
        ErrorSecondCommand: ULONG,
        ErrorUpperAttributes: ULONG,
        ControlUpdateEnable: ULONG,
        Rsvd: ULONG,
        DisableSingleBitCorrection: ULONG,
        EccMode: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SelectSecondaryRegisters: u32 =
                unsafe { ::core::mem::transmute(SelectSecondaryRegisters) };
            SelectSecondaryRegisters as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ErrorPresentInOtherBank: u32 =
                unsafe { ::core::mem::transmute(ErrorPresentInOtherBank) };
            ErrorPresentInOtherBank as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let AdditionalCorrectableError: u32 =
                unsafe { ::core::mem::transmute(AdditionalCorrectableError) };
            AdditionalCorrectableError as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AdditionalUncorrectableError: u32 =
                unsafe { ::core::mem::transmute(AdditionalUncorrectableError) };
            AdditionalUncorrectableError as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let ErrorPhase: u32 = unsafe { ::core::mem::transmute(ErrorPhase) };
            ErrorPhase as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ErrorCorrected: u32 = unsafe { ::core::mem::transmute(ErrorCorrected) };
            ErrorCorrected as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let Syndrome: u32 = unsafe { ::core::mem::transmute(Syndrome) };
            Syndrome as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let ErrorFirstCommand: u32 = unsafe { ::core::mem::transmute(ErrorFirstCommand) };
            ErrorFirstCommand as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let ErrorSecondCommand: u32 = unsafe { ::core::mem::transmute(ErrorSecondCommand) };
            ErrorSecondCommand as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let ErrorUpperAttributes: u32 = unsafe { ::core::mem::transmute(ErrorUpperAttributes) };
            ErrorUpperAttributes as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let ControlUpdateEnable: u32 = unsafe { ::core::mem::transmute(ControlUpdateEnable) };
            ControlUpdateEnable as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let Rsvd: u32 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let DisableSingleBitCorrection: u32 =
                unsafe { ::core::mem::transmute(DisableSingleBitCorrection) };
            DisableSingleBitCorrection as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let EccMode: u32 = unsafe { ::core::mem::transmute(EccMode) };
            EccMode as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCIX_BRIDGE_CAPABILITY = _PCIX_BRIDGE_CAPABILITY;
pub type PPCIX_BRIDGE_CAPABILITY = *mut _PCIX_BRIDGE_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_SUBSYSTEM_IDS_CAPABILITY {
    pub Header: PCI_CAPABILITIES_HEADER,
    pub Reserved: USHORT,
    pub SubVendorID: USHORT,
    pub SubSystemID: USHORT,
}
pub type PCI_SUBSYSTEM_IDS_CAPABILITY = _PCI_SUBSYSTEM_IDS_CAPABILITY;
pub type PPCI_SUBSYSTEM_IDS_CAPABILITY = *mut _PCI_SUBSYSTEM_IDS_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_ADVANCED_FEATURES_CAPABILITY {
    pub Header: PCI_CAPABILITIES_HEADER,
    pub Length: UCHAR,
    pub Capabilities: _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_1,
    pub Control: _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_2,
    pub Status: _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_1 {
    pub __bindgen_anon_1: _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_1__bindgen_ty_1,
    pub AsUCHAR: UCHAR,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn FunctionLevelResetSupported(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FunctionLevelResetSupported(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FunctionLevelResetSupported_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_FunctionLevelResetSupported_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TransactionsPendingSupported(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TransactionsPendingSupported(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TransactionsPendingSupported_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_TransactionsPendingSupported_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                6u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FunctionLevelResetSupported: UCHAR,
        TransactionsPendingSupported: UCHAR,
        Rsvd: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let FunctionLevelResetSupported: u8 =
                unsafe { ::core::mem::transmute(FunctionLevelResetSupported) };
            FunctionLevelResetSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TransactionsPendingSupported: u8 =
                unsafe { ::core::mem::transmute(TransactionsPendingSupported) };
            TransactionsPendingSupported as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let Rsvd: u8 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_2 {
    pub __bindgen_anon_1: _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_2__bindgen_ty_1,
    pub AsUCHAR: UCHAR,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn InitiateFunctionLevelReset(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_InitiateFunctionLevelReset(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InitiateFunctionLevelReset_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_InitiateFunctionLevelReset_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                7u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        InitiateFunctionLevelReset: UCHAR,
        Rsvd: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let InitiateFunctionLevelReset: u8 =
                unsafe { ::core::mem::transmute(InitiateFunctionLevelReset) };
            InitiateFunctionLevelReset as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let Rsvd: u8 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_3 {
    pub __bindgen_anon_1: _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_3__bindgen_ty_1,
    pub AsUCHAR: UCHAR,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _PCI_ADVANCED_FEATURES_CAPABILITY__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn TransactionsPending(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TransactionsPending(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TransactionsPending_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_TransactionsPending_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                7u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TransactionsPending: UCHAR,
        Rsvd: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let TransactionsPending: u8 = unsafe { ::core::mem::transmute(TransactionsPending) };
            TransactionsPending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let Rsvd: u8 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_ADVANCED_FEATURES_CAPABILITY = _PCI_ADVANCED_FEATURES_CAPABILITY;
pub type PPCI_ADVANCED_FEATURES_CAPABILITY = *mut _PCI_ADVANCED_FEATURES_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_ROOT_BUS_OSC_SUPPORT_FIELD {
    pub u: _PCI_ROOT_BUS_OSC_SUPPORT_FIELD__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_ROOT_BUS_OSC_SUPPORT_FIELD__bindgen_ty_1 {
    pub __bindgen_anon_1: _PCI_ROOT_BUS_OSC_SUPPORT_FIELD__bindgen_ty_1__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_ROOT_BUS_OSC_SUPPORT_FIELD__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_ROOT_BUS_OSC_SUPPORT_FIELD__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ExtendedConfigOpRegions(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExtendedConfigOpRegions(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ExtendedConfigOpRegions_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ExtendedConfigOpRegions_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ActiveStatePowerManagement(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ActiveStatePowerManagement(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ActiveStatePowerManagement_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ActiveStatePowerManagement_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ClockPowerManagement(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ClockPowerManagement(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ClockPowerManagement_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ClockPowerManagement_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SegmentGroups(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SegmentGroups(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SegmentGroups_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SegmentGroups_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MessageSignaledInterrupts(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MessageSignaledInterrupts(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MessageSignaledInterrupts_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MessageSignaledInterrupts_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn OptimizedBufferFlushAndFill(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OptimizedBufferFlushAndFill(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn OptimizedBufferFlushAndFill_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_OptimizedBufferFlushAndFill_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AspmOptionality(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AspmOptionality(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AspmOptionality_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AspmOptionality_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                25u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                25u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ExtendedConfigOpRegions: ULONG,
        ActiveStatePowerManagement: ULONG,
        ClockPowerManagement: ULONG,
        SegmentGroups: ULONG,
        MessageSignaledInterrupts: ULONG,
        OptimizedBufferFlushAndFill: ULONG,
        AspmOptionality: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ExtendedConfigOpRegions: u32 =
                unsafe { ::core::mem::transmute(ExtendedConfigOpRegions) };
            ExtendedConfigOpRegions as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ActiveStatePowerManagement: u32 =
                unsafe { ::core::mem::transmute(ActiveStatePowerManagement) };
            ActiveStatePowerManagement as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ClockPowerManagement: u32 = unsafe { ::core::mem::transmute(ClockPowerManagement) };
            ClockPowerManagement as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SegmentGroups: u32 = unsafe { ::core::mem::transmute(SegmentGroups) };
            SegmentGroups as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let MessageSignaledInterrupts: u32 =
                unsafe { ::core::mem::transmute(MessageSignaledInterrupts) };
            MessageSignaledInterrupts as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let OptimizedBufferFlushAndFill: u32 =
                unsafe { ::core::mem::transmute(OptimizedBufferFlushAndFill) };
            OptimizedBufferFlushAndFill as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let AspmOptionality: u32 = unsafe { ::core::mem::transmute(AspmOptionality) };
            AspmOptionality as u64
        });
        __bindgen_bitfield_unit.set(7usize, 25u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_ROOT_BUS_OSC_SUPPORT_FIELD = _PCI_ROOT_BUS_OSC_SUPPORT_FIELD;
pub type PPCI_ROOT_BUS_OSC_SUPPORT_FIELD = *mut _PCI_ROOT_BUS_OSC_SUPPORT_FIELD;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_ROOT_BUS_OSC_CONTROL_FIELD {
    pub u: _PCI_ROOT_BUS_OSC_CONTROL_FIELD__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_ROOT_BUS_OSC_CONTROL_FIELD__bindgen_ty_1 {
    pub __bindgen_anon_1: _PCI_ROOT_BUS_OSC_CONTROL_FIELD__bindgen_ty_1__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_ROOT_BUS_OSC_CONTROL_FIELD__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_ROOT_BUS_OSC_CONTROL_FIELD__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ExpressNativeHotPlug(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExpressNativeHotPlug(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ExpressNativeHotPlug_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ExpressNativeHotPlug_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ShpcNativeHotPlug(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ShpcNativeHotPlug(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ShpcNativeHotPlug_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ShpcNativeHotPlug_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ExpressNativePME(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExpressNativePME(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ExpressNativePME_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ExpressNativePME_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ExpressAdvancedErrorReporting(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExpressAdvancedErrorReporting(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ExpressAdvancedErrorReporting_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ExpressAdvancedErrorReporting_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ExpressCapabilityStructure(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExpressCapabilityStructure(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ExpressCapabilityStructure_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ExpressCapabilityStructure_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LatencyToleranceReporting(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LatencyToleranceReporting(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LatencyToleranceReporting_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_LatencyToleranceReporting_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                26u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                26u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ExpressNativeHotPlug: ULONG,
        ShpcNativeHotPlug: ULONG,
        ExpressNativePME: ULONG,
        ExpressAdvancedErrorReporting: ULONG,
        ExpressCapabilityStructure: ULONG,
        LatencyToleranceReporting: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ExpressNativeHotPlug: u32 = unsafe { ::core::mem::transmute(ExpressNativeHotPlug) };
            ExpressNativeHotPlug as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ShpcNativeHotPlug: u32 = unsafe { ::core::mem::transmute(ShpcNativeHotPlug) };
            ShpcNativeHotPlug as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ExpressNativePME: u32 = unsafe { ::core::mem::transmute(ExpressNativePME) };
            ExpressNativePME as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ExpressAdvancedErrorReporting: u32 =
                unsafe { ::core::mem::transmute(ExpressAdvancedErrorReporting) };
            ExpressAdvancedErrorReporting as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ExpressCapabilityStructure: u32 =
                unsafe { ::core::mem::transmute(ExpressCapabilityStructure) };
            ExpressCapabilityStructure as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let LatencyToleranceReporting: u32 =
                unsafe { ::core::mem::transmute(LatencyToleranceReporting) };
            LatencyToleranceReporting as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_ROOT_BUS_OSC_CONTROL_FIELD = _PCI_ROOT_BUS_OSC_CONTROL_FIELD;
pub type PPCI_ROOT_BUS_OSC_CONTROL_FIELD = *mut _PCI_ROOT_BUS_OSC_CONTROL_FIELD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_FIRMWARE_BUS_CAPS {
    pub Type: USHORT,
    pub Length: USHORT,
    pub __bindgen_anon_1: _PCI_FIRMWARE_BUS_CAPS__bindgen_ty_1,
    pub CurrentSpeedAndMode: UCHAR,
    pub SupportedSpeedsAndModesLowByte: UCHAR,
    pub SupportedSpeedsAndModesHighByte: UCHAR,
    pub Voltage: UCHAR,
    pub Reserved2: [UCHAR; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_FIRMWARE_BUS_CAPS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _PCI_FIRMWARE_BUS_CAPS__bindgen_ty_1 {
    #[inline]
    pub fn SixtyFourBitDevice(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SixtyFourBitDevice(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SixtyFourBitDevice_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_SixtyFourBitDevice_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PciXMode1EccCapable(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PciXMode1EccCapable(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PciXMode1EccCapable_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_PciXMode1EccCapable_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DeviceIdMessagingCapable(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DeviceIdMessagingCapable(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DeviceIdMessagingCapable_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_DeviceIdMessagingCapable_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ObffWakeSignalCapable(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ObffWakeSignalCapable(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ObffWakeSignalCapable_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ObffWakeSignalCapable_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SixtyFourBitDevice: UCHAR,
        PciXMode1EccCapable: UCHAR,
        DeviceIdMessagingCapable: UCHAR,
        ObffWakeSignalCapable: UCHAR,
        Reserved1: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SixtyFourBitDevice: u8 = unsafe { ::core::mem::transmute(SixtyFourBitDevice) };
            SixtyFourBitDevice as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PciXMode1EccCapable: u8 = unsafe { ::core::mem::transmute(PciXMode1EccCapable) };
            PciXMode1EccCapable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DeviceIdMessagingCapable: u8 =
                unsafe { ::core::mem::transmute(DeviceIdMessagingCapable) };
            DeviceIdMessagingCapable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ObffWakeSignalCapable: u8 =
                unsafe { ::core::mem::transmute(ObffWakeSignalCapable) };
            ObffWakeSignalCapable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let Reserved1: u8 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_FIRMWARE_BUS_CAPS = _PCI_FIRMWARE_BUS_CAPS;
pub type PPCI_FIRMWARE_BUS_CAPS = *mut _PCI_FIRMWARE_BUS_CAPS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_FIRMWARE_BUS_CAPS_RETURN_BUFFER {
    pub Version: USHORT,
    pub Status: USHORT,
    pub Length: ULONG,
    pub Caps: PCI_FIRMWARE_BUS_CAPS,
}
pub type PCI_FIRMWARE_BUS_CAPS_RETURN_BUFFER = _PCI_FIRMWARE_BUS_CAPS_RETURN_BUFFER;
pub type PPCI_FIRMWARE_BUS_CAPS_RETURN_BUFFER = *mut _PCI_FIRMWARE_BUS_CAPS_RETURN_BUFFER;
pub const _PCI_HARDWARE_INTERFACE_PciConventional: _PCI_HARDWARE_INTERFACE = 0;
pub const _PCI_HARDWARE_INTERFACE_PciXMode1: _PCI_HARDWARE_INTERFACE = 1;
pub const _PCI_HARDWARE_INTERFACE_PciXMode2: _PCI_HARDWARE_INTERFACE = 2;
pub const _PCI_HARDWARE_INTERFACE_PciExpress: _PCI_HARDWARE_INTERFACE = 3;
pub type _PCI_HARDWARE_INTERFACE = core::ffi::c_int;
pub use self::_PCI_HARDWARE_INTERFACE as PCI_HARDWARE_INTERFACE;
pub type PPCI_HARDWARE_INTERFACE = *mut _PCI_HARDWARE_INTERFACE;
pub const PCI_BUS_WIDTH_BusWidth32Bits: PCI_BUS_WIDTH = 0;
pub const PCI_BUS_WIDTH_BusWidth64Bits: PCI_BUS_WIDTH = 1;
pub type PCI_BUS_WIDTH = core::ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_ROOT_BUS_HARDWARE_CAPABILITY {
    pub SecondaryInterface: PCI_HARDWARE_INTERFACE,
    pub __bindgen_anon_1: _PCI_ROOT_BUS_HARDWARE_CAPABILITY__bindgen_ty_1,
    pub OscFeatureSupport: PCI_ROOT_BUS_OSC_SUPPORT_FIELD,
    pub OscControlRequest: PCI_ROOT_BUS_OSC_CONTROL_FIELD,
    pub OscControlGranted: PCI_ROOT_BUS_OSC_CONTROL_FIELD,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_ROOT_BUS_HARDWARE_CAPABILITY__bindgen_ty_1 {
    pub BusCapabilitiesFound: BOOLEAN,
    pub CurrentSpeedAndMode: ULONG,
    pub SupportedSpeedsAndModes: ULONG,
    pub DeviceIDMessagingCapable: BOOLEAN,
    pub SecondaryBusWidth: PCI_BUS_WIDTH,
}
pub type PCI_ROOT_BUS_HARDWARE_CAPABILITY = _PCI_ROOT_BUS_HARDWARE_CAPABILITY;
pub type PPCI_ROOT_BUS_HARDWARE_CAPABILITY = *mut _PCI_ROOT_BUS_HARDWARE_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_FPB_CAPABILITY_HEADER {
    pub Header: PCI_CAPABILITIES_HEADER,
    pub Reserved: USHORT,
}
pub type PCI_FPB_CAPABILITY_HEADER = _PCI_FPB_CAPABILITY_HEADER;
pub type PPCI_FPB_CAPABILITY_HEADER = *mut _PCI_FPB_CAPABILITY_HEADER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_FPB_CAPABILITIES_REGISTER {
    pub __bindgen_anon_1: _PCI_FPB_CAPABILITIES_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_FPB_CAPABILITIES_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_FPB_CAPABILITIES_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn RidDecodeMechanismSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RidDecodeMechanismSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RidDecodeMechanismSupported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RidDecodeMechanismSupported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemLowDecodeMechanismSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MemLowDecodeMechanismSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemLowDecodeMechanismSupported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemLowDecodeMechanismSupported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemHighDecodeMechanismSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MemHighDecodeMechanismSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemHighDecodeMechanismSupported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemHighDecodeMechanismSupported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NumSecDev(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_NumSecDev(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NumSecDev_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NumSecDev_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RidVectorSizeSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_RidVectorSizeSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RidVectorSizeSupported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RidVectorSizeSupported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd0(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd0(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd0_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd0_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemLowVectorSizeSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_MemLowVectorSizeSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemLowVectorSizeSupported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemLowVectorSizeSupported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemHighVectorSizeSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_MemHighVectorSizeSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemHighVectorSizeSupported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemHighVectorSizeSupported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RidDecodeMechanismSupported: ULONG,
        MemLowDecodeMechanismSupported: ULONG,
        MemHighDecodeMechanismSupported: ULONG,
        NumSecDev: ULONG,
        RidVectorSizeSupported: ULONG,
        Rsvd0: ULONG,
        MemLowVectorSizeSupported: ULONG,
        Rsvd1: ULONG,
        MemHighVectorSizeSupported: ULONG,
        Rsvd2: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let RidDecodeMechanismSupported: u32 =
                unsafe { ::core::mem::transmute(RidDecodeMechanismSupported) };
            RidDecodeMechanismSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let MemLowDecodeMechanismSupported: u32 =
                unsafe { ::core::mem::transmute(MemLowDecodeMechanismSupported) };
            MemLowDecodeMechanismSupported as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let MemHighDecodeMechanismSupported: u32 =
                unsafe { ::core::mem::transmute(MemHighDecodeMechanismSupported) };
            MemHighDecodeMechanismSupported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let NumSecDev: u32 = unsafe { ::core::mem::transmute(NumSecDev) };
            NumSecDev as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let RidVectorSizeSupported: u32 =
                unsafe { ::core::mem::transmute(RidVectorSizeSupported) };
            RidVectorSizeSupported as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let Rsvd0: u32 = unsafe { ::core::mem::transmute(Rsvd0) };
            Rsvd0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 3u8, {
            let MemLowVectorSizeSupported: u32 =
                unsafe { ::core::mem::transmute(MemLowVectorSizeSupported) };
            MemLowVectorSizeSupported as u64
        });
        __bindgen_bitfield_unit.set(19usize, 5u8, {
            let Rsvd1: u32 = unsafe { ::core::mem::transmute(Rsvd1) };
            Rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 3u8, {
            let MemHighVectorSizeSupported: u32 =
                unsafe { ::core::mem::transmute(MemHighVectorSizeSupported) };
            MemHighVectorSizeSupported as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let Rsvd2: u32 = unsafe { ::core::mem::transmute(Rsvd2) };
            Rsvd2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_FPB_CAPABILITIES_REGISTER = _PCI_FPB_CAPABILITIES_REGISTER;
pub type PPCI_FPB_CAPABILITIES_REGISTER = *mut _PCI_FPB_CAPABILITIES_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_FPB_RID_VECTOR_CONTROL1_REGISTER {
    pub __bindgen_anon_1: _PCI_FPB_RID_VECTOR_CONTROL1_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_FPB_RID_VECTOR_CONTROL1_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_FPB_RID_VECTOR_CONTROL1_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn RidDecodeMechanismEnable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RidDecodeMechanismEnable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RidDecodeMechanismEnable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RidDecodeMechanismEnable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd0(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd0(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd0_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd0_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RidVectorGranularity(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_RidVectorGranularity(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RidVectorGranularity_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RidVectorGranularity_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                11u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                11u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RidVectorStart(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_RidVectorStart(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RidVectorStart_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                13u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RidVectorStart_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                13u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RidDecodeMechanismEnable: ULONG,
        Rsvd0: ULONG,
        RidVectorGranularity: ULONG,
        Rsvd1: ULONG,
        RidVectorStart: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let RidDecodeMechanismEnable: u32 =
                unsafe { ::core::mem::transmute(RidDecodeMechanismEnable) };
            RidDecodeMechanismEnable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let Rsvd0: u32 = unsafe { ::core::mem::transmute(Rsvd0) };
            Rsvd0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let RidVectorGranularity: u32 = unsafe { ::core::mem::transmute(RidVectorGranularity) };
            RidVectorGranularity as u64
        });
        __bindgen_bitfield_unit.set(8usize, 11u8, {
            let Rsvd1: u32 = unsafe { ::core::mem::transmute(Rsvd1) };
            Rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 13u8, {
            let RidVectorStart: u32 = unsafe { ::core::mem::transmute(RidVectorStart) };
            RidVectorStart as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_FPB_RID_VECTOR_CONTROL1_REGISTER = _PCI_FPB_RID_VECTOR_CONTROL1_REGISTER;
pub type PPCI_FPB_RID_VECTOR_CONTROL1_REGISTER = *mut _PCI_FPB_RID_VECTOR_CONTROL1_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_FPB_RID_VECTOR_CONTROL2_REGISTER {
    pub __bindgen_anon_1: _PCI_FPB_RID_VECTOR_CONTROL2_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_FPB_RID_VECTOR_CONTROL2_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_FPB_RID_VECTOR_CONTROL2_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn Rsvd0(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd0(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd0_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd0_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RidSecondaryStart(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_RidSecondaryStart(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RidSecondaryStart_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                13u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RidSecondaryStart_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                13u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Rsvd0: ULONG,
        RidSecondaryStart: ULONG,
        Rsvd1: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let Rsvd0: u32 = unsafe { ::core::mem::transmute(Rsvd0) };
            Rsvd0 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 13u8, {
            let RidSecondaryStart: u32 = unsafe { ::core::mem::transmute(RidSecondaryStart) };
            RidSecondaryStart as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let Rsvd1: u32 = unsafe { ::core::mem::transmute(Rsvd1) };
            Rsvd1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_FPB_RID_VECTOR_CONTROL2_REGISTER = _PCI_FPB_RID_VECTOR_CONTROL2_REGISTER;
pub type PPCI_FPB_RID_VECTOR_CONTROL2_REGISTER = *mut _PCI_FPB_RID_VECTOR_CONTROL2_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_FPB_MEM_LOW_VECTOR_CONTROL_REGISTER {
    pub __bindgen_anon_1: _PCI_FPB_MEM_LOW_VECTOR_CONTROL_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_FPB_MEM_LOW_VECTOR_CONTROL_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_FPB_MEM_LOW_VECTOR_CONTROL_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn MemLowDecodeMechanismEnable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MemLowDecodeMechanismEnable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemLowDecodeMechanismEnable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemLowDecodeMechanismEnable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd0(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd0(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd0_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd0_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemLowVectorGranularity(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_MemLowVectorGranularity(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemLowVectorGranularity_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemLowVectorGranularity_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                12u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemLowVectorStart(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_MemLowVectorStart(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemLowVectorStart_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                12u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemLowVectorStart_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MemLowDecodeMechanismEnable: ULONG,
        Rsvd0: ULONG,
        MemLowVectorGranularity: ULONG,
        Rsvd1: ULONG,
        MemLowVectorStart: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let MemLowDecodeMechanismEnable: u32 =
                unsafe { ::core::mem::transmute(MemLowDecodeMechanismEnable) };
            MemLowDecodeMechanismEnable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let Rsvd0: u32 = unsafe { ::core::mem::transmute(Rsvd0) };
            Rsvd0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let MemLowVectorGranularity: u32 =
                unsafe { ::core::mem::transmute(MemLowVectorGranularity) };
            MemLowVectorGranularity as u64
        });
        __bindgen_bitfield_unit.set(8usize, 12u8, {
            let Rsvd1: u32 = unsafe { ::core::mem::transmute(Rsvd1) };
            Rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let MemLowVectorStart: u32 = unsafe { ::core::mem::transmute(MemLowVectorStart) };
            MemLowVectorStart as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_FPB_MEM_LOW_VECTOR_CONTROL_REGISTER = _PCI_FPB_MEM_LOW_VECTOR_CONTROL_REGISTER;
pub type PPCI_FPB_MEM_LOW_VECTOR_CONTROL_REGISTER = *mut _PCI_FPB_MEM_LOW_VECTOR_CONTROL_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_FPB_MEM_HIGH_VECTOR_CONTROL1_REGISTER {
    pub __bindgen_anon_1: _PCI_FPB_MEM_HIGH_VECTOR_CONTROL1_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_FPB_MEM_HIGH_VECTOR_CONTROL1_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_FPB_MEM_HIGH_VECTOR_CONTROL1_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn MemHighDecodeMechanismEnable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MemHighDecodeMechanismEnable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemHighDecodeMechanismEnable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemHighDecodeMechanismEnable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd0(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd0(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd0_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd0_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemHighVectorGranularity(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_MemHighVectorGranularity(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemHighVectorGranularity_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemHighVectorGranularity_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                20u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                20u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemHighVectorStartLower(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_MemHighVectorStartLower(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemHighVectorStartLower_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemHighVectorStartLower_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MemHighDecodeMechanismEnable: ULONG,
        Rsvd0: ULONG,
        MemHighVectorGranularity: ULONG,
        Rsvd1: ULONG,
        MemHighVectorStartLower: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let MemHighDecodeMechanismEnable: u32 =
                unsafe { ::core::mem::transmute(MemHighDecodeMechanismEnable) };
            MemHighDecodeMechanismEnable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let Rsvd0: u32 = unsafe { ::core::mem::transmute(Rsvd0) };
            Rsvd0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let MemHighVectorGranularity: u32 =
                unsafe { ::core::mem::transmute(MemHighVectorGranularity) };
            MemHighVectorGranularity as u64
        });
        __bindgen_bitfield_unit.set(8usize, 20u8, {
            let Rsvd1: u32 = unsafe { ::core::mem::transmute(Rsvd1) };
            Rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let MemHighVectorStartLower: u32 =
                unsafe { ::core::mem::transmute(MemHighVectorStartLower) };
            MemHighVectorStartLower as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_FPB_MEM_HIGH_VECTOR_CONTROL1_REGISTER = _PCI_FPB_MEM_HIGH_VECTOR_CONTROL1_REGISTER;
pub type PPCI_FPB_MEM_HIGH_VECTOR_CONTROL1_REGISTER =
*mut _PCI_FPB_MEM_HIGH_VECTOR_CONTROL1_REGISTER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_FPB_MEM_HIGH_VECTOR_CONTROL2_REGISTER {
    pub MemHighVectorStartUpper: ULONG,
}
pub type PCI_FPB_MEM_HIGH_VECTOR_CONTROL2_REGISTER = _PCI_FPB_MEM_HIGH_VECTOR_CONTROL2_REGISTER;
pub type PPCI_FPB_MEM_HIGH_VECTOR_CONTROL2_REGISTER =
*mut _PCI_FPB_MEM_HIGH_VECTOR_CONTROL2_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_FPB_VECTOR_ACCESS_CONTROL_REGISTER {
    pub __bindgen_anon_1: _PCI_FPB_VECTOR_ACCESS_CONTROL_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_FPB_VECTOR_ACCESS_CONTROL_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_FPB_VECTOR_ACCESS_CONTROL_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn VectorAccessOffset(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_VectorAccessOffset(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VectorAccessOffset_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VectorAccessOffset_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd0(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd0(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd0_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd0_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VectorSelect(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_VectorSelect(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VectorSelect_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VectorSelect_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        VectorAccessOffset: ULONG,
        Rsvd0: ULONG,
        VectorSelect: ULONG,
        Rsvd1: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let VectorAccessOffset: u32 = unsafe { ::core::mem::transmute(VectorAccessOffset) };
            VectorAccessOffset as u64
        });
        __bindgen_bitfield_unit.set(8usize, 6u8, {
            let Rsvd0: u32 = unsafe { ::core::mem::transmute(Rsvd0) };
            Rsvd0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let VectorSelect: u32 = unsafe { ::core::mem::transmute(VectorSelect) };
            VectorSelect as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let Rsvd1: u32 = unsafe { ::core::mem::transmute(Rsvd1) };
            Rsvd1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_FPB_VECTOR_ACCESS_CONTROL_REGISTER = _PCI_FPB_VECTOR_ACCESS_CONTROL_REGISTER;
pub type PPCI_FPB_VECTOR_ACCESS_CONTROL_REGISTER = *mut _PCI_FPB_VECTOR_ACCESS_CONTROL_REGISTER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_FPB_VECTOR_ACCESS_DATA_REGISTER {
    pub VectorAccessData: ULONG,
}
pub type PCI_FPB_VECTOR_ACCESS_DATA_REGISTER = _PCI_FPB_VECTOR_ACCESS_DATA_REGISTER;
pub type PPCI_FPB_VECTOR_ACCESS_DATA_REGISTER = *mut _PCI_FPB_VECTOR_ACCESS_DATA_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_FPB_CAPABILITY {
    pub Header: PCI_FPB_CAPABILITY_HEADER,
    pub CapabilitiesRegister: PCI_FPB_CAPABILITIES_REGISTER,
    pub RidVectorControl1Register: PCI_FPB_RID_VECTOR_CONTROL1_REGISTER,
    pub RidVectorControl2Register: PCI_FPB_RID_VECTOR_CONTROL2_REGISTER,
    pub MemLowVectorControlRegister: PCI_FPB_MEM_LOW_VECTOR_CONTROL_REGISTER,
    pub MemHighVectorControl1Register: PCI_FPB_MEM_HIGH_VECTOR_CONTROL1_REGISTER,
    pub MemHighVectorControl2Register: PCI_FPB_MEM_HIGH_VECTOR_CONTROL2_REGISTER,
    pub VectorAccessControlRegister: PCI_FPB_VECTOR_ACCESS_CONTROL_REGISTER,
    pub VectorAccessDataRegister: PCI_FPB_VECTOR_ACCESS_DATA_REGISTER,
}
pub type PCI_FPB_CAPABILITY = _PCI_FPB_CAPABILITY;
pub type PPCI_FPB_CAPABILITY = *mut _PCI_FPB_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_VENDOR_SPECIFIC_CAPABILITY {
    pub Header: PCI_CAPABILITIES_HEADER,
    pub VscLength: UCHAR,
    pub VendorSpecific: UCHAR,
}
pub type PCI_VENDOR_SPECIFIC_CAPABILITY = _PCI_VENDOR_SPECIFIC_CAPABILITY;
pub type PPCI_VENDOR_SPECIFIC_CAPABILITY = *mut _PCI_VENDOR_SPECIFIC_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_CAPABILITIES_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_CAPABILITIES_REGISTER__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_CAPABILITIES_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_CAPABILITIES_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn CapabilityVersion(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_CapabilityVersion(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CapabilityVersion_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_CapabilityVersion_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DeviceType(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_DeviceType(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DeviceType_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_DeviceType_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SlotImplemented(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SlotImplemented(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SlotImplemented_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_SlotImplemented_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn InterruptMessageNumber(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_InterruptMessageNumber(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InterruptMessageNumber_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_InterruptMessageNumber_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CapabilityVersion: USHORT,
        DeviceType: USHORT,
        SlotImplemented: USHORT,
        InterruptMessageNumber: USHORT,
        Rsvd: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let CapabilityVersion: u16 = unsafe { ::core::mem::transmute(CapabilityVersion) };
            CapabilityVersion as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let DeviceType: u16 = unsafe { ::core::mem::transmute(DeviceType) };
            DeviceType as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let SlotImplemented: u16 = unsafe { ::core::mem::transmute(SlotImplemented) };
            SlotImplemented as u64
        });
        __bindgen_bitfield_unit.set(9usize, 5u8, {
            let InterruptMessageNumber: u16 =
                unsafe { ::core::mem::transmute(InterruptMessageNumber) };
            InterruptMessageNumber as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let Rsvd: u16 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_CAPABILITIES_REGISTER = _PCI_EXPRESS_CAPABILITIES_REGISTER;
pub type PPCI_EXPRESS_CAPABILITIES_REGISTER = *mut _PCI_EXPRESS_CAPABILITIES_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn MaxPayloadSizeSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_MaxPayloadSizeSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MaxPayloadSizeSupported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MaxPayloadSizeSupported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PhantomFunctionsSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_PhantomFunctionsSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PhantomFunctionsSupported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PhantomFunctionsSupported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ExtendedTagSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExtendedTagSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ExtendedTagSupported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ExtendedTagSupported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn L0sAcceptableLatency(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_L0sAcceptableLatency(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn L0sAcceptableLatency_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_L0sAcceptableLatency_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn L1AcceptableLatency(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_L1AcceptableLatency(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn L1AcceptableLatency_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_L1AcceptableLatency_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Undefined(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Undefined(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Undefined_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Undefined_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RoleBasedErrorReporting(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RoleBasedErrorReporting(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RoleBasedErrorReporting_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RoleBasedErrorReporting_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CapturedSlotPowerLimit(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_CapturedSlotPowerLimit(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CapturedSlotPowerLimit_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CapturedSlotPowerLimit_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CapturedSlotPowerLimitScale(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_CapturedSlotPowerLimitScale(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CapturedSlotPowerLimitScale_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CapturedSlotPowerLimitScale_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FunctionLevelResetCapability(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FunctionLevelResetCapability(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FunctionLevelResetCapability_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FunctionLevelResetCapability_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                29usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                29usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MaxPayloadSizeSupported: ULONG,
        PhantomFunctionsSupported: ULONG,
        ExtendedTagSupported: ULONG,
        L0sAcceptableLatency: ULONG,
        L1AcceptableLatency: ULONG,
        Undefined: ULONG,
        RoleBasedErrorReporting: ULONG,
        Rsvd1: ULONG,
        CapturedSlotPowerLimit: ULONG,
        CapturedSlotPowerLimitScale: ULONG,
        FunctionLevelResetCapability: ULONG,
        Rsvd2: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let MaxPayloadSizeSupported: u32 =
                unsafe { ::core::mem::transmute(MaxPayloadSizeSupported) };
            MaxPayloadSizeSupported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let PhantomFunctionsSupported: u32 =
                unsafe { ::core::mem::transmute(PhantomFunctionsSupported) };
            PhantomFunctionsSupported as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ExtendedTagSupported: u32 = unsafe { ::core::mem::transmute(ExtendedTagSupported) };
            ExtendedTagSupported as u64
        });
        __bindgen_bitfield_unit.set(6usize, 3u8, {
            let L0sAcceptableLatency: u32 = unsafe { ::core::mem::transmute(L0sAcceptableLatency) };
            L0sAcceptableLatency as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let L1AcceptableLatency: u32 = unsafe { ::core::mem::transmute(L1AcceptableLatency) };
            L1AcceptableLatency as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let Undefined: u32 = unsafe { ::core::mem::transmute(Undefined) };
            Undefined as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let RoleBasedErrorReporting: u32 =
                unsafe { ::core::mem::transmute(RoleBasedErrorReporting) };
            RoleBasedErrorReporting as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let Rsvd1: u32 = unsafe { ::core::mem::transmute(Rsvd1) };
            Rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 8u8, {
            let CapturedSlotPowerLimit: u32 =
                unsafe { ::core::mem::transmute(CapturedSlotPowerLimit) };
            CapturedSlotPowerLimit as u64
        });
        __bindgen_bitfield_unit.set(26usize, 2u8, {
            let CapturedSlotPowerLimitScale: u32 =
                unsafe { ::core::mem::transmute(CapturedSlotPowerLimitScale) };
            CapturedSlotPowerLimitScale as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let FunctionLevelResetCapability: u32 =
                unsafe { ::core::mem::transmute(FunctionLevelResetCapability) };
            FunctionLevelResetCapability as u64
        });
        __bindgen_bitfield_unit.set(29usize, 3u8, {
            let Rsvd2: u32 = unsafe { ::core::mem::transmute(Rsvd2) };
            Rsvd2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER = _PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER;
pub type PPCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER = *mut _PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_DEVICE_CONTROL_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_DEVICE_CONTROL_REGISTER__bindgen_ty_1,
    pub __bindgen_anon_2: _PCI_EXPRESS_DEVICE_CONTROL_REGISTER__bindgen_ty_2,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_DEVICE_CONTROL_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_DEVICE_CONTROL_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn CorrectableErrorEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CorrectableErrorEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CorrectableErrorEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_CorrectableErrorEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NonFatalErrorEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_NonFatalErrorEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NonFatalErrorEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_NonFatalErrorEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FatalErrorEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_FatalErrorEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FatalErrorEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_FatalErrorEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UnsupportedRequestErrorEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UnsupportedRequestErrorEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UnsupportedRequestErrorEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_UnsupportedRequestErrorEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EnableRelaxedOrder(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EnableRelaxedOrder(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EnableRelaxedOrder_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_EnableRelaxedOrder_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MaxPayloadSize(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_MaxPayloadSize(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MaxPayloadSize_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_MaxPayloadSize_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ExtendedTagEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ExtendedTagEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ExtendedTagEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ExtendedTagEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PhantomFunctionsEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PhantomFunctionsEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PhantomFunctionsEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PhantomFunctionsEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AuxPowerEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_AuxPowerEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AuxPowerEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_AuxPowerEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NoSnoopEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_NoSnoopEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NoSnoopEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_NoSnoopEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MaxReadRequestSize(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_MaxReadRequestSize(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MaxReadRequestSize_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_MaxReadRequestSize_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn BridgeConfigRetryEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_BridgeConfigRetryEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn BridgeConfigRetryEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_BridgeConfigRetryEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CorrectableErrorEnable: USHORT,
        NonFatalErrorEnable: USHORT,
        FatalErrorEnable: USHORT,
        UnsupportedRequestErrorEnable: USHORT,
        EnableRelaxedOrder: USHORT,
        MaxPayloadSize: USHORT,
        ExtendedTagEnable: USHORT,
        PhantomFunctionsEnable: USHORT,
        AuxPowerEnable: USHORT,
        NoSnoopEnable: USHORT,
        MaxReadRequestSize: USHORT,
        BridgeConfigRetryEnable: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CorrectableErrorEnable: u16 =
                unsafe { ::core::mem::transmute(CorrectableErrorEnable) };
            CorrectableErrorEnable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let NonFatalErrorEnable: u16 = unsafe { ::core::mem::transmute(NonFatalErrorEnable) };
            NonFatalErrorEnable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let FatalErrorEnable: u16 = unsafe { ::core::mem::transmute(FatalErrorEnable) };
            FatalErrorEnable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let UnsupportedRequestErrorEnable: u16 =
                unsafe { ::core::mem::transmute(UnsupportedRequestErrorEnable) };
            UnsupportedRequestErrorEnable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let EnableRelaxedOrder: u16 = unsafe { ::core::mem::transmute(EnableRelaxedOrder) };
            EnableRelaxedOrder as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let MaxPayloadSize: u16 = unsafe { ::core::mem::transmute(MaxPayloadSize) };
            MaxPayloadSize as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ExtendedTagEnable: u16 = unsafe { ::core::mem::transmute(ExtendedTagEnable) };
            ExtendedTagEnable as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let PhantomFunctionsEnable: u16 =
                unsafe { ::core::mem::transmute(PhantomFunctionsEnable) };
            PhantomFunctionsEnable as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let AuxPowerEnable: u16 = unsafe { ::core::mem::transmute(AuxPowerEnable) };
            AuxPowerEnable as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let NoSnoopEnable: u16 = unsafe { ::core::mem::transmute(NoSnoopEnable) };
            NoSnoopEnable as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let MaxReadRequestSize: u16 = unsafe { ::core::mem::transmute(MaxReadRequestSize) };
            MaxReadRequestSize as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let BridgeConfigRetryEnable: u16 =
                unsafe { ::core::mem::transmute(BridgeConfigRetryEnable) };
            BridgeConfigRetryEnable as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_DEVICE_CONTROL_REGISTER__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_DEVICE_CONTROL_REGISTER__bindgen_ty_2 {
    #[inline]
    pub fn InitiateFunctionLevelReset(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_InitiateFunctionLevelReset(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InitiateFunctionLevelReset_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_InitiateFunctionLevelReset_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        InitiateFunctionLevelReset: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let InitiateFunctionLevelReset: u16 =
                unsafe { ::core::mem::transmute(InitiateFunctionLevelReset) };
            InitiateFunctionLevelReset as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_DEVICE_CONTROL_REGISTER = _PCI_EXPRESS_DEVICE_CONTROL_REGISTER;
pub type PPCI_EXPRESS_DEVICE_CONTROL_REGISTER = *mut _PCI_EXPRESS_DEVICE_CONTROL_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_DEVICE_STATUS_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_DEVICE_STATUS_REGISTER__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_DEVICE_STATUS_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_DEVICE_STATUS_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn CorrectableErrorDetected(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CorrectableErrorDetected(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CorrectableErrorDetected_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_CorrectableErrorDetected_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NonFatalErrorDetected(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_NonFatalErrorDetected(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NonFatalErrorDetected_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_NonFatalErrorDetected_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FatalErrorDetected(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_FatalErrorDetected(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FatalErrorDetected_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_FatalErrorDetected_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UnsupportedRequestDetected(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UnsupportedRequestDetected(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UnsupportedRequestDetected_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_UnsupportedRequestDetected_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AuxPowerDetected(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_AuxPowerDetected(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AuxPowerDetected_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_AuxPowerDetected_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TransactionsPending(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TransactionsPending(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TransactionsPending_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_TransactionsPending_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 10u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                10u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                10u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CorrectableErrorDetected: USHORT,
        NonFatalErrorDetected: USHORT,
        FatalErrorDetected: USHORT,
        UnsupportedRequestDetected: USHORT,
        AuxPowerDetected: USHORT,
        TransactionsPending: USHORT,
        Rsvd: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CorrectableErrorDetected: u16 =
                unsafe { ::core::mem::transmute(CorrectableErrorDetected) };
            CorrectableErrorDetected as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let NonFatalErrorDetected: u16 =
                unsafe { ::core::mem::transmute(NonFatalErrorDetected) };
            NonFatalErrorDetected as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let FatalErrorDetected: u16 = unsafe { ::core::mem::transmute(FatalErrorDetected) };
            FatalErrorDetected as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let UnsupportedRequestDetected: u16 =
                unsafe { ::core::mem::transmute(UnsupportedRequestDetected) };
            UnsupportedRequestDetected as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let AuxPowerDetected: u16 = unsafe { ::core::mem::transmute(AuxPowerDetected) };
            AuxPowerDetected as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let TransactionsPending: u16 = unsafe { ::core::mem::transmute(TransactionsPending) };
            TransactionsPending as u64
        });
        __bindgen_bitfield_unit.set(6usize, 10u8, {
            let Rsvd: u16 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_DEVICE_STATUS_REGISTER = _PCI_EXPRESS_DEVICE_STATUS_REGISTER;
pub type PPCI_EXPRESS_DEVICE_STATUS_REGISTER = *mut _PCI_EXPRESS_DEVICE_STATUS_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_LINK_CAPABILITIES_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_LINK_CAPABILITIES_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_LINK_CAPABILITIES_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_LINK_CAPABILITIES_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn MaximumLinkSpeed(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_MaximumLinkSpeed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MaximumLinkSpeed_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MaximumLinkSpeed_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MaximumLinkWidth(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_MaximumLinkWidth(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MaximumLinkWidth_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MaximumLinkWidth_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ActiveStatePMSupport(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ActiveStatePMSupport(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ActiveStatePMSupport_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ActiveStatePMSupport_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn L0sExitLatency(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_L0sExitLatency(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn L0sExitLatency_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_L0sExitLatency_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn L1ExitLatency(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_L1ExitLatency(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn L1ExitLatency_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_L1ExitLatency_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ClockPowerManagement(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ClockPowerManagement(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ClockPowerManagement_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ClockPowerManagement_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SurpriseDownErrorReportingCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SurpriseDownErrorReportingCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SurpriseDownErrorReportingCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SurpriseDownErrorReportingCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DataLinkLayerActiveReportingCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DataLinkLayerActiveReportingCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DataLinkLayerActiveReportingCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DataLinkLayerActiveReportingCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LinkBandwidthNotificationCapability(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LinkBandwidthNotificationCapability(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LinkBandwidthNotificationCapability_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_LinkBandwidthNotificationCapability_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AspmOptionalityCompliance(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AspmOptionalityCompliance(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AspmOptionalityCompliance_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AspmOptionalityCompliance_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PortNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_PortNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PortNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PortNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MaximumLinkSpeed: ULONG,
        MaximumLinkWidth: ULONG,
        ActiveStatePMSupport: ULONG,
        L0sExitLatency: ULONG,
        L1ExitLatency: ULONG,
        ClockPowerManagement: ULONG,
        SurpriseDownErrorReportingCapable: ULONG,
        DataLinkLayerActiveReportingCapable: ULONG,
        LinkBandwidthNotificationCapability: ULONG,
        AspmOptionalityCompliance: ULONG,
        Rsvd: ULONG,
        PortNumber: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let MaximumLinkSpeed: u32 = unsafe { ::core::mem::transmute(MaximumLinkSpeed) };
            MaximumLinkSpeed as u64
        });
        __bindgen_bitfield_unit.set(4usize, 6u8, {
            let MaximumLinkWidth: u32 = unsafe { ::core::mem::transmute(MaximumLinkWidth) };
            MaximumLinkWidth as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let ActiveStatePMSupport: u32 = unsafe { ::core::mem::transmute(ActiveStatePMSupport) };
            ActiveStatePMSupport as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let L0sExitLatency: u32 = unsafe { ::core::mem::transmute(L0sExitLatency) };
            L0sExitLatency as u64
        });
        __bindgen_bitfield_unit.set(15usize, 3u8, {
            let L1ExitLatency: u32 = unsafe { ::core::mem::transmute(L1ExitLatency) };
            L1ExitLatency as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let ClockPowerManagement: u32 = unsafe { ::core::mem::transmute(ClockPowerManagement) };
            ClockPowerManagement as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let SurpriseDownErrorReportingCapable: u32 =
                unsafe { ::core::mem::transmute(SurpriseDownErrorReportingCapable) };
            SurpriseDownErrorReportingCapable as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let DataLinkLayerActiveReportingCapable: u32 =
                unsafe { ::core::mem::transmute(DataLinkLayerActiveReportingCapable) };
            DataLinkLayerActiveReportingCapable as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let LinkBandwidthNotificationCapability: u32 =
                unsafe { ::core::mem::transmute(LinkBandwidthNotificationCapability) };
            LinkBandwidthNotificationCapability as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let AspmOptionalityCompliance: u32 =
                unsafe { ::core::mem::transmute(AspmOptionalityCompliance) };
            AspmOptionalityCompliance as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let Rsvd: u32 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let PortNumber: u32 = unsafe { ::core::mem::transmute(PortNumber) };
            PortNumber as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_LINK_CAPABILITIES_REGISTER = _PCI_EXPRESS_LINK_CAPABILITIES_REGISTER;
pub type PPCI_EXPRESS_LINK_CAPABILITIES_REGISTER = *mut _PCI_EXPRESS_LINK_CAPABILITIES_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_LINK_CONTROL_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_LINK_CONTROL_REGISTER__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_LINK_CONTROL_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_LINK_CONTROL_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn ActiveStatePMControl(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_ActiveStatePMControl(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ActiveStatePMControl_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ActiveStatePMControl_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd1(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd1(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd1_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd1_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReadCompletionBoundary(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ReadCompletionBoundary(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReadCompletionBoundary_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ReadCompletionBoundary_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LinkDisable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LinkDisable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LinkDisable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_LinkDisable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RetrainLink(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RetrainLink(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RetrainLink_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_RetrainLink_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CommonClockConfig(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CommonClockConfig(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CommonClockConfig_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_CommonClockConfig_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ExtendedSynch(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ExtendedSynch(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ExtendedSynch_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ExtendedSynch_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EnableClockPowerManagement(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EnableClockPowerManagement(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EnableClockPowerManagement_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_EnableClockPowerManagement_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd2(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 7u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd2_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                7u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd2_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ActiveStatePMControl: USHORT,
        Rsvd1: USHORT,
        ReadCompletionBoundary: USHORT,
        LinkDisable: USHORT,
        RetrainLink: USHORT,
        CommonClockConfig: USHORT,
        ExtendedSynch: USHORT,
        EnableClockPowerManagement: USHORT,
        Rsvd2: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let ActiveStatePMControl: u16 = unsafe { ::core::mem::transmute(ActiveStatePMControl) };
            ActiveStatePMControl as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Rsvd1: u16 = unsafe { ::core::mem::transmute(Rsvd1) };
            Rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ReadCompletionBoundary: u16 =
                unsafe { ::core::mem::transmute(ReadCompletionBoundary) };
            ReadCompletionBoundary as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let LinkDisable: u16 = unsafe { ::core::mem::transmute(LinkDisable) };
            LinkDisable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let RetrainLink: u16 = unsafe { ::core::mem::transmute(RetrainLink) };
            RetrainLink as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let CommonClockConfig: u16 = unsafe { ::core::mem::transmute(CommonClockConfig) };
            CommonClockConfig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ExtendedSynch: u16 = unsafe { ::core::mem::transmute(ExtendedSynch) };
            ExtendedSynch as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let EnableClockPowerManagement: u16 =
                unsafe { ::core::mem::transmute(EnableClockPowerManagement) };
            EnableClockPowerManagement as u64
        });
        __bindgen_bitfield_unit.set(9usize, 7u8, {
            let Rsvd2: u16 = unsafe { ::core::mem::transmute(Rsvd2) };
            Rsvd2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_LINK_CONTROL_REGISTER = _PCI_EXPRESS_LINK_CONTROL_REGISTER;
pub type PPCI_EXPRESS_LINK_CONTROL_REGISTER = *mut _PCI_EXPRESS_LINK_CONTROL_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_LINK_STATUS_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_LINK_STATUS_REGISTER__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_LINK_STATUS_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_LINK_STATUS_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn LinkSpeed(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_LinkSpeed(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LinkSpeed_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_LinkSpeed_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LinkWidth(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set_LinkWidth(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LinkWidth_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                6u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_LinkWidth_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Undefined(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Undefined(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Undefined_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Undefined_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LinkTraining(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LinkTraining(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LinkTraining_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_LinkTraining_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SlotClockConfig(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SlotClockConfig(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SlotClockConfig_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_SlotClockConfig_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DataLinkLayerActive(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DataLinkLayerActive(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DataLinkLayerActive_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_DataLinkLayerActive_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        LinkSpeed: USHORT,
        LinkWidth: USHORT,
        Undefined: USHORT,
        LinkTraining: USHORT,
        SlotClockConfig: USHORT,
        DataLinkLayerActive: USHORT,
        Rsvd: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let LinkSpeed: u16 = unsafe { ::core::mem::transmute(LinkSpeed) };
            LinkSpeed as u64
        });
        __bindgen_bitfield_unit.set(4usize, 6u8, {
            let LinkWidth: u16 = unsafe { ::core::mem::transmute(LinkWidth) };
            LinkWidth as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let Undefined: u16 = unsafe { ::core::mem::transmute(Undefined) };
            Undefined as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let LinkTraining: u16 = unsafe { ::core::mem::transmute(LinkTraining) };
            LinkTraining as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let SlotClockConfig: u16 = unsafe { ::core::mem::transmute(SlotClockConfig) };
            SlotClockConfig as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let DataLinkLayerActive: u16 = unsafe { ::core::mem::transmute(DataLinkLayerActive) };
            DataLinkLayerActive as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let Rsvd: u16 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_LINK_STATUS_REGISTER = _PCI_EXPRESS_LINK_STATUS_REGISTER;
pub type PPCI_EXPRESS_LINK_STATUS_REGISTER = *mut _PCI_EXPRESS_LINK_STATUS_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn AttentionButtonPresent(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AttentionButtonPresent(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AttentionButtonPresent_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AttentionButtonPresent_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PowerControllerPresent(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PowerControllerPresent(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PowerControllerPresent_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PowerControllerPresent_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MRLSensorPresent(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MRLSensorPresent(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MRLSensorPresent_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MRLSensorPresent_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AttentionIndicatorPresent(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AttentionIndicatorPresent(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AttentionIndicatorPresent_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AttentionIndicatorPresent_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PowerIndicatorPresent(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PowerIndicatorPresent(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PowerIndicatorPresent_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PowerIndicatorPresent_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn HotPlugSurprise(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HotPlugSurprise(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn HotPlugSurprise_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_HotPlugSurprise_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn HotPlugCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HotPlugCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn HotPlugCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_HotPlugCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SlotPowerLimit(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_SlotPowerLimit(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SlotPowerLimit_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SlotPowerLimit_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SlotPowerLimitScale(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_SlotPowerLimitScale(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SlotPowerLimitScale_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SlotPowerLimitScale_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ElectromechanicalLockPresent(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ElectromechanicalLockPresent(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ElectromechanicalLockPresent_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ElectromechanicalLockPresent_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NoCommandCompletedSupport(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoCommandCompletedSupport(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NoCommandCompletedSupport_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NoCommandCompletedSupport_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PhysicalSlotNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_PhysicalSlotNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PhysicalSlotNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                13u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PhysicalSlotNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                13u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AttentionButtonPresent: ULONG,
        PowerControllerPresent: ULONG,
        MRLSensorPresent: ULONG,
        AttentionIndicatorPresent: ULONG,
        PowerIndicatorPresent: ULONG,
        HotPlugSurprise: ULONG,
        HotPlugCapable: ULONG,
        SlotPowerLimit: ULONG,
        SlotPowerLimitScale: ULONG,
        ElectromechanicalLockPresent: ULONG,
        NoCommandCompletedSupport: ULONG,
        PhysicalSlotNumber: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let AttentionButtonPresent: u32 =
                unsafe { ::core::mem::transmute(AttentionButtonPresent) };
            AttentionButtonPresent as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PowerControllerPresent: u32 =
                unsafe { ::core::mem::transmute(PowerControllerPresent) };
            PowerControllerPresent as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let MRLSensorPresent: u32 = unsafe { ::core::mem::transmute(MRLSensorPresent) };
            MRLSensorPresent as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AttentionIndicatorPresent: u32 =
                unsafe { ::core::mem::transmute(AttentionIndicatorPresent) };
            AttentionIndicatorPresent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PowerIndicatorPresent: u32 =
                unsafe { ::core::mem::transmute(PowerIndicatorPresent) };
            PowerIndicatorPresent as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let HotPlugSurprise: u32 = unsafe { ::core::mem::transmute(HotPlugSurprise) };
            HotPlugSurprise as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let HotPlugCapable: u32 = unsafe { ::core::mem::transmute(HotPlugCapable) };
            HotPlugCapable as u64
        });
        __bindgen_bitfield_unit.set(7usize, 8u8, {
            let SlotPowerLimit: u32 = unsafe { ::core::mem::transmute(SlotPowerLimit) };
            SlotPowerLimit as u64
        });
        __bindgen_bitfield_unit.set(15usize, 2u8, {
            let SlotPowerLimitScale: u32 = unsafe { ::core::mem::transmute(SlotPowerLimitScale) };
            SlotPowerLimitScale as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let ElectromechanicalLockPresent: u32 =
                unsafe { ::core::mem::transmute(ElectromechanicalLockPresent) };
            ElectromechanicalLockPresent as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let NoCommandCompletedSupport: u32 =
                unsafe { ::core::mem::transmute(NoCommandCompletedSupport) };
            NoCommandCompletedSupport as u64
        });
        __bindgen_bitfield_unit.set(19usize, 13u8, {
            let PhysicalSlotNumber: u32 = unsafe { ::core::mem::transmute(PhysicalSlotNumber) };
            PhysicalSlotNumber as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER = _PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER;
pub type PPCI_EXPRESS_SLOT_CAPABILITIES_REGISTER = *mut _PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_SLOT_CONTROL_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_SLOT_CONTROL_REGISTER__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_SLOT_CONTROL_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_SLOT_CONTROL_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn AttentionButtonEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_AttentionButtonEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AttentionButtonEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_AttentionButtonEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PowerFaultDetectEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PowerFaultDetectEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PowerFaultDetectEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PowerFaultDetectEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MRLSensorEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_MRLSensorEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MRLSensorEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_MRLSensorEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PresenceDetectEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PresenceDetectEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PresenceDetectEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PresenceDetectEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CommandCompletedEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CommandCompletedEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CommandCompletedEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_CommandCompletedEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn HotPlugInterruptEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_HotPlugInterruptEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn HotPlugInterruptEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_HotPlugInterruptEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AttentionIndicatorControl(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_AttentionIndicatorControl(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AttentionIndicatorControl_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_AttentionIndicatorControl_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PowerIndicatorControl(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_PowerIndicatorControl(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PowerIndicatorControl_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PowerIndicatorControl_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PowerControllerControl(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PowerControllerControl(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PowerControllerControl_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PowerControllerControl_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ElectromechanicalLockControl(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ElectromechanicalLockControl(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ElectromechanicalLockControl_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ElectromechanicalLockControl_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DataLinkStateChangeEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DataLinkStateChangeEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DataLinkStateChangeEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_DataLinkStateChangeEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AttentionButtonEnable: USHORT,
        PowerFaultDetectEnable: USHORT,
        MRLSensorEnable: USHORT,
        PresenceDetectEnable: USHORT,
        CommandCompletedEnable: USHORT,
        HotPlugInterruptEnable: USHORT,
        AttentionIndicatorControl: USHORT,
        PowerIndicatorControl: USHORT,
        PowerControllerControl: USHORT,
        ElectromechanicalLockControl: USHORT,
        DataLinkStateChangeEnable: USHORT,
        Rsvd: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let AttentionButtonEnable: u16 =
                unsafe { ::core::mem::transmute(AttentionButtonEnable) };
            AttentionButtonEnable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PowerFaultDetectEnable: u16 =
                unsafe { ::core::mem::transmute(PowerFaultDetectEnable) };
            PowerFaultDetectEnable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let MRLSensorEnable: u16 = unsafe { ::core::mem::transmute(MRLSensorEnable) };
            MRLSensorEnable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PresenceDetectEnable: u16 = unsafe { ::core::mem::transmute(PresenceDetectEnable) };
            PresenceDetectEnable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CommandCompletedEnable: u16 =
                unsafe { ::core::mem::transmute(CommandCompletedEnable) };
            CommandCompletedEnable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let HotPlugInterruptEnable: u16 =
                unsafe { ::core::mem::transmute(HotPlugInterruptEnable) };
            HotPlugInterruptEnable as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let AttentionIndicatorControl: u16 =
                unsafe { ::core::mem::transmute(AttentionIndicatorControl) };
            AttentionIndicatorControl as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let PowerIndicatorControl: u16 =
                unsafe { ::core::mem::transmute(PowerIndicatorControl) };
            PowerIndicatorControl as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let PowerControllerControl: u16 =
                unsafe { ::core::mem::transmute(PowerControllerControl) };
            PowerControllerControl as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let ElectromechanicalLockControl: u16 =
                unsafe { ::core::mem::transmute(ElectromechanicalLockControl) };
            ElectromechanicalLockControl as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let DataLinkStateChangeEnable: u16 =
                unsafe { ::core::mem::transmute(DataLinkStateChangeEnable) };
            DataLinkStateChangeEnable as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let Rsvd: u16 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_SLOT_CONTROL_REGISTER = _PCI_EXPRESS_SLOT_CONTROL_REGISTER;
pub type PPCI_EXPRESS_SLOT_CONTROL_REGISTER = *mut _PCI_EXPRESS_SLOT_CONTROL_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_SLOT_STATUS_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_SLOT_STATUS_REGISTER__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_SLOT_STATUS_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_SLOT_STATUS_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn AttentionButtonPressed(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_AttentionButtonPressed(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AttentionButtonPressed_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_AttentionButtonPressed_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PowerFaultDetected(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PowerFaultDetected(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PowerFaultDetected_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PowerFaultDetected_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MRLSensorChanged(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_MRLSensorChanged(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MRLSensorChanged_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_MRLSensorChanged_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PresenceDetectChanged(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PresenceDetectChanged(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PresenceDetectChanged_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PresenceDetectChanged_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CommandCompleted(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CommandCompleted(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CommandCompleted_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_CommandCompleted_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MRLSensorState(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_MRLSensorState(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MRLSensorState_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_MRLSensorState_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PresenceDetectState(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PresenceDetectState(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PresenceDetectState_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PresenceDetectState_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ElectromechanicalLockEngaged(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ElectromechanicalLockEngaged(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ElectromechanicalLockEngaged_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ElectromechanicalLockEngaged_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DataLinkStateChanged(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DataLinkStateChanged(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DataLinkStateChanged_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_DataLinkStateChanged_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 7u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                7u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AttentionButtonPressed: USHORT,
        PowerFaultDetected: USHORT,
        MRLSensorChanged: USHORT,
        PresenceDetectChanged: USHORT,
        CommandCompleted: USHORT,
        MRLSensorState: USHORT,
        PresenceDetectState: USHORT,
        ElectromechanicalLockEngaged: USHORT,
        DataLinkStateChanged: USHORT,
        Rsvd: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let AttentionButtonPressed: u16 =
                unsafe { ::core::mem::transmute(AttentionButtonPressed) };
            AttentionButtonPressed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PowerFaultDetected: u16 = unsafe { ::core::mem::transmute(PowerFaultDetected) };
            PowerFaultDetected as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let MRLSensorChanged: u16 = unsafe { ::core::mem::transmute(MRLSensorChanged) };
            MRLSensorChanged as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PresenceDetectChanged: u16 =
                unsafe { ::core::mem::transmute(PresenceDetectChanged) };
            PresenceDetectChanged as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CommandCompleted: u16 = unsafe { ::core::mem::transmute(CommandCompleted) };
            CommandCompleted as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let MRLSensorState: u16 = unsafe { ::core::mem::transmute(MRLSensorState) };
            MRLSensorState as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PresenceDetectState: u16 = unsafe { ::core::mem::transmute(PresenceDetectState) };
            PresenceDetectState as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ElectromechanicalLockEngaged: u16 =
                unsafe { ::core::mem::transmute(ElectromechanicalLockEngaged) };
            ElectromechanicalLockEngaged as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let DataLinkStateChanged: u16 = unsafe { ::core::mem::transmute(DataLinkStateChanged) };
            DataLinkStateChanged as u64
        });
        __bindgen_bitfield_unit.set(9usize, 7u8, {
            let Rsvd: u16 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_SLOT_STATUS_REGISTER = _PCI_EXPRESS_SLOT_STATUS_REGISTER;
pub type PPCI_EXPRESS_SLOT_STATUS_REGISTER = *mut _PCI_EXPRESS_SLOT_STATUS_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_ROOT_CONTROL_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_ROOT_CONTROL_REGISTER__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_ROOT_CONTROL_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_ROOT_CONTROL_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn CorrectableSerrEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CorrectableSerrEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CorrectableSerrEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_CorrectableSerrEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NonFatalSerrEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_NonFatalSerrEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NonFatalSerrEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_NonFatalSerrEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FatalSerrEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_FatalSerrEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FatalSerrEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_FatalSerrEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PMEInterruptEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PMEInterruptEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PMEInterruptEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PMEInterruptEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CRSSoftwareVisibilityEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CRSSoftwareVisibilityEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CRSSoftwareVisibilityEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_CRSSoftwareVisibilityEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 11u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                11u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                11u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CorrectableSerrEnable: USHORT,
        NonFatalSerrEnable: USHORT,
        FatalSerrEnable: USHORT,
        PMEInterruptEnable: USHORT,
        CRSSoftwareVisibilityEnable: USHORT,
        Rsvd: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CorrectableSerrEnable: u16 =
                unsafe { ::core::mem::transmute(CorrectableSerrEnable) };
            CorrectableSerrEnable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let NonFatalSerrEnable: u16 = unsafe { ::core::mem::transmute(NonFatalSerrEnable) };
            NonFatalSerrEnable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let FatalSerrEnable: u16 = unsafe { ::core::mem::transmute(FatalSerrEnable) };
            FatalSerrEnable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PMEInterruptEnable: u16 = unsafe { ::core::mem::transmute(PMEInterruptEnable) };
            PMEInterruptEnable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CRSSoftwareVisibilityEnable: u16 =
                unsafe { ::core::mem::transmute(CRSSoftwareVisibilityEnable) };
            CRSSoftwareVisibilityEnable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 11u8, {
            let Rsvd: u16 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_ROOT_CONTROL_REGISTER = _PCI_EXPRESS_ROOT_CONTROL_REGISTER;
pub type PPCI_EXPRESS_ROOT_CONTROL_REGISTER = *mut _PCI_EXPRESS_ROOT_CONTROL_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn CRSSoftwareVisibility(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CRSSoftwareVisibility(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CRSSoftwareVisibility_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_CRSSoftwareVisibility_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 15u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                15u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                15u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CRSSoftwareVisibility: USHORT,
        Rsvd: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CRSSoftwareVisibility: u16 =
                unsafe { ::core::mem::transmute(CRSSoftwareVisibility) };
            CRSSoftwareVisibility as u64
        });
        __bindgen_bitfield_unit.set(1usize, 15u8, {
            let Rsvd: u16 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER = _PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER;
pub type PPCI_EXPRESS_ROOT_CAPABILITIES_REGISTER = *mut _PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_ROOT_STATUS_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_ROOT_STATUS_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_ROOT_STATUS_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_ROOT_STATUS_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn PMERequestorId(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_PMERequestorId(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PMERequestorId_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PMERequestorId_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PMEStatus(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PMEStatus(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PMEStatus_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PMEStatus_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PMEPending(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PMEPending(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PMEPending_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PMEPending_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                14u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                14u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PMERequestorId: ULONG,
        PMEStatus: ULONG,
        PMEPending: ULONG,
        Rsvd: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let PMERequestorId: u32 = unsafe { ::core::mem::transmute(PMERequestorId) };
            PMERequestorId as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let PMEStatus: u32 = unsafe { ::core::mem::transmute(PMEStatus) };
            PMEStatus as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let PMEPending: u32 = unsafe { ::core::mem::transmute(PMEPending) };
            PMEPending as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let Rsvd: u32 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_ROOT_STATUS_REGISTER = _PCI_EXPRESS_ROOT_STATUS_REGISTER;
pub type PPCI_EXPRESS_ROOT_STATUS_REGISTER = *mut _PCI_EXPRESS_ROOT_STATUS_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn CompletionTimeoutRangesSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_CompletionTimeoutRangesSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CompletionTimeoutRangesSupported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CompletionTimeoutRangesSupported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CompletionTimeoutDisableSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CompletionTimeoutDisableSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CompletionTimeoutDisableSupported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CompletionTimeoutDisableSupported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AriForwardingSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AriForwardingSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AriForwardingSupported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AriForwardingSupported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AtomicOpRoutingSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AtomicOpRoutingSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AtomicOpRoutingSupported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AtomicOpRoutingSupported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AtomicOpCompleterSupported32Bit(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AtomicOpCompleterSupported32Bit(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AtomicOpCompleterSupported32Bit_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AtomicOpCompleterSupported32Bit_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AtomicOpCompleterSupported64Bit(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AtomicOpCompleterSupported64Bit(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AtomicOpCompleterSupported64Bit_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AtomicOpCompleterSupported64Bit_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CASCompleterSupported128Bit(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CASCompleterSupported128Bit(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CASCompleterSupported128Bit_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CASCompleterSupported128Bit_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NoROEnabledPRPRPassing(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoROEnabledPRPRPassing(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NoROEnabledPRPRPassing_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NoROEnabledPRPRPassing_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LTRMechanismSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LTRMechanismSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LTRMechanismSupported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_LTRMechanismSupported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TPHCompleterSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_TPHCompleterSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TPHCompleterSupported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_TPHCompleterSupported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn OBFFSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_OBFFSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn OBFFSupported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_OBFFSupported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ExtendedFmtFieldSuported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExtendedFmtFieldSuported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ExtendedFmtFieldSuported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ExtendedFmtFieldSuported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EndEndTLPPrefixSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EndEndTLPPrefixSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EndEndTLPPrefixSupported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_EndEndTLPPrefixSupported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MaxEndEndTLPPrefixes(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_MaxEndEndTLPPrefixes(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MaxEndEndTLPPrefixes_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MaxEndEndTLPPrefixes_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CompletionTimeoutRangesSupported: ULONG,
        CompletionTimeoutDisableSupported: ULONG,
        AriForwardingSupported: ULONG,
        AtomicOpRoutingSupported: ULONG,
        AtomicOpCompleterSupported32Bit: ULONG,
        AtomicOpCompleterSupported64Bit: ULONG,
        CASCompleterSupported128Bit: ULONG,
        NoROEnabledPRPRPassing: ULONG,
        LTRMechanismSupported: ULONG,
        TPHCompleterSupported: ULONG,
        Rsvd: ULONG,
        OBFFSupported: ULONG,
        ExtendedFmtFieldSuported: ULONG,
        EndEndTLPPrefixSupported: ULONG,
        MaxEndEndTLPPrefixes: ULONG,
        Rsvd2: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let CompletionTimeoutRangesSupported: u32 =
                unsafe { ::core::mem::transmute(CompletionTimeoutRangesSupported) };
            CompletionTimeoutRangesSupported as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CompletionTimeoutDisableSupported: u32 =
                unsafe { ::core::mem::transmute(CompletionTimeoutDisableSupported) };
            CompletionTimeoutDisableSupported as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let AriForwardingSupported: u32 =
                unsafe { ::core::mem::transmute(AriForwardingSupported) };
            AriForwardingSupported as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let AtomicOpRoutingSupported: u32 =
                unsafe { ::core::mem::transmute(AtomicOpRoutingSupported) };
            AtomicOpRoutingSupported as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let AtomicOpCompleterSupported32Bit: u32 =
                unsafe { ::core::mem::transmute(AtomicOpCompleterSupported32Bit) };
            AtomicOpCompleterSupported32Bit as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let AtomicOpCompleterSupported64Bit: u32 =
                unsafe { ::core::mem::transmute(AtomicOpCompleterSupported64Bit) };
            AtomicOpCompleterSupported64Bit as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let CASCompleterSupported128Bit: u32 =
                unsafe { ::core::mem::transmute(CASCompleterSupported128Bit) };
            CASCompleterSupported128Bit as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let NoROEnabledPRPRPassing: u32 =
                unsafe { ::core::mem::transmute(NoROEnabledPRPRPassing) };
            NoROEnabledPRPRPassing as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let LTRMechanismSupported: u32 =
                unsafe { ::core::mem::transmute(LTRMechanismSupported) };
            LTRMechanismSupported as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let TPHCompleterSupported: u32 =
                unsafe { ::core::mem::transmute(TPHCompleterSupported) };
            TPHCompleterSupported as u64
        });
        __bindgen_bitfield_unit.set(14usize, 4u8, {
            let Rsvd: u32 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let OBFFSupported: u32 = unsafe { ::core::mem::transmute(OBFFSupported) };
            OBFFSupported as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let ExtendedFmtFieldSuported: u32 =
                unsafe { ::core::mem::transmute(ExtendedFmtFieldSuported) };
            ExtendedFmtFieldSuported as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let EndEndTLPPrefixSupported: u32 =
                unsafe { ::core::mem::transmute(EndEndTLPPrefixSupported) };
            EndEndTLPPrefixSupported as u64
        });
        __bindgen_bitfield_unit.set(22usize, 2u8, {
            let MaxEndEndTLPPrefixes: u32 = unsafe { ::core::mem::transmute(MaxEndEndTLPPrefixes) };
            MaxEndEndTLPPrefixes as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let Rsvd2: u32 = unsafe { ::core::mem::transmute(Rsvd2) };
            Rsvd2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER = _PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER;
pub type PPCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER =
*mut _PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn CompletionTimeoutValue(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_CompletionTimeoutValue(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CompletionTimeoutValue_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_CompletionTimeoutValue_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CompletionTimeoutDisable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CompletionTimeoutDisable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CompletionTimeoutDisable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_CompletionTimeoutDisable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AriForwardingEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_AriForwardingEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AriForwardingEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_AriForwardingEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AtomicOpRequesterEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_AtomicOpRequesterEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AtomicOpRequesterEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_AtomicOpRequesterEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AtomicOpEgresBlocking(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_AtomicOpEgresBlocking(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AtomicOpEgresBlocking_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_AtomicOpEgresBlocking_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IDORequestEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_IDORequestEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IDORequestEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_IDORequestEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IDOCompletionEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_IDOCompletionEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IDOCompletionEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_IDOCompletionEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LTRMechanismEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LTRMechanismEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LTRMechanismEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_LTRMechanismEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn OBFFEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_OBFFEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn OBFFEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_OBFFEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EndEndTLPPrefixBlocking(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EndEndTLPPrefixBlocking(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EndEndTLPPrefixBlocking_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_EndEndTLPPrefixBlocking_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CompletionTimeoutValue: USHORT,
        CompletionTimeoutDisable: USHORT,
        AriForwardingEnable: USHORT,
        AtomicOpRequesterEnable: USHORT,
        AtomicOpEgresBlocking: USHORT,
        IDORequestEnable: USHORT,
        IDOCompletionEnable: USHORT,
        LTRMechanismEnable: USHORT,
        Rsvd: USHORT,
        OBFFEnable: USHORT,
        EndEndTLPPrefixBlocking: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let CompletionTimeoutValue: u16 =
                unsafe { ::core::mem::transmute(CompletionTimeoutValue) };
            CompletionTimeoutValue as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CompletionTimeoutDisable: u16 =
                unsafe { ::core::mem::transmute(CompletionTimeoutDisable) };
            CompletionTimeoutDisable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let AriForwardingEnable: u16 = unsafe { ::core::mem::transmute(AriForwardingEnable) };
            AriForwardingEnable as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let AtomicOpRequesterEnable: u16 =
                unsafe { ::core::mem::transmute(AtomicOpRequesterEnable) };
            AtomicOpRequesterEnable as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let AtomicOpEgresBlocking: u16 =
                unsafe { ::core::mem::transmute(AtomicOpEgresBlocking) };
            AtomicOpEgresBlocking as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let IDORequestEnable: u16 = unsafe { ::core::mem::transmute(IDORequestEnable) };
            IDORequestEnable as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let IDOCompletionEnable: u16 = unsafe { ::core::mem::transmute(IDOCompletionEnable) };
            IDOCompletionEnable as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let LTRMechanismEnable: u16 = unsafe { ::core::mem::transmute(LTRMechanismEnable) };
            LTRMechanismEnable as u64
        });
        __bindgen_bitfield_unit.set(11usize, 2u8, {
            let Rsvd: u16 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let OBFFEnable: u16 = unsafe { ::core::mem::transmute(OBFFEnable) };
            OBFFEnable as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let EndEndTLPPrefixBlocking: u16 =
                unsafe { ::core::mem::transmute(EndEndTLPPrefixBlocking) };
            EndEndTLPPrefixBlocking as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER = _PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER;
pub type PPCI_EXPRESS_DEVICE_CONTROL_2_REGISTER = *mut _PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_DEVICE_STATUS_2_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_DEVICE_STATUS_2_REGISTER__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_DEVICE_STATUS_2_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_DEVICE_STATUS_2_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn Rsvd(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(Rsvd: USHORT) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let Rsvd: u16 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_DEVICE_STATUS_2_REGISTER = _PCI_EXPRESS_DEVICE_STATUS_2_REGISTER;
pub type PPCI_EXPRESS_DEVICE_STATUS_2_REGISTER = *mut _PCI_EXPRESS_DEVICE_STATUS_2_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_LINK_CAPABILITIES_2_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_LINK_CAPABILITIES_2_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_LINK_CAPABILITIES_2_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_LINK_CAPABILITIES_2_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn Rsvd0(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd0(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd0_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd0_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SupportedLinkSpeedsVector(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_SupportedLinkSpeedsVector(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SupportedLinkSpeedsVector_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                7u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SupportedLinkSpeedsVector_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd8_31(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd8_31(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd8_31_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd8_31_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Rsvd0: ULONG,
        SupportedLinkSpeedsVector: ULONG,
        Rsvd8_31: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Rsvd0: u32 = unsafe { ::core::mem::transmute(Rsvd0) };
            Rsvd0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let SupportedLinkSpeedsVector: u32 =
                unsafe { ::core::mem::transmute(SupportedLinkSpeedsVector) };
            SupportedLinkSpeedsVector as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let Rsvd8_31: u32 = unsafe { ::core::mem::transmute(Rsvd8_31) };
            Rsvd8_31 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_LINK_CAPABILITIES_2_REGISTER = _PCI_EXPRESS_LINK_CAPABILITIES_2_REGISTER;
pub type PPCI_EXPRESS_LINK_CAPABILITIES_2_REGISTER = *mut _PCI_EXPRESS_LINK_CAPABILITIES_2_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_LINK_CONTROL_2_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_LINK_CONTROL_2_REGISTER__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_LINK_CONTROL_2_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_LINK_CONTROL_2_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn TargetLinkSpeed(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_TargetLinkSpeed(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TargetLinkSpeed_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_TargetLinkSpeed_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd4_15(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd4_15(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd4_15_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                12u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd4_15_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TargetLinkSpeed: USHORT,
        Rsvd4_15: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let TargetLinkSpeed: u16 = unsafe { ::core::mem::transmute(TargetLinkSpeed) };
            TargetLinkSpeed as u64
        });
        __bindgen_bitfield_unit.set(4usize, 12u8, {
            let Rsvd4_15: u16 = unsafe { ::core::mem::transmute(Rsvd4_15) };
            Rsvd4_15 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_LINK_CONTROL_2_REGISTER = _PCI_EXPRESS_LINK_CONTROL_2_REGISTER;
pub type PPCI_EXPRESS_LINK_CONTROL_2_REGISTER = *mut _PCI_EXPRESS_LINK_CONTROL_2_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_LINK_STATUS_2_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_LINK_STATUS_2_REGISTER__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_LINK_STATUS_2_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_LINK_STATUS_2_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn Rsvd0_15(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_Rsvd0_15(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd0_15_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd0_15_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(Rsvd0_15: USHORT) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let Rsvd0_15: u16 = unsafe { ::core::mem::transmute(Rsvd0_15) };
            Rsvd0_15 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_LINK_STATUS_2_REGISTER = _PCI_EXPRESS_LINK_STATUS_2_REGISTER;
pub type PPCI_EXPRESS_LINK_STATUS_2_REGISTER = *mut _PCI_EXPRESS_LINK_STATUS_2_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_CAPABILITY {
    pub Header: PCI_CAPABILITIES_HEADER,
    pub ExpressCapabilities: PCI_EXPRESS_CAPABILITIES_REGISTER,
    pub DeviceCapabilities: PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER,
    pub DeviceControl: PCI_EXPRESS_DEVICE_CONTROL_REGISTER,
    pub DeviceStatus: PCI_EXPRESS_DEVICE_STATUS_REGISTER,
    pub LinkCapabilities: PCI_EXPRESS_LINK_CAPABILITIES_REGISTER,
    pub LinkControl: PCI_EXPRESS_LINK_CONTROL_REGISTER,
    pub LinkStatus: PCI_EXPRESS_LINK_STATUS_REGISTER,
    pub SlotCapabilities: PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER,
    pub SlotControl: PCI_EXPRESS_SLOT_CONTROL_REGISTER,
    pub SlotStatus: PCI_EXPRESS_SLOT_STATUS_REGISTER,
    pub RootControl: PCI_EXPRESS_ROOT_CONTROL_REGISTER,
    pub RootCapabilities: PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER,
    pub RootStatus: PCI_EXPRESS_ROOT_STATUS_REGISTER,
    pub DeviceCapabilities2: PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER,
    pub DeviceControl2: PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER,
    pub DeviceStatus2: PCI_EXPRESS_DEVICE_STATUS_2_REGISTER,
    pub LinkCapabilities2: PCI_EXPRESS_LINK_CAPABILITIES_2_REGISTER,
    pub LinkControl2: PCI_EXPRESS_LINK_CONTROL_2_REGISTER,
    pub LinkStatus2: PCI_EXPRESS_LINK_STATUS_2_REGISTER,
}
pub type PCI_EXPRESS_CAPABILITY = _PCI_EXPRESS_CAPABILITY;
pub type PPCI_EXPRESS_CAPABILITY = *mut _PCI_EXPRESS_CAPABILITY;
pub const PCI_EXPRESS_MRL_STATE_MRLClosed: PCI_EXPRESS_MRL_STATE = 0;
pub const PCI_EXPRESS_MRL_STATE_MRLOpen: PCI_EXPRESS_MRL_STATE = 1;
pub type PCI_EXPRESS_MRL_STATE = core::ffi::c_int;
pub const PCI_EXPRESS_CARD_PRESENCE_SlotEmpty: PCI_EXPRESS_CARD_PRESENCE = 0;
pub const PCI_EXPRESS_CARD_PRESENCE_CardPresent: PCI_EXPRESS_CARD_PRESENCE = 1;
pub type PCI_EXPRESS_CARD_PRESENCE = core::ffi::c_int;
pub const PCI_EXPRESS_INDICATOR_STATE_IndicatorOn: PCI_EXPRESS_INDICATOR_STATE = 1;
pub const PCI_EXPRESS_INDICATOR_STATE_IndicatorBlink: PCI_EXPRESS_INDICATOR_STATE = 2;
pub const PCI_EXPRESS_INDICATOR_STATE_IndicatorOff: PCI_EXPRESS_INDICATOR_STATE = 3;
pub type PCI_EXPRESS_INDICATOR_STATE = core::ffi::c_int;
pub const PCI_EXPRESS_POWER_STATE_PowerOn: PCI_EXPRESS_POWER_STATE = 0;
pub const PCI_EXPRESS_POWER_STATE_PowerOff: PCI_EXPRESS_POWER_STATE = 1;
pub type PCI_EXPRESS_POWER_STATE = core::ffi::c_int;
pub const PCI_EXPRESS_ASPM_SUPPORT_NoAspmSupport: PCI_EXPRESS_ASPM_SUPPORT = 0;
pub const PCI_EXPRESS_ASPM_SUPPORT_L0sEntrySupport: PCI_EXPRESS_ASPM_SUPPORT = 1;
pub const PCI_EXPRESS_ASPM_SUPPORT_L1EntrySupport: PCI_EXPRESS_ASPM_SUPPORT = 2;
pub const PCI_EXPRESS_ASPM_SUPPORT_L0sAndL1EntrySupport: PCI_EXPRESS_ASPM_SUPPORT = 3;
pub type PCI_EXPRESS_ASPM_SUPPORT = core::ffi::c_int;
pub const PCI_EXPRESS_ASPM_CONTROL_L0sAndL1EntryDisabled: PCI_EXPRESS_ASPM_CONTROL = 0;
pub const PCI_EXPRESS_ASPM_CONTROL_L0sEntryEnabled: PCI_EXPRESS_ASPM_CONTROL = 1;
pub const PCI_EXPRESS_ASPM_CONTROL_L1EntryEnabled: PCI_EXPRESS_ASPM_CONTROL = 2;
pub const PCI_EXPRESS_ASPM_CONTROL_L0sAndL1EntryEnabled: PCI_EXPRESS_ASPM_CONTROL = 3;
pub type PCI_EXPRESS_ASPM_CONTROL = core::ffi::c_int;
pub const PCI_EXPRESS_L0s_EXIT_LATENCY_L0s_Below64ns: PCI_EXPRESS_L0s_EXIT_LATENCY = 0;
pub const PCI_EXPRESS_L0s_EXIT_LATENCY_L0s_64ns_128ns: PCI_EXPRESS_L0s_EXIT_LATENCY = 1;
pub const PCI_EXPRESS_L0s_EXIT_LATENCY_L0s_128ns_256ns: PCI_EXPRESS_L0s_EXIT_LATENCY = 2;
pub const PCI_EXPRESS_L0s_EXIT_LATENCY_L0s_256ns_512ns: PCI_EXPRESS_L0s_EXIT_LATENCY = 3;
pub const PCI_EXPRESS_L0s_EXIT_LATENCY_L0s_512ns_1us: PCI_EXPRESS_L0s_EXIT_LATENCY = 4;
pub const PCI_EXPRESS_L0s_EXIT_LATENCY_L0s_1us_2us: PCI_EXPRESS_L0s_EXIT_LATENCY = 5;
pub const PCI_EXPRESS_L0s_EXIT_LATENCY_L0s_2us_4us: PCI_EXPRESS_L0s_EXIT_LATENCY = 6;
pub const PCI_EXPRESS_L0s_EXIT_LATENCY_L0s_Above4us: PCI_EXPRESS_L0s_EXIT_LATENCY = 7;
pub type PCI_EXPRESS_L0s_EXIT_LATENCY = core::ffi::c_int;
pub const PCI_EXPRESS_L1_EXIT_LATENCY_L1_Below1us: PCI_EXPRESS_L1_EXIT_LATENCY = 0;
pub const PCI_EXPRESS_L1_EXIT_LATENCY_L1_1us_2us: PCI_EXPRESS_L1_EXIT_LATENCY = 1;
pub const PCI_EXPRESS_L1_EXIT_LATENCY_L1_2us_4us: PCI_EXPRESS_L1_EXIT_LATENCY = 2;
pub const PCI_EXPRESS_L1_EXIT_LATENCY_L1_4us_8us: PCI_EXPRESS_L1_EXIT_LATENCY = 3;
pub const PCI_EXPRESS_L1_EXIT_LATENCY_L1_8us_16us: PCI_EXPRESS_L1_EXIT_LATENCY = 4;
pub const PCI_EXPRESS_L1_EXIT_LATENCY_L1_16us_32us: PCI_EXPRESS_L1_EXIT_LATENCY = 5;
pub const PCI_EXPRESS_L1_EXIT_LATENCY_L1_32us_64us: PCI_EXPRESS_L1_EXIT_LATENCY = 6;
pub const PCI_EXPRESS_L1_EXIT_LATENCY_L1_Above64us: PCI_EXPRESS_L1_EXIT_LATENCY = 7;
pub type PCI_EXPRESS_L1_EXIT_LATENCY = core::ffi::c_int;
pub const PCI_EXPRESS_RCB_RCB64Bytes: PCI_EXPRESS_RCB = 0;
pub const PCI_EXPRESS_RCB_RCB128Bytes: PCI_EXPRESS_RCB = 1;
pub type PCI_EXPRESS_RCB = core::ffi::c_int;
pub const PCI_EXPRESS_LINK_SUBSTATE_PciExpressPciPmLinkSubState_L11_BitIndex:
PCI_EXPRESS_LINK_SUBSTATE = 0;
pub const PCI_EXPRESS_LINK_SUBSTATE_PciExpressPciPmLinkSubState_L12_BitIndex:
PCI_EXPRESS_LINK_SUBSTATE = 1;
pub const PCI_EXPRESS_LINK_SUBSTATE_PciExpressASPMLinkSubState_L11_BitIndex:
PCI_EXPRESS_LINK_SUBSTATE = 2;
pub const PCI_EXPRESS_LINK_SUBSTATE_PciExpressASPMLinkSubState_L12_BitIndex:
PCI_EXPRESS_LINK_SUBSTATE = 3;
pub type PCI_EXPRESS_LINK_SUBSTATE = core::ffi::c_int;
pub const PCI_DEVICE_D3COLD_STATE_REASON_PciDeviceD3Cold_State_Disabled_BitIndex:
PCI_DEVICE_D3COLD_STATE_REASON = 1;
pub const PCI_DEVICE_D3COLD_STATE_REASON_PciDeviceD3Cold_State_Enabled_BitIndex:
PCI_DEVICE_D3COLD_STATE_REASON = 2;
pub const PCI_DEVICE_D3COLD_STATE_REASON_PciDeviceD3Cold_State_ParentRootPortS0WakeSupported_BitIndex : PCI_DEVICE_D3COLD_STATE_REASON = 3 ;
pub const PCI_DEVICE_D3COLD_STATE_REASON_PciDeviceD3Cold_State_Disabled_Bridge_HackFlags_BitIndex : PCI_DEVICE_D3COLD_STATE_REASON = 4 ;
pub const PCI_DEVICE_D3COLD_STATE_REASON_PciDeviceD3Cold_Reason_Default_State_BitIndex:
PCI_DEVICE_D3COLD_STATE_REASON = 8;
pub const PCI_DEVICE_D3COLD_STATE_REASON_PciDeviceD3Cold_Reason_INF_BitIndex:
PCI_DEVICE_D3COLD_STATE_REASON = 9;
pub const PCI_DEVICE_D3COLD_STATE_REASON_PciDeviceD3Cold_Reason_Interface_Api_BitIndex:
PCI_DEVICE_D3COLD_STATE_REASON = 10;
pub type PCI_DEVICE_D3COLD_STATE_REASON = core::ffi::c_int;
pub const PCI_EXPRESS_DEVICE_TYPE_PciExpressEndpoint: PCI_EXPRESS_DEVICE_TYPE = 0;
pub const PCI_EXPRESS_DEVICE_TYPE_PciExpressLegacyEndpoint: PCI_EXPRESS_DEVICE_TYPE = 1;
pub const PCI_EXPRESS_DEVICE_TYPE_PciExpressRootPort: PCI_EXPRESS_DEVICE_TYPE = 4;
pub const PCI_EXPRESS_DEVICE_TYPE_PciExpressUpstreamSwitchPort: PCI_EXPRESS_DEVICE_TYPE = 5;
pub const PCI_EXPRESS_DEVICE_TYPE_PciExpressDownstreamSwitchPort: PCI_EXPRESS_DEVICE_TYPE = 6;
pub const PCI_EXPRESS_DEVICE_TYPE_PciExpressToPciXBridge: PCI_EXPRESS_DEVICE_TYPE = 7;
pub const PCI_EXPRESS_DEVICE_TYPE_PciXToExpressBridge: PCI_EXPRESS_DEVICE_TYPE = 8;
pub const PCI_EXPRESS_DEVICE_TYPE_PciExpressRootComplexIntegratedEndpoint: PCI_EXPRESS_DEVICE_TYPE =
    9;
pub const PCI_EXPRESS_DEVICE_TYPE_PciExpressRootComplexEventCollector: PCI_EXPRESS_DEVICE_TYPE = 10;
pub type PCI_EXPRESS_DEVICE_TYPE = core::ffi::c_int;
pub const PCI_EXPRESS_MAX_PAYLOAD_SIZE_MaxPayload128Bytes: PCI_EXPRESS_MAX_PAYLOAD_SIZE = 0;
pub const PCI_EXPRESS_MAX_PAYLOAD_SIZE_MaxPayload256Bytes: PCI_EXPRESS_MAX_PAYLOAD_SIZE = 1;
pub const PCI_EXPRESS_MAX_PAYLOAD_SIZE_MaxPayload512Bytes: PCI_EXPRESS_MAX_PAYLOAD_SIZE = 2;
pub const PCI_EXPRESS_MAX_PAYLOAD_SIZE_MaxPayload1024Bytes: PCI_EXPRESS_MAX_PAYLOAD_SIZE = 3;
pub const PCI_EXPRESS_MAX_PAYLOAD_SIZE_MaxPayload2048Bytes: PCI_EXPRESS_MAX_PAYLOAD_SIZE = 4;
pub const PCI_EXPRESS_MAX_PAYLOAD_SIZE_MaxPayload4096Bytes: PCI_EXPRESS_MAX_PAYLOAD_SIZE = 5;
pub type PCI_EXPRESS_MAX_PAYLOAD_SIZE = core::ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_PME_REQUESTOR_ID {
    pub __bindgen_anon_1: _PCI_EXPRESS_PME_REQUESTOR_ID__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_PME_REQUESTOR_ID__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_PME_REQUESTOR_ID__bindgen_ty_1 {
    #[inline]
    pub fn FunctionNumber(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_FunctionNumber(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FunctionNumber_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_FunctionNumber_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DeviceNumber(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_DeviceNumber(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DeviceNumber_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_DeviceNumber_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn BusNumber(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_BusNumber(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn BusNumber_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_BusNumber_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FunctionNumber: USHORT,
        DeviceNumber: USHORT,
        BusNumber: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let FunctionNumber: u16 = unsafe { ::core::mem::transmute(FunctionNumber) };
            FunctionNumber as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let DeviceNumber: u16 = unsafe { ::core::mem::transmute(DeviceNumber) };
            DeviceNumber as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let BusNumber: u16 = unsafe { ::core::mem::transmute(BusNumber) };
            BusNumber as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_PME_REQUESTOR_ID = _PCI_EXPRESS_PME_REQUESTOR_ID;
pub type PPCI_EXPRESS_PME_REQUESTOR_ID = *mut _PCI_EXPRESS_PME_REQUESTOR_ID;
pub type PciPin2Line = ::core::option::Option<
    unsafe extern "C" fn(
        BusHandler: *mut _BUS_HANDLER,
        RootHandler: *mut _BUS_HANDLER,
        SlotNumber: PCI_SLOT_NUMBER,
        PciData: PPCI_COMMON_CONFIG,
    ),
>;
pub type PciLine2Pin = ::core::option::Option<
    unsafe extern "C" fn(
        BusHandler: *mut _BUS_HANDLER,
        RootHandler: *mut _BUS_HANDLER,
        SlotNumber: PCI_SLOT_NUMBER,
        PciNewData: PPCI_COMMON_CONFIG,
        PciOldData: PPCI_COMMON_CONFIG,
    ),
>;
pub type PciReadWriteConfig = ::core::option::Option<
    unsafe extern "C" fn(
        BusHandler: *mut _BUS_HANDLER,
        Slot: PCI_SLOT_NUMBER,
        Buffer: PVOID,
        Offset: ULONG,
        Length: ULONG,
    ),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCIBUSDATA {
    pub Tag: ULONG,
    pub Version: ULONG,
    pub ReadConfig: PciReadWriteConfig,
    pub WriteConfig: PciReadWriteConfig,
    pub Pin2Line: PciPin2Line,
    pub Line2Pin: PciLine2Pin,
    pub ParentSlot: PCI_SLOT_NUMBER,
    pub Reserved: [PVOID; 4usize],
}
pub type PCIBUSDATA = _PCIBUSDATA;
pub type PPCIBUSDATA = *mut _PCIBUSDATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn MaxSnoopLatencyValue(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_MaxSnoopLatencyValue(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MaxSnoopLatencyValue_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                10u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MaxSnoopLatencyValue_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                10u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MaxSnoopLatencyScale(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_MaxSnoopLatencyScale(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MaxSnoopLatencyScale_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MaxSnoopLatencyScale_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MaxSnoopRequirement(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MaxSnoopRequirement(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MaxSnoopRequirement_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MaxSnoopRequirement_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MaxNoSnoopLatencyValue(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_MaxNoSnoopLatencyValue(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MaxNoSnoopLatencyValue_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                10u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MaxNoSnoopLatencyValue_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                10u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MaxNoSnoopLatencyScale(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_MaxNoSnoopLatencyScale(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MaxNoSnoopLatencyScale_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MaxNoSnoopLatencyScale_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                29usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                29usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MaxNoSnoopRequirement(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MaxNoSnoopRequirement(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MaxNoSnoopRequirement_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MaxNoSnoopRequirement_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MaxSnoopLatencyValue: ULONG,
        MaxSnoopLatencyScale: ULONG,
        Rsvd: ULONG,
        MaxSnoopRequirement: ULONG,
        MaxNoSnoopLatencyValue: ULONG,
        MaxNoSnoopLatencyScale: ULONG,
        Rsvd2: ULONG,
        MaxNoSnoopRequirement: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let MaxSnoopLatencyValue: u32 = unsafe { ::core::mem::transmute(MaxSnoopLatencyValue) };
            MaxSnoopLatencyValue as u64
        });
        __bindgen_bitfield_unit.set(10usize, 3u8, {
            let MaxSnoopLatencyScale: u32 = unsafe { ::core::mem::transmute(MaxSnoopLatencyScale) };
            MaxSnoopLatencyScale as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let Rsvd: u32 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let MaxSnoopRequirement: u32 = unsafe { ::core::mem::transmute(MaxSnoopRequirement) };
            MaxSnoopRequirement as u64
        });
        __bindgen_bitfield_unit.set(16usize, 10u8, {
            let MaxNoSnoopLatencyValue: u32 =
                unsafe { ::core::mem::transmute(MaxNoSnoopLatencyValue) };
            MaxNoSnoopLatencyValue as u64
        });
        __bindgen_bitfield_unit.set(26usize, 3u8, {
            let MaxNoSnoopLatencyScale: u32 =
                unsafe { ::core::mem::transmute(MaxNoSnoopLatencyScale) };
            MaxNoSnoopLatencyScale as u64
        });
        __bindgen_bitfield_unit.set(29usize, 2u8, {
            let Rsvd2: u32 = unsafe { ::core::mem::transmute(Rsvd2) };
            Rsvd2 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let MaxNoSnoopRequirement: u32 =
                unsafe { ::core::mem::transmute(MaxNoSnoopRequirement) };
            MaxNoSnoopRequirement as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER = _PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER;
pub type PPCI_EXPRESS_LTR_MAX_LATENCY_REGISTER = *mut _PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_LTR_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub Latency: PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER,
}
pub type PCI_EXPRESS_LTR_CAPABILITY = _PCI_EXPRESS_LTR_CAPABILITY;
pub type PPCI_EXPRESS_LTR_CAPABILITY = *mut _PCI_EXPRESS_LTR_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn NoStModeSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoStModeSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NoStModeSupported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NoStModeSupported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn InteruptVectorModeSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InteruptVectorModeSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InteruptVectorModeSupported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_InteruptVectorModeSupported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DeviceSpecificModeSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeviceSpecificModeSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DeviceSpecificModeSupported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DeviceSpecificModeSupported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ExtendedTPHRequesterSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExtendedTPHRequesterSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ExtendedTPHRequesterSupported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ExtendedTPHRequesterSupported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn StTableLocation(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_StTableLocation(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn StTableLocation_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_StTableLocation_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn StTableSize(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_StTableSize(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn StTableSize_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                11u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_StTableSize_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                11u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd3(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd3(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd3_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd3_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NoStModeSupported: ULONG,
        InteruptVectorModeSupported: ULONG,
        DeviceSpecificModeSupported: ULONG,
        Rsvd: ULONG,
        ExtendedTPHRequesterSupported: ULONG,
        StTableLocation: ULONG,
        Rsvd2: ULONG,
        StTableSize: ULONG,
        Rsvd3: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let NoStModeSupported: u32 = unsafe { ::core::mem::transmute(NoStModeSupported) };
            NoStModeSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let InteruptVectorModeSupported: u32 =
                unsafe { ::core::mem::transmute(InteruptVectorModeSupported) };
            InteruptVectorModeSupported as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DeviceSpecificModeSupported: u32 =
                unsafe { ::core::mem::transmute(DeviceSpecificModeSupported) };
            DeviceSpecificModeSupported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let Rsvd: u32 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ExtendedTPHRequesterSupported: u32 =
                unsafe { ::core::mem::transmute(ExtendedTPHRequesterSupported) };
            ExtendedTPHRequesterSupported as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let StTableLocation: u32 = unsafe { ::core::mem::transmute(StTableLocation) };
            StTableLocation as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let Rsvd2: u32 = unsafe { ::core::mem::transmute(Rsvd2) };
            Rsvd2 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 11u8, {
            let StTableSize: u32 = unsafe { ::core::mem::transmute(StTableSize) };
            StTableSize as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let Rsvd3: u32 = unsafe { ::core::mem::transmute(Rsvd3) };
            Rsvd3 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER =
_PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER;
pub type PPCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER =
*mut _PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn StModeSelect(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_StModeSelect(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn StModeSelect_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_StModeSelect_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TphRequesterEnable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_TphRequesterEnable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TphRequesterEnable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_TphRequesterEnable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                22u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                22u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        StModeSelect: ULONG,
        Rsvd: ULONG,
        TphRequesterEnable: ULONG,
        Rsvd2: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let StModeSelect: u32 = unsafe { ::core::mem::transmute(StModeSelect) };
            StModeSelect as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let Rsvd: u32 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let TphRequesterEnable: u32 = unsafe { ::core::mem::transmute(TphRequesterEnable) };
            TphRequesterEnable as u64
        });
        __bindgen_bitfield_unit.set(10usize, 22u8, {
            let Rsvd2: u32 = unsafe { ::core::mem::transmute(Rsvd2) };
            Rsvd2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER = _PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER;
pub type PPCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER =
*mut _PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_TPH_ST_TABLE_ENTRY {
    pub __bindgen_anon_1: _PCI_EXPRESS_TPH_ST_TABLE_ENTRY__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_TPH_ST_TABLE_ENTRY__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_TPH_ST_TABLE_ENTRY__bindgen_ty_1 {
    #[inline]
    pub fn LowerEntry(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_LowerEntry(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LowerEntry_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_LowerEntry_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UpperEntry(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_UpperEntry(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UpperEntry_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_UpperEntry_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        LowerEntry: USHORT,
        UpperEntry: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let LowerEntry: u16 = unsafe { ::core::mem::transmute(LowerEntry) };
            LowerEntry as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let UpperEntry: u16 = unsafe { ::core::mem::transmute(UpperEntry) };
            UpperEntry as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_TPH_ST_TABLE_ENTRY = _PCI_EXPRESS_TPH_ST_TABLE_ENTRY;
pub type PPCI_EXPRESS_TPH_ST_TABLE_ENTRY = *mut _PCI_EXPRESS_TPH_ST_TABLE_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_TPH_REQUESTER_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub RequesterCapability: PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER,
    pub RequesterControl: PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER,
}
pub type PCI_EXPRESS_TPH_REQUESTER_CAPABILITY = _PCI_EXPRESS_TPH_REQUESTER_CAPABILITY;
pub type PPCI_EXPRESS_TPH_REQUESTER_CAPABILITY = *mut _PCI_EXPRESS_TPH_REQUESTER_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn PciPmL12Supported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PciPmL12Supported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PciPmL12Supported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PciPmL12Supported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PciPmL11Supported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PciPmL11Supported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PciPmL11Supported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PciPmL11Supported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AspmL12Supported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AspmL12Supported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AspmL12Supported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AspmL12Supported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AspmL11Supported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AspmL11Supported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AspmL11Supported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AspmL11Supported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn L1PmSsSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_L1PmSsSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn L1PmSsSupported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_L1PmSsSupported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PortCommonModeRestoreTime(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_PortCommonModeRestoreTime(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PortCommonModeRestoreTime_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PortCommonModeRestoreTime_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PortTPowerOnScale(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_PortTPowerOnScale(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PortTPowerOnScale_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PortTPowerOnScale_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PortTPowerOnValue(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_PortTPowerOnValue(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PortTPowerOnValue_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PortTPowerOnValue_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd3(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd3(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd3_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd3_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PciPmL12Supported: ULONG,
        PciPmL11Supported: ULONG,
        AspmL12Supported: ULONG,
        AspmL11Supported: ULONG,
        L1PmSsSupported: ULONG,
        Rsvd: ULONG,
        PortCommonModeRestoreTime: ULONG,
        PortTPowerOnScale: ULONG,
        Rsvd2: ULONG,
        PortTPowerOnValue: ULONG,
        Rsvd3: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PciPmL12Supported: u32 = unsafe { ::core::mem::transmute(PciPmL12Supported) };
            PciPmL12Supported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PciPmL11Supported: u32 = unsafe { ::core::mem::transmute(PciPmL11Supported) };
            PciPmL11Supported as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let AspmL12Supported: u32 = unsafe { ::core::mem::transmute(AspmL12Supported) };
            AspmL12Supported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AspmL11Supported: u32 = unsafe { ::core::mem::transmute(AspmL11Supported) };
            AspmL11Supported as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let L1PmSsSupported: u32 = unsafe { ::core::mem::transmute(L1PmSsSupported) };
            L1PmSsSupported as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let Rsvd: u32 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let PortCommonModeRestoreTime: u32 =
                unsafe { ::core::mem::transmute(PortCommonModeRestoreTime) };
            PortCommonModeRestoreTime as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let PortTPowerOnScale: u32 = unsafe { ::core::mem::transmute(PortTPowerOnScale) };
            PortTPowerOnScale as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let Rsvd2: u32 = unsafe { ::core::mem::transmute(Rsvd2) };
            Rsvd2 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 5u8, {
            let PortTPowerOnValue: u32 = unsafe { ::core::mem::transmute(PortTPowerOnValue) };
            PortTPowerOnValue as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let Rsvd3: u32 = unsafe { ::core::mem::transmute(Rsvd3) };
            Rsvd3 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER = _PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER;
pub type PPCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER =
*mut _PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn PciPmL12Enabled(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PciPmL12Enabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PciPmL12Enabled_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PciPmL12Enabled_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PciPmL11Enabled(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PciPmL11Enabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PciPmL11Enabled_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PciPmL11Enabled_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AspmL12Enabled(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AspmL12Enabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AspmL12Enabled_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AspmL12Enabled_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AspmL11Enabled(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AspmL11Enabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AspmL11Enabled_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AspmL11Enabled_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CommonModeRestoreTime(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_CommonModeRestoreTime(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CommonModeRestoreTime_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CommonModeRestoreTime_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LtrL12ThresholdValue(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_LtrL12ThresholdValue(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LtrL12ThresholdValue_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                10u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_LtrL12ThresholdValue_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                10u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LtrL12ThresholdScale(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_LtrL12ThresholdScale(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LtrL12ThresholdScale_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                29usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_LtrL12ThresholdScale_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                29usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PciPmL12Enabled: ULONG,
        PciPmL11Enabled: ULONG,
        AspmL12Enabled: ULONG,
        AspmL11Enabled: ULONG,
        Rsvd: ULONG,
        CommonModeRestoreTime: ULONG,
        LtrL12ThresholdValue: ULONG,
        Rsvd2: ULONG,
        LtrL12ThresholdScale: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PciPmL12Enabled: u32 = unsafe { ::core::mem::transmute(PciPmL12Enabled) };
            PciPmL12Enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PciPmL11Enabled: u32 = unsafe { ::core::mem::transmute(PciPmL11Enabled) };
            PciPmL11Enabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let AspmL12Enabled: u32 = unsafe { ::core::mem::transmute(AspmL12Enabled) };
            AspmL12Enabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AspmL11Enabled: u32 = unsafe { ::core::mem::transmute(AspmL11Enabled) };
            AspmL11Enabled as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let Rsvd: u32 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let CommonModeRestoreTime: u32 =
                unsafe { ::core::mem::transmute(CommonModeRestoreTime) };
            CommonModeRestoreTime as u64
        });
        __bindgen_bitfield_unit.set(16usize, 10u8, {
            let LtrL12ThresholdValue: u32 = unsafe { ::core::mem::transmute(LtrL12ThresholdValue) };
            LtrL12ThresholdValue as u64
        });
        __bindgen_bitfield_unit.set(26usize, 3u8, {
            let Rsvd2: u32 = unsafe { ::core::mem::transmute(Rsvd2) };
            Rsvd2 as u64
        });
        __bindgen_bitfield_unit.set(29usize, 3u8, {
            let LtrL12ThresholdScale: u32 = unsafe { ::core::mem::transmute(LtrL12ThresholdScale) };
            LtrL12ThresholdScale as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER = _PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER;
pub type PPCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER = *mut _PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn TPowerOnScale(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_TPowerOnScale(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TPowerOnScale_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_TPowerOnScale_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TPowerOnValue(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_TPowerOnValue(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TPowerOnValue_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_TPowerOnValue_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TPowerOnScale: ULONG,
        Rsvd: ULONG,
        TPowerOnValue: ULONG,
        Rsvd2: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let TPowerOnScale: u32 = unsafe { ::core::mem::transmute(TPowerOnScale) };
            TPowerOnScale as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Rsvd: u32 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let TPowerOnValue: u32 = unsafe { ::core::mem::transmute(TPowerOnValue) };
            TPowerOnValue as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let Rsvd2: u32 = unsafe { ::core::mem::transmute(Rsvd2) };
            Rsvd2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER = _PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER;
pub type PPCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER = *mut _PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_L1_PM_SS_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub L1PmSsCapabilities: PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER,
    pub L1PmSsControl1: PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER,
    pub L1PmSsControl2: PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER,
}
pub type PCI_EXPRESS_L1_PM_SS_CAPABILITY = _PCI_EXPRESS_L1_PM_SS_CAPABILITY;
pub type PPCI_EXPRESS_L1_PM_SS_CAPABILITY = *mut _PCI_EXPRESS_L1_PM_SS_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_DPC_CAPS_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_DPC_CAPS_REGISTER__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_DPC_CAPS_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_DPC_CAPS_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn InterruptMsgNumber(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_InterruptMsgNumber(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InterruptMsgNumber_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_InterruptMsgNumber_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RpExtensionsForDpc(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RpExtensionsForDpc(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RpExtensionsForDpc_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_RpExtensionsForDpc_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PoisonedTlpEgressBlockingSupported(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PoisonedTlpEgressBlockingSupported(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PoisonedTlpEgressBlockingSupported_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PoisonedTlpEgressBlockingSupported_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DpcSoftwareTriggeringSupported(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DpcSoftwareTriggeringSupported(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DpcSoftwareTriggeringSupported_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_DpcSoftwareTriggeringSupported_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RpPioLogSize(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_RpPioLogSize(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RpPioLogSize_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_RpPioLogSize_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DlActiveErrCorSignalingSupported(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DlActiveErrCorSignalingSupported(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DlActiveErrCorSignalingSupported_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_DlActiveErrCorSignalingSupported_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        InterruptMsgNumber: USHORT,
        RpExtensionsForDpc: USHORT,
        PoisonedTlpEgressBlockingSupported: USHORT,
        DpcSoftwareTriggeringSupported: USHORT,
        RpPioLogSize: USHORT,
        DlActiveErrCorSignalingSupported: USHORT,
        Reserved: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let InterruptMsgNumber: u16 = unsafe { ::core::mem::transmute(InterruptMsgNumber) };
            InterruptMsgNumber as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let RpExtensionsForDpc: u16 = unsafe { ::core::mem::transmute(RpExtensionsForDpc) };
            RpExtensionsForDpc as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PoisonedTlpEgressBlockingSupported: u16 =
                unsafe { ::core::mem::transmute(PoisonedTlpEgressBlockingSupported) };
            PoisonedTlpEgressBlockingSupported as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let DpcSoftwareTriggeringSupported: u16 =
                unsafe { ::core::mem::transmute(DpcSoftwareTriggeringSupported) };
            DpcSoftwareTriggeringSupported as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let RpPioLogSize: u16 = unsafe { ::core::mem::transmute(RpPioLogSize) };
            RpPioLogSize as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let DlActiveErrCorSignalingSupported: u16 =
                unsafe { ::core::mem::transmute(DlActiveErrCorSignalingSupported) };
            DlActiveErrCorSignalingSupported as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let Reserved: u16 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_DPC_CAPS_REGISTER = _PCI_EXPRESS_DPC_CAPS_REGISTER;
pub type PPCI_EXPRESS_DPC_CAPS_REGISTER = *mut _PCI_EXPRESS_DPC_CAPS_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_DPC_CONTROL_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_DPC_CONTROL_REGISTER__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_DPC_CONTROL_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_DPC_CONTROL_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn TriggerEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_TriggerEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TriggerEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_TriggerEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CompletionControl(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CompletionControl(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CompletionControl_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_CompletionControl_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn InterruptEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_InterruptEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InterruptEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_InterruptEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ErrCorEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ErrCorEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ErrCorEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ErrCorEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PoisonedTlpEgressBlockingEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PoisonedTlpEgressBlockingEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PoisonedTlpEgressBlockingEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PoisonedTlpEgressBlockingEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SoftwareTrigger(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SoftwareTrigger(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SoftwareTrigger_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_SoftwareTrigger_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DlActiveErrCorEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DlActiveErrCorEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DlActiveErrCorEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_DlActiveErrCorEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TriggerEnable: USHORT,
        CompletionControl: USHORT,
        InterruptEnable: USHORT,
        ErrCorEnable: USHORT,
        PoisonedTlpEgressBlockingEnable: USHORT,
        SoftwareTrigger: USHORT,
        DlActiveErrCorEnable: USHORT,
        Reserved: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let TriggerEnable: u16 = unsafe { ::core::mem::transmute(TriggerEnable) };
            TriggerEnable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CompletionControl: u16 = unsafe { ::core::mem::transmute(CompletionControl) };
            CompletionControl as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let InterruptEnable: u16 = unsafe { ::core::mem::transmute(InterruptEnable) };
            InterruptEnable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ErrCorEnable: u16 = unsafe { ::core::mem::transmute(ErrCorEnable) };
            ErrCorEnable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PoisonedTlpEgressBlockingEnable: u16 =
                unsafe { ::core::mem::transmute(PoisonedTlpEgressBlockingEnable) };
            PoisonedTlpEgressBlockingEnable as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SoftwareTrigger: u16 = unsafe { ::core::mem::transmute(SoftwareTrigger) };
            SoftwareTrigger as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let DlActiveErrCorEnable: u16 = unsafe { ::core::mem::transmute(DlActiveErrCorEnable) };
            DlActiveErrCorEnable as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let Reserved: u16 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_DPC_CONTROL_REGISTER = _PCI_EXPRESS_DPC_CONTROL_REGISTER;
pub type PPCI_EXPRESS_DPC_CONTROL_REGISTER = *mut _PCI_EXPRESS_DPC_CONTROL_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_DPC_STATUS_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_DPC_STATUS_REGISTER__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_DPC_STATUS_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_DPC_STATUS_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn TriggerStatus(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TriggerStatus(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TriggerStatus_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_TriggerStatus_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TriggerReason(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_TriggerReason(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TriggerReason_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_TriggerReason_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn InterruptStatus(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_InterruptStatus(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InterruptStatus_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_InterruptStatus_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RpBusy(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RpBusy(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RpBusy_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_RpBusy_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TriggerReasonExtension(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_TriggerReasonExtension(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TriggerReasonExtension_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_TriggerReasonExtension_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PioFirstErrPointer(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_PioFirstErrPointer(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PioFirstErrPointer_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PioFirstErrPointer_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved2_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved2_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TriggerStatus: USHORT,
        TriggerReason: USHORT,
        InterruptStatus: USHORT,
        RpBusy: USHORT,
        TriggerReasonExtension: USHORT,
        Reserved1: USHORT,
        PioFirstErrPointer: USHORT,
        Reserved2: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let TriggerStatus: u16 = unsafe { ::core::mem::transmute(TriggerStatus) };
            TriggerStatus as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let TriggerReason: u16 = unsafe { ::core::mem::transmute(TriggerReason) };
            TriggerReason as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let InterruptStatus: u16 = unsafe { ::core::mem::transmute(InterruptStatus) };
            InterruptStatus as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let RpBusy: u16 = unsafe { ::core::mem::transmute(RpBusy) };
            RpBusy as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let TriggerReasonExtension: u16 =
                unsafe { ::core::mem::transmute(TriggerReasonExtension) };
            TriggerReasonExtension as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Reserved1: u16 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let PioFirstErrPointer: u16 = unsafe { ::core::mem::transmute(PioFirstErrPointer) };
            PioFirstErrPointer as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let Reserved2: u16 = unsafe { ::core::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_DPC_STATUS_REGISTER = _PCI_EXPRESS_DPC_STATUS_REGISTER;
pub type PPCI_EXPRESS_DPC_STATUS_REGISTER = *mut _PCI_EXPRESS_DPC_STATUS_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_DPC_RP_PIO_STATUS_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_DPC_RP_PIO_STATUS_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_DPC_RP_PIO_STATUS_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_DPC_RP_PIO_STATUS_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn CfgURCpl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CfgURCpl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CfgURCpl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CfgURCpl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CfgCACpl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CfgCACpl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CfgCACpl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CfgCACpl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CfgCTO(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CfgCTO(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CfgCTO_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CfgCTO_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IoURCpl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoURCpl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IoURCpl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IoURCpl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IoCACpl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoCACpl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IoCACpl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IoCACpl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IoCTO(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoCTO(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IoCTO_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IoCTO_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemURCpl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MemURCpl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemURCpl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemURCpl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemCACpl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MemCACpl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemCACpl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemCACpl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemCTO(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MemCTO(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemCTO_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemCTO_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved3(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved3(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved3_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                12u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved3_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved4(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved4(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved4_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved4_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CfgURCpl: ULONG,
        CfgCACpl: ULONG,
        CfgCTO: ULONG,
        Reserved1: ULONG,
        IoURCpl: ULONG,
        IoCACpl: ULONG,
        IoCTO: ULONG,
        Reserved2: ULONG,
        MemURCpl: ULONG,
        MemCACpl: ULONG,
        MemCTO: ULONG,
        Reserved3: ULONG,
        Reserved4: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CfgURCpl: u32 = unsafe { ::core::mem::transmute(CfgURCpl) };
            CfgURCpl as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CfgCACpl: u32 = unsafe { ::core::mem::transmute(CfgCACpl) };
            CfgCACpl as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CfgCTO: u32 = unsafe { ::core::mem::transmute(CfgCTO) };
            CfgCTO as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let IoURCpl: u32 = unsafe { ::core::mem::transmute(IoURCpl) };
            IoURCpl as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let IoCACpl: u32 = unsafe { ::core::mem::transmute(IoCACpl) };
            IoCACpl as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let IoCTO: u32 = unsafe { ::core::mem::transmute(IoCTO) };
            IoCTO as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let Reserved2: u32 = unsafe { ::core::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let MemURCpl: u32 = unsafe { ::core::mem::transmute(MemURCpl) };
            MemURCpl as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let MemCACpl: u32 = unsafe { ::core::mem::transmute(MemCACpl) };
            MemCACpl as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let MemCTO: u32 = unsafe { ::core::mem::transmute(MemCTO) };
            MemCTO as u64
        });
        __bindgen_bitfield_unit.set(19usize, 12u8, {
            let Reserved3: u32 = unsafe { ::core::mem::transmute(Reserved3) };
            Reserved3 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let Reserved4: u32 = unsafe { ::core::mem::transmute(Reserved4) };
            Reserved4 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_DPC_RP_PIO_STATUS_REGISTER = _PCI_EXPRESS_DPC_RP_PIO_STATUS_REGISTER;
pub type PPCI_EXPRESS_DPC_RP_PIO_STATUS_REGISTER = *mut _PCI_EXPRESS_DPC_RP_PIO_STATUS_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_DPC_RP_PIO_MASK_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_DPC_RP_PIO_MASK_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_DPC_RP_PIO_MASK_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_DPC_RP_PIO_MASK_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn CfgURCpl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CfgURCpl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CfgURCpl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CfgURCpl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CfgCACpl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CfgCACpl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CfgCACpl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CfgCACpl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CfgCTO(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CfgCTO(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CfgCTO_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CfgCTO_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IoURCpl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoURCpl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IoURCpl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IoURCpl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IoCACpl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoCACpl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IoCACpl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IoCACpl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IoCTO(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoCTO(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IoCTO_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IoCTO_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemURCpl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MemURCpl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemURCpl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemURCpl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemCACpl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MemCACpl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemCACpl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemCACpl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemCTO(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MemCTO(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemCTO_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemCTO_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved3(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved3(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved3_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                13u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved3_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                13u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CfgURCpl: ULONG,
        CfgCACpl: ULONG,
        CfgCTO: ULONG,
        Reserved1: ULONG,
        IoURCpl: ULONG,
        IoCACpl: ULONG,
        IoCTO: ULONG,
        Reserved2: ULONG,
        MemURCpl: ULONG,
        MemCACpl: ULONG,
        MemCTO: ULONG,
        Reserved3: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CfgURCpl: u32 = unsafe { ::core::mem::transmute(CfgURCpl) };
            CfgURCpl as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CfgCACpl: u32 = unsafe { ::core::mem::transmute(CfgCACpl) };
            CfgCACpl as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CfgCTO: u32 = unsafe { ::core::mem::transmute(CfgCTO) };
            CfgCTO as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let IoURCpl: u32 = unsafe { ::core::mem::transmute(IoURCpl) };
            IoURCpl as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let IoCACpl: u32 = unsafe { ::core::mem::transmute(IoCACpl) };
            IoCACpl as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let IoCTO: u32 = unsafe { ::core::mem::transmute(IoCTO) };
            IoCTO as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let Reserved2: u32 = unsafe { ::core::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let MemURCpl: u32 = unsafe { ::core::mem::transmute(MemURCpl) };
            MemURCpl as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let MemCACpl: u32 = unsafe { ::core::mem::transmute(MemCACpl) };
            MemCACpl as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let MemCTO: u32 = unsafe { ::core::mem::transmute(MemCTO) };
            MemCTO as u64
        });
        __bindgen_bitfield_unit.set(19usize, 13u8, {
            let Reserved3: u32 = unsafe { ::core::mem::transmute(Reserved3) };
            Reserved3 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_DPC_RP_PIO_MASK_REGISTER = _PCI_EXPRESS_DPC_RP_PIO_MASK_REGISTER;
pub type PPCI_EXPRESS_DPC_RP_PIO_MASK_REGISTER = *mut _PCI_EXPRESS_DPC_RP_PIO_MASK_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_DPC_RP_PIO_SEVERITY_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_DPC_RP_PIO_SEVERITY_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_DPC_RP_PIO_SEVERITY_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_DPC_RP_PIO_SEVERITY_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn CfgURCpl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CfgURCpl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CfgURCpl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CfgURCpl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CfgCACpl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CfgCACpl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CfgCACpl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CfgCACpl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CfgCTO(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CfgCTO(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CfgCTO_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CfgCTO_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IoURCpl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoURCpl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IoURCpl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IoURCpl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IoCACpl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoCACpl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IoCACpl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IoCACpl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IoCTO(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoCTO(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IoCTO_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IoCTO_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemURCpl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MemURCpl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemURCpl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemURCpl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemCACpl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MemCACpl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemCACpl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemCACpl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemCTO(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MemCTO(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemCTO_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemCTO_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved3(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved3(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved3_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                13u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved3_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                13u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CfgURCpl: ULONG,
        CfgCACpl: ULONG,
        CfgCTO: ULONG,
        Reserved1: ULONG,
        IoURCpl: ULONG,
        IoCACpl: ULONG,
        IoCTO: ULONG,
        Reserved2: ULONG,
        MemURCpl: ULONG,
        MemCACpl: ULONG,
        MemCTO: ULONG,
        Reserved3: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CfgURCpl: u32 = unsafe { ::core::mem::transmute(CfgURCpl) };
            CfgURCpl as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CfgCACpl: u32 = unsafe { ::core::mem::transmute(CfgCACpl) };
            CfgCACpl as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CfgCTO: u32 = unsafe { ::core::mem::transmute(CfgCTO) };
            CfgCTO as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let IoURCpl: u32 = unsafe { ::core::mem::transmute(IoURCpl) };
            IoURCpl as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let IoCACpl: u32 = unsafe { ::core::mem::transmute(IoCACpl) };
            IoCACpl as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let IoCTO: u32 = unsafe { ::core::mem::transmute(IoCTO) };
            IoCTO as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let Reserved2: u32 = unsafe { ::core::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let MemURCpl: u32 = unsafe { ::core::mem::transmute(MemURCpl) };
            MemURCpl as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let MemCACpl: u32 = unsafe { ::core::mem::transmute(MemCACpl) };
            MemCACpl as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let MemCTO: u32 = unsafe { ::core::mem::transmute(MemCTO) };
            MemCTO as u64
        });
        __bindgen_bitfield_unit.set(19usize, 13u8, {
            let Reserved3: u32 = unsafe { ::core::mem::transmute(Reserved3) };
            Reserved3 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_DPC_RP_PIO_SEVERITY_REGISTER = _PCI_EXPRESS_DPC_RP_PIO_SEVERITY_REGISTER;
pub type PPCI_EXPRESS_DPC_RP_PIO_SEVERITY_REGISTER = *mut _PCI_EXPRESS_DPC_RP_PIO_SEVERITY_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_DPC_RP_PIO_SYSERR_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_DPC_RP_PIO_SYSERR_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_DPC_RP_PIO_SYSERR_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_DPC_RP_PIO_SYSERR_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn CfgURCpl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CfgURCpl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CfgURCpl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CfgURCpl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CfgCACpl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CfgCACpl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CfgCACpl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CfgCACpl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CfgCTO(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CfgCTO(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CfgCTO_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CfgCTO_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IoURCpl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoURCpl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IoURCpl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IoURCpl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IoCACpl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoCACpl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IoCACpl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IoCACpl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IoCTO(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoCTO(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IoCTO_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IoCTO_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemURCpl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MemURCpl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemURCpl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemURCpl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemCACpl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MemCACpl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemCACpl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemCACpl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemCTO(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MemCTO(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemCTO_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemCTO_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved3(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved3(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved3_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                13u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved3_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                13u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CfgURCpl: ULONG,
        CfgCACpl: ULONG,
        CfgCTO: ULONG,
        Reserved1: ULONG,
        IoURCpl: ULONG,
        IoCACpl: ULONG,
        IoCTO: ULONG,
        Reserved2: ULONG,
        MemURCpl: ULONG,
        MemCACpl: ULONG,
        MemCTO: ULONG,
        Reserved3: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CfgURCpl: u32 = unsafe { ::core::mem::transmute(CfgURCpl) };
            CfgURCpl as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CfgCACpl: u32 = unsafe { ::core::mem::transmute(CfgCACpl) };
            CfgCACpl as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CfgCTO: u32 = unsafe { ::core::mem::transmute(CfgCTO) };
            CfgCTO as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let IoURCpl: u32 = unsafe { ::core::mem::transmute(IoURCpl) };
            IoURCpl as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let IoCACpl: u32 = unsafe { ::core::mem::transmute(IoCACpl) };
            IoCACpl as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let IoCTO: u32 = unsafe { ::core::mem::transmute(IoCTO) };
            IoCTO as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let Reserved2: u32 = unsafe { ::core::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let MemURCpl: u32 = unsafe { ::core::mem::transmute(MemURCpl) };
            MemURCpl as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let MemCACpl: u32 = unsafe { ::core::mem::transmute(MemCACpl) };
            MemCACpl as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let MemCTO: u32 = unsafe { ::core::mem::transmute(MemCTO) };
            MemCTO as u64
        });
        __bindgen_bitfield_unit.set(19usize, 13u8, {
            let Reserved3: u32 = unsafe { ::core::mem::transmute(Reserved3) };
            Reserved3 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_DPC_RP_PIO_SYSERR_REGISTER = _PCI_EXPRESS_DPC_RP_PIO_SYSERR_REGISTER;
pub type PPCI_EXPRESS_DPC_RP_PIO_SYSERR_REGISTER = *mut _PCI_EXPRESS_DPC_RP_PIO_SYSERR_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_DPC_RP_PIO_EXCEPTION_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_DPC_RP_PIO_EXCEPTION_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_DPC_RP_PIO_EXCEPTION_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_DPC_RP_PIO_EXCEPTION_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn CfgURCpl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CfgURCpl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CfgURCpl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CfgURCpl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CfgCACpl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CfgCACpl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CfgCACpl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CfgCACpl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CfgCTO(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CfgCTO(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CfgCTO_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CfgCTO_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IoURCpl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoURCpl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IoURCpl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IoURCpl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IoCACpl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoCACpl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IoCACpl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IoCACpl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IoCTO(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoCTO(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IoCTO_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IoCTO_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemURCpl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MemURCpl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemURCpl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemURCpl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemCACpl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MemCACpl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemCACpl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemCACpl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemCTO(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MemCTO(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemCTO_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemCTO_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved3(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved3(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved3_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                13u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved3_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                13u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CfgURCpl: ULONG,
        CfgCACpl: ULONG,
        CfgCTO: ULONG,
        Reserved1: ULONG,
        IoURCpl: ULONG,
        IoCACpl: ULONG,
        IoCTO: ULONG,
        Reserved2: ULONG,
        MemURCpl: ULONG,
        MemCACpl: ULONG,
        MemCTO: ULONG,
        Reserved3: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CfgURCpl: u32 = unsafe { ::core::mem::transmute(CfgURCpl) };
            CfgURCpl as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CfgCACpl: u32 = unsafe { ::core::mem::transmute(CfgCACpl) };
            CfgCACpl as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CfgCTO: u32 = unsafe { ::core::mem::transmute(CfgCTO) };
            CfgCTO as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let IoURCpl: u32 = unsafe { ::core::mem::transmute(IoURCpl) };
            IoURCpl as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let IoCACpl: u32 = unsafe { ::core::mem::transmute(IoCACpl) };
            IoCACpl as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let IoCTO: u32 = unsafe { ::core::mem::transmute(IoCTO) };
            IoCTO as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let Reserved2: u32 = unsafe { ::core::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let MemURCpl: u32 = unsafe { ::core::mem::transmute(MemURCpl) };
            MemURCpl as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let MemCACpl: u32 = unsafe { ::core::mem::transmute(MemCACpl) };
            MemCACpl as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let MemCTO: u32 = unsafe { ::core::mem::transmute(MemCTO) };
            MemCTO as u64
        });
        __bindgen_bitfield_unit.set(19usize, 13u8, {
            let Reserved3: u32 = unsafe { ::core::mem::transmute(Reserved3) };
            Reserved3 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_DPC_RP_PIO_EXCEPTION_REGISTER = _PCI_EXPRESS_DPC_RP_PIO_EXCEPTION_REGISTER;
pub type PPCI_EXPRESS_DPC_RP_PIO_EXCEPTION_REGISTER =
*mut _PCI_EXPRESS_DPC_RP_PIO_EXCEPTION_REGISTER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_DPC_RP_PIO_HEADERLOG_REGISTER {
    pub PioHeaderLogRegister: [ULONG; 4usize],
}
pub type PCI_EXPRESS_DPC_RP_PIO_HEADERLOG_REGISTER = _PCI_EXPRESS_DPC_RP_PIO_HEADERLOG_REGISTER;
pub type PPCI_EXPRESS_DPC_RP_PIO_HEADERLOG_REGISTER =
*mut _PCI_EXPRESS_DPC_RP_PIO_HEADERLOG_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_DPC_RP_PIO_IMPSPECLOG_REGISTER {
    pub PioImpSpecLog: ULONG,
}
pub type PCI_EXPRESS_DPC_RP_PIO_IMPSPECLOG_REGISTER = _PCI_EXPRESS_DPC_RP_PIO_IMPSPECLOG_REGISTER;
pub type PPCI_EXPRESS_DPC_RP_PIO_IMPSPECLOG_REGISTER =
*mut _PCI_EXPRESS_DPC_RP_PIO_IMPSPECLOG_REGISTER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_DPC_RP_PIO_TLPPREFIXLOG_REGISTER {
    pub PioTlpPrefixLogRegister: [ULONG; 4usize],
}
pub type PCI_EXPRESS_DPC_RP_PIO_TLPPREFIXLOG_REGISTER =
_PCI_EXPRESS_DPC_RP_PIO_TLPPREFIXLOG_REGISTER;
pub type PPCI_EXPRESS_DPC_RP_PIO_TLPPREFIXLOG_REGISTER =
*mut _PCI_EXPRESS_DPC_RP_PIO_TLPPREFIXLOG_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_DPC_ERROR_SOURCE_ID {
    pub __bindgen_anon_1: _PCI_EXPRESS_DPC_ERROR_SOURCE_ID__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_DPC_ERROR_SOURCE_ID__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_DPC_ERROR_SOURCE_ID__bindgen_ty_1 {
    #[inline]
    pub fn Function(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_Function(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Function_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Function_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Device(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_Device(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Device_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Device_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Bus(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_Bus(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Bus_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Bus_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Function: USHORT,
        Device: USHORT,
        Bus: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let Function: u16 = unsafe { ::core::mem::transmute(Function) };
            Function as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let Device: u16 = unsafe { ::core::mem::transmute(Device) };
            Device as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let Bus: u16 = unsafe { ::core::mem::transmute(Bus) };
            Bus as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_DPC_ERROR_SOURCE_ID = _PCI_EXPRESS_DPC_ERROR_SOURCE_ID;
pub type PPCI_EXPRESS_DPC_ERROR_SOURCE_ID = *mut _PCI_EXPRESS_DPC_ERROR_SOURCE_ID;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_DPC_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub DpcCapabilities: PCI_EXPRESS_DPC_CAPS_REGISTER,
    pub DpcControl: PCI_EXPRESS_DPC_CONTROL_REGISTER,
    pub DpcStatus: PCI_EXPRESS_DPC_STATUS_REGISTER,
    pub DpcErrSrcId: PCI_EXPRESS_DPC_ERROR_SOURCE_ID,
    pub RpPioStatus: PCI_EXPRESS_DPC_RP_PIO_STATUS_REGISTER,
    pub RpPioMask: PCI_EXPRESS_DPC_RP_PIO_MASK_REGISTER,
    pub RpPioSeverity: PCI_EXPRESS_DPC_RP_PIO_SEVERITY_REGISTER,
    pub RpPioSysError: PCI_EXPRESS_DPC_RP_PIO_SYSERR_REGISTER,
    pub RpPioException: PCI_EXPRESS_DPC_RP_PIO_EXCEPTION_REGISTER,
    pub RpPioHeaderLog: PCI_EXPRESS_DPC_RP_PIO_HEADERLOG_REGISTER,
    pub RpPioImpSpecLog: PCI_EXPRESS_DPC_RP_PIO_IMPSPECLOG_REGISTER,
    pub RpPioPrefixLog: PCI_EXPRESS_DPC_RP_PIO_TLPPREFIXLOG_REGISTER,
}
pub type PCI_EXPRESS_DPC_CAPABILITY = _PCI_EXPRESS_DPC_CAPABILITY;
pub type PPCI_EXPRESS_DPC_CAPABILITY = *mut _PCI_EXPRESS_DPC_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SizesSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_SizesSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SizesSupported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                20u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SizesSupported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                20u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Rsvd: ULONG,
        SizesSupported: ULONG,
        Rsvd2: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let Rsvd: u32 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit.set(4usize, 20u8, {
            let SizesSupported: u32 = unsafe { ::core::mem::transmute(SizesSupported) };
            SizesSupported as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let Rsvd2: u32 = unsafe { ::core::mem::transmute(Rsvd2) };
            Rsvd2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER =
_PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER;
pub type PPCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER =
*mut _PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn BarIndex(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_BarIndex(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn BarIndex_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_BarIndex_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NumberOfResizableBars(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_NumberOfResizableBars(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NumberOfResizableBars_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NumberOfResizableBars_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn BarSize(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_BarSize(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn BarSize_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_BarSize_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                18u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                18u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BarIndex: ULONG,
        Rsvd: ULONG,
        NumberOfResizableBars: ULONG,
        BarSize: ULONG,
        Rsvd2: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let BarIndex: u32 = unsafe { ::core::mem::transmute(BarIndex) };
            BarIndex as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let Rsvd: u32 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let NumberOfResizableBars: u32 =
                unsafe { ::core::mem::transmute(NumberOfResizableBars) };
            NumberOfResizableBars as u64
        });
        __bindgen_bitfield_unit.set(8usize, 6u8, {
            let BarSize: u32 = unsafe { ::core::mem::transmute(BarSize) };
            BarSize as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let Rsvd2: u32 = unsafe { ::core::mem::transmute(Rsvd2) };
            Rsvd2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER = _PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER;
pub type PPCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER =
*mut _PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_RESIZABLE_BAR_ENTRY {
    pub Capability: PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER,
    pub Control: PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER,
}
pub type PCI_EXPRESS_RESIZABLE_BAR_ENTRY = _PCI_EXPRESS_RESIZABLE_BAR_ENTRY;
pub type PPCI_EXPRESS_RESIZABLE_BAR_ENTRY = *mut _PCI_EXPRESS_RESIZABLE_BAR_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub Entry: [PCI_EXPRESS_RESIZABLE_BAR_ENTRY; 6usize],
}
pub type PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY = _PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY;
pub type PPCI_EXPRESS_RESIZABLE_BAR_CAPABILITY = *mut _PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_HEADER_1 {
    pub __bindgen_anon_1: _PCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_HEADER_1__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_HEADER_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_HEADER_1__bindgen_ty_1 {
    #[inline]
    pub fn DvsecVendorId(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_DvsecVendorId(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DvsecVendorId_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DvsecVendorId_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DvsecVersion(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_DvsecVersion(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DvsecVersion_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DvsecVersion_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DvsecLength(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_DvsecLength(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DvsecLength_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                12u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DvsecLength_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DvsecVendorId: ULONG,
        DvsecVersion: ULONG,
        DvsecLength: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let DvsecVendorId: u32 = unsafe { ::core::mem::transmute(DvsecVendorId) };
            DvsecVendorId as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let DvsecVersion: u32 = unsafe { ::core::mem::transmute(DvsecVersion) };
            DvsecVersion as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let DvsecLength: u32 = unsafe { ::core::mem::transmute(DvsecLength) };
            DvsecLength as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_HEADER_1 =
_PCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_HEADER_1;
pub type PPCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_HEADER_1 =
*mut _PCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_HEADER_1;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_HEADER_2 {
    pub __bindgen_anon_1: _PCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_HEADER_2__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_HEADER_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_HEADER_2__bindgen_ty_1 {
    #[inline]
    pub fn DvsecId(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_DvsecId(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DvsecId_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_DvsecId_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(DvsecId: USHORT) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let DvsecId: u16 = unsafe { ::core::mem::transmute(DvsecId) };
            DvsecId as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_HEADER_2 =
_PCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_HEADER_2;
pub type PPCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_HEADER_2 =
*mut _PCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_HEADER_2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub DvsecHeader1: PCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_HEADER_1,
    pub DvsecHeader2: PCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_HEADER_2,
    pub DvsecRegisters: [USHORT; 1usize],
}
pub type PCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_CAPABILITY =
_PCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_CAPABILITY;
pub type PPCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_CAPABILITY =
*mut _PCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_LINK_CONTROL3 {
    pub __bindgen_anon_1: _PCI_EXPRESS_LINK_CONTROL3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_LINK_CONTROL3__bindgen_ty_1 {
    pub __bindgen_anon_1: _PCI_EXPRESS_LINK_CONTROL3__bindgen_ty_1__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_LINK_CONTROL3__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_LINK_CONTROL3__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn PerformEq(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PerformEq(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PerformEq_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PerformEq_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LinkEqIntEn(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LinkEqIntEn(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LinkEqIntEn_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_LinkEqIntEn_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PerformEq: ULONG,
        LinkEqIntEn: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PerformEq: u32 = unsafe { ::core::mem::transmute(PerformEq) };
            PerformEq as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let LinkEqIntEn: u32 = unsafe { ::core::mem::transmute(LinkEqIntEn) };
            LinkEqIntEn as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_LINK_CONTROL3 = _PCI_EXPRESS_LINK_CONTROL3;
pub type PPCI_EXPRESS_LINK_CONTROL3 = *mut _PCI_EXPRESS_LINK_CONTROL3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_LANE_ERROR_STATUS {
    pub LaneBitmap: ULONG,
}
pub type PCI_EXPRESS_LANE_ERROR_STATUS = _PCI_EXPRESS_LANE_ERROR_STATUS;
pub type PPCI_EXPRESS_LANE_ERROR_STATUS = *mut _PCI_EXPRESS_LANE_ERROR_STATUS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_SECONDARY_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub LinkControl3: PCI_EXPRESS_LINK_CONTROL3,
    pub LaneErrorStatus: PCI_EXPRESS_LANE_ERROR_STATUS,
}
pub type PCI_EXPRESS_SECONDARY_CAPABILITY = _PCI_EXPRESS_SECONDARY_CAPABILITY;
pub type PPCI_EXPRESS_SECONDARY_CAPABILITY = *mut _PCI_EXPRESS_SECONDARY_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_NPEM_CAPABILITY_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_NPEM_CAPABILITY_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_NPEM_CAPABILITY_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_NPEM_CAPABILITY_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn Capable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Capable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Capable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Capable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ResetCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ResetCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ResetCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ResetCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn OkCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OkCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn OkCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_OkCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LocateCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LocateCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LocateCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_LocateCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FailCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FailCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FailCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FailCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RebuildCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RebuildCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RebuildCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RebuildCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PFACapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PFACapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PFACapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PFACapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn HotSpareCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HotSpareCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn HotSpareCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_HotSpareCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn InACriticalArrayCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InACriticalArrayCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InACriticalArrayCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_InACriticalArrayCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn InAFailedArrayCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InAFailedArrayCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InAFailedArrayCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_InAFailedArrayCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn InvalidDeviceTypeCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InvalidDeviceTypeCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InvalidDeviceTypeCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_InvalidDeviceTypeCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DisabledCapable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisabledCapable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DisabledCapable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DisabledCapable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                12u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EnclosureSpecificCapabilities(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_EnclosureSpecificCapabilities(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EnclosureSpecificCapabilities_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_EnclosureSpecificCapabilities_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Capable: ULONG,
        ResetCapable: ULONG,
        OkCapable: ULONG,
        LocateCapable: ULONG,
        FailCapable: ULONG,
        RebuildCapable: ULONG,
        PFACapable: ULONG,
        HotSpareCapable: ULONG,
        InACriticalArrayCapable: ULONG,
        InAFailedArrayCapable: ULONG,
        InvalidDeviceTypeCapable: ULONG,
        DisabledCapable: ULONG,
        Rsvd: ULONG,
        EnclosureSpecificCapabilities: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Capable: u32 = unsafe { ::core::mem::transmute(Capable) };
            Capable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ResetCapable: u32 = unsafe { ::core::mem::transmute(ResetCapable) };
            ResetCapable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let OkCapable: u32 = unsafe { ::core::mem::transmute(OkCapable) };
            OkCapable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let LocateCapable: u32 = unsafe { ::core::mem::transmute(LocateCapable) };
            LocateCapable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let FailCapable: u32 = unsafe { ::core::mem::transmute(FailCapable) };
            FailCapable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let RebuildCapable: u32 = unsafe { ::core::mem::transmute(RebuildCapable) };
            RebuildCapable as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PFACapable: u32 = unsafe { ::core::mem::transmute(PFACapable) };
            PFACapable as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let HotSpareCapable: u32 = unsafe { ::core::mem::transmute(HotSpareCapable) };
            HotSpareCapable as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let InACriticalArrayCapable: u32 =
                unsafe { ::core::mem::transmute(InACriticalArrayCapable) };
            InACriticalArrayCapable as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let InAFailedArrayCapable: u32 =
                unsafe { ::core::mem::transmute(InAFailedArrayCapable) };
            InAFailedArrayCapable as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let InvalidDeviceTypeCapable: u32 =
                unsafe { ::core::mem::transmute(InvalidDeviceTypeCapable) };
            InvalidDeviceTypeCapable as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let DisabledCapable: u32 = unsafe { ::core::mem::transmute(DisabledCapable) };
            DisabledCapable as u64
        });
        __bindgen_bitfield_unit.set(12usize, 12u8, {
            let Rsvd: u32 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let EnclosureSpecificCapabilities: u32 =
                unsafe { ::core::mem::transmute(EnclosureSpecificCapabilities) };
            EnclosureSpecificCapabilities as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_NPEM_CAPABILITY_REGISTER = _PCI_EXPRESS_NPEM_CAPABILITY_REGISTER;
pub type PPCI_EXPRESS_NPEM_CAPABILITY_REGISTER = *mut _PCI_EXPRESS_NPEM_CAPABILITY_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_NPEM_CONTROL_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_NPEM_CONTROL_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_NPEM_CONTROL_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_NPEM_CONTROL_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn Enable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Enable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Enable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Enable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn InitiateReset(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InitiateReset(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InitiateReset_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_InitiateReset_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn OkControl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OkControl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn OkControl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_OkControl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LocateControl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LocateControl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LocateControl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_LocateControl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FailControl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FailControl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FailControl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FailControl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RebuildControl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RebuildControl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RebuildControl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RebuildControl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PFAControl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PFAControl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PFAControl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PFAControl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn HotSpareControl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HotSpareControl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn HotSpareControl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_HotSpareControl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn InACriticalArrayControl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InACriticalArrayControl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InACriticalArrayControl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_InACriticalArrayControl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn InAFailedArrayControl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InAFailedArrayControl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InAFailedArrayControl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_InAFailedArrayControl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn InvalidDeviceTypeControl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InvalidDeviceTypeControl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InvalidDeviceTypeControl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_InvalidDeviceTypeControl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DisabledControl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisabledControl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DisabledControl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DisabledControl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                12u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EnclosureSpecificControls(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_EnclosureSpecificControls(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EnclosureSpecificControls_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_EnclosureSpecificControls_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Enable: ULONG,
        InitiateReset: ULONG,
        OkControl: ULONG,
        LocateControl: ULONG,
        FailControl: ULONG,
        RebuildControl: ULONG,
        PFAControl: ULONG,
        HotSpareControl: ULONG,
        InACriticalArrayControl: ULONG,
        InAFailedArrayControl: ULONG,
        InvalidDeviceTypeControl: ULONG,
        DisabledControl: ULONG,
        Rsvd: ULONG,
        EnclosureSpecificControls: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Enable: u32 = unsafe { ::core::mem::transmute(Enable) };
            Enable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let InitiateReset: u32 = unsafe { ::core::mem::transmute(InitiateReset) };
            InitiateReset as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let OkControl: u32 = unsafe { ::core::mem::transmute(OkControl) };
            OkControl as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let LocateControl: u32 = unsafe { ::core::mem::transmute(LocateControl) };
            LocateControl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let FailControl: u32 = unsafe { ::core::mem::transmute(FailControl) };
            FailControl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let RebuildControl: u32 = unsafe { ::core::mem::transmute(RebuildControl) };
            RebuildControl as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PFAControl: u32 = unsafe { ::core::mem::transmute(PFAControl) };
            PFAControl as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let HotSpareControl: u32 = unsafe { ::core::mem::transmute(HotSpareControl) };
            HotSpareControl as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let InACriticalArrayControl: u32 =
                unsafe { ::core::mem::transmute(InACriticalArrayControl) };
            InACriticalArrayControl as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let InAFailedArrayControl: u32 =
                unsafe { ::core::mem::transmute(InAFailedArrayControl) };
            InAFailedArrayControl as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let InvalidDeviceTypeControl: u32 =
                unsafe { ::core::mem::transmute(InvalidDeviceTypeControl) };
            InvalidDeviceTypeControl as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let DisabledControl: u32 = unsafe { ::core::mem::transmute(DisabledControl) };
            DisabledControl as u64
        });
        __bindgen_bitfield_unit.set(12usize, 12u8, {
            let Rsvd: u32 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let EnclosureSpecificControls: u32 =
                unsafe { ::core::mem::transmute(EnclosureSpecificControls) };
            EnclosureSpecificControls as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_NPEM_CONTROL_REGISTER = _PCI_EXPRESS_NPEM_CONTROL_REGISTER;
pub type PPCI_EXPRESS_NPEM_CONTROL_REGISTER = *mut _PCI_EXPRESS_NPEM_CONTROL_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_NPEM_STATUS_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_NPEM_STATUS_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_NPEM_STATUS_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_NPEM_STATUS_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn CommandCompleted(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CommandCompleted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CommandCompleted_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CommandCompleted_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Rsvd(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_Rsvd(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Rsvd_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                23u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Rsvd_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                23u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EnclosureSpecificStatus(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_EnclosureSpecificStatus(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EnclosureSpecificStatus_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_EnclosureSpecificStatus_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CommandCompleted: ULONG,
        Rsvd: ULONG,
        EnclosureSpecificStatus: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CommandCompleted: u32 = unsafe { ::core::mem::transmute(CommandCompleted) };
            CommandCompleted as u64
        });
        __bindgen_bitfield_unit.set(1usize, 23u8, {
            let Rsvd: u32 = unsafe { ::core::mem::transmute(Rsvd) };
            Rsvd as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let EnclosureSpecificStatus: u32 =
                unsafe { ::core::mem::transmute(EnclosureSpecificStatus) };
            EnclosureSpecificStatus as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_NPEM_STATUS_REGISTER = _PCI_EXPRESS_NPEM_STATUS_REGISTER;
pub type PPCI_EXPRESS_NPEM_STATUS_REGISTER = *mut _PCI_EXPRESS_NPEM_STATUS_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_NPEM_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub Capability: PCI_EXPRESS_NPEM_CAPABILITY_REGISTER,
    pub Control: PCI_EXPRESS_NPEM_CONTROL_REGISTER,
    pub Status: PCI_EXPRESS_NPEM_STATUS_REGISTER,
}
pub type PCI_EXPRESS_NPEM_CAPABILITY = _PCI_EXPRESS_NPEM_CAPABILITY;
pub type PPCI_EXPRESS_NPEM_CAPABILITY = *mut _PCI_EXPRESS_NPEM_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_EVENT_COLLECTOR_ENDPOINT_ASSOCIATION_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub AssociationBitmap: ULONG,
}
pub type PCI_EXPRESS_EVENT_COLLECTOR_ENDPOINT_ASSOCIATION_CAPABILITY =
_PCI_EXPRESS_EVENT_COLLECTOR_ENDPOINT_ASSOCIATION_CAPABILITY;
pub type PPCI_EXPRESS_EVENT_COLLECTOR_ENDPOINT_ASSOCIATION_CAPABILITY =
*mut _PCI_EXPRESS_EVENT_COLLECTOR_ENDPOINT_ASSOCIATION_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_CXL_DVSEC_CAPABILITY_REGISTER_V11 {
    pub __bindgen_anon_1: _PCI_EXPRESS_CXL_DVSEC_CAPABILITY_REGISTER_V11__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_CXL_DVSEC_CAPABILITY_REGISTER_V11__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_CXL_DVSEC_CAPABILITY_REGISTER_V11__bindgen_ty_1 {
    #[inline]
    pub fn CacheCapable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CacheCapable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CacheCapable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_CacheCapable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IoCapable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_IoCapable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IoCapable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_IoCapable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemCapable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_MemCapable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemCapable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_MemCapable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemHwInitMode(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_MemHwInitMode(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemHwInitMode_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_MemHwInitMode_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn HdmCount(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_HdmCount(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn HdmCount_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_HdmCount_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved0(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved0_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                8u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved0_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ViralCapable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ViralCapable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ViralCapable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ViralCapable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CacheCapable: USHORT,
        IoCapable: USHORT,
        MemCapable: USHORT,
        MemHwInitMode: USHORT,
        HdmCount: USHORT,
        Reserved0: USHORT,
        ViralCapable: USHORT,
        Reserved1: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CacheCapable: u16 = unsafe { ::core::mem::transmute(CacheCapable) };
            CacheCapable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let IoCapable: u16 = unsafe { ::core::mem::transmute(IoCapable) };
            IoCapable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let MemCapable: u16 = unsafe { ::core::mem::transmute(MemCapable) };
            MemCapable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let MemHwInitMode: u16 = unsafe { ::core::mem::transmute(MemHwInitMode) };
            MemHwInitMode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let HdmCount: u16 = unsafe { ::core::mem::transmute(HdmCount) };
            HdmCount as u64
        });
        __bindgen_bitfield_unit.set(6usize, 8u8, {
            let Reserved0: u16 = unsafe { ::core::mem::transmute(Reserved0) };
            Reserved0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let ViralCapable: u16 = unsafe { ::core::mem::transmute(ViralCapable) };
            ViralCapable as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let Reserved1: u16 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_CXL_DVSEC_CAPABILITY_REGISTER_V11 =
_PCI_EXPRESS_CXL_DVSEC_CAPABILITY_REGISTER_V11;
pub type PPCI_EXPRESS_CXL_DVSEC_CAPABILITY_REGISTER_V11 =
*mut _PCI_EXPRESS_CXL_DVSEC_CAPABILITY_REGISTER_V11;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_CXL_DVSEC_CONTROL_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_CXL_DVSEC_CONTROL_REGISTER__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_CXL_DVSEC_CONTROL_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_CXL_DVSEC_CONTROL_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn CacheEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CacheEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CacheEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_CacheEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IoEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_IoEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IoEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_IoEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_MemEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_MemEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CacheSFCoverage(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_CacheSFCoverage(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CacheSFCoverage_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_CacheSFCoverage_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CacheSFGranularity(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_CacheSFGranularity(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CacheSFGranularity_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_CacheSFGranularity_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CacheCleanEviction(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CacheCleanEviction(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CacheCleanEviction_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_CacheCleanEviction_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved0(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved0_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved0_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ViralEnable(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ViralEnable(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ViralEnable_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ViralEnable_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CacheEnable: USHORT,
        IoEnable: USHORT,
        MemEnable: USHORT,
        CacheSFCoverage: USHORT,
        CacheSFGranularity: USHORT,
        CacheCleanEviction: USHORT,
        Reserved0: USHORT,
        ViralEnable: USHORT,
        Reserved1: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CacheEnable: u16 = unsafe { ::core::mem::transmute(CacheEnable) };
            CacheEnable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let IoEnable: u16 = unsafe { ::core::mem::transmute(IoEnable) };
            IoEnable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let MemEnable: u16 = unsafe { ::core::mem::transmute(MemEnable) };
            MemEnable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let CacheSFCoverage: u16 = unsafe { ::core::mem::transmute(CacheSFCoverage) };
            CacheSFCoverage as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let CacheSFGranularity: u16 = unsafe { ::core::mem::transmute(CacheSFGranularity) };
            CacheSFGranularity as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let CacheCleanEviction: u16 = unsafe { ::core::mem::transmute(CacheCleanEviction) };
            CacheCleanEviction as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let Reserved0: u16 = unsafe { ::core::mem::transmute(Reserved0) };
            Reserved0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let ViralEnable: u16 = unsafe { ::core::mem::transmute(ViralEnable) };
            ViralEnable as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let Reserved1: u16 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_CXL_DVSEC_CONTROL_REGISTER = _PCI_EXPRESS_CXL_DVSEC_CONTROL_REGISTER;
pub type PPCI_EXPRESS_CXL_DVSEC_CONTROL_REGISTER = *mut _PCI_EXPRESS_CXL_DVSEC_CONTROL_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_CXL_DVSEC_STATUS_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_CXL_DVSEC_STATUS_REGISTER__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_CXL_DVSEC_STATUS_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_CXL_DVSEC_STATUS_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn Reserved0(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 14u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved0_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                14u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved0_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                14u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ViralStatus(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ViralStatus(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ViralStatus_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ViralStatus_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Reserved0: USHORT,
        ViralStatus: USHORT,
        Reserved1: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 14u8, {
            let Reserved0: u16 = unsafe { ::core::mem::transmute(Reserved0) };
            Reserved0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let ViralStatus: u16 = unsafe { ::core::mem::transmute(ViralStatus) };
            ViralStatus as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let Reserved1: u16 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_CXL_DVSEC_STATUS_REGISTER = _PCI_EXPRESS_CXL_DVSEC_STATUS_REGISTER;
pub type PPCI_EXPRESS_CXL_DVSEC_STATUS_REGISTER = *mut _PCI_EXPRESS_CXL_DVSEC_STATUS_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_CXL_DVSEC_LOCK_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_CXL_DVSEC_LOCK_REGISTER__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_CXL_DVSEC_LOCK_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PCI_EXPRESS_CXL_DVSEC_LOCK_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn ConfigLock(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ConfigLock(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ConfigLock_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ConfigLock_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 15u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                15u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                15u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ConfigLock: USHORT,
        Reserved: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ConfigLock: u16 = unsafe { ::core::mem::transmute(ConfigLock) };
            ConfigLock as u64
        });
        __bindgen_bitfield_unit.set(1usize, 15u8, {
            let Reserved: u16 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_CXL_DVSEC_LOCK_REGISTER = _PCI_EXPRESS_CXL_DVSEC_LOCK_REGISTER;
pub type PPCI_EXPRESS_CXL_DVSEC_LOCK_REGISTER = *mut _PCI_EXPRESS_CXL_DVSEC_LOCK_REGISTER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_CXL_DVSEC_RANGE_SIZE_HIGH_REGISTER {
    pub MemSizeHigh: ULONG,
}
pub type PCI_EXPRESS_CXL_DVSEC_RANGE_SIZE_HIGH_REGISTER =
_PCI_EXPRESS_CXL_DVSEC_RANGE_SIZE_HIGH_REGISTER;
pub type PPCI_EXPRESS_CXL_DVSEC_RANGE_SIZE_HIGH_REGISTER =
*mut _PCI_EXPRESS_CXL_DVSEC_RANGE_SIZE_HIGH_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_CXL_DVSEC_RANGE_SIZE_LOW_REGISTER_V11 {
    pub __bindgen_anon_1: _PCI_EXPRESS_CXL_DVSEC_RANGE_SIZE_LOW_REGISTER_V11__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_CXL_DVSEC_RANGE_SIZE_LOW_REGISTER_V11__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_CXL_DVSEC_RANGE_SIZE_LOW_REGISTER_V11__bindgen_ty_1 {
    #[inline]
    pub fn MemInfoValid(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MemInfoValid(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemInfoValid_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemInfoValid_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemActive(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MemActive(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemActive_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemActive_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MediaType(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_MediaType(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MediaType_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MediaType_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemClass(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_MemClass(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemClass_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemClass_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DesiredInterleave(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_DesiredInterleave(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DesiredInterleave_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DesiredInterleave_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 17u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                17u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                17u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemSizeLow(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_MemSizeLow(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemSizeLow_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemSizeLow_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MemInfoValid: ULONG,
        MemActive: ULONG,
        MediaType: ULONG,
        MemClass: ULONG,
        DesiredInterleave: ULONG,
        Reserved: ULONG,
        MemSizeLow: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let MemInfoValid: u32 = unsafe { ::core::mem::transmute(MemInfoValid) };
            MemInfoValid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let MemActive: u32 = unsafe { ::core::mem::transmute(MemActive) };
            MemActive as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let MediaType: u32 = unsafe { ::core::mem::transmute(MediaType) };
            MediaType as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let MemClass: u32 = unsafe { ::core::mem::transmute(MemClass) };
            MemClass as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let DesiredInterleave: u32 = unsafe { ::core::mem::transmute(DesiredInterleave) };
            DesiredInterleave as u64
        });
        __bindgen_bitfield_unit.set(11usize, 17u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let MemSizeLow: u32 = unsafe { ::core::mem::transmute(MemSizeLow) };
            MemSizeLow as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_CXL_DVSEC_RANGE_SIZE_LOW_REGISTER_V11 =
_PCI_EXPRESS_CXL_DVSEC_RANGE_SIZE_LOW_REGISTER_V11;
pub type PPCI_EXPRESS_CXL_DVSEC_RANGE_SIZE_LOW_REGISTER_V11 =
*mut _PCI_EXPRESS_CXL_DVSEC_RANGE_SIZE_LOW_REGISTER_V11;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_CXL_DVSEC_RANGE_BASE_HIGH_REGISTER {
    pub MemBaseHigh: ULONG,
}
pub type PCI_EXPRESS_CXL_DVSEC_RANGE_BASE_HIGH_REGISTER =
_PCI_EXPRESS_CXL_DVSEC_RANGE_BASE_HIGH_REGISTER;
pub type PPCI_EXPRESS_CXL_DVSEC_RANGE_BASE_HIGH_REGISTER =
*mut _PCI_EXPRESS_CXL_DVSEC_RANGE_BASE_HIGH_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PCI_EXPRESS_CXL_DVSEC_RANGE_BASE_LOW_REGISTER {
    pub __bindgen_anon_1: _PCI_EXPRESS_CXL_DVSEC_RANGE_BASE_LOW_REGISTER__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_EXPRESS_CXL_DVSEC_RANGE_BASE_LOW_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PCI_EXPRESS_CXL_DVSEC_RANGE_BASE_LOW_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                28u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                28u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemBaseLow(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_MemBaseLow(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemBaseLow_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemBaseLow_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Reserved: ULONG,
        MemBaseLow: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let MemBaseLow: u32 = unsafe { ::core::mem::transmute(MemBaseLow) };
            MemBaseLow as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PCI_EXPRESS_CXL_DVSEC_RANGE_BASE_LOW_REGISTER =
_PCI_EXPRESS_CXL_DVSEC_RANGE_BASE_LOW_REGISTER;
pub type PPCI_EXPRESS_CXL_DVSEC_RANGE_BASE_LOW_REGISTER =
*mut _PCI_EXPRESS_CXL_DVSEC_RANGE_BASE_LOW_REGISTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_CXL_DVSEC_CAPABILITY {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub DvsecHeader1: PCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_HEADER_1,
    pub DvsecHeader2: PCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_HEADER_2,
    pub Reserved: [UCHAR; 46usize],
}
pub type PCI_EXPRESS_CXL_DVSEC_CAPABILITY = _PCI_EXPRESS_CXL_DVSEC_CAPABILITY;
pub type PPCI_EXPRESS_CXL_DVSEC_CAPABILITY = *mut _PCI_EXPRESS_CXL_DVSEC_CAPABILITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PCI_EXPRESS_CXL_DVSEC_CAPABILITY_V11 {
    pub Header: PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER,
    pub DvsecHeader1: PCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_HEADER_1,
    pub DvsecHeader2: PCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_HEADER_2,
    pub Capability: PCI_EXPRESS_CXL_DVSEC_CAPABILITY_REGISTER_V11,
    pub Control: PCI_EXPRESS_CXL_DVSEC_CONTROL_REGISTER,
    pub Status: PCI_EXPRESS_CXL_DVSEC_STATUS_REGISTER,
    pub Control2: USHORT,
    pub Status2: USHORT,
    pub Lock: PCI_EXPRESS_CXL_DVSEC_LOCK_REGISTER,
    pub Reserved: USHORT,
    pub Range1SizeHigh: PCI_EXPRESS_CXL_DVSEC_RANGE_SIZE_HIGH_REGISTER,
    pub Range1SizeLow: PCI_EXPRESS_CXL_DVSEC_RANGE_SIZE_LOW_REGISTER_V11,
    pub Range1BaseHigh: PCI_EXPRESS_CXL_DVSEC_RANGE_BASE_HIGH_REGISTER,
    pub Range1BaseLow: PCI_EXPRESS_CXL_DVSEC_RANGE_BASE_LOW_REGISTER,
    pub Range2SizeHigh: PCI_EXPRESS_CXL_DVSEC_RANGE_SIZE_HIGH_REGISTER,
    pub Range2SizeLow: PCI_EXPRESS_CXL_DVSEC_RANGE_SIZE_LOW_REGISTER_V11,
    pub Range2BaseHigh: PCI_EXPRESS_CXL_DVSEC_RANGE_BASE_HIGH_REGISTER,
    pub Range2BaseLow: PCI_EXPRESS_CXL_DVSEC_RANGE_BASE_LOW_REGISTER,
}
pub type PCI_EXPRESS_CXL_DVSEC_CAPABILITY_V11 = _PCI_EXPRESS_CXL_DVSEC_CAPABILITY_V11;
pub type PPCI_EXPRESS_CXL_DVSEC_CAPABILITY_V11 = *mut _PCI_EXPRESS_CXL_DVSEC_CAPABILITY_V11;
pub type PCI_READ_WRITE_CONFIG = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        BusOffset: ULONG,
        Slot: ULONG,
        Buffer: PVOID,
        Offset: ULONG,
        Length: ULONG,
    ) -> ULONG,
>;
pub type PPCI_READ_WRITE_CONFIG = PCI_READ_WRITE_CONFIG;
pub type PCI_PIN_TO_LINE =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, PciData: PPCI_COMMON_CONFIG)>;
pub type PPCI_PIN_TO_LINE = PCI_PIN_TO_LINE;
pub type PCI_LINE_TO_PIN = ::core::option::Option<
    unsafe extern "C" fn(
        Context: PVOID,
        PciNewData: PPCI_COMMON_CONFIG,
        PciOldData: PPCI_COMMON_CONFIG,
    ),
>;
pub type PPCI_LINE_TO_PIN = PCI_LINE_TO_PIN;
pub type PCI_ROOT_BUS_CAPABILITY = ::core::option::Option<
    unsafe extern "C" fn(Context: PVOID, HardwareCapability: PPCI_ROOT_BUS_HARDWARE_CAPABILITY),
>;
pub type PPCI_ROOT_BUS_CAPABILITY = PCI_ROOT_BUS_CAPABILITY;
pub type PCI_EXPRESS_WAKE_CONTROL =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, EnableWake: BOOLEAN)>;
pub type PPCI_EXPRESS_WAKE_CONTROL = PCI_EXPRESS_WAKE_CONTROL;
pub type PCI_PREPARE_MULTISTAGE_RESUME =
::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
pub type PPCI_PREPARE_MULTISTAGE_RESUME = PCI_PREPARE_MULTISTAGE_RESUME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PCI_BUS_INTERFACE_STANDARD {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
    pub ReadConfig: PPCI_READ_WRITE_CONFIG,
    pub WriteConfig: PPCI_READ_WRITE_CONFIG,
    pub PinToLine: PPCI_PIN_TO_LINE,
    pub LineToPin: PPCI_LINE_TO_PIN,
    pub RootBusCapability: PPCI_ROOT_BUS_CAPABILITY,
    pub ExpressWakeControl: PPCI_EXPRESS_WAKE_CONTROL,
    pub PrepareMultistageResume: PPCI_PREPARE_MULTISTAGE_RESUME,
}
pub type PCI_BUS_INTERFACE_STANDARD = _PCI_BUS_INTERFACE_STANDARD;
pub type PPCI_BUS_INTERFACE_STANDARD = *mut _PCI_BUS_INTERFACE_STANDARD;
unsafe extern "C" {
    pub fn ZwSetInformationThread(
        ThreadHandle: HANDLE,
        ThreadInformationClass: THREADINFOCLASS,
        ThreadInformation: PVOID,
        ThreadInformationLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwCreateTimer(
        TimerHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        TimerType: TIMER_TYPE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwOpenTimer(
        TimerHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwCancelTimer(TimerHandle: HANDLE, CurrentState: PBOOLEAN) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwSetTimer(
        TimerHandle: HANDLE,
        DueTime: PLARGE_INTEGER,
        TimerApcRoutine: PTIMER_APC_ROUTINE,
        TimerContext: PVOID,
        ResumeTimer: BOOLEAN,
        Period: LONG,
        PreviousState: PBOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwSetTimerEx(
        TimerHandle: HANDLE,
        TimerSetInformationClass: TIMER_SET_INFORMATION_CLASS,
        TimerSetInformation: PVOID,
        TimerSetInformationLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwQueryVolumeInformationFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FsInformation: PVOID,
        Length: ULONG,
        FsInformationClass: FS_INFORMATION_CLASS,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwDeviceIoControlFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        IoControlCode: ULONG,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwDisplayString(String: PUNICODE_STRING) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwPowerInformation(
        InformationLevel: POWER_INFORMATION_LEVEL,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwAllocateLocallyUniqueId(Luid: PLUID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwTerminateProcess(ProcessHandle: HANDLE, ExitStatus: NTSTATUS) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwOpenProcess(
        ProcessHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        ClientId: PCLIENT_ID,
    ) -> NTSTATUS;
}
pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypeMCE: _WHEA_ERROR_SOURCE_TYPE = 0;
pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypeCMC: _WHEA_ERROR_SOURCE_TYPE = 1;
pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypeCPE: _WHEA_ERROR_SOURCE_TYPE = 2;
pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypeNMI: _WHEA_ERROR_SOURCE_TYPE = 3;
pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypePCIe: _WHEA_ERROR_SOURCE_TYPE = 4;
pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypeGeneric: _WHEA_ERROR_SOURCE_TYPE = 5;
pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypeINIT: _WHEA_ERROR_SOURCE_TYPE = 6;
pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypeBOOT: _WHEA_ERROR_SOURCE_TYPE = 7;
pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypeSCIGeneric: _WHEA_ERROR_SOURCE_TYPE = 8;
pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypeIPFMCA: _WHEA_ERROR_SOURCE_TYPE = 9;
pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypeIPFCMC: _WHEA_ERROR_SOURCE_TYPE = 10;
pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypeIPFCPE: _WHEA_ERROR_SOURCE_TYPE = 11;
pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypeGenericV2: _WHEA_ERROR_SOURCE_TYPE = 12;
pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypeSCIGenericV2: _WHEA_ERROR_SOURCE_TYPE = 13;
pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypeBMC: _WHEA_ERROR_SOURCE_TYPE = 14;
pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypePMEM: _WHEA_ERROR_SOURCE_TYPE = 15;
pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypeDeviceDriver: _WHEA_ERROR_SOURCE_TYPE = 16;
pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypeSea: _WHEA_ERROR_SOURCE_TYPE = 17;
pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypeSei: _WHEA_ERROR_SOURCE_TYPE = 18;
pub const _WHEA_ERROR_SOURCE_TYPE_WheaErrSrcTypeMax: _WHEA_ERROR_SOURCE_TYPE = 19;
pub type _WHEA_ERROR_SOURCE_TYPE = core::ffi::c_int;
pub use self::_WHEA_ERROR_SOURCE_TYPE as WHEA_ERROR_SOURCE_TYPE;
pub type PWHEA_ERROR_SOURCE_TYPE = *mut _WHEA_ERROR_SOURCE_TYPE;
pub const _WHEA_ERROR_SOURCE_STATE_WheaErrSrcStateStopped: _WHEA_ERROR_SOURCE_STATE = 1;
pub const _WHEA_ERROR_SOURCE_STATE_WheaErrSrcStateStarted: _WHEA_ERROR_SOURCE_STATE = 2;
pub const _WHEA_ERROR_SOURCE_STATE_WheaErrSrcStateRemoved: _WHEA_ERROR_SOURCE_STATE = 3;
pub const _WHEA_ERROR_SOURCE_STATE_WheaErrSrcStateRemovePending: _WHEA_ERROR_SOURCE_STATE = 4;
pub type _WHEA_ERROR_SOURCE_STATE = core::ffi::c_int;
pub use self::_WHEA_ERROR_SOURCE_STATE as WHEA_ERROR_SOURCE_STATE;
pub type PWHEA_ERROR_SOURCE_STATE = *mut _WHEA_ERROR_SOURCE_STATE;
pub type _WHEA_ERROR_SOURCE_INITIALIZE_DEVICE_DRIVER =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, ErrorSourceId: ULONG) -> NTSTATUS>;
pub type WHEA_ERROR_SOURCE_INITIALIZE_DEVICE_DRIVER = _WHEA_ERROR_SOURCE_INITIALIZE_DEVICE_DRIVER;
pub type _WHEA_ERROR_SOURCE_UNINITIALIZE_DEVICE_DRIVER =
::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
pub type WHEA_ERROR_SOURCE_UNINITIALIZE_DEVICE_DRIVER =
_WHEA_ERROR_SOURCE_UNINITIALIZE_DEVICE_DRIVER;
pub type _WHEA_ERROR_SOURCE_CORRECT_DEVICE_DRIVER = ::core::option::Option<
    unsafe extern "C" fn(ErrorSourceDesc: PVOID, MaximumSectionLength: PULONG) -> NTSTATUS,
>;
pub type WHEA_ERROR_SOURCE_CORRECT_DEVICE_DRIVER = _WHEA_ERROR_SOURCE_CORRECT_DEVICE_DRIVER;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_ERROR_SOURCE_CONFIGURATION_DD {
    pub Initialize: WHEA_ERROR_SOURCE_INITIALIZE_DEVICE_DRIVER,
    pub Uninitialize: WHEA_ERROR_SOURCE_UNINITIALIZE_DEVICE_DRIVER,
    pub Correct: WHEA_ERROR_SOURCE_CORRECT_DEVICE_DRIVER,
}
pub type WHEA_ERROR_SOURCE_CONFIGURATION_DD = _WHEA_ERROR_SOURCE_CONFIGURATION_DD;
pub type PWHEA_ERROR_SOURCE_CONFIGURATION_DD = *mut _WHEA_ERROR_SOURCE_CONFIGURATION_DD;
pub type WHEA_ERROR_HANDLE = PVOID;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_ERROR_SOURCE_CONFIGURATION_DEVICE_DRIVER_V1 {
    pub Version: ULONG,
    pub SourceGuid: GUID,
    pub LogTag: USHORT,
    pub Reserved: [UCHAR; 6usize],
    pub Initialize: WHEA_ERROR_SOURCE_INITIALIZE_DEVICE_DRIVER,
    pub Uninitialize: WHEA_ERROR_SOURCE_UNINITIALIZE_DEVICE_DRIVER,
}
pub type WHEA_ERROR_SOURCE_CONFIGURATION_DEVICE_DRIVER_V1 =
_WHEA_ERROR_SOURCE_CONFIGURATION_DEVICE_DRIVER_V1;
pub type PWHEA_ERROR_SOURCE_CONFIGURATION_DEVICE_DRIVER_V1 =
*mut _WHEA_ERROR_SOURCE_CONFIGURATION_DEVICE_DRIVER_V1;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_ERROR_SOURCE_CONFIGURATION_DEVICE_DRIVER {
    pub Version: ULONG,
    pub SourceGuid: GUID,
    pub LogTag: USHORT,
    pub Reserved: [UCHAR; 6usize],
    pub Initialize: WHEA_ERROR_SOURCE_INITIALIZE_DEVICE_DRIVER,
    pub Uninitialize: WHEA_ERROR_SOURCE_UNINITIALIZE_DEVICE_DRIVER,
    pub MaxSectionDataLength: ULONG,
    pub MaxSectionsPerReport: ULONG,
    pub CreatorId: GUID,
    pub PartitionId: GUID,
}
pub type WHEA_ERROR_SOURCE_CONFIGURATION_DEVICE_DRIVER =
_WHEA_ERROR_SOURCE_CONFIGURATION_DEVICE_DRIVER;
pub type PWHEA_ERROR_SOURCE_CONFIGURATION_DEVICE_DRIVER =
*mut _WHEA_ERROR_SOURCE_CONFIGURATION_DEVICE_DRIVER;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_DRIVER_BUFFER_SET {
    pub Version: ULONG,
    pub Data: PUCHAR,
    pub DataSize: ULONG,
    pub SectionTypeGuid: LPGUID,
    pub SectionFriendlyName: PUCHAR,
    pub Flags: PUCHAR,
}
pub type WHEA_DRIVER_BUFFER_SET = _WHEA_DRIVER_BUFFER_SET;
pub type PWHEA_DRIVER_BUFFER_SET = *mut _WHEA_DRIVER_BUFFER_SET;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_NOTIFICATION_FLAGS {
    pub __bindgen_anon_1: _WHEA_NOTIFICATION_FLAGS__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_NOTIFICATION_FLAGS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _WHEA_NOTIFICATION_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn PollIntervalRW(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PollIntervalRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PollIntervalRW_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PollIntervalRW_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SwitchToPollingThresholdRW(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SwitchToPollingThresholdRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SwitchToPollingThresholdRW_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_SwitchToPollingThresholdRW_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SwitchToPollingWindowRW(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SwitchToPollingWindowRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SwitchToPollingWindowRW_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_SwitchToPollingWindowRW_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ErrorThresholdRW(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ErrorThresholdRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ErrorThresholdRW_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ErrorThresholdRW_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ErrorThresholdWindowRW(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ErrorThresholdWindowRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ErrorThresholdWindowRW_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ErrorThresholdWindowRW_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 11u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                11u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                11u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PollIntervalRW: USHORT,
        SwitchToPollingThresholdRW: USHORT,
        SwitchToPollingWindowRW: USHORT,
        ErrorThresholdRW: USHORT,
        ErrorThresholdWindowRW: USHORT,
        Reserved: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PollIntervalRW: u16 = unsafe { ::core::mem::transmute(PollIntervalRW) };
            PollIntervalRW as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SwitchToPollingThresholdRW: u16 =
                unsafe { ::core::mem::transmute(SwitchToPollingThresholdRW) };
            SwitchToPollingThresholdRW as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SwitchToPollingWindowRW: u16 =
                unsafe { ::core::mem::transmute(SwitchToPollingWindowRW) };
            SwitchToPollingWindowRW as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ErrorThresholdRW: u16 = unsafe { ::core::mem::transmute(ErrorThresholdRW) };
            ErrorThresholdRW as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ErrorThresholdWindowRW: u16 =
                unsafe { ::core::mem::transmute(ErrorThresholdWindowRW) };
            ErrorThresholdWindowRW as u64
        });
        __bindgen_bitfield_unit.set(5usize, 11u8, {
            let Reserved: u16 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_NOTIFICATION_FLAGS = _WHEA_NOTIFICATION_FLAGS;
pub type PWHEA_NOTIFICATION_FLAGS = *mut _WHEA_NOTIFICATION_FLAGS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _XPF_MC_BANK_FLAGS {
    pub __bindgen_anon_1: _XPF_MC_BANK_FLAGS__bindgen_ty_1,
    pub AsUCHAR: UCHAR,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XPF_MC_BANK_FLAGS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _XPF_MC_BANK_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn ClearOnInitializationRW(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ClearOnInitializationRW(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ClearOnInitializationRW_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ClearOnInitializationRW_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ControlDataRW(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ControlDataRW(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ControlDataRW_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ControlDataRW_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                6u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ClearOnInitializationRW: UCHAR,
        ControlDataRW: UCHAR,
        Reserved: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ClearOnInitializationRW: u8 =
                unsafe { ::core::mem::transmute(ClearOnInitializationRW) };
            ClearOnInitializationRW as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ControlDataRW: u8 = unsafe { ::core::mem::transmute(ControlDataRW) };
            ControlDataRW as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let Reserved: u8 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type XPF_MC_BANK_FLAGS = _XPF_MC_BANK_FLAGS;
pub type PXPF_MC_BANK_FLAGS = *mut _XPF_MC_BANK_FLAGS;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _XPF_MCE_FLAGS {
    pub __bindgen_anon_1: _XPF_MCE_FLAGS__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XPF_MCE_FLAGS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _XPF_MCE_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn MCG_CapabilityRW(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MCG_CapabilityRW(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MCG_CapabilityRW_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MCG_CapabilityRW_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MCG_GlobalControlRW(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MCG_GlobalControlRW(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MCG_GlobalControlRW_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MCG_GlobalControlRW_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MCG_CapabilityRW: ULONG,
        MCG_GlobalControlRW: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let MCG_CapabilityRW: u32 = unsafe { ::core::mem::transmute(MCG_CapabilityRW) };
            MCG_CapabilityRW as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let MCG_GlobalControlRW: u32 = unsafe { ::core::mem::transmute(MCG_GlobalControlRW) };
            MCG_GlobalControlRW as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type XPF_MCE_FLAGS = _XPF_MCE_FLAGS;
pub type PXPF_MCE_FLAGS = *mut _XPF_MCE_FLAGS;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _AER_ROOTPORT_DESCRIPTOR_FLAGS {
    pub __bindgen_anon_1: _AER_ROOTPORT_DESCRIPTOR_FLAGS__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AER_ROOTPORT_DESCRIPTOR_FLAGS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _AER_ROOTPORT_DESCRIPTOR_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn UncorrectableErrorMaskRW(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UncorrectableErrorMaskRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableErrorMaskRW_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableErrorMaskRW_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableErrorSeverityRW(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UncorrectableErrorSeverityRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableErrorSeverityRW_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableErrorSeverityRW_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CorrectableErrorMaskRW(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CorrectableErrorMaskRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CorrectableErrorMaskRW_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_CorrectableErrorMaskRW_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AdvancedCapsAndControlRW(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_AdvancedCapsAndControlRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AdvancedCapsAndControlRW_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_AdvancedCapsAndControlRW_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RootErrorCommandRW(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RootErrorCommandRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RootErrorCommandRW_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_RootErrorCommandRW_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 11u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                11u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                11u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        UncorrectableErrorMaskRW: USHORT,
        UncorrectableErrorSeverityRW: USHORT,
        CorrectableErrorMaskRW: USHORT,
        AdvancedCapsAndControlRW: USHORT,
        RootErrorCommandRW: USHORT,
        Reserved: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let UncorrectableErrorMaskRW: u16 =
                unsafe { ::core::mem::transmute(UncorrectableErrorMaskRW) };
            UncorrectableErrorMaskRW as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let UncorrectableErrorSeverityRW: u16 =
                unsafe { ::core::mem::transmute(UncorrectableErrorSeverityRW) };
            UncorrectableErrorSeverityRW as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CorrectableErrorMaskRW: u16 =
                unsafe { ::core::mem::transmute(CorrectableErrorMaskRW) };
            CorrectableErrorMaskRW as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AdvancedCapsAndControlRW: u16 =
                unsafe { ::core::mem::transmute(AdvancedCapsAndControlRW) };
            AdvancedCapsAndControlRW as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let RootErrorCommandRW: u16 = unsafe { ::core::mem::transmute(RootErrorCommandRW) };
            RootErrorCommandRW as u64
        });
        __bindgen_bitfield_unit.set(5usize, 11u8, {
            let Reserved: u16 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type AER_ROOTPORT_DESCRIPTOR_FLAGS = _AER_ROOTPORT_DESCRIPTOR_FLAGS;
pub type PAER_ROOTPORT_DESCRIPTOR_FLAGS = *mut _AER_ROOTPORT_DESCRIPTOR_FLAGS;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _AER_ENDPOINT_DESCRIPTOR_FLAGS {
    pub __bindgen_anon_1: _AER_ENDPOINT_DESCRIPTOR_FLAGS__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AER_ENDPOINT_DESCRIPTOR_FLAGS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _AER_ENDPOINT_DESCRIPTOR_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn UncorrectableErrorMaskRW(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UncorrectableErrorMaskRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableErrorMaskRW_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableErrorMaskRW_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableErrorSeverityRW(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UncorrectableErrorSeverityRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableErrorSeverityRW_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableErrorSeverityRW_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CorrectableErrorMaskRW(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CorrectableErrorMaskRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CorrectableErrorMaskRW_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_CorrectableErrorMaskRW_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AdvancedCapsAndControlRW(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_AdvancedCapsAndControlRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AdvancedCapsAndControlRW_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_AdvancedCapsAndControlRW_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                12u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        UncorrectableErrorMaskRW: USHORT,
        UncorrectableErrorSeverityRW: USHORT,
        CorrectableErrorMaskRW: USHORT,
        AdvancedCapsAndControlRW: USHORT,
        Reserved: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let UncorrectableErrorMaskRW: u16 =
                unsafe { ::core::mem::transmute(UncorrectableErrorMaskRW) };
            UncorrectableErrorMaskRW as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let UncorrectableErrorSeverityRW: u16 =
                unsafe { ::core::mem::transmute(UncorrectableErrorSeverityRW) };
            UncorrectableErrorSeverityRW as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CorrectableErrorMaskRW: u16 =
                unsafe { ::core::mem::transmute(CorrectableErrorMaskRW) };
            CorrectableErrorMaskRW as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AdvancedCapsAndControlRW: u16 =
                unsafe { ::core::mem::transmute(AdvancedCapsAndControlRW) };
            AdvancedCapsAndControlRW as u64
        });
        __bindgen_bitfield_unit.set(4usize, 12u8, {
            let Reserved: u16 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type AER_ENDPOINT_DESCRIPTOR_FLAGS = _AER_ENDPOINT_DESCRIPTOR_FLAGS;
pub type PAER_ENDPOINT_DESCRIPTOR_FLAGS = *mut _AER_ENDPOINT_DESCRIPTOR_FLAGS;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _AER_BRIDGE_DESCRIPTOR_FLAGS {
    pub __bindgen_anon_1: _AER_BRIDGE_DESCRIPTOR_FLAGS__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AER_BRIDGE_DESCRIPTOR_FLAGS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _AER_BRIDGE_DESCRIPTOR_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn UncorrectableErrorMaskRW(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UncorrectableErrorMaskRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableErrorMaskRW_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableErrorMaskRW_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectableErrorSeverityRW(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UncorrectableErrorSeverityRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableErrorSeverityRW_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableErrorSeverityRW_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CorrectableErrorMaskRW(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CorrectableErrorMaskRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CorrectableErrorMaskRW_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_CorrectableErrorMaskRW_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AdvancedCapsAndControlRW(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_AdvancedCapsAndControlRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AdvancedCapsAndControlRW_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_AdvancedCapsAndControlRW_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SecondaryUncorrectableErrorMaskRW(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SecondaryUncorrectableErrorMaskRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SecondaryUncorrectableErrorMaskRW_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_SecondaryUncorrectableErrorMaskRW_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SecondaryUncorrectableErrorSevRW(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SecondaryUncorrectableErrorSevRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SecondaryUncorrectableErrorSevRW_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_SecondaryUncorrectableErrorSevRW_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SecondaryCapsAndControlRW(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SecondaryCapsAndControlRW(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SecondaryCapsAndControlRW_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_SecondaryCapsAndControlRW_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                9u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                9u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        UncorrectableErrorMaskRW: USHORT,
        UncorrectableErrorSeverityRW: USHORT,
        CorrectableErrorMaskRW: USHORT,
        AdvancedCapsAndControlRW: USHORT,
        SecondaryUncorrectableErrorMaskRW: USHORT,
        SecondaryUncorrectableErrorSevRW: USHORT,
        SecondaryCapsAndControlRW: USHORT,
        Reserved: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let UncorrectableErrorMaskRW: u16 =
                unsafe { ::core::mem::transmute(UncorrectableErrorMaskRW) };
            UncorrectableErrorMaskRW as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let UncorrectableErrorSeverityRW: u16 =
                unsafe { ::core::mem::transmute(UncorrectableErrorSeverityRW) };
            UncorrectableErrorSeverityRW as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CorrectableErrorMaskRW: u16 =
                unsafe { ::core::mem::transmute(CorrectableErrorMaskRW) };
            CorrectableErrorMaskRW as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AdvancedCapsAndControlRW: u16 =
                unsafe { ::core::mem::transmute(AdvancedCapsAndControlRW) };
            AdvancedCapsAndControlRW as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let SecondaryUncorrectableErrorMaskRW: u16 =
                unsafe { ::core::mem::transmute(SecondaryUncorrectableErrorMaskRW) };
            SecondaryUncorrectableErrorMaskRW as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let SecondaryUncorrectableErrorSevRW: u16 =
                unsafe { ::core::mem::transmute(SecondaryUncorrectableErrorSevRW) };
            SecondaryUncorrectableErrorSevRW as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SecondaryCapsAndControlRW: u16 =
                unsafe { ::core::mem::transmute(SecondaryCapsAndControlRW) };
            SecondaryCapsAndControlRW as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let Reserved: u16 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type AER_BRIDGE_DESCRIPTOR_FLAGS = _AER_BRIDGE_DESCRIPTOR_FLAGS;
pub type PAER_BRIDGE_DESCRIPTOR_FLAGS = *mut _AER_BRIDGE_DESCRIPTOR_FLAGS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_NOTIFICATION_DESCRIPTOR {
    pub Type: UCHAR,
    pub Length: UCHAR,
    pub Flags: WHEA_NOTIFICATION_FLAGS,
    pub u: _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1 {
    pub Polled: _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
    pub Interrupt: _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2,
    pub LocalInterrupt: _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3,
    pub Sci: _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4,
    pub Nmi: _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5,
    pub Sea: _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6,
    pub Sei: _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7,
    pub Gsiv: _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    pub PollInterval: ULONG,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
    pub PollInterval: ULONG,
    pub Vector: ULONG,
    pub SwitchToPollingThreshold: ULONG,
    pub SwitchToPollingWindow: ULONG,
    pub ErrorThreshold: ULONG,
    pub ErrorThresholdWindow: ULONG,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 {
    pub PollInterval: ULONG,
    pub Vector: ULONG,
    pub SwitchToPollingThreshold: ULONG,
    pub SwitchToPollingWindow: ULONG,
    pub ErrorThreshold: ULONG,
    pub ErrorThresholdWindow: ULONG,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4 {
    pub PollInterval: ULONG,
    pub Vector: ULONG,
    pub SwitchToPollingThreshold: ULONG,
    pub SwitchToPollingWindow: ULONG,
    pub ErrorThreshold: ULONG,
    pub ErrorThresholdWindow: ULONG,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5 {
    pub PollInterval: ULONG,
    pub Vector: ULONG,
    pub SwitchToPollingThreshold: ULONG,
    pub SwitchToPollingWindow: ULONG,
    pub ErrorThreshold: ULONG,
    pub ErrorThresholdWindow: ULONG,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6 {
    pub PollInterval: ULONG,
    pub Vector: ULONG,
    pub SwitchToPollingThreshold: ULONG,
    pub SwitchToPollingWindow: ULONG,
    pub ErrorThreshold: ULONG,
    pub ErrorThresholdWindow: ULONG,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7 {
    pub PollInterval: ULONG,
    pub Vector: ULONG,
    pub SwitchToPollingThreshold: ULONG,
    pub SwitchToPollingWindow: ULONG,
    pub ErrorThreshold: ULONG,
    pub ErrorThresholdWindow: ULONG,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_NOTIFICATION_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8 {
    pub PollInterval: ULONG,
    pub Vector: ULONG,
    pub SwitchToPollingThreshold: ULONG,
    pub SwitchToPollingWindow: ULONG,
    pub ErrorThreshold: ULONG,
    pub ErrorThresholdWindow: ULONG,
}
pub type WHEA_NOTIFICATION_DESCRIPTOR = _WHEA_NOTIFICATION_DESCRIPTOR;
pub type PWHEA_NOTIFICATION_DESCRIPTOR = *mut _WHEA_NOTIFICATION_DESCRIPTOR;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_XPF_MC_BANK_DESCRIPTOR {
    pub BankNumber: UCHAR,
    pub ClearOnInitialization: BOOLEAN,
    pub StatusDataFormat: UCHAR,
    pub Flags: XPF_MC_BANK_FLAGS,
    pub ControlMsr: ULONG,
    pub StatusMsr: ULONG,
    pub AddressMsr: ULONG,
    pub MiscMsr: ULONG,
    pub ControlData: ULONGLONG,
}
pub type WHEA_XPF_MC_BANK_DESCRIPTOR = _WHEA_XPF_MC_BANK_DESCRIPTOR;
pub type PWHEA_XPF_MC_BANK_DESCRIPTOR = *mut _WHEA_XPF_MC_BANK_DESCRIPTOR;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_XPF_MCE_DESCRIPTOR {
    pub Type: USHORT,
    pub Enabled: UCHAR,
    pub NumberOfBanks: UCHAR,
    pub Flags: XPF_MCE_FLAGS,
    pub MCG_Capability: ULONGLONG,
    pub MCG_GlobalControl: ULONGLONG,
    pub Banks: [WHEA_XPF_MC_BANK_DESCRIPTOR; 32usize],
}
pub type WHEA_XPF_MCE_DESCRIPTOR = _WHEA_XPF_MCE_DESCRIPTOR;
pub type PWHEA_XPF_MCE_DESCRIPTOR = *mut _WHEA_XPF_MCE_DESCRIPTOR;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_XPF_CMC_DESCRIPTOR {
    pub Type: USHORT,
    pub Enabled: BOOLEAN,
    pub NumberOfBanks: UCHAR,
    pub Reserved: ULONG,
    pub Notify: WHEA_NOTIFICATION_DESCRIPTOR,
    pub Banks: [WHEA_XPF_MC_BANK_DESCRIPTOR; 32usize],
}
pub type WHEA_XPF_CMC_DESCRIPTOR = _WHEA_XPF_CMC_DESCRIPTOR;
pub type PWHEA_XPF_CMC_DESCRIPTOR = *mut _WHEA_XPF_CMC_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_PCI_SLOT_NUMBER {
    pub u: _WHEA_PCI_SLOT_NUMBER__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_PCI_SLOT_NUMBER__bindgen_ty_1 {
    pub bits: _WHEA_PCI_SLOT_NUMBER__bindgen_ty_1__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_PCI_SLOT_NUMBER__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _WHEA_PCI_SLOT_NUMBER__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn DeviceNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_DeviceNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DeviceNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DeviceNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FunctionNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_FunctionNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FunctionNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FunctionNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DeviceNumber: ULONG,
        FunctionNumber: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let DeviceNumber: u32 = unsafe { ::core::mem::transmute(DeviceNumber) };
            DeviceNumber as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let FunctionNumber: u32 = unsafe { ::core::mem::transmute(FunctionNumber) };
            FunctionNumber as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_PCI_SLOT_NUMBER = _WHEA_PCI_SLOT_NUMBER;
pub type PWHEA_PCI_SLOT_NUMBER = *mut _WHEA_PCI_SLOT_NUMBER;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_XPF_NMI_DESCRIPTOR {
    pub Type: USHORT,
    pub Enabled: BOOLEAN,
}
pub type WHEA_XPF_NMI_DESCRIPTOR = _WHEA_XPF_NMI_DESCRIPTOR;
pub type PWHEA_XPF_NMI_DESCRIPTOR = *mut _WHEA_XPF_NMI_DESCRIPTOR;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_AER_ROOTPORT_DESCRIPTOR {
    pub Type: USHORT,
    pub Enabled: BOOLEAN,
    pub Reserved: UCHAR,
    pub BusNumber: ULONG,
    pub Slot: WHEA_PCI_SLOT_NUMBER,
    pub DeviceControl: USHORT,
    pub Flags: AER_ROOTPORT_DESCRIPTOR_FLAGS,
    pub UncorrectableErrorMask: ULONG,
    pub UncorrectableErrorSeverity: ULONG,
    pub CorrectableErrorMask: ULONG,
    pub AdvancedCapsAndControl: ULONG,
    pub RootErrorCommand: ULONG,
}
pub type WHEA_AER_ROOTPORT_DESCRIPTOR = _WHEA_AER_ROOTPORT_DESCRIPTOR;
pub type PWHEA_AER_ROOTPORT_DESCRIPTOR = *mut _WHEA_AER_ROOTPORT_DESCRIPTOR;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_AER_ENDPOINT_DESCRIPTOR {
    pub Type: USHORT,
    pub Enabled: BOOLEAN,
    pub Reserved: UCHAR,
    pub BusNumber: ULONG,
    pub Slot: WHEA_PCI_SLOT_NUMBER,
    pub DeviceControl: USHORT,
    pub Flags: AER_ENDPOINT_DESCRIPTOR_FLAGS,
    pub UncorrectableErrorMask: ULONG,
    pub UncorrectableErrorSeverity: ULONG,
    pub CorrectableErrorMask: ULONG,
    pub AdvancedCapsAndControl: ULONG,
}
pub type WHEA_AER_ENDPOINT_DESCRIPTOR = _WHEA_AER_ENDPOINT_DESCRIPTOR;
pub type PWHEA_AER_ENDPOINT_DESCRIPTOR = *mut _WHEA_AER_ENDPOINT_DESCRIPTOR;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_AER_BRIDGE_DESCRIPTOR {
    pub Type: USHORT,
    pub Enabled: BOOLEAN,
    pub Reserved: UCHAR,
    pub BusNumber: ULONG,
    pub Slot: WHEA_PCI_SLOT_NUMBER,
    pub DeviceControl: USHORT,
    pub Flags: AER_BRIDGE_DESCRIPTOR_FLAGS,
    pub UncorrectableErrorMask: ULONG,
    pub UncorrectableErrorSeverity: ULONG,
    pub CorrectableErrorMask: ULONG,
    pub AdvancedCapsAndControl: ULONG,
    pub SecondaryUncorrectableErrorMask: ULONG,
    pub SecondaryUncorrectableErrorSev: ULONG,
    pub SecondaryCapsAndControl: ULONG,
}
pub type WHEA_AER_BRIDGE_DESCRIPTOR = _WHEA_AER_BRIDGE_DESCRIPTOR;
pub type PWHEA_AER_BRIDGE_DESCRIPTOR = *mut _WHEA_AER_BRIDGE_DESCRIPTOR;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_GENERIC_ERROR_DESCRIPTOR {
    pub Type: USHORT,
    pub Reserved: UCHAR,
    pub Enabled: UCHAR,
    pub ErrStatusBlockLength: ULONG,
    pub RelatedErrorSourceId: ULONG,
    pub ErrStatusAddressSpaceID: UCHAR,
    pub ErrStatusAddressBitWidth: UCHAR,
    pub ErrStatusAddressBitOffset: UCHAR,
    pub ErrStatusAddressAccessSize: UCHAR,
    pub ErrStatusAddress: LARGE_INTEGER,
    pub Notify: WHEA_NOTIFICATION_DESCRIPTOR,
}
pub type WHEA_GENERIC_ERROR_DESCRIPTOR = _WHEA_GENERIC_ERROR_DESCRIPTOR;
pub type PWHEA_GENERIC_ERROR_DESCRIPTOR = *mut _WHEA_GENERIC_ERROR_DESCRIPTOR;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_GENERIC_ERROR_DESCRIPTOR_V2 {
    pub Type: USHORT,
    pub Reserved: UCHAR,
    pub Enabled: UCHAR,
    pub ErrStatusBlockLength: ULONG,
    pub RelatedErrorSourceId: ULONG,
    pub ErrStatusAddressSpaceID: UCHAR,
    pub ErrStatusAddressBitWidth: UCHAR,
    pub ErrStatusAddressBitOffset: UCHAR,
    pub ErrStatusAddressAccessSize: UCHAR,
    pub ErrStatusAddress: LARGE_INTEGER,
    pub Notify: WHEA_NOTIFICATION_DESCRIPTOR,
    pub ReadAckAddressSpaceID: UCHAR,
    pub ReadAckAddressBitWidth: UCHAR,
    pub ReadAckAddressBitOffset: UCHAR,
    pub ReadAckAddressAccessSize: UCHAR,
    pub ReadAckAddress: LARGE_INTEGER,
    pub ReadAckPreserveMask: ULONGLONG,
    pub ReadAckWriteMask: ULONGLONG,
}
pub type WHEA_GENERIC_ERROR_DESCRIPTOR_V2 = _WHEA_GENERIC_ERROR_DESCRIPTOR_V2;
pub type PWHEA_GENERIC_ERROR_DESCRIPTOR_V2 = *mut _WHEA_GENERIC_ERROR_DESCRIPTOR_V2;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_DEVICE_DRIVER_DESCRIPTOR {
    pub Type: USHORT,
    pub Enabled: BOOLEAN,
    pub Reserved: UCHAR,
    pub SourceGuid: GUID,
    pub LogTag: USHORT,
    pub Reserved2: USHORT,
    pub PacketLength: ULONG,
    pub PacketCount: ULONG,
    pub PacketBuffer: PUCHAR,
    pub Config: WHEA_ERROR_SOURCE_CONFIGURATION_DD,
    pub CreatorId: GUID,
    pub PartitionId: GUID,
    pub MaxSectionDataLength: ULONG,
    pub MaxSectionsPerRecord: ULONG,
    pub PacketStateBuffer: PUCHAR,
    pub OpenHandles: LONG,
}
pub type WHEA_DEVICE_DRIVER_DESCRIPTOR = _WHEA_DEVICE_DRIVER_DESCRIPTOR;
pub type PWHEA_DEVICE_DRIVER_DESCRIPTOR = *mut _WHEA_DEVICE_DRIVER_DESCRIPTOR;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_IPF_MCA_DESCRIPTOR {
    pub Type: USHORT,
    pub Enabled: UCHAR,
    pub Reserved: UCHAR,
}
pub type WHEA_IPF_MCA_DESCRIPTOR = _WHEA_IPF_MCA_DESCRIPTOR;
pub type PWHEA_IPF_MCA_DESCRIPTOR = *mut _WHEA_IPF_MCA_DESCRIPTOR;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_IPF_CMC_DESCRIPTOR {
    pub Type: USHORT,
    pub Enabled: UCHAR,
    pub Reserved: UCHAR,
}
pub type WHEA_IPF_CMC_DESCRIPTOR = _WHEA_IPF_CMC_DESCRIPTOR;
pub type PWHEA_IPF_CMC_DESCRIPTOR = *mut _WHEA_IPF_CMC_DESCRIPTOR;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_IPF_CPE_DESCRIPTOR {
    pub Type: USHORT,
    pub Enabled: UCHAR,
    pub Reserved: UCHAR,
}
pub type WHEA_IPF_CPE_DESCRIPTOR = _WHEA_IPF_CPE_DESCRIPTOR;
pub type PWHEA_IPF_CPE_DESCRIPTOR = *mut _WHEA_IPF_CPE_DESCRIPTOR;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_ERROR_SOURCE_DESCRIPTOR {
    pub Length: ULONG,
    pub Version: ULONG,
    pub Type: WHEA_ERROR_SOURCE_TYPE,
    pub State: WHEA_ERROR_SOURCE_STATE,
    pub MaxRawDataLength: ULONG,
    pub NumRecordsToPreallocate: ULONG,
    pub MaxSectionsPerRecord: ULONG,
    pub ErrorSourceId: ULONG,
    pub PlatformErrorSourceId: ULONG,
    pub Flags: ULONG,
    pub Info: _WHEA_ERROR_SOURCE_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_ERROR_SOURCE_DESCRIPTOR__bindgen_ty_1 {
    pub XpfMceDescriptor: WHEA_XPF_MCE_DESCRIPTOR,
    pub XpfCmcDescriptor: WHEA_XPF_CMC_DESCRIPTOR,
    pub XpfNmiDescriptor: WHEA_XPF_NMI_DESCRIPTOR,
    pub IpfMcaDescriptor: WHEA_IPF_MCA_DESCRIPTOR,
    pub IpfCmcDescriptor: WHEA_IPF_CMC_DESCRIPTOR,
    pub IpfCpeDescriptor: WHEA_IPF_CPE_DESCRIPTOR,
    pub AerRootportDescriptor: WHEA_AER_ROOTPORT_DESCRIPTOR,
    pub AerEndpointDescriptor: WHEA_AER_ENDPOINT_DESCRIPTOR,
    pub AerBridgeDescriptor: WHEA_AER_BRIDGE_DESCRIPTOR,
    pub GenErrDescriptor: WHEA_GENERIC_ERROR_DESCRIPTOR,
    pub GenErrDescriptorV2: WHEA_GENERIC_ERROR_DESCRIPTOR_V2,
    pub DeviceDriverDescriptor: WHEA_DEVICE_DRIVER_DESCRIPTOR,
}
pub type WHEA_ERROR_SOURCE_DESCRIPTOR = _WHEA_ERROR_SOURCE_DESCRIPTOR;
pub const _IPMI_OS_SEL_RECORD_TYPE_IpmiOsSelRecordTypeWhea: _IPMI_OS_SEL_RECORD_TYPE = 0;
pub const _IPMI_OS_SEL_RECORD_TYPE_IpmiOsSelRecordTypeOther: _IPMI_OS_SEL_RECORD_TYPE = 1;
pub const _IPMI_OS_SEL_RECORD_TYPE_IpmiOsSelRecordTypeWheaErrorXpfMca: _IPMI_OS_SEL_RECORD_TYPE = 2;
pub const _IPMI_OS_SEL_RECORD_TYPE_IpmiOsSelRecordTypeWheaErrorPci: _IPMI_OS_SEL_RECORD_TYPE = 3;
pub const _IPMI_OS_SEL_RECORD_TYPE_IpmiOsSelRecordTypeWheaErrorNmi: _IPMI_OS_SEL_RECORD_TYPE = 4;
pub const _IPMI_OS_SEL_RECORD_TYPE_IpmiOsSelRecordTypeWheaErrorOther: _IPMI_OS_SEL_RECORD_TYPE = 5;
pub const _IPMI_OS_SEL_RECORD_TYPE_IpmiOsSelRecordTypeRaw: _IPMI_OS_SEL_RECORD_TYPE = 6;
pub const _IPMI_OS_SEL_RECORD_TYPE_IpmiOsSelRecordTypeDriver: _IPMI_OS_SEL_RECORD_TYPE = 7;
pub const _IPMI_OS_SEL_RECORD_TYPE_IpmiOsSelRecordTypeBugcheckRecovery: _IPMI_OS_SEL_RECORD_TYPE =
    8;
pub const _IPMI_OS_SEL_RECORD_TYPE_IpmiOsSelRecordTypeBugcheckData: _IPMI_OS_SEL_RECORD_TYPE = 9;
pub const _IPMI_OS_SEL_RECORD_TYPE_IpmiOsSelRecordTypeMax: _IPMI_OS_SEL_RECORD_TYPE = 10;
pub type _IPMI_OS_SEL_RECORD_TYPE = core::ffi::c_int;
pub use self::_IPMI_OS_SEL_RECORD_TYPE as IPMI_OS_SEL_RECORD_TYPE;
pub type PIPMI_OS_SEL_RECORD_TYPE = *mut _IPMI_OS_SEL_RECORD_TYPE;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _IPMI_OS_SEL_RECORD {
    pub Signature: ULONG,
    pub Version: ULONG,
    pub Length: ULONG,
    pub RecordType: IPMI_OS_SEL_RECORD_TYPE,
    pub DataLength: ULONG,
    pub Data: [UCHAR; 1usize],
}
pub type IPMI_OS_SEL_RECORD = _IPMI_OS_SEL_RECORD;
pub type PIPMI_OS_SEL_RECORD = *mut _IPMI_OS_SEL_RECORD;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_REVISION {
    pub __bindgen_anon_1: _WHEA_REVISION__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_REVISION__bindgen_ty_1 {
    pub MinorRevision: UCHAR,
    pub MajorRevision: UCHAR,
}
pub type WHEA_REVISION = _WHEA_REVISION;
pub type PWHEA_REVISION = *mut _WHEA_REVISION;
pub const _WHEA_ERROR_SEVERITY_WheaErrSevRecoverable: _WHEA_ERROR_SEVERITY = 0;
pub const _WHEA_ERROR_SEVERITY_WheaErrSevFatal: _WHEA_ERROR_SEVERITY = 1;
pub const _WHEA_ERROR_SEVERITY_WheaErrSevCorrected: _WHEA_ERROR_SEVERITY = 2;
pub const _WHEA_ERROR_SEVERITY_WheaErrSevInformational: _WHEA_ERROR_SEVERITY = 3;
pub type _WHEA_ERROR_SEVERITY = core::ffi::c_int;
pub use self::_WHEA_ERROR_SEVERITY as WHEA_ERROR_SEVERITY;
pub type PWHEA_ERROR_SEVERITY = *mut _WHEA_ERROR_SEVERITY;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_TIMESTAMP {
    pub __bindgen_anon_1: _WHEA_TIMESTAMP__bindgen_ty_1,
    pub AsLARGE_INTEGER: LARGE_INTEGER,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_TIMESTAMP__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _WHEA_TIMESTAMP__bindgen_ty_1 {
    #[inline]
    pub fn Seconds(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Seconds(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Seconds_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Seconds_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Minutes(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Minutes(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Minutes_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Minutes_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Hours(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Hours(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Hours_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Hours_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Precise(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Precise(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Precise_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Precise_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                7u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Day(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Day(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Day_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Day_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Month(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(40usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Month(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Month_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                40usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Month_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Year(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(48usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Year(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(48usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Year_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                48usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Year_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                48usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Century(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Century(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Century_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                56usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Century_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                56usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Seconds: ULONGLONG,
        Minutes: ULONGLONG,
        Hours: ULONGLONG,
        Precise: ULONGLONG,
        Reserved: ULONGLONG,
        Day: ULONGLONG,
        Month: ULONGLONG,
        Year: ULONGLONG,
        Century: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let Seconds: u64 = unsafe { ::core::mem::transmute(Seconds) };
            Seconds as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let Minutes: u64 = unsafe { ::core::mem::transmute(Minutes) };
            Minutes as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let Hours: u64 = unsafe { ::core::mem::transmute(Hours) };
            Hours as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let Precise: u64 = unsafe { ::core::mem::transmute(Precise) };
            Precise as u64
        });
        __bindgen_bitfield_unit.set(25usize, 7u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(32usize, 8u8, {
            let Day: u64 = unsafe { ::core::mem::transmute(Day) };
            Day as u64
        });
        __bindgen_bitfield_unit.set(40usize, 8u8, {
            let Month: u64 = unsafe { ::core::mem::transmute(Month) };
            Month as u64
        });
        __bindgen_bitfield_unit.set(48usize, 8u8, {
            let Year: u64 = unsafe { ::core::mem::transmute(Year) };
            Year as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let Century: u64 = unsafe { ::core::mem::transmute(Century) };
            Century as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_TIMESTAMP = _WHEA_TIMESTAMP;
pub type PWHEA_TIMESTAMP = *mut _WHEA_TIMESTAMP;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_PERSISTENCE_INFO {
    pub __bindgen_anon_1: _WHEA_PERSISTENCE_INFO__bindgen_ty_1,
    pub AsULONGLONG: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_PERSISTENCE_INFO__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _WHEA_PERSISTENCE_INFO__bindgen_ty_1 {
    #[inline]
    pub fn Signature(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_Signature(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Signature_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Signature_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Length(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 24u8) as u64) }
    }
    #[inline]
    pub fn set_Length(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Length_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                24u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Length_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Identifier(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(40usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_Identifier(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Identifier_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                40usize,
                16u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Identifier_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Attributes(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(56usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_Attributes(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(56usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Attributes_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                56usize,
                2u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Attributes_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                56usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DoNotLog(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(58usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_DoNotLog(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(58usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DoNotLog_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                58usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_DoNotLog_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                58usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(59usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(59usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                59usize,
                5u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                59usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Signature: ULONGLONG,
        Length: ULONGLONG,
        Identifier: ULONGLONG,
        Attributes: ULONGLONG,
        DoNotLog: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let Signature: u64 = unsafe { ::core::mem::transmute(Signature) };
            Signature as u64
        });
        __bindgen_bitfield_unit.set(16usize, 24u8, {
            let Length: u64 = unsafe { ::core::mem::transmute(Length) };
            Length as u64
        });
        __bindgen_bitfield_unit.set(40usize, 16u8, {
            let Identifier: u64 = unsafe { ::core::mem::transmute(Identifier) };
            Identifier as u64
        });
        __bindgen_bitfield_unit.set(56usize, 2u8, {
            let Attributes: u64 = unsafe { ::core::mem::transmute(Attributes) };
            Attributes as u64
        });
        __bindgen_bitfield_unit.set(58usize, 1u8, {
            let DoNotLog: u64 = unsafe { ::core::mem::transmute(DoNotLog) };
            DoNotLog as u64
        });
        __bindgen_bitfield_unit.set(59usize, 5u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_PERSISTENCE_INFO = _WHEA_PERSISTENCE_INFO;
pub type PWHEA_PERSISTENCE_INFO = *mut _WHEA_PERSISTENCE_INFO;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_ERROR_STATUS {
    pub ErrorStatus: ULONGLONG,
    pub __bindgen_anon_1: _WHEA_ERROR_STATUS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_ERROR_STATUS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _WHEA_ERROR_STATUS__bindgen_ty_1 {
    #[inline]
    pub fn Reserved1(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ErrorType(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_ErrorType(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ErrorType_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ErrorType_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Address(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Address(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Address_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Address_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Control(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Control(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Control_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Control_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Data(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Data(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Data_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Data_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Responder(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Responder(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Responder_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Responder_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Requester(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Requester(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Requester_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Requester_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FirstError(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_FirstError(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FirstError_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_FirstError_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Overflow(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Overflow(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Overflow_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Overflow_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 41u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 41u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved2_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                41u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved2_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                41u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Reserved1: ULONGLONG,
        ErrorType: ULONGLONG,
        Address: ULONGLONG,
        Control: ULONGLONG,
        Data: ULONGLONG,
        Responder: ULONGLONG,
        Requester: ULONGLONG,
        FirstError: ULONGLONG,
        Overflow: ULONGLONG,
        Reserved2: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let Reserved1: u64 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let ErrorType: u64 = unsafe { ::core::mem::transmute(ErrorType) };
            ErrorType as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let Address: u64 = unsafe { ::core::mem::transmute(Address) };
            Address as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let Control: u64 = unsafe { ::core::mem::transmute(Control) };
            Control as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let Data: u64 = unsafe { ::core::mem::transmute(Data) };
            Data as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let Responder: u64 = unsafe { ::core::mem::transmute(Responder) };
            Responder as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let Requester: u64 = unsafe { ::core::mem::transmute(Requester) };
            Requester as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let FirstError: u64 = unsafe { ::core::mem::transmute(FirstError) };
            FirstError as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let Overflow: u64 = unsafe { ::core::mem::transmute(Overflow) };
            Overflow as u64
        });
        __bindgen_bitfield_unit.set(23usize, 41u8, {
            let Reserved2: u64 = unsafe { ::core::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_ERROR_STATUS = _WHEA_ERROR_STATUS;
pub type PWHEA_ERROR_STATUS = *mut _WHEA_ERROR_STATUS;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_ERROR_RECORD_HEADER_VALIDBITS {
    pub __bindgen_anon_1: _WHEA_ERROR_RECORD_HEADER_VALIDBITS__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_ERROR_RECORD_HEADER_VALIDBITS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _WHEA_ERROR_RECORD_HEADER_VALIDBITS__bindgen_ty_1 {
    #[inline]
    pub fn PlatformId(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PlatformId(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PlatformId_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PlatformId_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Timestamp(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Timestamp(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Timestamp_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Timestamp_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PartitionId(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PartitionId(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PartitionId_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PartitionId_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                29u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                29u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PlatformId: ULONG,
        Timestamp: ULONG,
        PartitionId: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PlatformId: u32 = unsafe { ::core::mem::transmute(PlatformId) };
            PlatformId as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Timestamp: u32 = unsafe { ::core::mem::transmute(Timestamp) };
            Timestamp as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PartitionId: u32 = unsafe { ::core::mem::transmute(PartitionId) };
            PartitionId as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_ERROR_RECORD_HEADER_VALIDBITS = _WHEA_ERROR_RECORD_HEADER_VALIDBITS;
pub type PWHEA_ERROR_RECORD_HEADER_VALIDBITS = *mut _WHEA_ERROR_RECORD_HEADER_VALIDBITS;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_ERROR_RECORD_HEADER_FLAGS {
    pub __bindgen_anon_1: _WHEA_ERROR_RECORD_HEADER_FLAGS__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_ERROR_RECORD_HEADER_FLAGS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _WHEA_ERROR_RECORD_HEADER_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn Recovered(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Recovered(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Recovered_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Recovered_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PreviousError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PreviousError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PreviousError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PreviousError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Simulated(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Simulated(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Simulated_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Simulated_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DeviceDriver(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeviceDriver(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DeviceDriver_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DeviceDriver_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CriticalEvent(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CriticalEvent(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CriticalEvent_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CriticalEvent_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PersistPfn(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PersistPfn(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PersistPfn_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PersistPfn_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SectionsTruncated(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SectionsTruncated(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SectionsTruncated_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SectionsTruncated_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RecoveryInProgress(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RecoveryInProgress(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RecoveryInProgress_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RecoveryInProgress_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Throttle(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Throttle(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Throttle_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Throttle_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                23u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                23u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Recovered: ULONG,
        PreviousError: ULONG,
        Simulated: ULONG,
        DeviceDriver: ULONG,
        CriticalEvent: ULONG,
        PersistPfn: ULONG,
        SectionsTruncated: ULONG,
        RecoveryInProgress: ULONG,
        Throttle: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Recovered: u32 = unsafe { ::core::mem::transmute(Recovered) };
            Recovered as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PreviousError: u32 = unsafe { ::core::mem::transmute(PreviousError) };
            PreviousError as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Simulated: u32 = unsafe { ::core::mem::transmute(Simulated) };
            Simulated as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DeviceDriver: u32 = unsafe { ::core::mem::transmute(DeviceDriver) };
            DeviceDriver as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CriticalEvent: u32 = unsafe { ::core::mem::transmute(CriticalEvent) };
            CriticalEvent as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PersistPfn: u32 = unsafe { ::core::mem::transmute(PersistPfn) };
            PersistPfn as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SectionsTruncated: u32 = unsafe { ::core::mem::transmute(SectionsTruncated) };
            SectionsTruncated as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let RecoveryInProgress: u32 = unsafe { ::core::mem::transmute(RecoveryInProgress) };
            RecoveryInProgress as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Throttle: u32 = unsafe { ::core::mem::transmute(Throttle) };
            Throttle as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_ERROR_RECORD_HEADER_FLAGS = _WHEA_ERROR_RECORD_HEADER_FLAGS;
pub type PWHEA_ERROR_RECORD_HEADER_FLAGS = *mut _WHEA_ERROR_RECORD_HEADER_FLAGS;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_ERROR_RECORD_HEADER {
    pub Signature: ULONG,
    pub Revision: WHEA_REVISION,
    pub SignatureEnd: ULONG,
    pub SectionCount: USHORT,
    pub Severity: WHEA_ERROR_SEVERITY,
    pub ValidBits: WHEA_ERROR_RECORD_HEADER_VALIDBITS,
    pub Length: ULONG,
    pub Timestamp: WHEA_TIMESTAMP,
    pub PlatformId: GUID,
    pub PartitionId: GUID,
    pub CreatorId: GUID,
    pub NotifyType: GUID,
    pub RecordId: ULONGLONG,
    pub Flags: WHEA_ERROR_RECORD_HEADER_FLAGS,
    pub PersistenceInfo: WHEA_PERSISTENCE_INFO,
    pub __bindgen_anon_1: _WHEA_ERROR_RECORD_HEADER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_ERROR_RECORD_HEADER__bindgen_ty_1 {
    pub __bindgen_anon_1: _WHEA_ERROR_RECORD_HEADER__bindgen_ty_1__bindgen_ty_1,
    pub Reserved: [UCHAR; 12usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_ERROR_RECORD_HEADER__bindgen_ty_1__bindgen_ty_1 {
    pub OsBuildNumber: ULONG,
    pub Reserved2: [UCHAR; 8usize],
}
pub type WHEA_ERROR_RECORD_HEADER = _WHEA_ERROR_RECORD_HEADER;
pub type PWHEA_ERROR_RECORD_HEADER = *mut _WHEA_ERROR_RECORD_HEADER;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS {
    pub __bindgen_anon_1: _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn Primary(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Primary(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Primary_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Primary_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ContainmentWarning(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ContainmentWarning(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ContainmentWarning_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ContainmentWarning_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reset(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Reset(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reset_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reset_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ThresholdExceeded(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ThresholdExceeded(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ThresholdExceeded_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ThresholdExceeded_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ResourceNotAvailable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ResourceNotAvailable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ResourceNotAvailable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ResourceNotAvailable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LatentError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LatentError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LatentError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_LatentError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Propagated(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Propagated(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Propagated_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Propagated_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FruTextByPlugin(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FruTextByPlugin(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FruTextByPlugin_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FruTextByPlugin_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Primary: ULONG,
        ContainmentWarning: ULONG,
        Reset: ULONG,
        ThresholdExceeded: ULONG,
        ResourceNotAvailable: ULONG,
        LatentError: ULONG,
        Propagated: ULONG,
        FruTextByPlugin: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Primary: u32 = unsafe { ::core::mem::transmute(Primary) };
            Primary as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ContainmentWarning: u32 = unsafe { ::core::mem::transmute(ContainmentWarning) };
            ContainmentWarning as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Reset: u32 = unsafe { ::core::mem::transmute(Reset) };
            Reset as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ThresholdExceeded: u32 = unsafe { ::core::mem::transmute(ThresholdExceeded) };
            ThresholdExceeded as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ResourceNotAvailable: u32 = unsafe { ::core::mem::transmute(ResourceNotAvailable) };
            ResourceNotAvailable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let LatentError: u32 = unsafe { ::core::mem::transmute(LatentError) };
            LatentError as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Propagated: u32 = unsafe { ::core::mem::transmute(Propagated) };
            Propagated as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let FruTextByPlugin: u32 = unsafe { ::core::mem::transmute(FruTextByPlugin) };
            FruTextByPlugin as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS = _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS;
pub type PWHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS =
*mut _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS {
    pub __bindgen_anon_1: _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS__bindgen_ty_1,
    pub AsUCHAR: UCHAR,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS__bindgen_ty_1 {
    #[inline]
    pub fn FRUId(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FRUId(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FRUId_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_FRUId_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FRUText(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FRUText(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FRUText_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_FRUText_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                6u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FRUId: UCHAR,
        FRUText: UCHAR,
        Reserved: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let FRUId: u8 = unsafe { ::core::mem::transmute(FRUId) };
            FRUId as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let FRUText: u8 = unsafe { ::core::mem::transmute(FRUText) };
            FRUText as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let Reserved: u8 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS =
_WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS;
pub type PWHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS =
*mut _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR {
    pub SectionOffset: ULONG,
    pub SectionLength: ULONG,
    pub Revision: WHEA_REVISION,
    pub ValidBits: WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS,
    pub Reserved: UCHAR,
    pub Flags: WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS,
    pub SectionType: GUID,
    pub FRUId: GUID,
    pub SectionSeverity: WHEA_ERROR_SEVERITY,
    pub FRUText: [CCHAR; 20usize],
}
pub type WHEA_ERROR_RECORD_SECTION_DESCRIPTOR = _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR;
pub type PWHEA_ERROR_RECORD_SECTION_DESCRIPTOR = *mut _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_ERROR_RECORD {
    pub Header: WHEA_ERROR_RECORD_HEADER,
    pub SectionDescriptor: [WHEA_ERROR_RECORD_SECTION_DESCRIPTOR; 1usize],
}
pub type WHEA_ERROR_RECORD = _WHEA_ERROR_RECORD;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_PROCESSOR_FAMILY_INFO {
    pub __bindgen_anon_1: _WHEA_PROCESSOR_FAMILY_INFO__bindgen_ty_1,
    pub AsULONGLONG: ULONGLONG,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_PROCESSOR_FAMILY_INFO__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub NativeModelId: ULONG,
}
impl _WHEA_PROCESSOR_FAMILY_INFO__bindgen_ty_1 {
    #[inline]
    pub fn Stepping(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_Stepping(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Stepping_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Stepping_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Model(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_Model(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Model_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Model_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Family(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_Family(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Family_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Family_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ProcessorType(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessorType(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ProcessorType_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ProcessorType_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ExtendedModel(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ExtendedModel(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ExtendedModel_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ExtendedModel_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ExtendedFamily(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ExtendedFamily(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ExtendedFamily_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ExtendedFamily_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Stepping: ULONG,
        Model: ULONG,
        Family: ULONG,
        ProcessorType: ULONG,
        Reserved1: ULONG,
        ExtendedModel: ULONG,
        ExtendedFamily: ULONG,
        Reserved2: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let Stepping: u32 = unsafe { ::core::mem::transmute(Stepping) };
            Stepping as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let Model: u32 = unsafe { ::core::mem::transmute(Model) };
            Model as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let Family: u32 = unsafe { ::core::mem::transmute(Family) };
            Family as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let ProcessorType: u32 = unsafe { ::core::mem::transmute(ProcessorType) };
            ProcessorType as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let ExtendedModel: u32 = unsafe { ::core::mem::transmute(ExtendedModel) };
            ExtendedModel as u64
        });
        __bindgen_bitfield_unit.set(20usize, 8u8, {
            let ExtendedFamily: u32 = unsafe { ::core::mem::transmute(ExtendedFamily) };
            ExtendedFamily as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let Reserved2: u32 = unsafe { ::core::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_PROCESSOR_FAMILY_INFO = _WHEA_PROCESSOR_FAMILY_INFO;
pub type PWHEA_PROCESSOR_FAMILY_INFO = *mut _WHEA_PROCESSOR_FAMILY_INFO;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS {
    pub __bindgen_anon_1: _WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS__bindgen_ty_1,
    pub ValidBits: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    #[inline]
    pub fn ProcessorType(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ProcessorType(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ProcessorType_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ProcessorType_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn InstructionSet(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_InstructionSet(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InstructionSet_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_InstructionSet_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ErrorType(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ErrorType(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ErrorType_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ErrorType_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Operation(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Operation(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Operation_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Operation_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Flags(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Flags(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Flags_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Flags_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Level(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Level(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Level_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Level_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CPUVersion(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_CPUVersion(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CPUVersion_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_CPUVersion_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CPUBrandString(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_CPUBrandString(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CPUBrandString_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_CPUBrandString_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ProcessorId(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ProcessorId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ProcessorId_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ProcessorId_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TargetAddress(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_TargetAddress(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TargetAddress_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_TargetAddress_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RequesterId(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RequesterId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RequesterId_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_RequesterId_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ResponderId(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ResponderId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ResponderId_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ResponderId_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn InstructionPointer(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_InstructionPointer(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InstructionPointer_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_InstructionPointer_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NativeModelId(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_NativeModelId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NativeModelId_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_NativeModelId_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 50u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 50u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                50u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                50u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ProcessorType: ULONGLONG,
        InstructionSet: ULONGLONG,
        ErrorType: ULONGLONG,
        Operation: ULONGLONG,
        Flags: ULONGLONG,
        Level: ULONGLONG,
        CPUVersion: ULONGLONG,
        CPUBrandString: ULONGLONG,
        ProcessorId: ULONGLONG,
        TargetAddress: ULONGLONG,
        RequesterId: ULONGLONG,
        ResponderId: ULONGLONG,
        InstructionPointer: ULONGLONG,
        NativeModelId: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ProcessorType: u64 = unsafe { ::core::mem::transmute(ProcessorType) };
            ProcessorType as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let InstructionSet: u64 = unsafe { ::core::mem::transmute(InstructionSet) };
            InstructionSet as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ErrorType: u64 = unsafe { ::core::mem::transmute(ErrorType) };
            ErrorType as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Operation: u64 = unsafe { ::core::mem::transmute(Operation) };
            Operation as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Flags: u64 = unsafe { ::core::mem::transmute(Flags) };
            Flags as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Level: u64 = unsafe { ::core::mem::transmute(Level) };
            Level as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let CPUVersion: u64 = unsafe { ::core::mem::transmute(CPUVersion) };
            CPUVersion as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let CPUBrandString: u64 = unsafe { ::core::mem::transmute(CPUBrandString) };
            CPUBrandString as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ProcessorId: u64 = unsafe { ::core::mem::transmute(ProcessorId) };
            ProcessorId as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let TargetAddress: u64 = unsafe { ::core::mem::transmute(TargetAddress) };
            TargetAddress as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let RequesterId: u64 = unsafe { ::core::mem::transmute(RequesterId) };
            RequesterId as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let ResponderId: u64 = unsafe { ::core::mem::transmute(ResponderId) };
            ResponderId as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let InstructionPointer: u64 = unsafe { ::core::mem::transmute(InstructionPointer) };
            InstructionPointer as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let NativeModelId: u64 = unsafe { ::core::mem::transmute(NativeModelId) };
            NativeModelId as u64
        });
        __bindgen_bitfield_unit.set(14usize, 50u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS =
_WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS;
pub type PWHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS =
*mut _WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_PROCESSOR_GENERIC_ERROR_SECTION {
    pub ValidBits: WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS,
    pub ProcessorType: UCHAR,
    pub InstructionSet: UCHAR,
    pub ErrorType: UCHAR,
    pub Operation: UCHAR,
    pub Flags: UCHAR,
    pub Level: UCHAR,
    pub Reserved: USHORT,
    pub CPUVersion: ULONGLONG,
    pub CPUBrandString: [UCHAR; 128usize],
    pub ProcessorId: ULONGLONG,
    pub TargetAddress: ULONGLONG,
    pub RequesterId: ULONGLONG,
    pub ResponderId: ULONGLONG,
    pub InstructionPointer: ULONGLONG,
}
pub type WHEA_PROCESSOR_GENERIC_ERROR_SECTION = _WHEA_PROCESSOR_GENERIC_ERROR_SECTION;
pub type PWHEA_PROCESSOR_GENERIC_ERROR_SECTION = *mut _WHEA_PROCESSOR_GENERIC_ERROR_SECTION;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_XPF_CACHE_CHECK {
    pub __bindgen_anon_1: _WHEA_XPF_CACHE_CHECK__bindgen_ty_1,
    pub XpfCacheCheck: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_XPF_CACHE_CHECK__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _WHEA_XPF_CACHE_CHECK__bindgen_ty_1 {
    #[inline]
    pub fn TransactionTypeValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_TransactionTypeValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TransactionTypeValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_TransactionTypeValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn OperationValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_OperationValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn OperationValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_OperationValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LevelValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_LevelValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LevelValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_LevelValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ProcessorContextCorruptValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ProcessorContextCorruptValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ProcessorContextCorruptValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ProcessorContextCorruptValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectedValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_UncorrectedValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectedValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectedValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PreciseIPValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PreciseIPValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PreciseIPValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_PreciseIPValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RestartableIPValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RestartableIPValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RestartableIPValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_RestartableIPValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn OverflowValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_OverflowValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn OverflowValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_OverflowValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReservedValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_ReservedValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReservedValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ReservedValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TransactionType(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_TransactionType(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TransactionType_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                2u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_TransactionType_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Operation(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_Operation(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Operation_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                4u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Operation_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Level(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_Level(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Level_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                3u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Level_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ProcessorContextCorrupt(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ProcessorContextCorrupt(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ProcessorContextCorrupt_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ProcessorContextCorrupt_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Uncorrected(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Uncorrected(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Uncorrected_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Uncorrected_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PreciseIP(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PreciseIP(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PreciseIP_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_PreciseIP_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RestartableIP(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RestartableIP(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RestartableIP_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_RestartableIP_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Overflow(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Overflow(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Overflow_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                29usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Overflow_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                29usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 34u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 34u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                34u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                34u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TransactionTypeValid: ULONGLONG,
        OperationValid: ULONGLONG,
        LevelValid: ULONGLONG,
        ProcessorContextCorruptValid: ULONGLONG,
        UncorrectedValid: ULONGLONG,
        PreciseIPValid: ULONGLONG,
        RestartableIPValid: ULONGLONG,
        OverflowValid: ULONGLONG,
        ReservedValid: ULONGLONG,
        TransactionType: ULONGLONG,
        Operation: ULONGLONG,
        Level: ULONGLONG,
        ProcessorContextCorrupt: ULONGLONG,
        Uncorrected: ULONGLONG,
        PreciseIP: ULONGLONG,
        RestartableIP: ULONGLONG,
        Overflow: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let TransactionTypeValid: u64 = unsafe { ::core::mem::transmute(TransactionTypeValid) };
            TransactionTypeValid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let OperationValid: u64 = unsafe { ::core::mem::transmute(OperationValid) };
            OperationValid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let LevelValid: u64 = unsafe { ::core::mem::transmute(LevelValid) };
            LevelValid as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ProcessorContextCorruptValid: u64 =
                unsafe { ::core::mem::transmute(ProcessorContextCorruptValid) };
            ProcessorContextCorruptValid as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let UncorrectedValid: u64 = unsafe { ::core::mem::transmute(UncorrectedValid) };
            UncorrectedValid as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PreciseIPValid: u64 = unsafe { ::core::mem::transmute(PreciseIPValid) };
            PreciseIPValid as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RestartableIPValid: u64 = unsafe { ::core::mem::transmute(RestartableIPValid) };
            RestartableIPValid as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let OverflowValid: u64 = unsafe { ::core::mem::transmute(OverflowValid) };
            OverflowValid as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let ReservedValid: u64 = unsafe { ::core::mem::transmute(ReservedValid) };
            ReservedValid as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let TransactionType: u64 = unsafe { ::core::mem::transmute(TransactionType) };
            TransactionType as u64
        });
        __bindgen_bitfield_unit.set(18usize, 4u8, {
            let Operation: u64 = unsafe { ::core::mem::transmute(Operation) };
            Operation as u64
        });
        __bindgen_bitfield_unit.set(22usize, 3u8, {
            let Level: u64 = unsafe { ::core::mem::transmute(Level) };
            Level as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let ProcessorContextCorrupt: u64 =
                unsafe { ::core::mem::transmute(ProcessorContextCorrupt) };
            ProcessorContextCorrupt as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let Uncorrected: u64 = unsafe { ::core::mem::transmute(Uncorrected) };
            Uncorrected as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let PreciseIP: u64 = unsafe { ::core::mem::transmute(PreciseIP) };
            PreciseIP as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let RestartableIP: u64 = unsafe { ::core::mem::transmute(RestartableIP) };
            RestartableIP as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let Overflow: u64 = unsafe { ::core::mem::transmute(Overflow) };
            Overflow as u64
        });
        __bindgen_bitfield_unit.set(30usize, 34u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_XPF_CACHE_CHECK = _WHEA_XPF_CACHE_CHECK;
pub type PWHEA_XPF_CACHE_CHECK = *mut _WHEA_XPF_CACHE_CHECK;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_XPF_TLB_CHECK {
    pub __bindgen_anon_1: _WHEA_XPF_TLB_CHECK__bindgen_ty_1,
    pub XpfTLBCheck: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_XPF_TLB_CHECK__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _WHEA_XPF_TLB_CHECK__bindgen_ty_1 {
    #[inline]
    pub fn TransactionTypeValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_TransactionTypeValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TransactionTypeValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_TransactionTypeValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn OperationValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_OperationValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn OperationValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_OperationValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LevelValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_LevelValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LevelValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_LevelValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ProcessorContextCorruptValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ProcessorContextCorruptValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ProcessorContextCorruptValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ProcessorContextCorruptValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectedValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_UncorrectedValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectedValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectedValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PreciseIPValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PreciseIPValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PreciseIPValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_PreciseIPValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RestartableIPValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RestartableIPValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RestartableIPValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_RestartableIPValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn OverflowValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_OverflowValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn OverflowValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_OverflowValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReservedValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_ReservedValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReservedValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ReservedValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TransactionType(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_TransactionType(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TransactionType_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                2u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_TransactionType_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Operation(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_Operation(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Operation_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                4u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Operation_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Level(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_Level(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Level_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                3u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Level_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ProcessorContextCorrupt(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ProcessorContextCorrupt(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ProcessorContextCorrupt_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ProcessorContextCorrupt_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Uncorrected(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Uncorrected(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Uncorrected_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Uncorrected_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PreciseIP(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PreciseIP(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PreciseIP_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_PreciseIP_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RestartableIP(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RestartableIP(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RestartableIP_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_RestartableIP_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Overflow(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Overflow(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Overflow_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                29usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Overflow_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                29usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 34u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 34u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                34u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                34u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TransactionTypeValid: ULONGLONG,
        OperationValid: ULONGLONG,
        LevelValid: ULONGLONG,
        ProcessorContextCorruptValid: ULONGLONG,
        UncorrectedValid: ULONGLONG,
        PreciseIPValid: ULONGLONG,
        RestartableIPValid: ULONGLONG,
        OverflowValid: ULONGLONG,
        ReservedValid: ULONGLONG,
        TransactionType: ULONGLONG,
        Operation: ULONGLONG,
        Level: ULONGLONG,
        ProcessorContextCorrupt: ULONGLONG,
        Uncorrected: ULONGLONG,
        PreciseIP: ULONGLONG,
        RestartableIP: ULONGLONG,
        Overflow: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let TransactionTypeValid: u64 = unsafe { ::core::mem::transmute(TransactionTypeValid) };
            TransactionTypeValid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let OperationValid: u64 = unsafe { ::core::mem::transmute(OperationValid) };
            OperationValid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let LevelValid: u64 = unsafe { ::core::mem::transmute(LevelValid) };
            LevelValid as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ProcessorContextCorruptValid: u64 =
                unsafe { ::core::mem::transmute(ProcessorContextCorruptValid) };
            ProcessorContextCorruptValid as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let UncorrectedValid: u64 = unsafe { ::core::mem::transmute(UncorrectedValid) };
            UncorrectedValid as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PreciseIPValid: u64 = unsafe { ::core::mem::transmute(PreciseIPValid) };
            PreciseIPValid as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RestartableIPValid: u64 = unsafe { ::core::mem::transmute(RestartableIPValid) };
            RestartableIPValid as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let OverflowValid: u64 = unsafe { ::core::mem::transmute(OverflowValid) };
            OverflowValid as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let ReservedValid: u64 = unsafe { ::core::mem::transmute(ReservedValid) };
            ReservedValid as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let TransactionType: u64 = unsafe { ::core::mem::transmute(TransactionType) };
            TransactionType as u64
        });
        __bindgen_bitfield_unit.set(18usize, 4u8, {
            let Operation: u64 = unsafe { ::core::mem::transmute(Operation) };
            Operation as u64
        });
        __bindgen_bitfield_unit.set(22usize, 3u8, {
            let Level: u64 = unsafe { ::core::mem::transmute(Level) };
            Level as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let ProcessorContextCorrupt: u64 =
                unsafe { ::core::mem::transmute(ProcessorContextCorrupt) };
            ProcessorContextCorrupt as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let Uncorrected: u64 = unsafe { ::core::mem::transmute(Uncorrected) };
            Uncorrected as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let PreciseIP: u64 = unsafe { ::core::mem::transmute(PreciseIP) };
            PreciseIP as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let RestartableIP: u64 = unsafe { ::core::mem::transmute(RestartableIP) };
            RestartableIP as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let Overflow: u64 = unsafe { ::core::mem::transmute(Overflow) };
            Overflow as u64
        });
        __bindgen_bitfield_unit.set(30usize, 34u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_XPF_TLB_CHECK = _WHEA_XPF_TLB_CHECK;
pub type PWHEA_XPF_TLB_CHECK = *mut _WHEA_XPF_TLB_CHECK;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_XPF_BUS_CHECK {
    pub __bindgen_anon_1: _WHEA_XPF_BUS_CHECK__bindgen_ty_1,
    pub XpfBusCheck: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_XPF_BUS_CHECK__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _WHEA_XPF_BUS_CHECK__bindgen_ty_1 {
    #[inline]
    pub fn TransactionTypeValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_TransactionTypeValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TransactionTypeValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_TransactionTypeValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn OperationValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_OperationValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn OperationValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_OperationValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LevelValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_LevelValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LevelValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_LevelValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ProcessorContextCorruptValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ProcessorContextCorruptValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ProcessorContextCorruptValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ProcessorContextCorruptValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectedValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_UncorrectedValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectedValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectedValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PreciseIPValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PreciseIPValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PreciseIPValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_PreciseIPValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RestartableIPValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RestartableIPValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RestartableIPValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_RestartableIPValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn OverflowValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_OverflowValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn OverflowValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_OverflowValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ParticipationValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ParticipationValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ParticipationValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ParticipationValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TimeoutValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_TimeoutValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TimeoutValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_TimeoutValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AddressSpaceValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AddressSpaceValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AddressSpaceValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_AddressSpaceValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReservedValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_ReservedValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReservedValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                5u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ReservedValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TransactionType(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_TransactionType(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TransactionType_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                2u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_TransactionType_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Operation(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_Operation(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Operation_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                4u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Operation_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Level(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_Level(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Level_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                3u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Level_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ProcessorContextCorrupt(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ProcessorContextCorrupt(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ProcessorContextCorrupt_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ProcessorContextCorrupt_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Uncorrected(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Uncorrected(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Uncorrected_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Uncorrected_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PreciseIP(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PreciseIP(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PreciseIP_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_PreciseIP_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RestartableIP(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RestartableIP(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RestartableIP_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_RestartableIP_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Overflow(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Overflow(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Overflow_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                29usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Overflow_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                29usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Participation(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_Participation(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Participation_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                2u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Participation_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Timeout(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Timeout(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Timeout_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Timeout_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AddressSpace(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_AddressSpace(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AddressSpace_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                33usize,
                2u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_AddressSpace_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                33usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(35usize, 29u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(35usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                35usize,
                29u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                35usize,
                29u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TransactionTypeValid: ULONGLONG,
        OperationValid: ULONGLONG,
        LevelValid: ULONGLONG,
        ProcessorContextCorruptValid: ULONGLONG,
        UncorrectedValid: ULONGLONG,
        PreciseIPValid: ULONGLONG,
        RestartableIPValid: ULONGLONG,
        OverflowValid: ULONGLONG,
        ParticipationValid: ULONGLONG,
        TimeoutValid: ULONGLONG,
        AddressSpaceValid: ULONGLONG,
        ReservedValid: ULONGLONG,
        TransactionType: ULONGLONG,
        Operation: ULONGLONG,
        Level: ULONGLONG,
        ProcessorContextCorrupt: ULONGLONG,
        Uncorrected: ULONGLONG,
        PreciseIP: ULONGLONG,
        RestartableIP: ULONGLONG,
        Overflow: ULONGLONG,
        Participation: ULONGLONG,
        Timeout: ULONGLONG,
        AddressSpace: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let TransactionTypeValid: u64 = unsafe { ::core::mem::transmute(TransactionTypeValid) };
            TransactionTypeValid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let OperationValid: u64 = unsafe { ::core::mem::transmute(OperationValid) };
            OperationValid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let LevelValid: u64 = unsafe { ::core::mem::transmute(LevelValid) };
            LevelValid as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ProcessorContextCorruptValid: u64 =
                unsafe { ::core::mem::transmute(ProcessorContextCorruptValid) };
            ProcessorContextCorruptValid as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let UncorrectedValid: u64 = unsafe { ::core::mem::transmute(UncorrectedValid) };
            UncorrectedValid as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PreciseIPValid: u64 = unsafe { ::core::mem::transmute(PreciseIPValid) };
            PreciseIPValid as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RestartableIPValid: u64 = unsafe { ::core::mem::transmute(RestartableIPValid) };
            RestartableIPValid as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let OverflowValid: u64 = unsafe { ::core::mem::transmute(OverflowValid) };
            OverflowValid as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ParticipationValid: u64 = unsafe { ::core::mem::transmute(ParticipationValid) };
            ParticipationValid as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let TimeoutValid: u64 = unsafe { ::core::mem::transmute(TimeoutValid) };
            TimeoutValid as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let AddressSpaceValid: u64 = unsafe { ::core::mem::transmute(AddressSpaceValid) };
            AddressSpaceValid as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let ReservedValid: u64 = unsafe { ::core::mem::transmute(ReservedValid) };
            ReservedValid as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let TransactionType: u64 = unsafe { ::core::mem::transmute(TransactionType) };
            TransactionType as u64
        });
        __bindgen_bitfield_unit.set(18usize, 4u8, {
            let Operation: u64 = unsafe { ::core::mem::transmute(Operation) };
            Operation as u64
        });
        __bindgen_bitfield_unit.set(22usize, 3u8, {
            let Level: u64 = unsafe { ::core::mem::transmute(Level) };
            Level as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let ProcessorContextCorrupt: u64 =
                unsafe { ::core::mem::transmute(ProcessorContextCorrupt) };
            ProcessorContextCorrupt as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let Uncorrected: u64 = unsafe { ::core::mem::transmute(Uncorrected) };
            Uncorrected as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let PreciseIP: u64 = unsafe { ::core::mem::transmute(PreciseIP) };
            PreciseIP as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let RestartableIP: u64 = unsafe { ::core::mem::transmute(RestartableIP) };
            RestartableIP as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let Overflow: u64 = unsafe { ::core::mem::transmute(Overflow) };
            Overflow as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let Participation: u64 = unsafe { ::core::mem::transmute(Participation) };
            Participation as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let Timeout: u64 = unsafe { ::core::mem::transmute(Timeout) };
            Timeout as u64
        });
        __bindgen_bitfield_unit.set(33usize, 2u8, {
            let AddressSpace: u64 = unsafe { ::core::mem::transmute(AddressSpace) };
            AddressSpace as u64
        });
        __bindgen_bitfield_unit.set(35usize, 29u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_XPF_BUS_CHECK = _WHEA_XPF_BUS_CHECK;
pub type PWHEA_XPF_BUS_CHECK = *mut _WHEA_XPF_BUS_CHECK;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_XPF_MS_CHECK {
    pub __bindgen_anon_1: _WHEA_XPF_MS_CHECK__bindgen_ty_1,
    pub XpfMsCheck: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_XPF_MS_CHECK__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _WHEA_XPF_MS_CHECK__bindgen_ty_1 {
    #[inline]
    pub fn ErrorTypeValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ErrorTypeValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ErrorTypeValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ErrorTypeValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ProcessorContextCorruptValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ProcessorContextCorruptValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ProcessorContextCorruptValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ProcessorContextCorruptValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectedValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_UncorrectedValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectedValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectedValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PreciseIPValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PreciseIPValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PreciseIPValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_PreciseIPValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RestartableIPValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RestartableIPValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RestartableIPValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_RestartableIPValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn OverflowValid(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_OverflowValid(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn OverflowValid_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_OverflowValid_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReservedValue(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 10u8) as u64) }
    }
    #[inline]
    pub fn set_ReservedValue(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReservedValue_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                10u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ReservedValue_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                10u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ErrorType(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_ErrorType(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ErrorType_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                3u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ErrorType_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ProcessorContextCorrupt(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ProcessorContextCorrupt(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ProcessorContextCorrupt_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ProcessorContextCorrupt_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Uncorrected(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Uncorrected(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Uncorrected_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Uncorrected_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PreciseIP(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PreciseIP(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PreciseIP_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_PreciseIP_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RestartableIP(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RestartableIP(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RestartableIP_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_RestartableIP_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Overflow(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Overflow(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Overflow_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Overflow_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 40u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 40u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                40u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                40u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ErrorTypeValid: ULONGLONG,
        ProcessorContextCorruptValid: ULONGLONG,
        UncorrectedValid: ULONGLONG,
        PreciseIPValid: ULONGLONG,
        RestartableIPValid: ULONGLONG,
        OverflowValid: ULONGLONG,
        ReservedValue: ULONGLONG,
        ErrorType: ULONGLONG,
        ProcessorContextCorrupt: ULONGLONG,
        Uncorrected: ULONGLONG,
        PreciseIP: ULONGLONG,
        RestartableIP: ULONGLONG,
        Overflow: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ErrorTypeValid: u64 = unsafe { ::core::mem::transmute(ErrorTypeValid) };
            ErrorTypeValid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ProcessorContextCorruptValid: u64 =
                unsafe { ::core::mem::transmute(ProcessorContextCorruptValid) };
            ProcessorContextCorruptValid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let UncorrectedValid: u64 = unsafe { ::core::mem::transmute(UncorrectedValid) };
            UncorrectedValid as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PreciseIPValid: u64 = unsafe { ::core::mem::transmute(PreciseIPValid) };
            PreciseIPValid as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let RestartableIPValid: u64 = unsafe { ::core::mem::transmute(RestartableIPValid) };
            RestartableIPValid as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let OverflowValid: u64 = unsafe { ::core::mem::transmute(OverflowValid) };
            OverflowValid as u64
        });
        __bindgen_bitfield_unit.set(6usize, 10u8, {
            let ReservedValue: u64 = unsafe { ::core::mem::transmute(ReservedValue) };
            ReservedValue as u64
        });
        __bindgen_bitfield_unit.set(16usize, 3u8, {
            let ErrorType: u64 = unsafe { ::core::mem::transmute(ErrorType) };
            ErrorType as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ProcessorContextCorrupt: u64 =
                unsafe { ::core::mem::transmute(ProcessorContextCorrupt) };
            ProcessorContextCorrupt as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let Uncorrected: u64 = unsafe { ::core::mem::transmute(Uncorrected) };
            Uncorrected as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let PreciseIP: u64 = unsafe { ::core::mem::transmute(PreciseIP) };
            PreciseIP as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let RestartableIP: u64 = unsafe { ::core::mem::transmute(RestartableIP) };
            RestartableIP as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let Overflow: u64 = unsafe { ::core::mem::transmute(Overflow) };
            Overflow as u64
        });
        __bindgen_bitfield_unit.set(24usize, 40u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_XPF_MS_CHECK = _WHEA_XPF_MS_CHECK;
pub type PWHEA_XPF_MS_CHECK = *mut _WHEA_XPF_MS_CHECK;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_XPF_PROCINFO_VALIDBITS {
    pub __bindgen_anon_1: _WHEA_XPF_PROCINFO_VALIDBITS__bindgen_ty_1,
    pub ValidBits: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_XPF_PROCINFO_VALIDBITS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _WHEA_XPF_PROCINFO_VALIDBITS__bindgen_ty_1 {
    #[inline]
    pub fn CheckInfo(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_CheckInfo(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CheckInfo_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_CheckInfo_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TargetId(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_TargetId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TargetId_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_TargetId_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RequesterId(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RequesterId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RequesterId_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_RequesterId_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ResponderId(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ResponderId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ResponderId_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ResponderId_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn InstructionPointer(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_InstructionPointer(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InstructionPointer_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_InstructionPointer_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 59u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 59u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                59u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                59u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CheckInfo: ULONGLONG,
        TargetId: ULONGLONG,
        RequesterId: ULONGLONG,
        ResponderId: ULONGLONG,
        InstructionPointer: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CheckInfo: u64 = unsafe { ::core::mem::transmute(CheckInfo) };
            CheckInfo as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TargetId: u64 = unsafe { ::core::mem::transmute(TargetId) };
            TargetId as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RequesterId: u64 = unsafe { ::core::mem::transmute(RequesterId) };
            RequesterId as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ResponderId: u64 = unsafe { ::core::mem::transmute(ResponderId) };
            ResponderId as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let InstructionPointer: u64 = unsafe { ::core::mem::transmute(InstructionPointer) };
            InstructionPointer as u64
        });
        __bindgen_bitfield_unit.set(5usize, 59u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_XPF_PROCINFO_VALIDBITS = _WHEA_XPF_PROCINFO_VALIDBITS;
pub type PWHEA_XPF_PROCINFO_VALIDBITS = *mut _WHEA_XPF_PROCINFO_VALIDBITS;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_XPF_PROCINFO {
    pub CheckInfoId: GUID,
    pub ValidBits: WHEA_XPF_PROCINFO_VALIDBITS,
    pub CheckInfo: _WHEA_XPF_PROCINFO__bindgen_ty_1,
    pub TargetId: ULONGLONG,
    pub RequesterId: ULONGLONG,
    pub ResponderId: ULONGLONG,
    pub InstructionPointer: ULONGLONG,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_XPF_PROCINFO__bindgen_ty_1 {
    pub CacheCheck: WHEA_XPF_CACHE_CHECK,
    pub TlbCheck: WHEA_XPF_TLB_CHECK,
    pub BusCheck: WHEA_XPF_BUS_CHECK,
    pub MsCheck: WHEA_XPF_MS_CHECK,
    pub AsULONGLONG: ULONGLONG,
}
pub type WHEA_XPF_PROCINFO = _WHEA_XPF_PROCINFO;
pub type PWHEA_XPF_PROCINFO = *mut _WHEA_XPF_PROCINFO;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_X86_REGISTER_STATE {
    pub Eax: ULONG,
    pub Ebx: ULONG,
    pub Ecx: ULONG,
    pub Edx: ULONG,
    pub Esi: ULONG,
    pub Edi: ULONG,
    pub Ebp: ULONG,
    pub Esp: ULONG,
    pub Cs: USHORT,
    pub Ds: USHORT,
    pub Ss: USHORT,
    pub Es: USHORT,
    pub Fs: USHORT,
    pub Gs: USHORT,
    pub Eflags: ULONG,
    pub Eip: ULONG,
    pub Cr0: ULONG,
    pub Cr1: ULONG,
    pub Cr2: ULONG,
    pub Cr3: ULONG,
    pub Cr4: ULONG,
    pub Gdtr: ULONGLONG,
    pub Idtr: ULONGLONG,
    pub Ldtr: USHORT,
    pub Tr: USHORT,
}
pub type WHEA_X86_REGISTER_STATE = _WHEA_X86_REGISTER_STATE;
pub type PWHEA_X86_REGISTER_STATE = *mut _WHEA_X86_REGISTER_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA128A {
    pub Low: ULONGLONG,
    pub High: LONGLONG,
}
pub type WHEA128A = _WHEA128A;
pub type PWHEA128A = *mut _WHEA128A;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_X64_REGISTER_STATE {
    pub Rax: ULONGLONG,
    pub Rbx: ULONGLONG,
    pub Rcx: ULONGLONG,
    pub Rdx: ULONGLONG,
    pub Rsi: ULONGLONG,
    pub Rdi: ULONGLONG,
    pub Rbp: ULONGLONG,
    pub Rsp: ULONGLONG,
    pub R8: ULONGLONG,
    pub R9: ULONGLONG,
    pub R10: ULONGLONG,
    pub R11: ULONGLONG,
    pub R12: ULONGLONG,
    pub R13: ULONGLONG,
    pub R14: ULONGLONG,
    pub R15: ULONGLONG,
    pub Cs: USHORT,
    pub Ds: USHORT,
    pub Ss: USHORT,
    pub Es: USHORT,
    pub Fs: USHORT,
    pub Gs: USHORT,
    pub Reserved: ULONG,
    pub Rflags: ULONGLONG,
    pub Eip: ULONGLONG,
    pub Cr0: ULONGLONG,
    pub Cr1: ULONGLONG,
    pub Cr2: ULONGLONG,
    pub Cr3: ULONGLONG,
    pub Cr4: ULONGLONG,
    pub Cr8: ULONGLONG,
    pub Gdtr: WHEA128A,
    pub Idtr: WHEA128A,
    pub Ldtr: USHORT,
    pub Tr: USHORT,
}
pub type WHEA_X64_REGISTER_STATE = _WHEA_X64_REGISTER_STATE;
pub type PWHEA_X64_REGISTER_STATE = *mut _WHEA_X64_REGISTER_STATE;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_XPF_CONTEXT_INFO {
    pub RegisterContextType: USHORT,
    pub RegisterDataSize: USHORT,
    pub MSRAddress: ULONG,
    pub MmRegisterAddress: ULONGLONG,
}
pub type WHEA_XPF_CONTEXT_INFO = _WHEA_XPF_CONTEXT_INFO;
pub type PWHEA_XPF_CONTEXT_INFO = *mut _WHEA_XPF_CONTEXT_INFO;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS {
    pub __bindgen_anon_1: _WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS__bindgen_ty_1,
    pub ValidBits: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    #[inline]
    pub fn LocalAPICId(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_LocalAPICId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LocalAPICId_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_LocalAPICId_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CpuId(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_CpuId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CpuId_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_CpuId_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ProcInfoCount(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u64) }
    }
    #[inline]
    pub fn set_ProcInfoCount(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ProcInfoCount_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                6u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ProcInfoCount_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ContextInfoCount(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 6u8) as u64) }
    }
    #[inline]
    pub fn set_ContextInfoCount(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ContextInfoCount_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                6u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ContextInfoCount_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 50u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 50u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                50u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                50u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        LocalAPICId: ULONGLONG,
        CpuId: ULONGLONG,
        ProcInfoCount: ULONGLONG,
        ContextInfoCount: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let LocalAPICId: u64 = unsafe { ::core::mem::transmute(LocalAPICId) };
            LocalAPICId as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CpuId: u64 = unsafe { ::core::mem::transmute(CpuId) };
            CpuId as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let ProcInfoCount: u64 = unsafe { ::core::mem::transmute(ProcInfoCount) };
            ProcInfoCount as u64
        });
        __bindgen_bitfield_unit.set(8usize, 6u8, {
            let ContextInfoCount: u64 = unsafe { ::core::mem::transmute(ContextInfoCount) };
            ContextInfoCount as u64
        });
        __bindgen_bitfield_unit.set(14usize, 50u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS = _WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS;
pub type PWHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS =
*mut _WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_XPF_PROCESSOR_ERROR_SECTION {
    pub ValidBits: WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS,
    pub LocalAPICId: ULONGLONG,
    pub CpuId: [UCHAR; 48usize],
    pub VariableInfo: [UCHAR; 1usize],
}
pub type WHEA_XPF_PROCESSOR_ERROR_SECTION = _WHEA_XPF_PROCESSOR_ERROR_SECTION;
pub type PWHEA_XPF_PROCESSOR_ERROR_SECTION = *mut _WHEA_XPF_PROCESSOR_ERROR_SECTION;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_MEMORY_ERROR_SECTION_VALIDBITS {
    pub __bindgen_anon_1: _WHEA_MEMORY_ERROR_SECTION_VALIDBITS__bindgen_ty_1,
    pub ValidBits: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_MEMORY_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _WHEA_MEMORY_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    #[inline]
    pub fn ErrorStatus(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ErrorStatus(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ErrorStatus_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ErrorStatus_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PhysicalAddress(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PhysicalAddress(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PhysicalAddress_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_PhysicalAddress_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PhysicalAddressMask(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PhysicalAddressMask(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PhysicalAddressMask_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_PhysicalAddressMask_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Node(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Node(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Node_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Node_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Card(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Card(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Card_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Card_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Module(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Module(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Module_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Module_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Bank(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Bank(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Bank_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Bank_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Device(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Device(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Device_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Device_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Row(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Row(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Row_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Row_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Column(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Column(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Column_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Column_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn BitPosition(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_BitPosition(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn BitPosition_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_BitPosition_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RequesterId(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RequesterId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RequesterId_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_RequesterId_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ResponderId(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ResponderId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ResponderId_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ResponderId_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TargetId(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_TargetId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TargetId_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_TargetId_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ErrorType(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ErrorType(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ErrorType_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ErrorType_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RankNumber(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RankNumber(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RankNumber_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_RankNumber_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CardHandle(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_CardHandle(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CardHandle_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_CardHandle_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ModuleHandle(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ModuleHandle(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ModuleHandle_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ModuleHandle_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ExtendedRow(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ExtendedRow(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ExtendedRow_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ExtendedRow_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn BankGroup(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_BankGroup(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn BankGroup_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_BankGroup_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn BankAddress(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_BankAddress(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn BankAddress_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_BankAddress_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ChipIdentification(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ChipIdentification(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ChipIdentification_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ChipIdentification_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 42u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 42u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                42u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                42u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ErrorStatus: ULONGLONG,
        PhysicalAddress: ULONGLONG,
        PhysicalAddressMask: ULONGLONG,
        Node: ULONGLONG,
        Card: ULONGLONG,
        Module: ULONGLONG,
        Bank: ULONGLONG,
        Device: ULONGLONG,
        Row: ULONGLONG,
        Column: ULONGLONG,
        BitPosition: ULONGLONG,
        RequesterId: ULONGLONG,
        ResponderId: ULONGLONG,
        TargetId: ULONGLONG,
        ErrorType: ULONGLONG,
        RankNumber: ULONGLONG,
        CardHandle: ULONGLONG,
        ModuleHandle: ULONGLONG,
        ExtendedRow: ULONGLONG,
        BankGroup: ULONGLONG,
        BankAddress: ULONGLONG,
        ChipIdentification: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ErrorStatus: u64 = unsafe { ::core::mem::transmute(ErrorStatus) };
            ErrorStatus as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PhysicalAddress: u64 = unsafe { ::core::mem::transmute(PhysicalAddress) };
            PhysicalAddress as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PhysicalAddressMask: u64 = unsafe { ::core::mem::transmute(PhysicalAddressMask) };
            PhysicalAddressMask as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Node: u64 = unsafe { ::core::mem::transmute(Node) };
            Node as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Card: u64 = unsafe { ::core::mem::transmute(Card) };
            Card as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Module: u64 = unsafe { ::core::mem::transmute(Module) };
            Module as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Bank: u64 = unsafe { ::core::mem::transmute(Bank) };
            Bank as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Device: u64 = unsafe { ::core::mem::transmute(Device) };
            Device as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Row: u64 = unsafe { ::core::mem::transmute(Row) };
            Row as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let Column: u64 = unsafe { ::core::mem::transmute(Column) };
            Column as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let BitPosition: u64 = unsafe { ::core::mem::transmute(BitPosition) };
            BitPosition as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let RequesterId: u64 = unsafe { ::core::mem::transmute(RequesterId) };
            RequesterId as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ResponderId: u64 = unsafe { ::core::mem::transmute(ResponderId) };
            ResponderId as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let TargetId: u64 = unsafe { ::core::mem::transmute(TargetId) };
            TargetId as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let ErrorType: u64 = unsafe { ::core::mem::transmute(ErrorType) };
            ErrorType as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let RankNumber: u64 = unsafe { ::core::mem::transmute(RankNumber) };
            RankNumber as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let CardHandle: u64 = unsafe { ::core::mem::transmute(CardHandle) };
            CardHandle as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let ModuleHandle: u64 = unsafe { ::core::mem::transmute(ModuleHandle) };
            ModuleHandle as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let ExtendedRow: u64 = unsafe { ::core::mem::transmute(ExtendedRow) };
            ExtendedRow as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let BankGroup: u64 = unsafe { ::core::mem::transmute(BankGroup) };
            BankGroup as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let BankAddress: u64 = unsafe { ::core::mem::transmute(BankAddress) };
            BankAddress as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let ChipIdentification: u64 = unsafe { ::core::mem::transmute(ChipIdentification) };
            ChipIdentification as u64
        });
        __bindgen_bitfield_unit.set(22usize, 42u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_MEMORY_ERROR_SECTION_VALIDBITS = _WHEA_MEMORY_ERROR_SECTION_VALIDBITS;
pub type PWHEA_MEMORY_ERROR_SECTION_VALIDBITS = *mut _WHEA_MEMORY_ERROR_SECTION_VALIDBITS;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_MEMORY_ERROR_SECTION {
    pub ValidBits: WHEA_MEMORY_ERROR_SECTION_VALIDBITS,
    pub ErrorStatus: WHEA_ERROR_STATUS,
    pub PhysicalAddress: ULONGLONG,
    pub PhysicalAddressMask: ULONGLONG,
    pub Node: USHORT,
    pub Card: USHORT,
    pub Module: USHORT,
    pub Bank: USHORT,
    pub Device: USHORT,
    pub Row: USHORT,
    pub Column: USHORT,
    pub BitPosition: USHORT,
    pub RequesterId: ULONGLONG,
    pub ResponderId: ULONGLONG,
    pub TargetId: ULONGLONG,
    pub ErrorType: UCHAR,
    pub Extended: UCHAR,
    pub RankNumber: USHORT,
    pub CardHandle: USHORT,
    pub ModuleHandle: USHORT,
}
pub type WHEA_MEMORY_ERROR_SECTION = _WHEA_MEMORY_ERROR_SECTION;
pub type PWHEA_MEMORY_ERROR_SECTION = *mut _WHEA_MEMORY_ERROR_SECTION;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_PMEM_ERROR_SECTION_VALIDBITS {
    pub __bindgen_anon_1: _WHEA_PMEM_ERROR_SECTION_VALIDBITS__bindgen_ty_1,
    pub ValidBits: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_PMEM_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _WHEA_PMEM_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    #[inline]
    pub fn ErrorStatus(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ErrorStatus(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ErrorStatus_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ErrorStatus_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NFITHandle(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_NFITHandle(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NFITHandle_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_NFITHandle_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LocationInfo(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_LocationInfo(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LocationInfo_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_LocationInfo_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 61u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 61u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                61u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                61u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ErrorStatus: ULONGLONG,
        NFITHandle: ULONGLONG,
        LocationInfo: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ErrorStatus: u64 = unsafe { ::core::mem::transmute(ErrorStatus) };
            ErrorStatus as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let NFITHandle: u64 = unsafe { ::core::mem::transmute(NFITHandle) };
            NFITHandle as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let LocationInfo: u64 = unsafe { ::core::mem::transmute(LocationInfo) };
            LocationInfo as u64
        });
        __bindgen_bitfield_unit.set(3usize, 61u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_PMEM_ERROR_SECTION_VALIDBITS = _WHEA_PMEM_ERROR_SECTION_VALIDBITS;
pub type PWHEA_PMEM_ERROR_SECTION_VALIDBITS = *mut _WHEA_PMEM_ERROR_SECTION_VALIDBITS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_PMEM_PAGE_RANGE {
    pub StartingPfn: ULONG64,
    pub PageCount: ULONG64,
    pub MarkedBadBitmap: ULONG64,
}
pub type WHEA_PMEM_PAGE_RANGE = _WHEA_PMEM_PAGE_RANGE;
pub type PWHEA_PMEM_PAGE_RANGE = *mut _WHEA_PMEM_PAGE_RANGE;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_PMEM_ERROR_SECTION {
    pub ValidBits: WHEA_PMEM_ERROR_SECTION_VALIDBITS,
    pub LocationInfo: [UCHAR; 64usize],
    pub ErrorStatus: WHEA_ERROR_STATUS,
    pub NFITHandle: ULONG,
    pub PageRangeCount: ULONG,
    pub PageRange: [WHEA_PMEM_PAGE_RANGE; 1usize],
}
pub type WHEA_PMEM_ERROR_SECTION = _WHEA_PMEM_ERROR_SECTION;
pub type PWHEA_PMEM_ERROR_SECTION = *mut _WHEA_PMEM_ERROR_SECTION;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_PCIE_ADDRESS {
    pub Segment: UINT32,
    pub Bus: UINT32,
    pub Device: UINT32,
    pub Function: UINT32,
}
pub type WHEA_PCIE_ADDRESS = _WHEA_PCIE_ADDRESS;
pub type PWHEA_PCIE_ADDRESS = *mut _WHEA_PCIE_ADDRESS;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_PCIE_CORRECTABLE_ERROR_DEVICES_VALIDBITS {
    pub __bindgen_anon_1: _WHEA_PCIE_CORRECTABLE_ERROR_DEVICES_VALIDBITS__bindgen_ty_1,
    pub ValidBits: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_PCIE_CORRECTABLE_ERROR_DEVICES_VALIDBITS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _WHEA_PCIE_CORRECTABLE_ERROR_DEVICES_VALIDBITS__bindgen_ty_1 {
    #[inline]
    pub fn Segment(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Segment(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Segment_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Segment_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Bus(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Bus(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Bus_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Bus_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Device(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Device(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Device_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Device_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Function(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Function(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Function_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Function_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Mask(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Mask(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Mask_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Mask_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CorrectableErrorCount(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_CorrectableErrorCount(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CorrectableErrorCount_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_CorrectableErrorCount_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 58u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 58u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                58u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                58u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Segment: ULONGLONG,
        Bus: ULONGLONG,
        Device: ULONGLONG,
        Function: ULONGLONG,
        Mask: ULONGLONG,
        CorrectableErrorCount: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Segment: u64 = unsafe { ::core::mem::transmute(Segment) };
            Segment as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Bus: u64 = unsafe { ::core::mem::transmute(Bus) };
            Bus as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Device: u64 = unsafe { ::core::mem::transmute(Device) };
            Device as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Function: u64 = unsafe { ::core::mem::transmute(Function) };
            Function as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Mask: u64 = unsafe { ::core::mem::transmute(Mask) };
            Mask as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let CorrectableErrorCount: u64 =
                unsafe { ::core::mem::transmute(CorrectableErrorCount) };
            CorrectableErrorCount as u64
        });
        __bindgen_bitfield_unit.set(6usize, 58u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_PCIE_CORRECTABLE_ERROR_DEVICES_VALIDBITS =
_WHEA_PCIE_CORRECTABLE_ERROR_DEVICES_VALIDBITS;
pub type PWHEA_PCIE_CORRECTABLE_ERROR_DEVICES_VALIDBITS =
*mut _WHEA_PCIE_CORRECTABLE_ERROR_DEVICES_VALIDBITS;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_PCIE_CORRECTABLE_ERROR_DEVICES {
    pub ValidBits: WHEA_PCIE_CORRECTABLE_ERROR_DEVICES_VALIDBITS,
    pub Address: WHEA_PCIE_ADDRESS,
    pub Mask: UINT32,
    pub CorrectableErrorCount: [UINT32; 32usize],
}
pub type WHEA_PCIE_CORRECTABLE_ERROR_DEVICES = _WHEA_PCIE_CORRECTABLE_ERROR_DEVICES;
pub type PWHEA_PCIE_CORRECTABLE_ERROR_DEVICES = *mut _WHEA_PCIE_CORRECTABLE_ERROR_DEVICES;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_PCIE_CORRECTABLE_ERROR_SECTION_HEADER {
    pub Version: UINT16,
    pub Count: UINT16,
}
pub type WHEA_PCIE_CORRECTABLE_ERROR_SECTION_HEADER = _WHEA_PCIE_CORRECTABLE_ERROR_SECTION_HEADER;
pub type PWHEA_PCIE_CORRECTABLE_ERROR_SECTION_HEADER =
*mut _WHEA_PCIE_CORRECTABLE_ERROR_SECTION_HEADER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_PCIE_CORRECTABLE_ERROR_SECTION {
    pub Header: WHEA_PCIE_CORRECTABLE_ERROR_SECTION_HEADER,
    pub Devices: [WHEA_PCIE_CORRECTABLE_ERROR_DEVICES; 1usize],
}
pub type WHEA_PCIE_CORRECTABLE_ERROR_SECTION = _WHEA_PCIE_CORRECTABLE_ERROR_SECTION;
pub type PWHEA_PCIE_CORRECTABLE_ERROR_SECTION = *mut _WHEA_PCIE_CORRECTABLE_ERROR_SECTION;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_MEMORY_CORRECTABLE_ERROR_SECTION_VALIDBITS {
    pub __bindgen_anon_1: _WHEA_MEMORY_CORRECTABLE_ERROR_SECTION_VALIDBITS__bindgen_ty_1,
    pub ValidBits: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_MEMORY_CORRECTABLE_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _WHEA_MEMORY_CORRECTABLE_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    #[inline]
    pub fn SocketId(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_SocketId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SocketId_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_SocketId_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ChannelId(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ChannelId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ChannelId_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ChannelId_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DimmSlot(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_DimmSlot(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DimmSlot_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_DimmSlot_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CorrectableErrorCount(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_CorrectableErrorCount(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CorrectableErrorCount_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_CorrectableErrorCount_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 60u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 60u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                60u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                60u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SocketId: ULONGLONG,
        ChannelId: ULONGLONG,
        DimmSlot: ULONGLONG,
        CorrectableErrorCount: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SocketId: u64 = unsafe { ::core::mem::transmute(SocketId) };
            SocketId as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ChannelId: u64 = unsafe { ::core::mem::transmute(ChannelId) };
            ChannelId as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DimmSlot: u64 = unsafe { ::core::mem::transmute(DimmSlot) };
            DimmSlot as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let CorrectableErrorCount: u64 =
                unsafe { ::core::mem::transmute(CorrectableErrorCount) };
            CorrectableErrorCount as u64
        });
        __bindgen_bitfield_unit.set(4usize, 60u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_MEMORY_CORRECTABLE_ERROR_SECTION_VALIDBITS =
_WHEA_MEMORY_CORRECTABLE_ERROR_SECTION_VALIDBITS;
pub type PWHEA_MEMORY_CORRECTABLE_ERROR_SECTION_VALIDBITS =
*mut _WHEA_MEMORY_CORRECTABLE_ERROR_SECTION_VALIDBITS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_MEMORY_CORRECTABLE_ERROR_HEADER {
    pub Version: UINT16,
    pub Count: UINT16,
}
pub type WHEA_MEMORY_CORRECTABLE_ERROR_HEADER = _WHEA_MEMORY_CORRECTABLE_ERROR_HEADER;
pub type PWHEA_MEMORY_CORRECTABLE_ERROR_HEADER = *mut _WHEA_MEMORY_CORRECTABLE_ERROR_HEADER;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_MEMORY_CORRECTABLE_ERROR_DATA {
    pub ValidBits: WHEA_MEMORY_CORRECTABLE_ERROR_SECTION_VALIDBITS,
    pub SocketId: UINT32,
    pub ChannelId: UINT32,
    pub DimmSlot: UINT32,
    pub CorrectableErrorCount: UINT32,
}
pub type WHEA_MEMORY_CORRECTABLE_ERROR_DATA = _WHEA_MEMORY_CORRECTABLE_ERROR_DATA;
pub type PWHEA_MEMORY_CORRECTABLE_ERROR_DATA = *mut _WHEA_MEMORY_CORRECTABLE_ERROR_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_MEMORY_CORRECTABLE_ERROR_SECTION {
    pub Header: WHEA_MEMORY_CORRECTABLE_ERROR_HEADER,
    pub Data: [WHEA_MEMORY_CORRECTABLE_ERROR_DATA; 1usize],
}
pub type WHEA_MEMORY_CORRECTABLE_ERROR_SECTION = _WHEA_MEMORY_CORRECTABLE_ERROR_SECTION;
pub type PWHEA_MEMORY_CORRECTABLE_ERROR_SECTION = *mut _WHEA_MEMORY_CORRECTABLE_ERROR_SECTION;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS {
    pub __bindgen_anon_1: _WHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS__bindgen_ty_1,
    pub ValidBits: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _WHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    #[inline]
    pub fn PortType(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PortType(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PortType_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_PortType_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Version(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Version(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Version_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Version_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CommandStatus(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_CommandStatus(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CommandStatus_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_CommandStatus_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DeviceId(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_DeviceId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DeviceId_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_DeviceId_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DeviceSerialNumber(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_DeviceSerialNumber(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DeviceSerialNumber_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_DeviceSerialNumber_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn BridgeControlStatus(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_BridgeControlStatus(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn BridgeControlStatus_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_BridgeControlStatus_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ExpressCapability(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ExpressCapability(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ExpressCapability_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ExpressCapability_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AerInfo(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AerInfo(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AerInfo_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_AerInfo_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 56u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 56u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                56u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                56u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PortType: ULONGLONG,
        Version: ULONGLONG,
        CommandStatus: ULONGLONG,
        DeviceId: ULONGLONG,
        DeviceSerialNumber: ULONGLONG,
        BridgeControlStatus: ULONGLONG,
        ExpressCapability: ULONGLONG,
        AerInfo: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PortType: u64 = unsafe { ::core::mem::transmute(PortType) };
            PortType as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Version: u64 = unsafe { ::core::mem::transmute(Version) };
            Version as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CommandStatus: u64 = unsafe { ::core::mem::transmute(CommandStatus) };
            CommandStatus as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DeviceId: u64 = unsafe { ::core::mem::transmute(DeviceId) };
            DeviceId as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let DeviceSerialNumber: u64 = unsafe { ::core::mem::transmute(DeviceSerialNumber) };
            DeviceSerialNumber as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let BridgeControlStatus: u64 = unsafe { ::core::mem::transmute(BridgeControlStatus) };
            BridgeControlStatus as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ExpressCapability: u64 = unsafe { ::core::mem::transmute(ExpressCapability) };
            ExpressCapability as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let AerInfo: u64 = unsafe { ::core::mem::transmute(AerInfo) };
            AerInfo as u64
        });
        __bindgen_bitfield_unit.set(8usize, 56u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS = _WHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS;
pub type PWHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS = *mut _WHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_PCIEXPRESS_DEVICE_ID {
    pub VendorID: USHORT,
    pub DeviceID: USHORT,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 12usize]>,
}
impl _WHEA_PCIEXPRESS_DEVICE_ID {
    #[inline]
    pub fn ClassCode(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_ClassCode(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ClassCode_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ClassCode_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FunctionNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_FunctionNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FunctionNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FunctionNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DeviceNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_DeviceNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DeviceNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DeviceNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Segment(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(40usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_Segment(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Segment_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                40usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Segment_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PrimaryBusNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_PrimaryBusNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PrimaryBusNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                56usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PrimaryBusNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                56usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SecondaryBusNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(64usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_SecondaryBusNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(64usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SecondaryBusNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                64usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SecondaryBusNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                64usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(72usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(72usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                72usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                72usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SlotNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(75usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_SlotNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(75usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SlotNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                75usize,
                13u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SlotNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                75usize,
                13u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(88usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(88usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                88usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                88usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ClassCode: ULONG,
        FunctionNumber: ULONG,
        DeviceNumber: ULONG,
        Segment: ULONG,
        PrimaryBusNumber: ULONG,
        SecondaryBusNumber: ULONG,
        Reserved1: ULONG,
        SlotNumber: ULONG,
        Reserved2: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 12usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 12usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let ClassCode: u32 = unsafe { ::core::mem::transmute(ClassCode) };
            ClassCode as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let FunctionNumber: u32 = unsafe { ::core::mem::transmute(FunctionNumber) };
            FunctionNumber as u64
        });
        __bindgen_bitfield_unit.set(32usize, 8u8, {
            let DeviceNumber: u32 = unsafe { ::core::mem::transmute(DeviceNumber) };
            DeviceNumber as u64
        });
        __bindgen_bitfield_unit.set(40usize, 16u8, {
            let Segment: u32 = unsafe { ::core::mem::transmute(Segment) };
            Segment as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let PrimaryBusNumber: u32 = unsafe { ::core::mem::transmute(PrimaryBusNumber) };
            PrimaryBusNumber as u64
        });
        __bindgen_bitfield_unit.set(64usize, 8u8, {
            let SecondaryBusNumber: u32 = unsafe { ::core::mem::transmute(SecondaryBusNumber) };
            SecondaryBusNumber as u64
        });
        __bindgen_bitfield_unit.set(72usize, 3u8, {
            let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(75usize, 13u8, {
            let SlotNumber: u32 = unsafe { ::core::mem::transmute(SlotNumber) };
            SlotNumber as u64
        });
        __bindgen_bitfield_unit.set(88usize, 8u8, {
            let Reserved2: u32 = unsafe { ::core::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_PCIEXPRESS_DEVICE_ID = _WHEA_PCIEXPRESS_DEVICE_ID;
pub type PWHEA_PCIEXPRESS_DEVICE_ID = *mut _WHEA_PCIEXPRESS_DEVICE_ID;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_PCIEXPRESS_VERSION {
    pub __bindgen_anon_1: _WHEA_PCIEXPRESS_VERSION__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_PCIEXPRESS_VERSION__bindgen_ty_1 {
    pub MinorVersion: UCHAR,
    pub MajorVersion: UCHAR,
    pub Reserved: USHORT,
}
pub type WHEA_PCIEXPRESS_VERSION = _WHEA_PCIEXPRESS_VERSION;
pub type PWHEA_PCIEXPRESS_VERSION = *mut _WHEA_PCIEXPRESS_VERSION;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_PCIEXPRESS_COMMAND_STATUS {
    pub __bindgen_anon_1: _WHEA_PCIEXPRESS_COMMAND_STATUS__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_PCIEXPRESS_COMMAND_STATUS__bindgen_ty_1 {
    pub Command: USHORT,
    pub Status: USHORT,
}
pub type WHEA_PCIEXPRESS_COMMAND_STATUS = _WHEA_PCIEXPRESS_COMMAND_STATUS;
pub type PWHEA_PCIEXPRESS_COMMAND_STATUS = *mut _WHEA_PCIEXPRESS_COMMAND_STATUS;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS {
    pub __bindgen_anon_1: _WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS__bindgen_ty_1 {
    pub BridgeSecondaryStatus: USHORT,
    pub BridgeControl: USHORT,
}
pub type WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS = _WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS;
pub type PWHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS = *mut _WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS;
pub const _WHEA_PCIEXPRESS_DEVICE_TYPE_WheaPciExpressEndpoint: _WHEA_PCIEXPRESS_DEVICE_TYPE = 0;
pub const _WHEA_PCIEXPRESS_DEVICE_TYPE_WheaPciExpressLegacyEndpoint: _WHEA_PCIEXPRESS_DEVICE_TYPE =
    1;
pub const _WHEA_PCIEXPRESS_DEVICE_TYPE_WheaPciExpressRootPort: _WHEA_PCIEXPRESS_DEVICE_TYPE = 4;
pub const _WHEA_PCIEXPRESS_DEVICE_TYPE_WheaPciExpressUpstreamSwitchPort:
_WHEA_PCIEXPRESS_DEVICE_TYPE = 5;
pub const _WHEA_PCIEXPRESS_DEVICE_TYPE_WheaPciExpressDownstreamSwitchPort:
_WHEA_PCIEXPRESS_DEVICE_TYPE = 6;
pub const _WHEA_PCIEXPRESS_DEVICE_TYPE_WheaPciExpressToPciXBridge: _WHEA_PCIEXPRESS_DEVICE_TYPE = 7;
pub const _WHEA_PCIEXPRESS_DEVICE_TYPE_WheaPciXToExpressBridge: _WHEA_PCIEXPRESS_DEVICE_TYPE = 8;
pub const _WHEA_PCIEXPRESS_DEVICE_TYPE_WheaPciExpressRootComplexIntegratedEndpoint:
_WHEA_PCIEXPRESS_DEVICE_TYPE = 9;
pub const _WHEA_PCIEXPRESS_DEVICE_TYPE_WheaPciExpressRootComplexEventCollector:
_WHEA_PCIEXPRESS_DEVICE_TYPE = 10;
pub type _WHEA_PCIEXPRESS_DEVICE_TYPE = core::ffi::c_int;
pub use self::_WHEA_PCIEXPRESS_DEVICE_TYPE as WHEA_PCIEXPRESS_DEVICE_TYPE;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_PCIEXPRESS_ERROR_SECTION {
    pub ValidBits: WHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS,
    pub PortType: WHEA_PCIEXPRESS_DEVICE_TYPE,
    pub Version: WHEA_PCIEXPRESS_VERSION,
    pub CommandStatus: WHEA_PCIEXPRESS_COMMAND_STATUS,
    pub Reserved: ULONG,
    pub DeviceId: WHEA_PCIEXPRESS_DEVICE_ID,
    pub DeviceSerialNumber: ULONGLONG,
    pub BridgeControlStatus: WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS,
    pub ExpressCapability: [UCHAR; 60usize],
    pub AerInfo: [UCHAR; 96usize],
}
pub type WHEA_PCIEXPRESS_ERROR_SECTION = _WHEA_PCIEXPRESS_ERROR_SECTION;
pub type PWHEA_PCIEXPRESS_ERROR_SECTION = *mut _WHEA_PCIEXPRESS_ERROR_SECTION;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_PCIXBUS_ERROR_SECTION_VALIDBITS {
    pub __bindgen_anon_1: _WHEA_PCIXBUS_ERROR_SECTION_VALIDBITS__bindgen_ty_1,
    pub ValidBits: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_PCIXBUS_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _WHEA_PCIXBUS_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    #[inline]
    pub fn ErrorStatus(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ErrorStatus(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ErrorStatus_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ErrorStatus_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ErrorType(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ErrorType(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ErrorType_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ErrorType_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn BusId(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_BusId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn BusId_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_BusId_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn BusAddress(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_BusAddress(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn BusAddress_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_BusAddress_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn BusData(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_BusData(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn BusData_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_BusData_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn BusCommand(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_BusCommand(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn BusCommand_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_BusCommand_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RequesterId(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RequesterId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RequesterId_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_RequesterId_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CompleterId(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_CompleterId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CompleterId_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_CompleterId_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TargetId(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_TargetId(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TargetId_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_TargetId_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 55u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 55u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                55u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                55u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ErrorStatus: ULONGLONG,
        ErrorType: ULONGLONG,
        BusId: ULONGLONG,
        BusAddress: ULONGLONG,
        BusData: ULONGLONG,
        BusCommand: ULONGLONG,
        RequesterId: ULONGLONG,
        CompleterId: ULONGLONG,
        TargetId: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ErrorStatus: u64 = unsafe { ::core::mem::transmute(ErrorStatus) };
            ErrorStatus as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ErrorType: u64 = unsafe { ::core::mem::transmute(ErrorType) };
            ErrorType as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let BusId: u64 = unsafe { ::core::mem::transmute(BusId) };
            BusId as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let BusAddress: u64 = unsafe { ::core::mem::transmute(BusAddress) };
            BusAddress as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let BusData: u64 = unsafe { ::core::mem::transmute(BusData) };
            BusData as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let BusCommand: u64 = unsafe { ::core::mem::transmute(BusCommand) };
            BusCommand as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RequesterId: u64 = unsafe { ::core::mem::transmute(RequesterId) };
            RequesterId as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let CompleterId: u64 = unsafe { ::core::mem::transmute(CompleterId) };
            CompleterId as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let TargetId: u64 = unsafe { ::core::mem::transmute(TargetId) };
            TargetId as u64
        });
        __bindgen_bitfield_unit.set(9usize, 55u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_PCIXBUS_ERROR_SECTION_VALIDBITS = _WHEA_PCIXBUS_ERROR_SECTION_VALIDBITS;
pub type PWHEA_PCIXBUS_ERROR_SECTION_VALIDBITS = *mut _WHEA_PCIXBUS_ERROR_SECTION_VALIDBITS;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_PCIXBUS_ID {
    pub __bindgen_anon_1: _WHEA_PCIXBUS_ID__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_PCIXBUS_ID__bindgen_ty_1 {
    pub BusNumber: UCHAR,
    pub BusSegment: UCHAR,
}
pub type WHEA_PCIXBUS_ID = _WHEA_PCIXBUS_ID;
pub type PWHEA_PCIXBUS_ID = *mut _WHEA_PCIXBUS_ID;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_PCIXBUS_COMMAND {
    pub __bindgen_anon_1: _WHEA_PCIXBUS_COMMAND__bindgen_ty_1,
    pub AsULONGLONG: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_PCIXBUS_COMMAND__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _WHEA_PCIXBUS_COMMAND__bindgen_ty_1 {
    #[inline]
    pub fn Command(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 56u8) as u64) }
    }
    #[inline]
    pub fn set_Command(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 56u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Command_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                56u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Command_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                56u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PCIXCommand(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(56usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PCIXCommand(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(56usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PCIXCommand_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                56usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_PCIXCommand_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                56usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(57usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(57usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                57usize,
                7u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                57usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Command: ULONGLONG,
        PCIXCommand: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 56u8, {
            let Command: u64 = unsafe { ::core::mem::transmute(Command) };
            Command as u64
        });
        __bindgen_bitfield_unit.set(56usize, 1u8, {
            let PCIXCommand: u64 = unsafe { ::core::mem::transmute(PCIXCommand) };
            PCIXCommand as u64
        });
        __bindgen_bitfield_unit.set(57usize, 7u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_PCIXBUS_COMMAND = _WHEA_PCIXBUS_COMMAND;
pub type PWHEA_PCIXBUS_COMMAND = *mut _WHEA_PCIXBUS_COMMAND;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_PCIXBUS_ERROR_SECTION {
    pub ValidBits: WHEA_PCIXBUS_ERROR_SECTION_VALIDBITS,
    pub ErrorStatus: WHEA_ERROR_STATUS,
    pub ErrorType: USHORT,
    pub BusId: WHEA_PCIXBUS_ID,
    pub Reserved: ULONG,
    pub BusAddress: ULONGLONG,
    pub BusData: ULONGLONG,
    pub BusCommand: WHEA_PCIXBUS_COMMAND,
    pub RequesterId: ULONGLONG,
    pub CompleterId: ULONGLONG,
    pub TargetId: ULONGLONG,
}
pub type WHEA_PCIXBUS_ERROR_SECTION = _WHEA_PCIXBUS_ERROR_SECTION;
pub type PWHEA_PCIXBUS_ERROR_SECTION = *mut _WHEA_PCIXBUS_ERROR_SECTION;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS {
    pub __bindgen_anon_1: _WHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS__bindgen_ty_1,
    pub ValidBits: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _WHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS__bindgen_ty_1 {
    #[inline]
    pub fn ErrorStatus(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ErrorStatus(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ErrorStatus_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ErrorStatus_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IdInfo(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_IdInfo(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IdInfo_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_IdInfo_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemoryNumber(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_MemoryNumber(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemoryNumber_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_MemoryNumber_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IoNumber(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_IoNumber(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IoNumber_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_IoNumber_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RegisterDataPairs(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RegisterDataPairs(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RegisterDataPairs_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_RegisterDataPairs_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 59u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 59u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                59u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                59u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ErrorStatus: ULONGLONG,
        IdInfo: ULONGLONG,
        MemoryNumber: ULONGLONG,
        IoNumber: ULONGLONG,
        RegisterDataPairs: ULONGLONG,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ErrorStatus: u64 = unsafe { ::core::mem::transmute(ErrorStatus) };
            ErrorStatus as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let IdInfo: u64 = unsafe { ::core::mem::transmute(IdInfo) };
            IdInfo as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let MemoryNumber: u64 = unsafe { ::core::mem::transmute(MemoryNumber) };
            MemoryNumber as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let IoNumber: u64 = unsafe { ::core::mem::transmute(IoNumber) };
            IoNumber as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let RegisterDataPairs: u64 = unsafe { ::core::mem::transmute(RegisterDataPairs) };
            RegisterDataPairs as u64
        });
        __bindgen_bitfield_unit.set(5usize, 59u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS = _WHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS;
pub type PWHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS = *mut _WHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_PCIXDEVICE_ID {
    pub VendorId: USHORT,
    pub DeviceId: USHORT,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub Reserved2: ULONG,
}
impl _WHEA_PCIXDEVICE_ID {
    #[inline]
    pub fn ClassCode(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_ClassCode(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ClassCode_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ClassCode_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FunctionNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_FunctionNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FunctionNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FunctionNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DeviceNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_DeviceNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DeviceNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DeviceNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn BusNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(40usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BusNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn BusNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                40usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_BusNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SegmentNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(48usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_SegmentNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(48usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SegmentNumber_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                48usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SegmentNumber_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                48usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                56usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                56usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ClassCode: ULONG,
        FunctionNumber: ULONG,
        DeviceNumber: ULONG,
        BusNumber: ULONG,
        SegmentNumber: ULONG,
        Reserved1: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let ClassCode: u32 = unsafe { ::core::mem::transmute(ClassCode) };
            ClassCode as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let FunctionNumber: u32 = unsafe { ::core::mem::transmute(FunctionNumber) };
            FunctionNumber as u64
        });
        __bindgen_bitfield_unit.set(32usize, 8u8, {
            let DeviceNumber: u32 = unsafe { ::core::mem::transmute(DeviceNumber) };
            DeviceNumber as u64
        });
        __bindgen_bitfield_unit.set(40usize, 8u8, {
            let BusNumber: u32 = unsafe { ::core::mem::transmute(BusNumber) };
            BusNumber as u64
        });
        __bindgen_bitfield_unit.set(48usize, 8u8, {
            let SegmentNumber: u32 = unsafe { ::core::mem::transmute(SegmentNumber) };
            SegmentNumber as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_PCIXDEVICE_ID = _WHEA_PCIXDEVICE_ID;
pub type PWHEA_PCIXDEVICE_ID = *mut _WHEA_PCIXDEVICE_ID;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct WHEA_PCIXDEVICE_REGISTER_PAIR {
    pub Register: ULONGLONG,
    pub Data: ULONGLONG,
}
pub type PWHEA_PCIXDEVICE_REGISTER_PAIR = *mut WHEA_PCIXDEVICE_REGISTER_PAIR;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_PCIXDEVICE_ERROR_SECTION {
    pub ValidBits: WHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS,
    pub ErrorStatus: WHEA_ERROR_STATUS,
    pub IdInfo: WHEA_PCIXDEVICE_ID,
    pub MemoryNumber: ULONG,
    pub IoNumber: ULONG,
    pub RegisterDataPairs: [WHEA_PCIXDEVICE_REGISTER_PAIR; 1usize],
}
pub type WHEA_PCIXDEVICE_ERROR_SECTION = _WHEA_PCIXDEVICE_ERROR_SECTION;
pub type PWHEA_PCIXDEVICE_ERROR_SECTION = *mut _WHEA_PCIXDEVICE_ERROR_SECTION;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_FIRMWARE_ERROR_RECORD_REFERENCE {
    pub Type: UCHAR,
    pub Reserved: [UCHAR; 7usize],
    pub FirmwareRecordId: ULONGLONG,
}
pub type WHEA_FIRMWARE_ERROR_RECORD_REFERENCE = _WHEA_FIRMWARE_ERROR_RECORD_REFERENCE;
pub type PWHEA_FIRMWARE_ERROR_RECORD_REFERENCE = *mut _WHEA_FIRMWARE_ERROR_RECORD_REFERENCE;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _MCG_CAP {
    pub __bindgen_anon_1: _MCG_CAP__bindgen_ty_1,
    pub QuadPart: ULONG64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MCG_CAP__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_padding_0: u32,
}
impl _MCG_CAP__bindgen_ty_1 {
    #[inline]
    pub fn CountField(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_CountField(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CountField_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_CountField_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ControlMsrPresent(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ControlMsrPresent(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ControlMsrPresent_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ControlMsrPresent_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ExtendedMsrsPresent(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ExtendedMsrsPresent(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ExtendedMsrsPresent_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ExtendedMsrsPresent_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SignalingExtensionPresent(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_SignalingExtensionPresent(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SignalingExtensionPresent_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_SignalingExtensionPresent_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ThresholdErrorStatusPresent(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ThresholdErrorStatusPresent(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ThresholdErrorStatusPresent_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ThresholdErrorStatusPresent_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                4u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ExtendedRegisterCount(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_ExtendedRegisterCount(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ExtendedRegisterCount_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ExtendedRegisterCount_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SoftwareErrorRecoverySupported(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_SoftwareErrorRecoverySupported(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SoftwareErrorRecoverySupported_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_SoftwareErrorRecoverySupported_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn EnhancedMachineCheckCapability(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_EnhancedMachineCheckCapability(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn EnhancedMachineCheckCapability_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_EnhancedMachineCheckCapability_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ExtendedErrorLogging(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ExtendedErrorLogging(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ExtendedErrorLogging_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ExtendedErrorLogging_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LocalMachineCheckException(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_LocalMachineCheckException(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LocalMachineCheckException_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_LocalMachineCheckException_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CountField: ULONG64,
        ControlMsrPresent: ULONG64,
        ExtendedMsrsPresent: ULONG64,
        SignalingExtensionPresent: ULONG64,
        ThresholdErrorStatusPresent: ULONG64,
        Reserved: ULONG64,
        ExtendedRegisterCount: ULONG64,
        SoftwareErrorRecoverySupported: ULONG64,
        EnhancedMachineCheckCapability: ULONG64,
        ExtendedErrorLogging: ULONG64,
        LocalMachineCheckException: ULONG64,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let CountField: u64 = unsafe { ::core::mem::transmute(CountField) };
            CountField as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ControlMsrPresent: u64 = unsafe { ::core::mem::transmute(ControlMsrPresent) };
            ControlMsrPresent as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let ExtendedMsrsPresent: u64 = unsafe { ::core::mem::transmute(ExtendedMsrsPresent) };
            ExtendedMsrsPresent as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let SignalingExtensionPresent: u64 =
                unsafe { ::core::mem::transmute(SignalingExtensionPresent) };
            SignalingExtensionPresent as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let ThresholdErrorStatusPresent: u64 =
                unsafe { ::core::mem::transmute(ThresholdErrorStatusPresent) };
            ThresholdErrorStatusPresent as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let ExtendedRegisterCount: u64 =
                unsafe { ::core::mem::transmute(ExtendedRegisterCount) };
            ExtendedRegisterCount as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let SoftwareErrorRecoverySupported: u64 =
                unsafe { ::core::mem::transmute(SoftwareErrorRecoverySupported) };
            SoftwareErrorRecoverySupported as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let EnhancedMachineCheckCapability: u64 =
                unsafe { ::core::mem::transmute(EnhancedMachineCheckCapability) };
            EnhancedMachineCheckCapability as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let ExtendedErrorLogging: u64 = unsafe { ::core::mem::transmute(ExtendedErrorLogging) };
            ExtendedErrorLogging as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let LocalMachineCheckException: u64 =
                unsafe { ::core::mem::transmute(LocalMachineCheckException) };
            LocalMachineCheckException as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type MCG_CAP = _MCG_CAP;
pub type PMCG_CAP = *mut _MCG_CAP;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _MCG_STATUS {
    pub __bindgen_anon_1: _MCG_STATUS__bindgen_ty_1,
    pub QuadPart: ULONGLONG,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _MCG_STATUS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub Reserved2: ULONG,
}
impl _MCG_STATUS__bindgen_ty_1 {
    #[inline]
    pub fn RestartIpValid(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RestartIpValid(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RestartIpValid_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RestartIpValid_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ErrorIpValid(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ErrorIpValid(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ErrorIpValid_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ErrorIpValid_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MachineCheckInProgress(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MachineCheckInProgress(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MachineCheckInProgress_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MachineCheckInProgress_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LocalMceValid(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LocalMceValid(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LocalMceValid_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_LocalMceValid_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                28u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                28u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RestartIpValid: ULONG,
        ErrorIpValid: ULONG,
        MachineCheckInProgress: ULONG,
        LocalMceValid: ULONG,
        Reserved1: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let RestartIpValid: u32 = unsafe { ::core::mem::transmute(RestartIpValid) };
            RestartIpValid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ErrorIpValid: u32 = unsafe { ::core::mem::transmute(ErrorIpValid) };
            ErrorIpValid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let MachineCheckInProgress: u32 =
                unsafe { ::core::mem::transmute(MachineCheckInProgress) };
            MachineCheckInProgress as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let LocalMceValid: u32 = unsafe { ::core::mem::transmute(LocalMceValid) };
            LocalMceValid as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type MCG_STATUS = _MCG_STATUS;
pub type PMCG_STATUS = *mut _MCG_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MCI_STATUS_BITS_COMMON {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _MCI_STATUS_BITS_COMMON {
    #[inline]
    pub fn McaErrorCode(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_McaErrorCode(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn McaErrorCode_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_McaErrorCode_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ModelErrorCode(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_ModelErrorCode(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ModelErrorCode_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ModelErrorCode_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 25u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                25u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                25u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ContextCorrupt(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(57usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ContextCorrupt(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(57usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ContextCorrupt_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                57usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ContextCorrupt_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                57usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AddressValid(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(58usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AddressValid(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(58usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AddressValid_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                58usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_AddressValid_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                58usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MiscValid(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(59usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_MiscValid(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MiscValid_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                59usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_MiscValid_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                59usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ErrorEnabled(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(60usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ErrorEnabled(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(60usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ErrorEnabled_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                60usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ErrorEnabled_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                60usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectedError(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(61usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_UncorrectedError(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(61usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectedError_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                61usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectedError_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                61usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn StatusOverFlow(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(62usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_StatusOverFlow(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(62usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn StatusOverFlow_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                62usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_StatusOverFlow_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                62usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Valid(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Valid(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Valid_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                63usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Valid_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                63usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        McaErrorCode: ULONG64,
        ModelErrorCode: ULONG64,
        Reserved: ULONG64,
        ContextCorrupt: ULONG64,
        AddressValid: ULONG64,
        MiscValid: ULONG64,
        ErrorEnabled: ULONG64,
        UncorrectedError: ULONG64,
        StatusOverFlow: ULONG64,
        Valid: ULONG64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let McaErrorCode: u64 = unsafe { ::core::mem::transmute(McaErrorCode) };
            McaErrorCode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let ModelErrorCode: u64 = unsafe { ::core::mem::transmute(ModelErrorCode) };
            ModelErrorCode as u64
        });
        __bindgen_bitfield_unit.set(32usize, 25u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(57usize, 1u8, {
            let ContextCorrupt: u64 = unsafe { ::core::mem::transmute(ContextCorrupt) };
            ContextCorrupt as u64
        });
        __bindgen_bitfield_unit.set(58usize, 1u8, {
            let AddressValid: u64 = unsafe { ::core::mem::transmute(AddressValid) };
            AddressValid as u64
        });
        __bindgen_bitfield_unit.set(59usize, 1u8, {
            let MiscValid: u64 = unsafe { ::core::mem::transmute(MiscValid) };
            MiscValid as u64
        });
        __bindgen_bitfield_unit.set(60usize, 1u8, {
            let ErrorEnabled: u64 = unsafe { ::core::mem::transmute(ErrorEnabled) };
            ErrorEnabled as u64
        });
        __bindgen_bitfield_unit.set(61usize, 1u8, {
            let UncorrectedError: u64 = unsafe { ::core::mem::transmute(UncorrectedError) };
            UncorrectedError as u64
        });
        __bindgen_bitfield_unit.set(62usize, 1u8, {
            let StatusOverFlow: u64 = unsafe { ::core::mem::transmute(StatusOverFlow) };
            StatusOverFlow as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let Valid: u64 = unsafe { ::core::mem::transmute(Valid) };
            Valid as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type MCI_STATUS_BITS_COMMON = _MCI_STATUS_BITS_COMMON;
pub type PMCI_STATUS_BITS_COMMON = *mut _MCI_STATUS_BITS_COMMON;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MCI_STATUS_AMD_BITS {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _MCI_STATUS_AMD_BITS {
    #[inline]
    pub fn McaErrorCode(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_McaErrorCode(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn McaErrorCode_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_McaErrorCode_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ModelErrorCode(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_ModelErrorCode(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ModelErrorCode_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ModelErrorCode_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ImplementationSpecific2(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 11u8) as u64) }
    }
    #[inline]
    pub fn set_ImplementationSpecific2(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ImplementationSpecific2_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                11u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ImplementationSpecific2_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                11u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Poison(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(43usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Poison(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(43usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Poison_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                43usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Poison_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                43usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Deferred(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(44usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Deferred(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(44usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Deferred_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                44usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Deferred_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                44usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ImplementationSpecific1(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(45usize, 12u8) as u64) }
    }
    #[inline]
    pub fn set_ImplementationSpecific1(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(45usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ImplementationSpecific1_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                45usize,
                12u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ImplementationSpecific1_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                45usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ContextCorrupt(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(57usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ContextCorrupt(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(57usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ContextCorrupt_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                57usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ContextCorrupt_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                57usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AddressValid(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(58usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AddressValid(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(58usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AddressValid_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                58usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_AddressValid_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                58usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MiscValid(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(59usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_MiscValid(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MiscValid_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                59usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_MiscValid_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                59usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ErrorEnabled(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(60usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ErrorEnabled(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(60usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ErrorEnabled_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                60usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ErrorEnabled_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                60usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectedError(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(61usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_UncorrectedError(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(61usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectedError_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                61usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectedError_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                61usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn StatusOverFlow(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(62usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_StatusOverFlow(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(62usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn StatusOverFlow_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                62usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_StatusOverFlow_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                62usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Valid(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Valid(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Valid_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                63usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Valid_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                63usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        McaErrorCode: ULONG64,
        ModelErrorCode: ULONG64,
        ImplementationSpecific2: ULONG64,
        Poison: ULONG64,
        Deferred: ULONG64,
        ImplementationSpecific1: ULONG64,
        ContextCorrupt: ULONG64,
        AddressValid: ULONG64,
        MiscValid: ULONG64,
        ErrorEnabled: ULONG64,
        UncorrectedError: ULONG64,
        StatusOverFlow: ULONG64,
        Valid: ULONG64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let McaErrorCode: u64 = unsafe { ::core::mem::transmute(McaErrorCode) };
            McaErrorCode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let ModelErrorCode: u64 = unsafe { ::core::mem::transmute(ModelErrorCode) };
            ModelErrorCode as u64
        });
        __bindgen_bitfield_unit.set(32usize, 11u8, {
            let ImplementationSpecific2: u64 =
                unsafe { ::core::mem::transmute(ImplementationSpecific2) };
            ImplementationSpecific2 as u64
        });
        __bindgen_bitfield_unit.set(43usize, 1u8, {
            let Poison: u64 = unsafe { ::core::mem::transmute(Poison) };
            Poison as u64
        });
        __bindgen_bitfield_unit.set(44usize, 1u8, {
            let Deferred: u64 = unsafe { ::core::mem::transmute(Deferred) };
            Deferred as u64
        });
        __bindgen_bitfield_unit.set(45usize, 12u8, {
            let ImplementationSpecific1: u64 =
                unsafe { ::core::mem::transmute(ImplementationSpecific1) };
            ImplementationSpecific1 as u64
        });
        __bindgen_bitfield_unit.set(57usize, 1u8, {
            let ContextCorrupt: u64 = unsafe { ::core::mem::transmute(ContextCorrupt) };
            ContextCorrupt as u64
        });
        __bindgen_bitfield_unit.set(58usize, 1u8, {
            let AddressValid: u64 = unsafe { ::core::mem::transmute(AddressValid) };
            AddressValid as u64
        });
        __bindgen_bitfield_unit.set(59usize, 1u8, {
            let MiscValid: u64 = unsafe { ::core::mem::transmute(MiscValid) };
            MiscValid as u64
        });
        __bindgen_bitfield_unit.set(60usize, 1u8, {
            let ErrorEnabled: u64 = unsafe { ::core::mem::transmute(ErrorEnabled) };
            ErrorEnabled as u64
        });
        __bindgen_bitfield_unit.set(61usize, 1u8, {
            let UncorrectedError: u64 = unsafe { ::core::mem::transmute(UncorrectedError) };
            UncorrectedError as u64
        });
        __bindgen_bitfield_unit.set(62usize, 1u8, {
            let StatusOverFlow: u64 = unsafe { ::core::mem::transmute(StatusOverFlow) };
            StatusOverFlow as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let Valid: u64 = unsafe { ::core::mem::transmute(Valid) };
            Valid as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type MCI_STATUS_AMD_BITS = _MCI_STATUS_AMD_BITS;
pub type PMCI_STATUS_AMD_BITS = *mut _MCI_STATUS_AMD_BITS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MCI_STATUS_INTEL_BITS {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _MCI_STATUS_INTEL_BITS {
    #[inline]
    pub fn McaErrorCode(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_McaErrorCode(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn McaErrorCode_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_McaErrorCode_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ModelErrorCode(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_ModelErrorCode(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ModelErrorCode_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ModelErrorCode_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn OtherInfo(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_OtherInfo(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn OtherInfo_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                5u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_OtherInfo_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FirmwareUpdateError(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_FirmwareUpdateError(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FirmwareUpdateError_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                37usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_FirmwareUpdateError_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                37usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CorrectedErrorCount(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(38usize, 15u8) as u64) }
    }
    #[inline]
    pub fn set_CorrectedErrorCount(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(38usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CorrectedErrorCount_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                38usize,
                15u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_CorrectedErrorCount_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                38usize,
                15u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ThresholdErrorStatus(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(53usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_ThresholdErrorStatus(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(53usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ThresholdErrorStatus_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                53usize,
                2u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ThresholdErrorStatus_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                53usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ActionRequired(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(55usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ActionRequired(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(55usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ActionRequired_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                55usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ActionRequired_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                55usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Signalling(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(56usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Signalling(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(56usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Signalling_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                56usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Signalling_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                56usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ContextCorrupt(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(57usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ContextCorrupt(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(57usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ContextCorrupt_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                57usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ContextCorrupt_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                57usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AddressValid(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(58usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AddressValid(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(58usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AddressValid_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                58usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_AddressValid_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                58usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MiscValid(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(59usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_MiscValid(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MiscValid_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                59usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_MiscValid_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                59usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ErrorEnabled(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(60usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ErrorEnabled(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(60usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ErrorEnabled_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                60usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ErrorEnabled_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                60usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UncorrectedError(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(61usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_UncorrectedError(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(61usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectedError_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                61usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectedError_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                61usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn StatusOverFlow(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(62usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_StatusOverFlow(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(62usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn StatusOverFlow_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                62usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_StatusOverFlow_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                62usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Valid(&self) -> ULONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Valid(&mut self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Valid_raw(this: *const Self) -> ULONG64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                63usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Valid_raw(this: *mut Self, val: ULONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                63usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        McaErrorCode: ULONG64,
        ModelErrorCode: ULONG64,
        OtherInfo: ULONG64,
        FirmwareUpdateError: ULONG64,
        CorrectedErrorCount: ULONG64,
        ThresholdErrorStatus: ULONG64,
        ActionRequired: ULONG64,
        Signalling: ULONG64,
        ContextCorrupt: ULONG64,
        AddressValid: ULONG64,
        MiscValid: ULONG64,
        ErrorEnabled: ULONG64,
        UncorrectedError: ULONG64,
        StatusOverFlow: ULONG64,
        Valid: ULONG64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let McaErrorCode: u64 = unsafe { ::core::mem::transmute(McaErrorCode) };
            McaErrorCode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let ModelErrorCode: u64 = unsafe { ::core::mem::transmute(ModelErrorCode) };
            ModelErrorCode as u64
        });
        __bindgen_bitfield_unit.set(32usize, 5u8, {
            let OtherInfo: u64 = unsafe { ::core::mem::transmute(OtherInfo) };
            OtherInfo as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let FirmwareUpdateError: u64 = unsafe { ::core::mem::transmute(FirmwareUpdateError) };
            FirmwareUpdateError as u64
        });
        __bindgen_bitfield_unit.set(38usize, 15u8, {
            let CorrectedErrorCount: u64 = unsafe { ::core::mem::transmute(CorrectedErrorCount) };
            CorrectedErrorCount as u64
        });
        __bindgen_bitfield_unit.set(53usize, 2u8, {
            let ThresholdErrorStatus: u64 = unsafe { ::core::mem::transmute(ThresholdErrorStatus) };
            ThresholdErrorStatus as u64
        });
        __bindgen_bitfield_unit.set(55usize, 1u8, {
            let ActionRequired: u64 = unsafe { ::core::mem::transmute(ActionRequired) };
            ActionRequired as u64
        });
        __bindgen_bitfield_unit.set(56usize, 1u8, {
            let Signalling: u64 = unsafe { ::core::mem::transmute(Signalling) };
            Signalling as u64
        });
        __bindgen_bitfield_unit.set(57usize, 1u8, {
            let ContextCorrupt: u64 = unsafe { ::core::mem::transmute(ContextCorrupt) };
            ContextCorrupt as u64
        });
        __bindgen_bitfield_unit.set(58usize, 1u8, {
            let AddressValid: u64 = unsafe { ::core::mem::transmute(AddressValid) };
            AddressValid as u64
        });
        __bindgen_bitfield_unit.set(59usize, 1u8, {
            let MiscValid: u64 = unsafe { ::core::mem::transmute(MiscValid) };
            MiscValid as u64
        });
        __bindgen_bitfield_unit.set(60usize, 1u8, {
            let ErrorEnabled: u64 = unsafe { ::core::mem::transmute(ErrorEnabled) };
            ErrorEnabled as u64
        });
        __bindgen_bitfield_unit.set(61usize, 1u8, {
            let UncorrectedError: u64 = unsafe { ::core::mem::transmute(UncorrectedError) };
            UncorrectedError as u64
        });
        __bindgen_bitfield_unit.set(62usize, 1u8, {
            let StatusOverFlow: u64 = unsafe { ::core::mem::transmute(StatusOverFlow) };
            StatusOverFlow as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let Valid: u64 = unsafe { ::core::mem::transmute(Valid) };
            Valid as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type MCI_STATUS_INTEL_BITS = _MCI_STATUS_INTEL_BITS;
pub type PMCI_STATUS_INTEL_BITS = *mut _MCI_STATUS_INTEL_BITS;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _MCI_STATUS {
    pub CommonBits: MCI_STATUS_BITS_COMMON,
    pub AmdBits: MCI_STATUS_AMD_BITS,
    pub IntelBits: MCI_STATUS_INTEL_BITS,
    pub QuadPart: ULONG64,
}
pub type MCI_STATUS = _MCI_STATUS;
pub type PMCI_STATUS = *mut _MCI_STATUS;
pub const _WHEA_CPU_VENDOR_WheaCpuVendorOther: _WHEA_CPU_VENDOR = 0;
pub const _WHEA_CPU_VENDOR_WheaCpuVendorIntel: _WHEA_CPU_VENDOR = 1;
pub const _WHEA_CPU_VENDOR_WheaCpuVendorAmd: _WHEA_CPU_VENDOR = 2;
pub type _WHEA_CPU_VENDOR = core::ffi::c_int;
pub use self::_WHEA_CPU_VENDOR as WHEA_CPU_VENDOR;
pub type PWHEA_CPU_VENDOR = *mut _WHEA_CPU_VENDOR;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_AMD_EXTENDED_REGISTERS {
    pub IPID: ULONGLONG,
    pub SYND: ULONGLONG,
    pub CONFIG: ULONGLONG,
    pub DESTAT: ULONGLONG,
    pub DEADDR: ULONGLONG,
    pub MISC1: ULONGLONG,
    pub MISC2: ULONGLONG,
    pub MISC3: ULONGLONG,
    pub MISC4: ULONGLONG,
    pub RasCap: ULONGLONG,
    pub Reserved: [ULONGLONG; 14usize],
}
pub type WHEA_AMD_EXTENDED_REGISTERS = _WHEA_AMD_EXTENDED_REGISTERS;
pub type PWHEA_AMD_EXTENDED_REGISTERS = *mut _WHEA_AMD_EXTENDED_REGISTERS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _XPF_RECOVERY_INFO {
    pub FailureReason: _XPF_RECOVERY_INFO__bindgen_ty_1,
    pub Action: _XPF_RECOVERY_INFO__bindgen_ty_2,
    pub ActionRequired: BOOLEAN,
    pub RecoverySucceeded: BOOLEAN,
    pub RecoveryKernel: BOOLEAN,
    pub Reserved: UINT8,
    pub Reserved2: UINT16,
    pub Reserved3: UINT16,
    pub Reserved4: UINT32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XPF_RECOVERY_INFO__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _XPF_RECOVERY_INFO__bindgen_ty_1 {
    #[inline]
    pub fn NotSupported(&self) -> UINT32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NotSupported(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NotSupported_raw(this: *const Self) -> UINT32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NotSupported_raw(this: *mut Self, val: UINT32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Overflow(&self) -> UINT32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Overflow(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Overflow_raw(this: *const Self) -> UINT32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Overflow_raw(this: *mut Self, val: UINT32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ContextCorrupt(&self) -> UINT32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ContextCorrupt(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ContextCorrupt_raw(this: *const Self) -> UINT32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ContextCorrupt_raw(this: *mut Self, val: UINT32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RestartIpErrorIpNotValid(&self) -> UINT32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RestartIpErrorIpNotValid(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RestartIpErrorIpNotValid_raw(this: *const Self) -> UINT32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RestartIpErrorIpNotValid_raw(this: *mut Self, val: UINT32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NoRecoveryContext(&self) -> UINT32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoRecoveryContext(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NoRecoveryContext_raw(this: *const Self) -> UINT32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NoRecoveryContext_raw(this: *mut Self, val: UINT32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MiscOrAddrNotValid(&self) -> UINT32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MiscOrAddrNotValid(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MiscOrAddrNotValid_raw(this: *const Self) -> UINT32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MiscOrAddrNotValid_raw(this: *mut Self, val: UINT32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn InvalidAddressMode(&self) -> UINT32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InvalidAddressMode(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InvalidAddressMode_raw(this: *const Self) -> UINT32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_InvalidAddressMode_raw(this: *mut Self, val: UINT32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn HighIrql(&self) -> UINT32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HighIrql(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn HighIrql_raw(this: *const Self) -> UINT32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_HighIrql_raw(this: *mut Self, val: UINT32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn InterruptsDisabled(&self) -> UINT32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InterruptsDisabled(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn InterruptsDisabled_raw(this: *const Self) -> UINT32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_InterruptsDisabled_raw(this: *mut Self, val: UINT32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SwapBusy(&self) -> UINT32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SwapBusy(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SwapBusy_raw(this: *const Self) -> UINT32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SwapBusy_raw(this: *mut Self, val: UINT32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn StackOverflow(&self) -> UINT32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_StackOverflow(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn StackOverflow_raw(this: *const Self) -> UINT32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_StackOverflow_raw(this: *mut Self, val: UINT32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> UINT32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                21u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: UINT32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                21u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NotSupported: UINT32,
        Overflow: UINT32,
        ContextCorrupt: UINT32,
        RestartIpErrorIpNotValid: UINT32,
        NoRecoveryContext: UINT32,
        MiscOrAddrNotValid: UINT32,
        InvalidAddressMode: UINT32,
        HighIrql: UINT32,
        InterruptsDisabled: UINT32,
        SwapBusy: UINT32,
        StackOverflow: UINT32,
        Reserved: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let NotSupported: u32 = unsafe { ::core::mem::transmute(NotSupported) };
            NotSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Overflow: u32 = unsafe { ::core::mem::transmute(Overflow) };
            Overflow as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ContextCorrupt: u32 = unsafe { ::core::mem::transmute(ContextCorrupt) };
            ContextCorrupt as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let RestartIpErrorIpNotValid: u32 =
                unsafe { ::core::mem::transmute(RestartIpErrorIpNotValid) };
            RestartIpErrorIpNotValid as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let NoRecoveryContext: u32 = unsafe { ::core::mem::transmute(NoRecoveryContext) };
            NoRecoveryContext as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let MiscOrAddrNotValid: u32 = unsafe { ::core::mem::transmute(MiscOrAddrNotValid) };
            MiscOrAddrNotValid as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let InvalidAddressMode: u32 = unsafe { ::core::mem::transmute(InvalidAddressMode) };
            InvalidAddressMode as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let HighIrql: u32 = unsafe { ::core::mem::transmute(HighIrql) };
            HighIrql as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let InterruptsDisabled: u32 = unsafe { ::core::mem::transmute(InterruptsDisabled) };
            InterruptsDisabled as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let SwapBusy: u32 = unsafe { ::core::mem::transmute(SwapBusy) };
            SwapBusy as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let StackOverflow: u32 = unsafe { ::core::mem::transmute(StackOverflow) };
            StackOverflow as u64
        });
        __bindgen_bitfield_unit.set(11usize, 21u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XPF_RECOVERY_INFO__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _XPF_RECOVERY_INFO__bindgen_ty_2 {
    #[inline]
    pub fn RecoveryAttempted(&self) -> UINT32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RecoveryAttempted(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RecoveryAttempted_raw(this: *const Self) -> UINT32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RecoveryAttempted_raw(this: *mut Self, val: UINT32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn HvHandled(&self) -> UINT32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HvHandled(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn HvHandled_raw(this: *const Self) -> UINT32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_HvHandled_raw(this: *mut Self, val: UINT32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> UINT32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: UINT32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RecoveryAttempted: UINT32,
        HvHandled: UINT32,
        Reserved: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let RecoveryAttempted: u32 = unsafe { ::core::mem::transmute(RecoveryAttempted) };
            RecoveryAttempted as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let HvHandled: u32 = unsafe { ::core::mem::transmute(HvHandled) };
            HvHandled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type XPF_RECOVERY_INFO = _XPF_RECOVERY_INFO;
pub type PXPF_RECOVERY_INFO = *mut _XPF_RECOVERY_INFO;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_XPF_MCA_SECTION {
    pub VersionNumber: ULONG,
    pub CpuVendor: WHEA_CPU_VENDOR,
    pub Timestamp: LARGE_INTEGER,
    pub ProcessorNumber: ULONG,
    pub GlobalStatus: MCG_STATUS,
    pub InstructionPointer: ULONGLONG,
    pub BankNumber: ULONG,
    pub Status: MCI_STATUS,
    pub Address: ULONGLONG,
    pub Misc: ULONGLONG,
    pub ExtendedRegisterCount: ULONG,
    pub ApicId: ULONG,
    pub __bindgen_anon_1: _WHEA_XPF_MCA_SECTION__bindgen_ty_1,
    pub GlobalCapability: MCG_CAP,
    pub RecoveryInfo: XPF_RECOVERY_INFO,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_XPF_MCA_SECTION__bindgen_ty_1 {
    pub ExtendedRegisters: [ULONGLONG; 24usize],
    pub AMDExtendedRegisters: WHEA_AMD_EXTENDED_REGISTERS,
}
pub type WHEA_XPF_MCA_SECTION = _WHEA_XPF_MCA_SECTION;
pub type PWHEA_XPF_MCA_SECTION = *mut _WHEA_XPF_MCA_SECTION;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_NMI_ERROR_SECTION_FLAGS {
    pub __bindgen_anon_1: _WHEA_NMI_ERROR_SECTION_FLAGS__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_NMI_ERROR_SECTION_FLAGS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _WHEA_NMI_ERROR_SECTION_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn HypervisorError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HypervisorError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn HypervisorError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_HypervisorError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        HypervisorError: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let HypervisorError: u32 = unsafe { ::core::mem::transmute(HypervisorError) };
            HypervisorError as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_NMI_ERROR_SECTION_FLAGS = _WHEA_NMI_ERROR_SECTION_FLAGS;
pub type PWHEA_NMI_ERROR_SECTION_FLAGS = *mut _WHEA_NMI_ERROR_SECTION_FLAGS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_NMI_ERROR_SECTION {
    pub Data: [UCHAR; 8usize],
    pub Flags: WHEA_NMI_ERROR_SECTION_FLAGS,
}
pub type WHEA_NMI_ERROR_SECTION = _WHEA_NMI_ERROR_SECTION;
pub type PWHEA_NMI_ERROR_SECTION = *mut _WHEA_NMI_ERROR_SECTION;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_MSR_DUMP_SECTION {
    pub MsrDumpBuffer: UCHAR,
    pub MsrDumpLength: ULONG,
    pub MsrDumpData: [UCHAR; 1usize],
}
pub type WHEA_MSR_DUMP_SECTION = _WHEA_MSR_DUMP_SECTION;
pub type PWHEA_MSR_DUMP_SECTION = *mut _WHEA_MSR_DUMP_SECTION;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _MU_TELEMETRY_SECTION {
    pub ComponentID: GUID,
    pub SubComponentID: GUID,
    pub Reserved: UINT32,
    pub ErrorStatusValue: UINT32,
    pub AdditionalInfo1: UINT64,
    pub AdditionalInfo2: UINT64,
}
pub type MU_TELEMETRY_SECTION = _MU_TELEMETRY_SECTION;
pub type PMU_TELEMETRY_SECTION = *mut _MU_TELEMETRY_SECTION;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_ARM_PROCESSOR_ERROR_SECTION_VALID_BITS {
    pub __bindgen_anon_1: _WHEA_ARM_PROCESSOR_ERROR_SECTION_VALID_BITS__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_ARM_PROCESSOR_ERROR_SECTION_VALID_BITS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _WHEA_ARM_PROCESSOR_ERROR_SECTION_VALID_BITS__bindgen_ty_1 {
    #[inline]
    pub fn MPIDR(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MPIDR(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MPIDR_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MPIDR_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AffinityLevel(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AffinityLevel(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AffinityLevel_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AffinityLevel_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RunningState(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RunningState(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RunningState_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RunningState_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VendorSpecificInfo(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VendorSpecificInfo(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VendorSpecificInfo_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VendorSpecificInfo_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                28u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                28u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MPIDR: ULONG,
        AffinityLevel: ULONG,
        RunningState: ULONG,
        VendorSpecificInfo: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let MPIDR: u32 = unsafe { ::core::mem::transmute(MPIDR) };
            MPIDR as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AffinityLevel: u32 = unsafe { ::core::mem::transmute(AffinityLevel) };
            AffinityLevel as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RunningState: u32 = unsafe { ::core::mem::transmute(RunningState) };
            RunningState as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let VendorSpecificInfo: u32 = unsafe { ::core::mem::transmute(VendorSpecificInfo) };
            VendorSpecificInfo as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_ARM_PROCESSOR_ERROR_SECTION_VALID_BITS = _WHEA_ARM_PROCESSOR_ERROR_SECTION_VALID_BITS;
pub type PWHEA_ARM_PROCESSOR_ERROR_SECTION_VALID_BITS =
*mut _WHEA_ARM_PROCESSOR_ERROR_SECTION_VALID_BITS;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_ARM_PROCESSOR_ERROR_SECTION {
    pub ValidBits: WHEA_ARM_PROCESSOR_ERROR_SECTION_VALID_BITS,
    pub ErrorInformationStructures: USHORT,
    pub ContextInformationStructures: USHORT,
    pub SectionLength: ULONG,
    pub ErrorAffinityLevel: UCHAR,
    pub Reserved: [UCHAR; 3usize],
    pub MPIDR_EL1: ULONGLONG,
    pub MIDR_EL1: ULONGLONG,
    pub RunningState: ULONG,
    pub PSCIState: ULONG,
    pub Data: [UCHAR; 1usize],
}
pub type WHEA_ARM_PROCESSOR_ERROR_SECTION = _WHEA_ARM_PROCESSOR_ERROR_SECTION;
pub type PWHEA_ARM_PROCESSOR_ERROR_SECTION = *mut _WHEA_ARM_PROCESSOR_ERROR_SECTION;
pub const _WHEA_RECOVERY_TYPE_WheaRecoveryTypeActionRequired: _WHEA_RECOVERY_TYPE = 1;
pub const _WHEA_RECOVERY_TYPE_WheaRecoveryTypeActionOptional: _WHEA_RECOVERY_TYPE = 2;
pub const _WHEA_RECOVERY_TYPE_WheaRecoveryTypeMax: _WHEA_RECOVERY_TYPE = 3;
pub type _WHEA_RECOVERY_TYPE = core::ffi::c_int;
pub use self::_WHEA_RECOVERY_TYPE as WHEA_RECOVERY_TYPE;
pub type PWHEA_RECOVERY_TYPE = *mut _WHEA_RECOVERY_TYPE;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_RECOVERY_ACTION {
    pub __bindgen_anon_1: _WHEA_RECOVERY_ACTION__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_RECOVERY_ACTION__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 5usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _WHEA_RECOVERY_ACTION__bindgen_ty_1 {
    #[inline]
    pub fn NoneAttempted(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoneAttempted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NoneAttempted_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NoneAttempted_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TerminateProcess(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TerminateProcess(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TerminateProcess_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_TerminateProcess_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ForwardedToVm(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ForwardedToVm(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ForwardedToVm_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ForwardedToVm_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MarkPageBad(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MarkPageBad(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MarkPageBad_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MarkPageBad_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PoisonNotPresent(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PoisonNotPresent(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PoisonNotPresent_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PoisonNotPresent_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                28u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                28u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NoneAttempted: ULONG,
        TerminateProcess: ULONG,
        ForwardedToVm: ULONG,
        MarkPageBad: ULONG,
        PoisonNotPresent: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 5usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 5usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let NoneAttempted: u32 = unsafe { ::core::mem::transmute(NoneAttempted) };
            NoneAttempted as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TerminateProcess: u32 = unsafe { ::core::mem::transmute(TerminateProcess) };
            TerminateProcess as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ForwardedToVm: u32 = unsafe { ::core::mem::transmute(ForwardedToVm) };
            ForwardedToVm as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let MarkPageBad: u32 = unsafe { ::core::mem::transmute(MarkPageBad) };
            MarkPageBad as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PoisonNotPresent: u32 = unsafe { ::core::mem::transmute(PoisonNotPresent) };
            PoisonNotPresent as u64
        });
        __bindgen_bitfield_unit.set(5usize, 28u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_RECOVERY_ACTION = _WHEA_RECOVERY_ACTION;
pub type PWHEA_RECOVERY_ACTION = *mut _WHEA_RECOVERY_ACTION;
pub const _WHEA_RECOVERY_FAILURE_REASON_WheaRecoveryFailureReasonKernelCouldNotMarkMemoryBad:
_WHEA_RECOVERY_FAILURE_REASON = 1;
pub const _WHEA_RECOVERY_FAILURE_REASON_WheaRecoveryFailureReasonKernelMarkMemoryBadTimedOut:
_WHEA_RECOVERY_FAILURE_REASON = 2;
pub const _WHEA_RECOVERY_FAILURE_REASON_WheaRecoveryFailureReasonNoRecoveryContext:
_WHEA_RECOVERY_FAILURE_REASON = 3;
pub const _WHEA_RECOVERY_FAILURE_REASON_WheaRecoveryFailureReasonNotContinuable:
_WHEA_RECOVERY_FAILURE_REASON = 4;
pub const _WHEA_RECOVERY_FAILURE_REASON_WheaRecoveryFailureReasonPcc:
_WHEA_RECOVERY_FAILURE_REASON = 5;
pub const _WHEA_RECOVERY_FAILURE_REASON_WheaRecoveryFailureReasonOverflow:
_WHEA_RECOVERY_FAILURE_REASON = 6;
pub const _WHEA_RECOVERY_FAILURE_REASON_WheaRecoveryFailureReasonNotSupported:
_WHEA_RECOVERY_FAILURE_REASON = 7;
pub const _WHEA_RECOVERY_FAILURE_REASON_WheaRecoveryFailureReasonMiscOrAddrNotValid:
_WHEA_RECOVERY_FAILURE_REASON = 8;
pub const _WHEA_RECOVERY_FAILURE_REASON_WheaRecoveryFailureReasonInvalidAddressMode:
_WHEA_RECOVERY_FAILURE_REASON = 9;
pub const _WHEA_RECOVERY_FAILURE_REASON_WheaRecoveryFailureReasonHighIrql:
_WHEA_RECOVERY_FAILURE_REASON = 10;
pub const _WHEA_RECOVERY_FAILURE_REASON_WheaRecoveryFailureReasonInsufficientAltContextWrappers:
_WHEA_RECOVERY_FAILURE_REASON = 11;
pub const _WHEA_RECOVERY_FAILURE_REASON_WheaRecoveryFailureReasonInterruptsDisabled:
_WHEA_RECOVERY_FAILURE_REASON = 12;
pub const _WHEA_RECOVERY_FAILURE_REASON_WheaRecoveryFailureReasonSwapBusy:
_WHEA_RECOVERY_FAILURE_REASON = 13;
pub const _WHEA_RECOVERY_FAILURE_REASON_WheaRecoveryFailureReasonStackOverflow:
_WHEA_RECOVERY_FAILURE_REASON = 14;
pub const _WHEA_RECOVERY_FAILURE_REASON_WheaRecoveryFailureReasonUnexpectedFailure:
_WHEA_RECOVERY_FAILURE_REASON = 15;
pub const _WHEA_RECOVERY_FAILURE_REASON_WheaRecoveryFailureReasonKernelWillPageFaultBCAtCurrentIrql : _WHEA_RECOVERY_FAILURE_REASON = 16 ;
pub const _WHEA_RECOVERY_FAILURE_REASON_WheaRecoveryFailureReasonFarNotValid:
_WHEA_RECOVERY_FAILURE_REASON = 17;
pub const _WHEA_RECOVERY_FAILURE_REASON_WheaRecoveryFailureReasonMax:
_WHEA_RECOVERY_FAILURE_REASON = 18;
pub type _WHEA_RECOVERY_FAILURE_REASON = core::ffi::c_int;
pub use self::_WHEA_RECOVERY_FAILURE_REASON as WHEA_RECOVERY_FAILURE_REASON;
pub type PWHEA_RECOVERY_FAILURE_REASON = *mut _WHEA_RECOVERY_FAILURE_REASON;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_ERROR_RECOVERY_INFO_SECTION {
    pub RecoveryKernel: BOOLEAN,
    pub RecoveryAction: WHEA_RECOVERY_ACTION,
    pub RecoveryType: WHEA_RECOVERY_TYPE,
    pub Irql: KIRQL,
    pub RecoverySucceeded: BOOLEAN,
    pub FailureReason: WHEA_RECOVERY_FAILURE_REASON,
    pub ProcessName: [CCHAR; 20usize],
}
pub type WHEA_ERROR_RECOVERY_INFO_SECTION = _WHEA_ERROR_RECOVERY_INFO_SECTION;
pub type PWHEA_ERROR_RECOVERY_INFO_SECTION = *mut _WHEA_ERROR_RECOVERY_INFO_SECTION;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_ARM_PROCESSOR_ERROR_INFORMATION_VALID_BITS {
    pub __bindgen_anon_1: _WHEA_ARM_PROCESSOR_ERROR_INFORMATION_VALID_BITS__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_ARM_PROCESSOR_ERROR_INFORMATION_VALID_BITS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _WHEA_ARM_PROCESSOR_ERROR_INFORMATION_VALID_BITS__bindgen_ty_1 {
    #[inline]
    pub fn MultipleError(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_MultipleError(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MultipleError_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_MultipleError_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Flags(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Flags(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Flags_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Flags_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ErrorInformation(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ErrorInformation(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ErrorInformation_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ErrorInformation_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VirtualFaultAddress(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_VirtualFaultAddress(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VirtualFaultAddress_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_VirtualFaultAddress_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PhysicalFaultAddress(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PhysicalFaultAddress(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PhysicalFaultAddress_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PhysicalFaultAddress_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 11u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                11u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                11u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MultipleError: USHORT,
        Flags: USHORT,
        ErrorInformation: USHORT,
        VirtualFaultAddress: USHORT,
        PhysicalFaultAddress: USHORT,
        Reserved: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let MultipleError: u16 = unsafe { ::core::mem::transmute(MultipleError) };
            MultipleError as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Flags: u16 = unsafe { ::core::mem::transmute(Flags) };
            Flags as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ErrorInformation: u16 = unsafe { ::core::mem::transmute(ErrorInformation) };
            ErrorInformation as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let VirtualFaultAddress: u16 = unsafe { ::core::mem::transmute(VirtualFaultAddress) };
            VirtualFaultAddress as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PhysicalFaultAddress: u16 = unsafe { ::core::mem::transmute(PhysicalFaultAddress) };
            PhysicalFaultAddress as u64
        });
        __bindgen_bitfield_unit.set(5usize, 11u8, {
            let Reserved: u16 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_ARM_PROCESSOR_ERROR_INFORMATION_VALID_BITS =
_WHEA_ARM_PROCESSOR_ERROR_INFORMATION_VALID_BITS;
pub type PWHEA_ARM_PROCESSOR_ERROR_INFORMATION_VALID_BITS =
*mut _WHEA_ARM_PROCESSOR_ERROR_INFORMATION_VALID_BITS;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_ARM_CACHE_ERROR_VALID_BITS {
    pub __bindgen_anon_1: _WHEA_ARM_CACHE_ERROR_VALID_BITS__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_ARM_CACHE_ERROR_VALID_BITS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _WHEA_ARM_CACHE_ERROR_VALID_BITS__bindgen_ty_1 {
    #[inline]
    pub fn TransactionType(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TransactionType(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TransactionType_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_TransactionType_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Operation(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Operation(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Operation_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Operation_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Level(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Level(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Level_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Level_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ProcessorContextCorrupt(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ProcessorContextCorrupt(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ProcessorContextCorrupt_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ProcessorContextCorrupt_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Corrected(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Corrected(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Corrected_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Corrected_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PrecisePC(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PrecisePC(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PrecisePC_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PrecisePC_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RestartablePC(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RestartablePC(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RestartablePC_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_RestartablePC_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                9u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                9u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TransactionType: USHORT,
        Operation: USHORT,
        Level: USHORT,
        ProcessorContextCorrupt: USHORT,
        Corrected: USHORT,
        PrecisePC: USHORT,
        RestartablePC: USHORT,
        Reserved: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let TransactionType: u16 = unsafe { ::core::mem::transmute(TransactionType) };
            TransactionType as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Operation: u16 = unsafe { ::core::mem::transmute(Operation) };
            Operation as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Level: u16 = unsafe { ::core::mem::transmute(Level) };
            Level as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ProcessorContextCorrupt: u16 =
                unsafe { ::core::mem::transmute(ProcessorContextCorrupt) };
            ProcessorContextCorrupt as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Corrected: u16 = unsafe { ::core::mem::transmute(Corrected) };
            Corrected as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PrecisePC: u16 = unsafe { ::core::mem::transmute(PrecisePC) };
            PrecisePC as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RestartablePC: u16 = unsafe { ::core::mem::transmute(RestartablePC) };
            RestartablePC as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let Reserved: u16 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_ARM_CACHE_ERROR_VALID_BITS = _WHEA_ARM_CACHE_ERROR_VALID_BITS;
pub type PWHEA_ARM_CACHE_ERROR_VALID_BITS = *mut _WHEA_ARM_CACHE_ERROR_VALID_BITS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_ARM_CACHE_ERROR {
    pub ValidationBit: WHEA_ARM_CACHE_ERROR_VALID_BITS,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 6usize]>,
    pub __bindgen_padding_0: u32,
}
impl _WHEA_ARM_CACHE_ERROR {
    #[inline]
    pub fn TransactionType(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_TransactionType(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TransactionType_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_TransactionType_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Operation(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_Operation(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Operation_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Operation_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Level(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_Level(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Level_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Level_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ProcessorContextCorrupt(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ProcessorContextCorrupt(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ProcessorContextCorrupt_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ProcessorContextCorrupt_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Corrected(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Corrected(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Corrected_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Corrected_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PrecisePC(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PrecisePC(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PrecisePC_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_PrecisePC_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RestartablePC(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RestartablePC(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RestartablePC_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_RestartablePC_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 35u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 35u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                35u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                35u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TransactionType: UCHAR,
        Operation: UCHAR,
        Level: UCHAR,
        ProcessorContextCorrupt: UCHAR,
        Corrected: UCHAR,
        PrecisePC: UCHAR,
        RestartablePC: UCHAR,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 6usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 6usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let TransactionType: u8 = unsafe { ::core::mem::transmute(TransactionType) };
            TransactionType as u64
        });
        __bindgen_bitfield_unit.set(2usize, 4u8, {
            let Operation: u8 = unsafe { ::core::mem::transmute(Operation) };
            Operation as u64
        });
        __bindgen_bitfield_unit.set(6usize, 3u8, {
            let Level: u8 = unsafe { ::core::mem::transmute(Level) };
            Level as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let ProcessorContextCorrupt: u8 =
                unsafe { ::core::mem::transmute(ProcessorContextCorrupt) };
            ProcessorContextCorrupt as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let Corrected: u8 = unsafe { ::core::mem::transmute(Corrected) };
            Corrected as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let PrecisePC: u8 = unsafe { ::core::mem::transmute(PrecisePC) };
            PrecisePC as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let RestartablePC: u8 = unsafe { ::core::mem::transmute(RestartablePC) };
            RestartablePC as u64
        });
        __bindgen_bitfield_unit.set(13usize, 35u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_ARM_CACHE_ERROR = _WHEA_ARM_CACHE_ERROR;
pub type PWHEA_ARM_CACHE_ERROR = *mut _WHEA_ARM_CACHE_ERROR;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_ARM_TLB_ERROR_VALID_BITS {
    pub __bindgen_anon_1: _WHEA_ARM_TLB_ERROR_VALID_BITS__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_ARM_TLB_ERROR_VALID_BITS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _WHEA_ARM_TLB_ERROR_VALID_BITS__bindgen_ty_1 {
    #[inline]
    pub fn TransactionType(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TransactionType(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TransactionType_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_TransactionType_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Operation(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Operation(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Operation_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Operation_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Level(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Level(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Level_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Level_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ProcessorContextCorrupt(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ProcessorContextCorrupt(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ProcessorContextCorrupt_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ProcessorContextCorrupt_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Corrected(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Corrected(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Corrected_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Corrected_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PrecisePC(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PrecisePC(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PrecisePC_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PrecisePC_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RestartablePC(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RestartablePC(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RestartablePC_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_RestartablePC_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                9u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                9u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TransactionType: USHORT,
        Operation: USHORT,
        Level: USHORT,
        ProcessorContextCorrupt: USHORT,
        Corrected: USHORT,
        PrecisePC: USHORT,
        RestartablePC: USHORT,
        Reserved: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let TransactionType: u16 = unsafe { ::core::mem::transmute(TransactionType) };
            TransactionType as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Operation: u16 = unsafe { ::core::mem::transmute(Operation) };
            Operation as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Level: u16 = unsafe { ::core::mem::transmute(Level) };
            Level as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ProcessorContextCorrupt: u16 =
                unsafe { ::core::mem::transmute(ProcessorContextCorrupt) };
            ProcessorContextCorrupt as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Corrected: u16 = unsafe { ::core::mem::transmute(Corrected) };
            Corrected as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PrecisePC: u16 = unsafe { ::core::mem::transmute(PrecisePC) };
            PrecisePC as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RestartablePC: u16 = unsafe { ::core::mem::transmute(RestartablePC) };
            RestartablePC as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let Reserved: u16 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_ARM_TLB_ERROR_VALID_BITS = _WHEA_ARM_TLB_ERROR_VALID_BITS;
pub type PWHEA_ARM_TLB_ERROR_VALID_BITS = *mut _WHEA_ARM_TLB_ERROR_VALID_BITS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_ARM_TLB_ERROR {
    pub ValidationBit: WHEA_ARM_TLB_ERROR_VALID_BITS,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 7usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _WHEA_ARM_TLB_ERROR {
    #[inline]
    pub fn TransactionType(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_TransactionType(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TransactionType_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_TransactionType_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Operation(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_Operation(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Operation_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Operation_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Level(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_Level(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Level_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Level_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ProcessorContextCorrupt(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ProcessorContextCorrupt(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ProcessorContextCorrupt_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ProcessorContextCorrupt_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Corrected(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Corrected(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Corrected_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Corrected_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PrecisePC(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PrecisePC(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PrecisePC_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_PrecisePC_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RestartablePC(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RestartablePC(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RestartablePC_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_RestartablePC_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 36u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 36u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                36u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                36u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TransactionType: UCHAR,
        Operation: UCHAR,
        Level: UCHAR,
        ProcessorContextCorrupt: UCHAR,
        Corrected: UCHAR,
        PrecisePC: UCHAR,
        RestartablePC: UCHAR,
        Reserved: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 7usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 7usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let TransactionType: u8 = unsafe { ::core::mem::transmute(TransactionType) };
            TransactionType as u64
        });
        __bindgen_bitfield_unit.set(2usize, 4u8, {
            let Operation: u8 = unsafe { ::core::mem::transmute(Operation) };
            Operation as u64
        });
        __bindgen_bitfield_unit.set(6usize, 3u8, {
            let Level: u8 = unsafe { ::core::mem::transmute(Level) };
            Level as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let ProcessorContextCorrupt: u8 =
                unsafe { ::core::mem::transmute(ProcessorContextCorrupt) };
            ProcessorContextCorrupt as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let Corrected: u8 = unsafe { ::core::mem::transmute(Corrected) };
            Corrected as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let PrecisePC: u8 = unsafe { ::core::mem::transmute(PrecisePC) };
            PrecisePC as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let RestartablePC: u8 = unsafe { ::core::mem::transmute(RestartablePC) };
            RestartablePC as u64
        });
        __bindgen_bitfield_unit.set(13usize, 36u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_ARM_TLB_ERROR = _WHEA_ARM_TLB_ERROR;
pub type PWHEA_ARM_TLB_ERROR = *mut _WHEA_ARM_TLB_ERROR;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_ARM_BUS_ERROR_VALID_BITS {
    pub __bindgen_anon_1: _WHEA_ARM_BUS_ERROR_VALID_BITS__bindgen_ty_1,
    pub AsUSHORT: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_ARM_BUS_ERROR_VALID_BITS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _WHEA_ARM_BUS_ERROR_VALID_BITS__bindgen_ty_1 {
    #[inline]
    pub fn TransactionType(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TransactionType(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TransactionType_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_TransactionType_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Operation(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Operation(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Operation_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Operation_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Level(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Level(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Level_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Level_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ProcessorContextCorrupt(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ProcessorContextCorrupt(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ProcessorContextCorrupt_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ProcessorContextCorrupt_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Corrected(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Corrected(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Corrected_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Corrected_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PrecisePC(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PrecisePC(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PrecisePC_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_PrecisePC_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RestartablePC(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RestartablePC(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RestartablePC_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_RestartablePC_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ParticipationType(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ParticipationType(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ParticipationType_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ParticipationType_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Timeout(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Timeout(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Timeout_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Timeout_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AddressSpace(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_AddressSpace(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AddressSpace_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_AddressSpace_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemoryAttributes(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_MemoryAttributes(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemoryAttributes_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_MemoryAttributes_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AccessMode(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_AccessMode(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AccessMode_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_AccessMode_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TransactionType: USHORT,
        Operation: USHORT,
        Level: USHORT,
        ProcessorContextCorrupt: USHORT,
        Corrected: USHORT,
        PrecisePC: USHORT,
        RestartablePC: USHORT,
        ParticipationType: USHORT,
        Timeout: USHORT,
        AddressSpace: USHORT,
        MemoryAttributes: USHORT,
        AccessMode: USHORT,
        Reserved: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let TransactionType: u16 = unsafe { ::core::mem::transmute(TransactionType) };
            TransactionType as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Operation: u16 = unsafe { ::core::mem::transmute(Operation) };
            Operation as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Level: u16 = unsafe { ::core::mem::transmute(Level) };
            Level as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ProcessorContextCorrupt: u16 =
                unsafe { ::core::mem::transmute(ProcessorContextCorrupt) };
            ProcessorContextCorrupt as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Corrected: u16 = unsafe { ::core::mem::transmute(Corrected) };
            Corrected as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PrecisePC: u16 = unsafe { ::core::mem::transmute(PrecisePC) };
            PrecisePC as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RestartablePC: u16 = unsafe { ::core::mem::transmute(RestartablePC) };
            RestartablePC as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ParticipationType: u16 = unsafe { ::core::mem::transmute(ParticipationType) };
            ParticipationType as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Timeout: u16 = unsafe { ::core::mem::transmute(Timeout) };
            Timeout as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let AddressSpace: u16 = unsafe { ::core::mem::transmute(AddressSpace) };
            AddressSpace as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let MemoryAttributes: u16 = unsafe { ::core::mem::transmute(MemoryAttributes) };
            MemoryAttributes as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let AccessMode: u16 = unsafe { ::core::mem::transmute(AccessMode) };
            AccessMode as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let Reserved: u16 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_ARM_BUS_ERROR_VALID_BITS = _WHEA_ARM_BUS_ERROR_VALID_BITS;
pub type PWHEA_ARM_BUS_ERROR_VALID_BITS = *mut _WHEA_ARM_BUS_ERROR_VALID_BITS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_ARM_BUS_ERROR {
    pub ValidationBit: WHEA_ARM_BUS_ERROR_VALID_BITS,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 6usize]>,
    pub __bindgen_padding_0: u32,
}
impl _WHEA_ARM_BUS_ERROR {
    #[inline]
    pub fn TransactionType(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_TransactionType(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TransactionType_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_TransactionType_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Operation(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_Operation(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Operation_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Operation_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Level(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_Level(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Level_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Level_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ProcessorContextCorrupt(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ProcessorContextCorrupt(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ProcessorContextCorrupt_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ProcessorContextCorrupt_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Corrected(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Corrected(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Corrected_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Corrected_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PrecisePC(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PrecisePC(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PrecisePC_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_PrecisePC_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RestartablePC(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RestartablePC(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RestartablePC_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_RestartablePC_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ParticipationType(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ParticipationType(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ParticipationType_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ParticipationType_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn TimeOut(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TimeOut(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn TimeOut_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_TimeOut_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AddressSpace(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_AddressSpace(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AddressSpace_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_AddressSpace_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemoryAccessAttributes(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 9u8) as u16) }
    }
    #[inline]
    pub fn set_MemoryAccessAttributes(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemoryAccessAttributes_raw(this: *const Self) -> USHORT {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                9u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_MemoryAccessAttributes_raw(this: *mut Self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                9u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AccessMode(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AccessMode(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AccessMode_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_AccessMode_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                20u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                20u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TransactionType: UCHAR,
        Operation: UCHAR,
        Level: UCHAR,
        ProcessorContextCorrupt: UCHAR,
        Corrected: UCHAR,
        PrecisePC: UCHAR,
        RestartablePC: UCHAR,
        ParticipationType: UCHAR,
        TimeOut: UCHAR,
        AddressSpace: UCHAR,
        MemoryAccessAttributes: USHORT,
        AccessMode: UCHAR,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 6usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 6usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let TransactionType: u8 = unsafe { ::core::mem::transmute(TransactionType) };
            TransactionType as u64
        });
        __bindgen_bitfield_unit.set(2usize, 4u8, {
            let Operation: u8 = unsafe { ::core::mem::transmute(Operation) };
            Operation as u64
        });
        __bindgen_bitfield_unit.set(6usize, 3u8, {
            let Level: u8 = unsafe { ::core::mem::transmute(Level) };
            Level as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let ProcessorContextCorrupt: u8 =
                unsafe { ::core::mem::transmute(ProcessorContextCorrupt) };
            ProcessorContextCorrupt as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let Corrected: u8 = unsafe { ::core::mem::transmute(Corrected) };
            Corrected as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let PrecisePC: u8 = unsafe { ::core::mem::transmute(PrecisePC) };
            PrecisePC as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let RestartablePC: u8 = unsafe { ::core::mem::transmute(RestartablePC) };
            RestartablePC as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let ParticipationType: u8 = unsafe { ::core::mem::transmute(ParticipationType) };
            ParticipationType as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let TimeOut: u8 = unsafe { ::core::mem::transmute(TimeOut) };
            TimeOut as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let AddressSpace: u8 = unsafe { ::core::mem::transmute(AddressSpace) };
            AddressSpace as u64
        });
        __bindgen_bitfield_unit.set(18usize, 9u8, {
            let MemoryAccessAttributes: u16 =
                unsafe { ::core::mem::transmute(MemoryAccessAttributes) };
            MemoryAccessAttributes as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let AccessMode: u8 = unsafe { ::core::mem::transmute(AccessMode) };
            AccessMode as u64
        });
        __bindgen_bitfield_unit.set(28usize, 20u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_ARM_BUS_ERROR = _WHEA_ARM_BUS_ERROR;
pub type PWHEA_ARM_BUS_ERROR = *mut _WHEA_ARM_BUS_ERROR;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_ARM_PROCESSOR_ERROR {
    pub CacheError: WHEA_ARM_CACHE_ERROR,
    pub TlbError: WHEA_ARM_TLB_ERROR,
    pub BusError: WHEA_ARM_BUS_ERROR,
    pub AsULONGLONG: ULONGLONG,
}
pub type WHEA_ARM_PROCESSOR_ERROR = _WHEA_ARM_PROCESSOR_ERROR;
pub type PWHEA_ARM_PROCESSOR_ERROR = *mut _WHEA_ARM_PROCESSOR_ERROR;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_ARM_PROCESSOR_ERROR_INFORMATION {
    pub Version: UCHAR,
    pub Length: UCHAR,
    pub ValidationBit: WHEA_ARM_PROCESSOR_ERROR_INFORMATION_VALID_BITS,
    pub Type: UCHAR,
    pub MultipleError: USHORT,
    pub Flags: UCHAR,
    pub ErrorInformation: ULONGLONG,
    pub VirtualFaultAddress: ULONGLONG,
    pub PhysicalFaultAddress: ULONGLONG,
}
pub type WHEA_ARM_PROCESSOR_ERROR_INFORMATION = _WHEA_ARM_PROCESSOR_ERROR_INFORMATION;
pub type PWHEA_ARM_PROCESSOR_ERROR_INFORMATION = *mut _WHEA_ARM_PROCESSOR_ERROR_INFORMATION;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER_FLAGS {
    pub __bindgen_anon_1: _WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER_FLAGS__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER_FLAGS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn ExceptionLevel(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExceptionLevel(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ExceptionLevel_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ExceptionLevel_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NonSecure(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NonSecure(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NonSecure_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NonSecure_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AArch64(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AArch64(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AArch64_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AArch64_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                29u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                29u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ExceptionLevel: ULONG,
        NonSecure: ULONG,
        AArch64: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ExceptionLevel: u32 = unsafe { ::core::mem::transmute(ExceptionLevel) };
            ExceptionLevel as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let NonSecure: u32 = unsafe { ::core::mem::transmute(NonSecure) };
            NonSecure as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let AArch64: u32 = unsafe { ::core::mem::transmute(AArch64) };
            AArch64 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER_FLAGS =
_WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER_FLAGS;
pub type PWHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER_FLAGS =
*mut _WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER_FLAGS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_ARMV8_AARCH32_GPRS {
    pub R0: ULONG,
    pub R1: ULONG,
    pub R2: ULONG,
    pub R3: ULONG,
    pub R4: ULONG,
    pub R5: ULONG,
    pub R6: ULONG,
    pub R7: ULONG,
    pub R8: ULONG,
    pub R9: ULONG,
    pub R10: ULONG,
    pub R11: ULONG,
    pub R12: ULONG,
    pub R13: ULONG,
    pub R14: ULONG,
    pub R15: ULONG,
}
pub type WHEA_ARMV8_AARCH32_GPRS = _WHEA_ARMV8_AARCH32_GPRS;
pub type PWHEA_ARMV8_AARCH32_GPRS = *mut _WHEA_ARMV8_AARCH32_GPRS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_ARM_AARCH32_EL1_CSR {
    pub DFAR: ULONG,
    pub DFSR: ULONG,
    pub IFAR: ULONG,
    pub ISR: ULONG,
    pub MAIR0: ULONG,
    pub MAIR1: ULONG,
    pub MIDR: ULONG,
    pub MPIDR: ULONG,
    pub NMRR: ULONG,
    pub PRRR: ULONG,
    pub SCTLR: ULONG,
    pub SPSR: ULONG,
    pub SPSR_abt: ULONG,
    pub SPSR_fiq: ULONG,
    pub SPSR_irq: ULONG,
    pub SPSR_svc: ULONG,
    pub SPSR_und: ULONG,
    pub TPIDRPRW: ULONG,
    pub TPIDRURO: ULONG,
    pub TPIDRURW: ULONG,
    pub TTBCR: ULONG,
    pub TTBR0: ULONG,
    pub TTBR1: ULONG,
    pub DACR: ULONG,
}
pub type WHEA_ARM_AARCH32_EL1_CSR = _WHEA_ARM_AARCH32_EL1_CSR;
pub type PWHEA_ARM_AARCH32_EL1 = *mut _WHEA_ARM_AARCH32_EL1_CSR;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_ARM_AARCH32_EL2_CSR {
    pub ELR_hyp: ULONG,
    pub HAMAIR0: ULONG,
    pub HAMAIR1: ULONG,
    pub HCR: ULONG,
    pub HCR2: ULONG,
    pub HDFAR: ULONG,
    pub HIFAR: ULONG,
    pub HPFAR: ULONG,
    pub HSR: ULONG,
    pub HTCR: ULONG,
    pub HTPIDR: ULONG,
    pub HTTBR: ULONG,
    pub SPSR_hyp: ULONG,
    pub VTCR: ULONG,
    pub VTTBR: ULONG,
    pub DACR32_EL2: ULONG,
}
pub type WHEA_ARM_AARCH32_EL2_CSR = _WHEA_ARM_AARCH32_EL2_CSR;
pub type PWHEA_ARM_AARCH32_EL2_CSR = *mut _WHEA_ARM_AARCH32_EL2_CSR;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_ARM_AARCH32_SECURE_CSR {
    pub SCTLR: ULONG,
    pub SPSR_mon: ULONG,
}
pub type WHEA_ARM_AARCH32_SECURE_CSR = _WHEA_ARM_AARCH32_SECURE_CSR;
pub type PWHEA_ARM_AARCH32_SECURE_CSR = *mut _WHEA_ARM_AARCH32_SECURE_CSR;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_ARMV8_AARCH64_GPRS {
    pub X0: ULONGLONG,
    pub X1: ULONGLONG,
    pub X2: ULONGLONG,
    pub X3: ULONGLONG,
    pub X4: ULONGLONG,
    pub X5: ULONGLONG,
    pub X6: ULONGLONG,
    pub X7: ULONGLONG,
    pub X8: ULONGLONG,
    pub X9: ULONGLONG,
    pub X10: ULONGLONG,
    pub X11: ULONGLONG,
    pub X12: ULONGLONG,
    pub X13: ULONGLONG,
    pub X14: ULONGLONG,
    pub X15: ULONGLONG,
    pub X16: ULONGLONG,
    pub X17: ULONGLONG,
    pub X18: ULONGLONG,
    pub X19: ULONGLONG,
    pub X20: ULONGLONG,
    pub X21: ULONGLONG,
    pub X22: ULONGLONG,
    pub X23: ULONGLONG,
    pub X24: ULONGLONG,
    pub X25: ULONGLONG,
    pub X26: ULONGLONG,
    pub X27: ULONGLONG,
    pub X28: ULONGLONG,
    pub X29: ULONGLONG,
    pub X30: ULONGLONG,
    pub SP: ULONGLONG,
}
pub type WHEA_ARMV8_AARCH64_GPRS = _WHEA_ARMV8_AARCH64_GPRS;
pub type PWHEA_ARMV8_AARCH64_GPRS = *mut _WHEA_ARMV8_AARCH64_GPRS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_ARM_AARCH64_EL1_CSR {
    pub ELR_EL1: ULONGLONG,
    pub ESR_EL2: ULONGLONG,
    pub FAR_EL1: ULONGLONG,
    pub ISR_EL1: ULONGLONG,
    pub MAIR_EL1: ULONGLONG,
    pub MIDR_EL1: ULONGLONG,
    pub MPIDR_EL1: ULONGLONG,
    pub SCTLR_EL1: ULONGLONG,
    pub SP_EL0: ULONGLONG,
    pub SP_EL1: ULONGLONG,
    pub SPSR_EL1: ULONGLONG,
    pub TCR_EL1: ULONGLONG,
    pub TPIDR_EL0: ULONGLONG,
    pub TPIDR_EL1: ULONGLONG,
    pub TPIDRRO_EL0: ULONGLONG,
    pub TTBR0_EL1: ULONGLONG,
    pub TTBR1_EL1: ULONGLONG,
}
pub type WHEA_ARM_AARCH64_EL1_CSR = _WHEA_ARM_AARCH64_EL1_CSR;
pub type PWHEA_ARM_AARCH64_EL1_CSR = *mut _WHEA_ARM_AARCH64_EL1_CSR;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_ARM_AARCH64_EL2_CSR {
    pub ELR_EL2: ULONGLONG,
    pub ESR_EL2: ULONGLONG,
    pub FAR_EL2: ULONGLONG,
    pub HACR_EL2: ULONGLONG,
    pub HCR_EL2: ULONGLONG,
    pub HPFAR_EL2: ULONGLONG,
    pub MAIR_EL2: ULONGLONG,
    pub SCTLR_EL2: ULONGLONG,
    pub SP_EL2: ULONGLONG,
    pub SPSR_EL2: ULONGLONG,
    pub TCR_EL2: ULONGLONG,
    pub TPIDR_EL2: ULONGLONG,
    pub TTBR0_EL2: ULONGLONG,
    pub VTCR_EL2: ULONGLONG,
    pub VTTBR_EL2: ULONGLONG,
}
pub type WHEA_ARM_AARCH64_EL2_CSR = _WHEA_ARM_AARCH64_EL2_CSR;
pub type PWHEA_ARM_AARCH64_EL2_CSR = *mut _WHEA_ARM_AARCH64_EL2_CSR;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_ARMV8_AARCH64_EL3_CSR {
    pub ELR_EL3: ULONGLONG,
    pub ESR_EL3: ULONGLONG,
    pub FAR_EL3: ULONGLONG,
    pub MAIR_EL3: ULONGLONG,
    pub SCTLR_EL3: ULONGLONG,
    pub SP_EL3: ULONGLONG,
    pub SPSR_EL3: ULONGLONG,
    pub TCR_EL3: ULONGLONG,
    pub TPIDR_EL3: ULONGLONG,
    pub TTBR0_EL3: ULONGLONG,
}
pub type WHEA_ARMV8_AARCH64_EL3_CSR = _WHEA_ARMV8_AARCH64_EL3_CSR;
pub type PWHEA_ARMV8_AARCH64_EL3_CSR = *mut _WHEA_ARMV8_AARCH64_EL3_CSR;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_ARM_MISC_CSR {
    pub MRSEncoding: USHORT,
    pub Value: ULONGLONG,
}
pub type WHEA_ARM_MISC_CSR = _WHEA_ARM_MISC_CSR;
pub type PWHEA_ARM_MISC_CSR = *mut _WHEA_ARM_MISC_CSR;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER {
    pub Version: USHORT,
    pub RegisterContextType: USHORT,
    pub RegisterArraySize: ULONG,
    pub RegisterArray: [UCHAR; 1usize],
}
pub type WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER =
_WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER;
pub type PWHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER =
*mut _WHEA_ARM_PROCESSOR_ERROR_CONTEXT_INFORMATION_HEADER;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_SEA_SECTION {
    pub Esr: ULONG,
    pub Far: ULONG64,
    pub Par: ULONG64,
    pub WasKernel: BOOLEAN,
}
pub type WHEA_SEA_SECTION = _WHEA_SEA_SECTION;
pub type PWHEA_SEA_SECTION = *mut _WHEA_SEA_SECTION;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_SEI_SECTION {
    pub Esr: ULONG,
    pub Far: ULONG64,
}
pub type WHEA_SEI_SECTION = _WHEA_SEI_SECTION;
pub type PWHEA_SEI_SECTION = *mut _WHEA_SEI_SECTION;
pub const _WHEA_PCI_RECOVERY_SIGNAL_WheaPciRecoverySignalUnknown: _WHEA_PCI_RECOVERY_SIGNAL = 0;
pub const _WHEA_PCI_RECOVERY_SIGNAL_WheaPciRecoverySignalAer: _WHEA_PCI_RECOVERY_SIGNAL = 1;
pub const _WHEA_PCI_RECOVERY_SIGNAL_WheaPciRecoverySignalDpc: _WHEA_PCI_RECOVERY_SIGNAL = 2;
pub type _WHEA_PCI_RECOVERY_SIGNAL = core::ffi::c_int;
pub use self::_WHEA_PCI_RECOVERY_SIGNAL as WHEA_PCI_RECOVERY_SIGNAL;
pub type PWHEA_PCI_RECOVERY_SIGNAL = *mut _WHEA_PCI_RECOVERY_SIGNAL;
pub const _WHEA_PCI_RECOVERY_STATUS_WheaPciREcoveryStatusUnknown: _WHEA_PCI_RECOVERY_STATUS = 0;
pub const _WHEA_PCI_RECOVERY_STATUS_WheaPciRecoveryStatusNoError: _WHEA_PCI_RECOVERY_STATUS = 1;
pub const _WHEA_PCI_RECOVERY_STATUS_WheaPciRecoveryStatusLinkDisableTimeout:
_WHEA_PCI_RECOVERY_STATUS = 2;
pub const _WHEA_PCI_RECOVERY_STATUS_WheaPciRecoveryStatusLinkEnableTimeout:
_WHEA_PCI_RECOVERY_STATUS = 3;
pub const _WHEA_PCI_RECOVERY_STATUS_WheaPciRecoveryStatusRpBusyTimeout: _WHEA_PCI_RECOVERY_STATUS =
    4;
pub const _WHEA_PCI_RECOVERY_STATUS_WheaPciRecoveryStatusComplexTree: _WHEA_PCI_RECOVERY_STATUS = 5;
pub const _WHEA_PCI_RECOVERY_STATUS_WheaPciRecoveryStatusBusNotFound: _WHEA_PCI_RECOVERY_STATUS = 6;
pub type _WHEA_PCI_RECOVERY_STATUS = core::ffi::c_int;
pub use self::_WHEA_PCI_RECOVERY_STATUS as WHEA_PCI_RECOVERY_STATUS;
pub type PWHEA_PCI_RECOVERY_STATUS = *mut _WHEA_PCI_RECOVERY_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_PCI_RECOVERY_SECTION {
    pub SignalType: UINT8,
    pub RecoveryAttempted: BOOLEAN,
    pub RecoveryStatus: UINT8,
}
pub type WHEA_PCI_RECOVERY_SECTION = _WHEA_PCI_RECOVERY_SECTION;
pub type PWHEA_PCI_RECOVERY_SECTION = *mut _WHEA_PCI_RECOVERY_SECTION;
unsafe extern "C" {
    pub static CMC_NOTIFY_TYPE_GUID: GUID;
}
unsafe extern "C" {
    pub static CPE_NOTIFY_TYPE_GUID: GUID;
}
unsafe extern "C" {
    pub static MCE_NOTIFY_TYPE_GUID: GUID;
}
unsafe extern "C" {
    pub static PCIe_NOTIFY_TYPE_GUID: GUID;
}
unsafe extern "C" {
    pub static INIT_NOTIFY_TYPE_GUID: GUID;
}
unsafe extern "C" {
    pub static NMI_NOTIFY_TYPE_GUID: GUID;
}
unsafe extern "C" {
    pub static BOOT_NOTIFY_TYPE_GUID: GUID;
}
unsafe extern "C" {
    pub static SEA_NOTIFY_TYPE_GUID: GUID;
}
unsafe extern "C" {
    pub static SEI_NOTIFY_TYPE_GUID: GUID;
}
unsafe extern "C" {
    pub static PEI_NOTIFY_TYPE_GUID: GUID;
}
unsafe extern "C" {
    pub static BMC_NOTIFY_TYPE_GUID: GUID;
}
unsafe extern "C" {
    pub static SCI_NOTIFY_TYPE_GUID: GUID;
}
unsafe extern "C" {
    pub static EXTINT_NOTIFY_TYPE_GUID: GUID;
}
unsafe extern "C" {
    pub static DEVICE_DRIVER_NOTIFY_TYPE_GUID: GUID;
}
unsafe extern "C" {
    pub static CMCI_NOTIFY_TYPE_GUID: GUID;
}
unsafe extern "C" {
    pub static WHEA_DEVICE_ERROR_SUMMARY_GUID: GUID;
}
unsafe extern "C" {
    pub static PROCESSOR_GENERIC_ERROR_SECTION_GUID: GUID;
}
unsafe extern "C" {
    pub static XPF_PROCESSOR_ERROR_SECTION_GUID: GUID;
}
unsafe extern "C" {
    pub static IPF_PROCESSOR_ERROR_SECTION_GUID: GUID;
}
unsafe extern "C" {
    pub static ARM_PROCESSOR_ERROR_SECTION_GUID: GUID;
}
unsafe extern "C" {
    pub static MEMORY_ERROR_SECTION_GUID: GUID;
}
unsafe extern "C" {
    pub static PCIEXPRESS_ERROR_SECTION_GUID: GUID;
}
unsafe extern "C" {
    pub static PCIXBUS_ERROR_SECTION_GUID: GUID;
}
unsafe extern "C" {
    pub static PCIXDEVICE_ERROR_SECTION_GUID: GUID;
}
unsafe extern "C" {
    pub static FIRMWARE_ERROR_RECORD_REFERENCE_GUID: GUID;
}
unsafe extern "C" {
    pub static PMEM_ERROR_SECTION_GUID: GUID;
}
unsafe extern "C" {
    pub static MU_TELEMETRY_SECTION_GUID: GUID;
}
unsafe extern "C" {
    pub static RECOVERY_INFO_SECTION_GUID: GUID;
}
unsafe extern "C" {
    pub static WHEA_CACHECHECK_GUID: GUID;
}
unsafe extern "C" {
    pub static WHEA_TLBCHECK_GUID: GUID;
}
unsafe extern "C" {
    pub static WHEA_BUSCHECK_GUID: GUID;
}
unsafe extern "C" {
    pub static WHEA_MSCHECK_GUID: GUID;
}
unsafe extern "C" {
    pub static CPER_EMPTY_GUID: GUID;
}
unsafe extern "C" {
    pub static WHEA_RECORD_CREATOR_GUID: GUID;
}
unsafe extern "C" {
    pub static DEFAULT_DEVICE_DRIVER_CREATOR_GUID: GUID;
}
unsafe extern "C" {
    pub static GENERIC_NOTIFY_TYPE_GUID: GUID;
}
unsafe extern "C" {
    pub static IPF_SAL_RECORD_SECTION_GUID: GUID;
}
unsafe extern "C" {
    pub static XPF_MCA_SECTION_GUID: GUID;
}
unsafe extern "C" {
    pub static NMI_SECTION_GUID: GUID;
}
unsafe extern "C" {
    pub static GENERIC_SECTION_GUID: GUID;
}
unsafe extern "C" {
    pub static IPMI_MSR_DUMP_SECTION_GUID: GUID;
}
unsafe extern "C" {
    pub static WHEA_ERROR_PACKET_SECTION_GUID: GUID;
}
unsafe extern "C" {
    pub static WHEA_DPC_CAPABILITY_SECTION_GUID: GUID;
}
unsafe extern "C" {
    pub static PCIE_CORRECTABLE_ERROR_SUMMARY_SECTION_GUID: GUID;
}
unsafe extern "C" {
    pub static MEMORY_CORRECTABLE_ERROR_SUMMARY_SECTION_GUID: GUID;
}
unsafe extern "C" {
    pub static SEA_SECTION_GUID: GUID;
}
unsafe extern "C" {
    pub static SEI_SECTION_GUID: GUID;
}
unsafe extern "C" {
    pub static PCI_RECOVERY_SECTION_GUID: GUID;
}
pub const _WHEA_ERROR_TYPE_WheaErrTypeProcessor: _WHEA_ERROR_TYPE = 0;
pub const _WHEA_ERROR_TYPE_WheaErrTypeMemory: _WHEA_ERROR_TYPE = 1;
pub const _WHEA_ERROR_TYPE_WheaErrTypePCIExpress: _WHEA_ERROR_TYPE = 2;
pub const _WHEA_ERROR_TYPE_WheaErrTypeNMI: _WHEA_ERROR_TYPE = 3;
pub const _WHEA_ERROR_TYPE_WheaErrTypePCIXBus: _WHEA_ERROR_TYPE = 4;
pub const _WHEA_ERROR_TYPE_WheaErrTypePCIXDevice: _WHEA_ERROR_TYPE = 5;
pub const _WHEA_ERROR_TYPE_WheaErrTypeGeneric: _WHEA_ERROR_TYPE = 6;
pub const _WHEA_ERROR_TYPE_WheaErrTypePmem: _WHEA_ERROR_TYPE = 7;
pub type _WHEA_ERROR_TYPE = core::ffi::c_int;
pub use self::_WHEA_ERROR_TYPE as WHEA_ERROR_TYPE;
pub type PWHEA_ERROR_TYPE = *mut _WHEA_ERROR_TYPE;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_ERROR_PACKET_FLAGS {
    pub __bindgen_anon_1: _WHEA_ERROR_PACKET_FLAGS__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_ERROR_PACKET_FLAGS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _WHEA_ERROR_PACKET_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn PreviousError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PreviousError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PreviousError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PreviousError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CriticalEvent(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CriticalEvent(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CriticalEvent_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CriticalEvent_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn HypervisorError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HypervisorError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn HypervisorError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_HypervisorError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Simulated(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Simulated(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Simulated_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Simulated_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PlatformPfaControl(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PlatformPfaControl(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PlatformPfaControl_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PlatformPfaControl_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PlatformDirectedOffline(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PlatformDirectedOffline(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PlatformDirectedOffline_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PlatformDirectedOffline_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AddressTranslationRequired(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AddressTranslationRequired(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AddressTranslationRequired_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AddressTranslationRequired_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AddressTranslationCompleted(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AddressTranslationCompleted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AddressTranslationCompleted_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AddressTranslationCompleted_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RecoveryOptional(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RecoveryOptional(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RecoveryOptional_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RecoveryOptional_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                23u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                23u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PreviousError: ULONG,
        CriticalEvent: ULONG,
        HypervisorError: ULONG,
        Simulated: ULONG,
        PlatformPfaControl: ULONG,
        PlatformDirectedOffline: ULONG,
        AddressTranslationRequired: ULONG,
        AddressTranslationCompleted: ULONG,
        RecoveryOptional: ULONG,
        Reserved2: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PreviousError: u32 = unsafe { ::core::mem::transmute(PreviousError) };
            PreviousError as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CriticalEvent: u32 = unsafe { ::core::mem::transmute(CriticalEvent) };
            CriticalEvent as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let HypervisorError: u32 = unsafe { ::core::mem::transmute(HypervisorError) };
            HypervisorError as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Simulated: u32 = unsafe { ::core::mem::transmute(Simulated) };
            Simulated as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PlatformPfaControl: u32 = unsafe { ::core::mem::transmute(PlatformPfaControl) };
            PlatformPfaControl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PlatformDirectedOffline: u32 =
                unsafe { ::core::mem::transmute(PlatformDirectedOffline) };
            PlatformDirectedOffline as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let AddressTranslationRequired: u32 =
                unsafe { ::core::mem::transmute(AddressTranslationRequired) };
            AddressTranslationRequired as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let AddressTranslationCompleted: u32 =
                unsafe { ::core::mem::transmute(AddressTranslationCompleted) };
            AddressTranslationCompleted as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let RecoveryOptional: u32 = unsafe { ::core::mem::transmute(RecoveryOptional) };
            RecoveryOptional as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let Reserved2: u32 = unsafe { ::core::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_ERROR_PACKET_FLAGS = _WHEA_ERROR_PACKET_FLAGS;
pub type PWHEA_ERROR_PACKET_FLAGS = *mut _WHEA_ERROR_PACKET_FLAGS;
pub const _WHEA_ERROR_PACKET_DATA_FORMAT_WheaDataFormatIPFSalRecord:
_WHEA_ERROR_PACKET_DATA_FORMAT = 0;
pub const _WHEA_ERROR_PACKET_DATA_FORMAT_WheaDataFormatXPFMCA: _WHEA_ERROR_PACKET_DATA_FORMAT = 1;
pub const _WHEA_ERROR_PACKET_DATA_FORMAT_WheaDataFormatMemory: _WHEA_ERROR_PACKET_DATA_FORMAT = 2;
pub const _WHEA_ERROR_PACKET_DATA_FORMAT_WheaDataFormatPCIExpress: _WHEA_ERROR_PACKET_DATA_FORMAT =
    3;
pub const _WHEA_ERROR_PACKET_DATA_FORMAT_WheaDataFormatNMIPort: _WHEA_ERROR_PACKET_DATA_FORMAT = 4;
pub const _WHEA_ERROR_PACKET_DATA_FORMAT_WheaDataFormatPCIXBus: _WHEA_ERROR_PACKET_DATA_FORMAT = 5;
pub const _WHEA_ERROR_PACKET_DATA_FORMAT_WheaDataFormatPCIXDevice: _WHEA_ERROR_PACKET_DATA_FORMAT =
    6;
pub const _WHEA_ERROR_PACKET_DATA_FORMAT_WheaDataFormatGeneric: _WHEA_ERROR_PACKET_DATA_FORMAT = 7;
pub const _WHEA_ERROR_PACKET_DATA_FORMAT_WheaDataFormatMax: _WHEA_ERROR_PACKET_DATA_FORMAT = 8;
pub type _WHEA_ERROR_PACKET_DATA_FORMAT = core::ffi::c_int;
pub use self::_WHEA_ERROR_PACKET_DATA_FORMAT as WHEA_ERROR_PACKET_DATA_FORMAT;
pub type PWHEA_ERROR_PACKET_DATA_FORMAT = *mut _WHEA_ERROR_PACKET_DATA_FORMAT;
pub const _WHEA_RAW_DATA_FORMAT_WheaRawDataFormatIPFSalRecord: _WHEA_RAW_DATA_FORMAT = 0;
pub const _WHEA_RAW_DATA_FORMAT_WheaRawDataFormatIA32MCA: _WHEA_RAW_DATA_FORMAT = 1;
pub const _WHEA_RAW_DATA_FORMAT_WheaRawDataFormatIntel64MCA: _WHEA_RAW_DATA_FORMAT = 2;
pub const _WHEA_RAW_DATA_FORMAT_WheaRawDataFormatAMD64MCA: _WHEA_RAW_DATA_FORMAT = 3;
pub const _WHEA_RAW_DATA_FORMAT_WheaRawDataFormatMemory: _WHEA_RAW_DATA_FORMAT = 4;
pub const _WHEA_RAW_DATA_FORMAT_WheaRawDataFormatPCIExpress: _WHEA_RAW_DATA_FORMAT = 5;
pub const _WHEA_RAW_DATA_FORMAT_WheaRawDataFormatNMIPort: _WHEA_RAW_DATA_FORMAT = 6;
pub const _WHEA_RAW_DATA_FORMAT_WheaRawDataFormatPCIXBus: _WHEA_RAW_DATA_FORMAT = 7;
pub const _WHEA_RAW_DATA_FORMAT_WheaRawDataFormatPCIXDevice: _WHEA_RAW_DATA_FORMAT = 8;
pub const _WHEA_RAW_DATA_FORMAT_WheaRawDataFormatGeneric: _WHEA_RAW_DATA_FORMAT = 9;
pub const _WHEA_RAW_DATA_FORMAT_WheaRawDataFormatMax: _WHEA_RAW_DATA_FORMAT = 10;
pub type _WHEA_RAW_DATA_FORMAT = core::ffi::c_int;
pub use self::_WHEA_RAW_DATA_FORMAT as WHEA_RAW_DATA_FORMAT;
pub type PWHEA_RAW_DATA_FORMAT = *mut _WHEA_RAW_DATA_FORMAT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_ERROR_PACKET_V1 {
    pub Signature: ULONG,
    pub Flags: WHEA_ERROR_PACKET_FLAGS,
    pub Size: ULONG,
    pub RawDataLength: ULONG,
    pub Reserved1: ULONGLONG,
    pub Context: ULONGLONG,
    pub ErrorType: WHEA_ERROR_TYPE,
    pub ErrorSeverity: WHEA_ERROR_SEVERITY,
    pub ErrorSourceId: ULONG,
    pub ErrorSourceType: WHEA_ERROR_SOURCE_TYPE,
    pub Reserved2: ULONG,
    pub Version: ULONG,
    pub Cpu: ULONGLONG,
    pub u: _WHEA_ERROR_PACKET_V1__bindgen_ty_1,
    pub RawDataFormat: WHEA_RAW_DATA_FORMAT,
    pub RawDataOffset: ULONG,
    pub RawData: [UCHAR; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_ERROR_PACKET_V1__bindgen_ty_1 {
    pub ProcessorError: WHEA_PROCESSOR_GENERIC_ERROR_SECTION,
    pub MemoryError: WHEA_MEMORY_ERROR_SECTION,
    pub NmiError: WHEA_NMI_ERROR_SECTION,
    pub PciExpressError: WHEA_PCIEXPRESS_ERROR_SECTION,
    pub PciXBusError: WHEA_PCIXBUS_ERROR_SECTION,
    pub PciXDeviceError: WHEA_PCIXDEVICE_ERROR_SECTION,
    pub PmemError: WHEA_PMEM_ERROR_SECTION,
}
pub type WHEA_ERROR_PACKET_V1 = _WHEA_ERROR_PACKET_V1;
pub type PWHEA_ERROR_PACKET_V1 = *mut _WHEA_ERROR_PACKET_V1;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_ERROR_PACKET_V2 {
    pub Signature: ULONG,
    pub Version: ULONG,
    pub Length: ULONG,
    pub Flags: WHEA_ERROR_PACKET_FLAGS,
    pub ErrorType: WHEA_ERROR_TYPE,
    pub ErrorSeverity: WHEA_ERROR_SEVERITY,
    pub ErrorSourceId: ULONG,
    pub ErrorSourceType: WHEA_ERROR_SOURCE_TYPE,
    pub NotifyType: GUID,
    pub Context: ULONGLONG,
    pub DataFormat: WHEA_ERROR_PACKET_DATA_FORMAT,
    pub Reserved1: ULONG,
    pub DataOffset: ULONG,
    pub DataLength: ULONG,
    pub PshedDataOffset: ULONG,
    pub PshedDataLength: ULONG,
}
pub type WHEA_ERROR_PACKET_V2 = _WHEA_ERROR_PACKET_V2;
pub type PWHEA_ERROR_PACKET_V2 = *mut _WHEA_ERROR_PACKET_V2;
pub type WHEA_ERROR_PACKET = _WHEA_ERROR_PACKET_V2;
pub type PWHEA_ERROR_PACKET = *mut _WHEA_ERROR_PACKET_V2;
pub type WHEA_PCI_DPC_SECTION = PCI_EXPRESS_DPC_CAPABILITY;
pub type PWHEA_PCI_DPC_SECTION = *mut PCI_EXPRESS_DPC_CAPABILITY;
pub const _WHEA_EVENT_LOG_ENTRY_TYPE_WheaEventLogEntryTypeInformational:
_WHEA_EVENT_LOG_ENTRY_TYPE = 0;
pub const _WHEA_EVENT_LOG_ENTRY_TYPE_WheaEventLogEntryTypeWarning: _WHEA_EVENT_LOG_ENTRY_TYPE = 1;
pub const _WHEA_EVENT_LOG_ENTRY_TYPE_WheaEventLogEntryTypeError: _WHEA_EVENT_LOG_ENTRY_TYPE = 2;
pub type _WHEA_EVENT_LOG_ENTRY_TYPE = core::ffi::c_int;
pub use self::_WHEA_EVENT_LOG_ENTRY_TYPE as WHEA_EVENT_LOG_ENTRY_TYPE;
pub type PWHEA_EVENT_LOG_ENTRY_TYPE = *mut _WHEA_EVENT_LOG_ENTRY_TYPE;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdCmcPollingTimeout: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483647;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdWheaInit: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483646;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdCmcSwitchToPolling: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483645;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdDroppedCorrectedError:
_WHEA_EVENT_LOG_ENTRY_ID = -2147483644;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdStartedReportHwError:
_WHEA_EVENT_LOG_ENTRY_ID = -2147483643;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdPFAMemoryOfflined: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483642;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdPFAMemoryRemoveMonitor:
_WHEA_EVENT_LOG_ENTRY_ID = -2147483641;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdPFAMemoryPolicy: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483640;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdPshedInjectError: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483639;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdOscCapabilities: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483638;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdPshedPluginRegister:
_WHEA_EVENT_LOG_ENTRY_ID = -2147483637;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdAddRemoveErrorSource:
_WHEA_EVENT_LOG_ENTRY_ID = -2147483636;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdWorkQueueItem: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483635;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdAttemptErrorRecovery:
_WHEA_EVENT_LOG_ENTRY_ID = -2147483634;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdMcaFoundErrorInBank:
_WHEA_EVENT_LOG_ENTRY_ID = -2147483633;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdMcaStuckErrorCheck: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483632;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdMcaErrorCleared: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483631;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdClearedPoison: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483630;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdProcessEINJ: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483629;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdProcessHEST: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483628;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdCreateGenericRecord:
_WHEA_EVENT_LOG_ENTRY_ID = -2147483627;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdErrorRecord: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483626;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdErrorRecordLimit: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483625;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdAerNotGrantedToOs: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483624;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdErrSrcArrayInvalid: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483623;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdAcpiTimeOut: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483622;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogCmciRestart: _WHEA_EVENT_LOG_ENTRY_ID = -2147483621;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogCmciFinalRestart: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483620;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryEtwOverFlow: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483619;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogAzccRootBusSearchErr: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483618;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogAzccRootBusList: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483617;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdErrSrcInvalid: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483616;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdGenericErrMemMap: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483615;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdPshedCallbackCollision:
_WHEA_EVENT_LOG_ENTRY_ID = -2147483614;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdSELBugCheckProgress:
_WHEA_EVENT_LOG_ENTRY_ID = -2147483613;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdPshedPluginLoad: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483612;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdPshedPluginUnload: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483611;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdPshedPluginSupported:
_WHEA_EVENT_LOG_ENTRY_ID = -2147483610;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdDeviceDriver: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483609;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdCmciImplPresent: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483608;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdCmciInitError: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483607;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdSELBugCheckRecovery:
_WHEA_EVENT_LOG_ENTRY_ID = -2147483606;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdDrvErrSrcInvalid: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483605;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdDrvHandleBusy: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483604;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdWheaHeartbeat: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483603;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogAzccRootBusPoisonSet: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483602;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdSELBugCheckInfo: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483601;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdErrDimmInfoMismatch:
_WHEA_EVENT_LOG_ENTRY_ID = -2147483600;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdeDpcEnabled: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483599;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryPageOfflineDone: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483598;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryPageOfflinePendMax: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483597;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdBadPageLimitReached:
_WHEA_EVENT_LOG_ENTRY_ID = -2147483596;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntrySrarDetail: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483595;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryEarlyError: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483594;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdPcieOverrideInfo: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483593;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdReadPcieOverridesErr:
_WHEA_EVENT_LOG_ENTRY_ID = -2147483592;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdPcieConfigInfo: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483591;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdPcieSummaryFailed: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483584;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdThrottleRegCorrupt: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483583;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdThrottleAddErrSrcFailed:
_WHEA_EVENT_LOG_ENTRY_ID = -2147483582;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdThrottleRegDataIgnored:
_WHEA_EVENT_LOG_ENTRY_ID = -2147483581;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdEnableKeyNotifFailed:
_WHEA_EVENT_LOG_ENTRY_ID = -2147483580;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdKeyNotificationFailed:
_WHEA_EVENT_LOG_ENTRY_ID = -2147483579;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdPcieRemoveDevice: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483578;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdPcieAddDevice: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483577;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdPcieSpuriousErrSource:
_WHEA_EVENT_LOG_ENTRY_ID = -2147483576;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdMemoryAddDevice: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483575;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdMemoryRemoveDevice: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483574;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdMemorySummaryFailed:
_WHEA_EVENT_LOG_ENTRY_ID = -2147483573;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdPcieDpcError: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483572;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdCpuBusesInitFailed: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483571;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdPshedPluginInitFailed:
_WHEA_EVENT_LOG_ENTRY_ID = -2147483570;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdFailedAddToDefectList:
_WHEA_EVENT_LOG_ENTRY_ID = -2147483569;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdDefectListFull: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483568;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdDefectListUEFIVarFailed:
_WHEA_EVENT_LOG_ENTRY_ID = -2147483567;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdDefectListCorrupt: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483566;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdBadHestNotifyData: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483565;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdSrasTableNotFound: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483564;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdSrasTableError: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483563;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdSrasTableEntries: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483562;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdRowFailure: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483561;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdCpusFrozen: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147483552;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdCpusFrozenNoCrashDump:
_WHEA_EVENT_LOG_ENTRY_ID = -2147483551;
pub const _WHEA_EVENT_LOG_ENTRY_ID_WheaEventLogEntryIdPshedPiTraceLog: _WHEA_EVENT_LOG_ENTRY_ID =
    -2147221488;
pub type _WHEA_EVENT_LOG_ENTRY_ID = core::ffi::c_int;
pub use self::_WHEA_EVENT_LOG_ENTRY_ID as WHEA_EVENT_LOG_ENTRY_ID;
pub type PWHEA_EVENT_LOG_ENTRY_ID = *mut _WHEA_EVENT_LOG_ENTRY_ID;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_EVENT_LOG_ENTRY_FLAGS {
    pub __bindgen_anon_1: _WHEA_EVENT_LOG_ENTRY_FLAGS__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_EVENT_LOG_ENTRY_FLAGS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _WHEA_EVENT_LOG_ENTRY_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LogInternalEtw(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LogInternalEtw(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LogInternalEtw_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_LogInternalEtw_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LogBlackbox(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LogBlackbox(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LogBlackbox_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_LogBlackbox_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn LogSel(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LogSel(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn LogSel_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_LogSel_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RawSel(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RawSel(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RawSel_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RawSel_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NoFormat(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoFormat(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NoFormat_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NoFormat_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Driver(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Driver(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Driver_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Driver_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved2_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                25u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved2_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                25u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Reserved1: ULONG,
        LogInternalEtw: ULONG,
        LogBlackbox: ULONG,
        LogSel: ULONG,
        RawSel: ULONG,
        NoFormat: ULONG,
        Driver: ULONG,
        Reserved2: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let LogInternalEtw: u32 = unsafe { ::core::mem::transmute(LogInternalEtw) };
            LogInternalEtw as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let LogBlackbox: u32 = unsafe { ::core::mem::transmute(LogBlackbox) };
            LogBlackbox as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let LogSel: u32 = unsafe { ::core::mem::transmute(LogSel) };
            LogSel as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let RawSel: u32 = unsafe { ::core::mem::transmute(RawSel) };
            RawSel as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let NoFormat: u32 = unsafe { ::core::mem::transmute(NoFormat) };
            NoFormat as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Driver: u32 = unsafe { ::core::mem::transmute(Driver) };
            Driver as u64
        });
        __bindgen_bitfield_unit.set(7usize, 25u8, {
            let Reserved2: u32 = unsafe { ::core::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_EVENT_LOG_ENTRY_FLAGS = _WHEA_EVENT_LOG_ENTRY_FLAGS;
pub type PWHEA_EVENT_LOG_ENTRY_FLAGS = *mut _WHEA_EVENT_LOG_ENTRY_FLAGS;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_EVENT_LOG_ENTRY_HEADER {
    pub Signature: ULONG,
    pub Version: ULONG,
    pub Length: ULONG,
    pub Type: WHEA_EVENT_LOG_ENTRY_TYPE,
    pub OwnerTag: ULONG,
    pub Id: WHEA_EVENT_LOG_ENTRY_ID,
    pub Flags: WHEA_EVENT_LOG_ENTRY_FLAGS,
    pub PayloadLength: ULONG,
}
pub type WHEA_EVENT_LOG_ENTRY_HEADER = _WHEA_EVENT_LOG_ENTRY_HEADER;
pub type PWHEA_EVENT_LOG_ENTRY_HEADER = *mut _WHEA_EVENT_LOG_ENTRY_HEADER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_EVENT_LOG_ENTRY {
    pub Header: WHEA_EVENT_LOG_ENTRY_HEADER,
}
pub type WHEA_EVENT_LOG_ENTRY = _WHEA_EVENT_LOG_ENTRY;
pub type PWHEA_EVENT_LOG_ENTRY = *mut _WHEA_EVENT_LOG_ENTRY;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEAP_DEFERRED_EVENT {
    pub ListEntry: LIST_ENTRY,
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
}
pub type WHEAP_DEFERRED_EVENT = _WHEAP_DEFERRED_EVENT;
pub type PWHEAP_DEFERRED_EVENT = *mut _WHEAP_DEFERRED_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEAP_BAD_HEST_NOTIFY_DATA_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub SourceId: USHORT,
    pub Reserved: USHORT,
    pub NotifyDesc: WHEA_NOTIFICATION_DESCRIPTOR,
}
pub type WHEAP_BAD_HEST_NOTIFY_DATA_EVENT = _WHEAP_BAD_HEST_NOTIFY_DATA_EVENT;
pub type PWHEAP_BAD_HEST_NOTIFY_DATA_EVENT = *mut _WHEAP_BAD_HEST_NOTIFY_DATA_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEAP_STARTED_REPORT_HW_ERROR {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub ErrorPacket: PWHEA_ERROR_PACKET,
}
pub type WHEAP_STARTED_REPORT_HW_ERROR = _WHEAP_STARTED_REPORT_HW_ERROR;
pub type PWHEAP_STARTED_REPORT_HW_ERROR = *mut _WHEAP_STARTED_REPORT_HW_ERROR;
pub const _WHEAP_PFA_OFFLINE_DECISION_TYPE_WheapPfaOfflinePredictiveFailure:
_WHEAP_PFA_OFFLINE_DECISION_TYPE = 1;
pub const _WHEAP_PFA_OFFLINE_DECISION_TYPE_WheapPfaOfflineUncorrectedError:
_WHEAP_PFA_OFFLINE_DECISION_TYPE = 2;
pub type _WHEAP_PFA_OFFLINE_DECISION_TYPE = core::ffi::c_int;
pub use self::_WHEAP_PFA_OFFLINE_DECISION_TYPE as WHEAP_PFA_OFFLINE_DECISION_TYPE;
pub type PWHEAP_PFA_OFFLINE_DECISION_TYPE = *mut _WHEAP_PFA_OFFLINE_DECISION_TYPE;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEAP_PFA_MEMORY_OFFLINED {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub DecisionType: WHEAP_PFA_OFFLINE_DECISION_TYPE,
    pub ImmediateSuccess: BOOLEAN,
    pub Page: ULONG,
}
pub type WHEAP_PFA_MEMORY_OFFLINED = _WHEAP_PFA_MEMORY_OFFLINED;
pub type PWHEAP_PFA_MEMORY_OFFLINED = *mut _WHEAP_PFA_MEMORY_OFFLINED;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEAP_PSHED_INJECT_ERROR {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub ErrorType: ULONG,
    pub Parameter1: ULONGLONG,
    pub Parameter2: ULONGLONG,
    pub Parameter3: ULONGLONG,
    pub Parameter4: ULONGLONG,
    pub InjectionStatus: NTSTATUS,
    pub InjectionAttempted: BOOLEAN,
    pub InjectionByPlugin: BOOLEAN,
}
pub type WHEAP_PSHED_INJECT_ERROR = _WHEAP_PSHED_INJECT_ERROR;
pub type PWHEAP_PSHED_INJECT_ERROR = *mut _WHEAP_PSHED_INJECT_ERROR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEAP_OSC_IMPLEMENTED {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub OscImplemented: BOOLEAN,
    pub DebugChecked: BOOLEAN,
}
pub type WHEAP_OSC_IMPLEMENTED = _WHEAP_OSC_IMPLEMENTED;
pub type PWHEAP_OSC_IMPLEMENTED = *mut _WHEAP_OSC_IMPLEMENTED;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEAP_PSHED_PLUGIN_REGISTER {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub Version: ULONG,
    pub Length: ULONG,
    pub FunctionalAreaMask: ULONG,
    pub Status: NTSTATUS,
}
pub type WHEAP_PSHED_PLUGIN_REGISTER = _WHEAP_PSHED_PLUGIN_REGISTER;
pub type PWHEAP_PSHED_PLUGIN_REGISTER = *mut _WHEAP_PSHED_PLUGIN_REGISTER;
pub const _WHEA_PFA_REMOVE_TRIGGER_WheaPfaRemoveErrorThreshold: _WHEA_PFA_REMOVE_TRIGGER = 1;
pub const _WHEA_PFA_REMOVE_TRIGGER_WheaPfaRemoveTimeout: _WHEA_PFA_REMOVE_TRIGGER = 2;
pub const _WHEA_PFA_REMOVE_TRIGGER_WheaPfaRemoveCapacity: _WHEA_PFA_REMOVE_TRIGGER = 3;
pub type _WHEA_PFA_REMOVE_TRIGGER = core::ffi::c_int;
pub use self::_WHEA_PFA_REMOVE_TRIGGER as WHEA_PFA_REMOVE_TRIGGER;
pub type PWHEA_PFA_REMOVE_TRIGGER = *mut _WHEA_PFA_REMOVE_TRIGGER;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEAP_PFA_MEMORY_REMOVE_MONITOR {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub RemoveTrigger: WHEA_PFA_REMOVE_TRIGGER,
    pub TimeInList: ULONG,
    pub ErrorCount: ULONG,
    pub Page: ULONG,
}
pub type WHEAP_PFA_MEMORY_REMOVE_MONITOR = _WHEAP_PFA_MEMORY_REMOVE_MONITOR;
pub type PWHEAP_PFA_MEMORY_REMOVE_MONITOR = *mut _WHEAP_PFA_MEMORY_REMOVE_MONITOR;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEAP_PFA_MEMORY_POLICY {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub RegistryKeysPresent: ULONG,
    pub DisableOffline: BOOLEAN,
    pub PersistOffline: BOOLEAN,
    pub PfaDisabled: BOOLEAN,
    pub PageCount: ULONG,
    pub ErrorThreshold: ULONG,
    pub TimeOut: ULONG,
}
pub type WHEAP_PFA_MEMORY_POLICY = _WHEAP_PFA_MEMORY_POLICY;
pub type PWHEAP_PFA_MEMORY_POLICY = *mut _WHEAP_PFA_MEMORY_POLICY;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEAP_DROPPED_CORRECTED_ERROR_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub ErrorSourceType: WHEA_ERROR_SOURCE_TYPE,
    pub ErrorSourceId: ULONG,
}
pub type WHEAP_DROPPED_CORRECTED_ERROR_EVENT = _WHEAP_DROPPED_CORRECTED_ERROR_EVENT;
pub type PWHEAP_DROPPED_CORRECTED_ERROR_EVENT = *mut _WHEAP_DROPPED_CORRECTED_ERROR_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEAP_CLEARED_POISON_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub PhysicalAddress: ULONG64,
}
pub type WHEAP_CLEARED_POISON_EVENT = _WHEAP_CLEARED_POISON_EVENT;
pub type PWHEAP_CLEARED_POISON_EVENT = *mut _WHEAP_CLEARED_POISON_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEAP_ADD_REMOVE_ERROR_SOURCE_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub Descriptor: WHEA_ERROR_SOURCE_DESCRIPTOR,
    pub Status: NTSTATUS,
    pub IsRemove: BOOLEAN,
}
pub type WHEAP_ADD_REMOVE_ERROR_SOURCE_EVENT = _WHEAP_ADD_REMOVE_ERROR_SOURCE_EVENT;
pub type PWHEAP_ADD_REMOVE_ERROR_SOURCE_EVENT = *mut _WHEAP_ADD_REMOVE_ERROR_SOURCE_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEAP_ATTEMPT_RECOVERY_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub ErrorHeader: WHEA_ERROR_RECORD_HEADER,
    pub ArchitecturalRecovery: BOOLEAN,
    pub PshedRecovery: BOOLEAN,
    pub Status: NTSTATUS,
}
pub type WHEAP_ATTEMPT_RECOVERY_EVENT = _WHEAP_ATTEMPT_RECOVERY_EVENT;
pub type PWHEAP_ATTEMPT_RECOVERY_EVENT = *mut _WHEAP_ATTEMPT_RECOVERY_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEAP_FOUND_ERROR_IN_BANK_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub EpIndex: ULONG,
    pub Bank: ULONG,
    pub MciStatus: ULONG64,
    pub ErrorType: ULONG,
}
pub type WHEAP_FOUND_ERROR_IN_BANK_EVENT = _WHEAP_FOUND_ERROR_IN_BANK_EVENT;
pub type PWHEAP_FOUND_ERROR_IN_BANK_EVENT = *mut _WHEAP_FOUND_ERROR_IN_BANK_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEAP_STUCK_ERROR_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub EpIndex: ULONG,
    pub Bank: ULONG,
    pub MciStatus: ULONG64,
}
pub type WHEAP_STUCK_ERROR_EVENT = _WHEAP_STUCK_ERROR_EVENT;
pub type PWHEAP_STUCK_ERROR_EVENT = *mut _WHEAP_STUCK_ERROR_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEAP_ERROR_CLEARED_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub EpIndex: ULONG,
    pub Bank: ULONG,
}
pub type WHEAP_ERROR_CLEARED_EVENT = _WHEAP_ERROR_CLEARED_EVENT;
pub type PWHEAP_ERROR_CLEARED_EVENT = *mut _WHEAP_ERROR_CLEARED_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEAP_PROCESS_EINJ_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub Error: [CHAR; 32usize],
    pub InjectionActionTableValid: BOOLEAN,
    pub BeginInjectionInstructionCount: ULONG,
    pub GetTriggerErrorActionTableInstructionCount: ULONG,
    pub SetErrorTypeInstructionCount: ULONG,
    pub GetErrorTypeInstructionCount: ULONG,
    pub EndOperationInstructionCount: ULONG,
    pub ExecuteOperationInstructionCount: ULONG,
    pub CheckBusyStatusInstructionCount: ULONG,
    pub GetCommandStatusInstructionCount: ULONG,
    pub SetErrorTypeWithAddressInstructionCount: ULONG,
    pub GetExecuteOperationTimingsInstructionCount: ULONG,
}
pub type WHEAP_PROCESS_EINJ_EVENT = _WHEAP_PROCESS_EINJ_EVENT;
pub type PWHEAP_PROCESS_EINJ_EVENT = *mut _WHEAP_PROCESS_EINJ_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEAP_PROCESS_HEST_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub Error: [CHAR; 32usize],
    pub EntryType: [CHAR; 32usize],
    pub EntryIndex: ULONG,
    pub HestValid: BOOLEAN,
    pub CmcCount: ULONG,
    pub MceCount: ULONG,
    pub NmiCount: ULONG,
    pub AerRootCount: ULONG,
    pub AerBridgeCount: ULONG,
    pub AerEndPointCount: ULONG,
    pub GenericV1Count: ULONG,
    pub GenericV2Count: ULONG,
}
pub type WHEAP_PROCESS_HEST_EVENT = _WHEAP_PROCESS_HEST_EVENT;
pub type PWHEAP_PROCESS_HEST_EVENT = *mut _WHEAP_PROCESS_HEST_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEAP_CREATE_GENERIC_RECORD_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub Error: [CHAR; 32usize],
    pub EntryCount: ULONG,
    pub Status: NTSTATUS,
}
pub type WHEAP_CREATE_GENERIC_RECORD_EVENT = _WHEAP_CREATE_GENERIC_RECORD_EVENT;
pub type PWHEAP_CREATE_GENERIC_RECORD_EVENT = *mut _WHEAP_CREATE_GENERIC_RECORD_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEAP_ERROR_RECORD_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub Record: PWHEA_ERROR_RECORD,
}
pub type WHEAP_ERROR_RECORD_EVENT = _WHEAP_ERROR_RECORD_EVENT;
pub type PWHEAP_ERROR_RECORD_EVENT = *mut _WHEAP_ERROR_RECORD_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEAP_ERR_SRC_ARRAY_INVALID_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub ErrorSourceCount: ULONG,
    pub ReportedLength: ULONG,
    pub ExpectedLength: ULONG,
}
pub type WHEAP_ERR_SRC_ARRAY_INVALID_EVENT = _WHEAP_ERR_SRC_ARRAY_INVALID_EVENT;
pub type PWHEAP_ERR_SRC_ARRAY_INVALID_EVENT = *mut _WHEAP_ERR_SRC_ARRAY_INVALID_EVENT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEAP_ERR_SRC_INVALID_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub ErrDescriptor: WHEA_ERROR_SOURCE_DESCRIPTOR,
    pub Error: [CHAR; 32usize],
}
pub type WHEAP_ERR_SRC_INVALID_EVENT = _WHEAP_ERR_SRC_INVALID_EVENT;
pub type PWHEAP_ERR_SRC_INVALID_EVENT = *mut _WHEAP_ERR_SRC_INVALID_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEAP_GENERIC_ERR_MEM_MAP_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub MapReason: [CHAR; 32usize],
    pub PhysicalAddress: ULONG64,
    pub Length: ULONG64,
}
pub type WHEAP_GENERIC_ERR_MEM_MAP_EVENT = _WHEAP_GENERIC_ERR_MEM_MAP_EVENT;
pub type PWHEAP_GENERIC_ERR_MEM_MAP_EVENT = *mut _WHEAP_GENERIC_ERR_MEM_MAP_EVENT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEAP_ACPI_TIMEOUT_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub TableType: [CHAR; 32usize],
    pub TableRequest: [CHAR; 32usize],
}
pub type WHEAP_ACPI_TIMEOUT_EVENT = _WHEAP_ACPI_TIMEOUT_EVENT;
pub type PWHEAP_ACPI_TIMEOUT_EVENT = *mut _WHEAP_ACPI_TIMEOUT_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEAP_CMCI_RESTART_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub CmciRestoreAttempts: ULONG,
    pub MaxCmciRestoreLimit: ULONG,
    pub MaxCorrectedErrorsFound: ULONG,
    pub MaxCorrectedErrorLimit: ULONG,
}
pub type WHEAP_CMCI_RESTART_EVENT = _WHEAP_CMCI_RESTART_EVENT;
pub type PWHEAP_CMCI_RESTART_EVENT = *mut _WHEAP_CMCI_RESTART_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_SEL_BUGCHECK_PROGRESS {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub BugCheckCode: ULONG,
    pub BugCheckProgressSummary: ULONG,
}
pub type WHEA_SEL_BUGCHECK_PROGRESS = _WHEA_SEL_BUGCHECK_PROGRESS;
pub type PWHEA_SEL_BUGCHECK_PROGRESS = *mut _WHEA_SEL_BUGCHECK_PROGRESS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_SEL_BUGCHECK_RECOVERY_STATUS_START_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub StartingIrql: KIRQL,
}
pub type WHEA_SEL_BUGCHECK_RECOVERY_STATUS_START_EVENT =
_WHEA_SEL_BUGCHECK_RECOVERY_STATUS_START_EVENT;
pub type PWHEA_SEL_BUGCHECK_RECOVERY_STATUS_START_EVENT =
*mut _WHEA_SEL_BUGCHECK_RECOVERY_STATUS_START_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_SEL_BUGCHECK_RECOVERY_STATUS_PHASE1_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub Success: BOOLEAN,
    pub Version: UCHAR,
    pub EntryCount: USHORT,
    pub Data: _WHEA_SEL_BUGCHECK_RECOVERY_STATUS_PHASE1_EVENT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_SEL_BUGCHECK_RECOVERY_STATUS_PHASE1_EVENT__bindgen_ty_1 {
    pub DumpPolicy: UCHAR,
    pub Reserved: [UCHAR; 3usize],
}
pub type WHEA_SEL_BUGCHECK_RECOVERY_STATUS_PHASE1_EVENT =
_WHEA_SEL_BUGCHECK_RECOVERY_STATUS_PHASE1_EVENT;
pub type PWHEA_SEL_BUGCHECK_RECOVERY_STATUS_PHASE1_EVENT =
*mut _WHEA_SEL_BUGCHECK_RECOVERY_STATUS_PHASE1_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_SEL_BUGCHECK_RECOVERY_STATUS_PHASE2_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub BootId: ULONG,
    pub Success: BOOLEAN,
}
pub type WHEA_SEL_BUGCHECK_RECOVERY_STATUS_PHASE2_EVENT =
_WHEA_SEL_BUGCHECK_RECOVERY_STATUS_PHASE2_EVENT;
pub type PWHEA_SEL_BUGCHECK_RECOVERY_STATUS_PHASE2_EVENT =
*mut _WHEA_SEL_BUGCHECK_RECOVERY_STATUS_PHASE2_EVENT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_SEL_BUGCHECK_RECOVERY_STATUS_MULTIPLE_BUGCHECK_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub IsBugcheckOwner: BOOLEAN,
    pub RecursionCount: UCHAR,
    pub IsBugcheckRecoveryOwner: BOOLEAN,
}
pub type WHEA_SEL_BUGCHECK_RECOVERY_STATUS_MULTIPLE_BUGCHECK_EVENT =
_WHEA_SEL_BUGCHECK_RECOVERY_STATUS_MULTIPLE_BUGCHECK_EVENT;
pub type PWHEA_SEL_BUGCHECK_RECOVERY_STATUS_MULTIPLE_BUGCHECK_EVENT =
*mut _WHEA_SEL_BUGCHECK_RECOVERY_STATUS_MULTIPLE_BUGCHECK_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_PSHED_PLUGIN_LOAD_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub PluginName: [WCHAR; 32usize],
    pub MajorVersion: ULONG,
    pub MinorVersion: ULONG,
}
pub type WHEA_PSHED_PLUGIN_LOAD_EVENT = _WHEA_PSHED_PLUGIN_LOAD_EVENT;
pub type PWHEA_PSHED_PLUGIN_LOAD_EVENT = *mut _WHEA_PSHED_PLUGIN_LOAD_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_PSHED_PLUGIN_UNLOAD_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub PluginName: [WCHAR; 32usize],
}
pub type WHEA_PSHED_PLUGIN_UNLOAD_EVENT = _WHEA_PSHED_PLUGIN_UNLOAD_EVENT;
pub type PWHEA_PSHED_PLUGIN_UNLOAD_EVENT = *mut _WHEA_PSHED_PLUGIN_UNLOAD_EVENT;
pub const _WHEA_PSHED_PLUGIN_ENABLE_NOTIFY_ERRORS_PshedPiEnableNotifyErrorCreateNotifyEvent:
_WHEA_PSHED_PLUGIN_ENABLE_NOTIFY_ERRORS = 1;
pub const _WHEA_PSHED_PLUGIN_ENABLE_NOTIFY_ERRORS_PshedPiEnableNotifyErrorCreateSystemThread:
_WHEA_PSHED_PLUGIN_ENABLE_NOTIFY_ERRORS = 2;
pub const _WHEA_PSHED_PLUGIN_ENABLE_NOTIFY_ERRORS_PshedPiEnableNotifyErrorMax:
_WHEA_PSHED_PLUGIN_ENABLE_NOTIFY_ERRORS = 3;
pub type _WHEA_PSHED_PLUGIN_ENABLE_NOTIFY_ERRORS = core::ffi::c_int;
pub use self::_WHEA_PSHED_PLUGIN_ENABLE_NOTIFY_ERRORS as WHEA_PSHED_PLUGIN_ENABLE_NOTIFY_ERRORS;
pub type PWHEA_PSHED_PLUGIN_ENABLE_NOTIFY_ERRORS = *mut _WHEA_PSHED_PLUGIN_ENABLE_NOTIFY_ERRORS;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_PSHED_PLUGIN_ENABLE_NOTIFY_FAILED_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub EnableError: WHEA_PSHED_PLUGIN_ENABLE_NOTIFY_ERRORS,
}
pub type WHEA_PSHED_PLUGIN_ENABLE_NOTIFY_FAILED_EVENT =
_WHEA_PSHED_PLUGIN_ENABLE_NOTIFY_FAILED_EVENT;
pub type PWHEA_PSHED_PLUGIN_ENABLE_NOTIFY_FAILED_EVENT =
*mut _WHEA_PSHED_PLUGIN_ENABLE_NOTIFY_FAILED_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_PSHED_PLUGIN_PLATFORM_SUPPORT_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub PluginName: [WCHAR; 32usize],
    pub Supported: BOOLEAN,
}
pub type WHEA_PSHED_PLUGIN_PLATFORM_SUPPORT_EVENT = _WHEA_PSHED_PLUGIN_PLATFORM_SUPPORT_EVENT;
pub type PWHEA_PSHED_PLUGIN_PLATFORM_SUPPORT_EVENT = *mut _WHEA_PSHED_PLUGIN_PLATFORM_SUPPORT_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_PSHED_PLUGIN_INIT_FAILED_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub Status: NTSTATUS,
}
pub type WHEA_PSHED_PLUGIN_INIT_FAILED_EVENT = _WHEA_PSHED_PLUGIN_INIT_FAILED_EVENT;
pub type PWHEA_PSHED_PLUGIN_INIT_FAILED_EVENT = *mut _WHEA_PSHED_PLUGIN_INIT_FAILED_EVENT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_PSHED_PLUGIN_HEARTBEAT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
}
pub type WHEA_PSHED_PLUGIN_HEARTBEAT = _WHEA_PSHED_PLUGIN_HEARTBEAT;
pub type PWHEA_PSHED_PLUGIN_HEARTBEAT = *mut _WHEA_PSHED_PLUGIN_HEARTBEAT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_PSHED_PLUGIN_DIMM_MISMATCH {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub FirmwareBank: UINT16,
    pub FirmwareCol: UINT16,
    pub FirmwareRow: UINT16,
    pub RetryRdBank: UINT16,
    pub RetryRdCol: UINT16,
    pub RetryRdRow: UINT16,
    pub TaBank: UINT16,
    pub TaCol: UINT16,
    pub TaRow: UINT16,
}
pub type WHEA_PSHED_PLUGIN_DIMM_MISMATCH = _WHEA_PSHED_PLUGIN_DIMM_MISMATCH;
pub type PWHEA_PSHED_PLUGIN_DIMM_MISMATCH = *mut _WHEA_PSHED_PLUGIN_DIMM_MISMATCH;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_ETW_OVERFLOW_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub RecordId: ULONGLONG,
}
pub type WHEA_ETW_OVERFLOW_EVENT = _WHEA_ETW_OVERFLOW_EVENT;
pub type PWHEA_ETW_OVERFLOW_EVENT = *mut _WHEA_ETW_OVERFLOW_EVENT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEAP_CMCI_IMPLEMENTED_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub CmciAvailable: BOOLEAN,
}
pub type WHEAP_CMCI_IMPLEMENTED_EVENT = _WHEAP_CMCI_IMPLEMENTED_EVENT;
pub type PWHEAP_CMCI_IMPLEMENTED_EVENT = *mut _WHEAP_CMCI_IMPLEMENTED_EVENT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEAP_DEVICE_DRV_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub Function: [CHAR; 32usize],
}
pub type WHEAP_DEVICE_DRV_EVENT = _WHEAP_DEVICE_DRV_EVENT;
pub type PWHEAP_DEVICE_DRV_EVENT = *mut _WHEAP_DEVICE_DRV_EVENT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEAP_PLUGIN_PFA_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub NoFurtherPfa: BOOLEAN,
}
pub type WHEAP_PLUGIN_PFA_EVENT = _WHEAP_PLUGIN_PFA_EVENT;
pub type PWHEAP_PLUGIN_PFA_EVENT = *mut _WHEAP_PLUGIN_PFA_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEAP_CMCI_INITERR_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub Msr: ULONGLONG,
    pub Type: ULONG,
    pub Bank: ULONG,
    pub EpIndex: ULONG,
}
pub type WHEAP_CMCI_INITERR_EVENT = _WHEAP_CMCI_INITERR_EVENT;
pub type PWHEAP_CMCI_INITERR_EVENT = *mut _WHEAP_CMCI_INITERR_EVENT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_AZCC_ROOT_BUS_ERR_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub MaxBusCountPassed: BOOLEAN,
    pub InvalidBusMSR: BOOLEAN,
}
pub type WHEA_AZCC_ROOT_BUS_ERR_EVENT = _WHEA_AZCC_ROOT_BUS_ERR_EVENT;
pub type PWHEA_AZCC_ROOT_BUS_ERR_EVENT = *mut _WHEA_AZCC_ROOT_BUS_ERR_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_AZCC_ROOT_BUS_LIST_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub RootBusCount: UINT32,
    pub RootBuses: [UINT32; 8usize],
}
pub type WHEA_AZCC_ROOT_BUS_LIST_EVENT = _WHEA_AZCC_ROOT_BUS_LIST_EVENT;
pub type PWHEA_AZCC_ROOT_BUS_LIST_EVENT = *mut _WHEA_AZCC_ROOT_BUS_LIST_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_AZCC_SET_POISON_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub Bus: UINT32,
    pub ReadSuccess: BOOLEAN,
    pub WriteSuccess: BOOLEAN,
    pub IsEnable: BOOLEAN,
}
pub type WHEA_AZCC_SET_POISON_EVENT = _WHEA_AZCC_SET_POISON_EVENT;
pub type PWHEA_AZCC_SET_POISON_EVENT = *mut _WHEA_AZCC_SET_POISON_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_OFFLINE_DONE_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub Address: ULONG64,
}
pub type WHEA_OFFLINE_DONE_EVENT = _WHEA_OFFLINE_DONE_EVENT;
pub type PWHEA_OFFLINE_DONE_EVENT = *mut _WHEA_OFFLINE_DONE_EVENT;
pub const _WHEA_BUGCHECK_RECOVERY_LOG_TYPE_WheaEventBugCheckRecoveryEntry:
_WHEA_BUGCHECK_RECOVERY_LOG_TYPE = 0;
pub const _WHEA_BUGCHECK_RECOVERY_LOG_TYPE_WheaEventBugCheckRecoveryReturn:
_WHEA_BUGCHECK_RECOVERY_LOG_TYPE = 1;
pub const _WHEA_BUGCHECK_RECOVERY_LOG_TYPE_WheaEventBugCheckRecoveryMax:
_WHEA_BUGCHECK_RECOVERY_LOG_TYPE = 2;
pub type _WHEA_BUGCHECK_RECOVERY_LOG_TYPE = core::ffi::c_int;
pub use self::_WHEA_BUGCHECK_RECOVERY_LOG_TYPE as WHEA_BUGCHECK_RECOVERY_LOG_TYPE;
pub type PWHEA_BUGCHECK_RECOVERY_LOG_TYPE = *mut _WHEA_BUGCHECK_RECOVERY_LOG_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEAP_EDPC_ENABLED_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub eDPCEnabled: BOOLEAN,
    pub eDPCRecovEnabled: BOOLEAN,
}
pub type WHEAP_EDPC_ENABLED_EVENT = _WHEAP_EDPC_ENABLED_EVENT;
pub type PWHEAP_EDPC_ENABLED_EVENT = *mut _WHEAP_EDPC_ENABLED_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_SRAR_DETAIL_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub RecoveryContextFlags: UINT32,
    pub RecoveryContextPa: UINT64,
    pub PageOfflineStatus: NTSTATUS,
    pub KernelConsumerError: BOOLEAN,
}
pub type WHEA_SRAR_DETAIL_EVENT = _WHEA_SRAR_DETAIL_EVENT;
pub type PWHEA_SRAR_DETAIL_EVENT = *mut _WHEA_SRAR_DETAIL_EVENT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_FAILED_ADD_DEFECT_LIST_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
}
pub type WHEA_FAILED_ADD_DEFECT_LIST_EVENT = _WHEA_FAILED_ADD_DEFECT_LIST_EVENT;
pub type PWHEA_FAILED_ADD_DEFECT_LIST_EVENT = *mut _WHEA_FAILED_ADD_DEFECT_LIST_EVENT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEAP_PLUGIN_DEFECT_LIST_FULL_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
}
pub type WHEAP_PLUGIN_DEFECT_LIST_FULL_EVENT = _WHEAP_PLUGIN_DEFECT_LIST_FULL_EVENT;
pub type PWHEAP_PLUGIN_DEFECT_LIST_FULL_EVENT = *mut _WHEAP_PLUGIN_DEFECT_LIST_FULL_EVENT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEAP_PLUGIN_DEFECT_LIST_UEFI_VAR_FAILED {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
}
pub type WHEAP_PLUGIN_DEFECT_LIST_UEFI_VAR_FAILED = _WHEAP_PLUGIN_DEFECT_LIST_UEFI_VAR_FAILED;
pub type PWHEAP_PLUGIN_DEFECT_LIST_UEFI_VAR_FAILED = *mut _WHEAP_PLUGIN_DEFECT_LIST_UEFI_VAR_FAILED;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEAP_PLUGIN_DEFECT_LIST_CORRUPT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
}
pub type WHEAP_PLUGIN_DEFECT_LIST_CORRUPT = _WHEAP_PLUGIN_DEFECT_LIST_CORRUPT;
pub type PWHEAP_PLUGIN_DEFECT_LIST_CORRUPT = *mut _WHEAP_PLUGIN_DEFECT_LIST_CORRUPT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEAP_SPURIOUS_AER_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub ErrorSeverity: WHEA_ERROR_SEVERITY,
    pub ErrorHandlerType: ULONG,
    pub SpuriousErrorSourceId: ULONG,
    pub RootErrorCommand: ULONG,
    pub RootErrorStatus: ULONG,
    pub DeviceAssociationBitmap: ULONG,
}
pub type WHEAP_SPURIOUS_AER_EVENT = _WHEAP_SPURIOUS_AER_EVENT;
pub type PWHEAP_SPURIOUS_AER_EVENT = *mut _WHEAP_SPURIOUS_AER_EVENT;
pub const _WHEAP_DPC_ERROR_EVENT_TYPE_WheapDpcErrNoErr: _WHEAP_DPC_ERROR_EVENT_TYPE = 0;
pub const _WHEAP_DPC_ERROR_EVENT_TYPE_WheapDpcErrBusNotFound: _WHEAP_DPC_ERROR_EVENT_TYPE = 1;
pub const _WHEAP_DPC_ERROR_EVENT_TYPE_WheapDpcErrDpcedSubtree: _WHEAP_DPC_ERROR_EVENT_TYPE = 2;
pub const _WHEAP_DPC_ERROR_EVENT_TYPE_WheapDpcErrDeviceIdBad: _WHEAP_DPC_ERROR_EVENT_TYPE = 3;
pub const _WHEAP_DPC_ERROR_EVENT_TYPE_WheapDpcErrResetFailed: _WHEAP_DPC_ERROR_EVENT_TYPE = 4;
pub const _WHEAP_DPC_ERROR_EVENT_TYPE_WheapDpcErrNoChildren: _WHEAP_DPC_ERROR_EVENT_TYPE = 5;
pub type _WHEAP_DPC_ERROR_EVENT_TYPE = core::ffi::c_int;
pub use self::_WHEAP_DPC_ERROR_EVENT_TYPE as WHEAP_DPC_ERROR_EVENT_TYPE;
pub type PWHEAP_DPC_ERROR_EVENT_TYPE = *mut _WHEAP_DPC_ERROR_EVENT_TYPE;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEAP_DPC_ERROR_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub ErrType: WHEAP_DPC_ERROR_EVENT_TYPE,
    pub Bus: ULONG,
    pub Device: ULONG,
    pub Function: ULONG,
    pub DeviceId: USHORT,
    pub VendorId: USHORT,
}
pub type WHEAP_DPC_ERROR_EVENT = _WHEAP_DPC_ERROR_EVENT;
pub type PWHEAP_DPC_ERROR_EVENT = *mut _WHEAP_DPC_ERROR_EVENT;
pub const _PSHED_PI_ERR_READING_PCIE_OVERRIDES_PshedPiErrReadingPcieOverridesNoErr:
_PSHED_PI_ERR_READING_PCIE_OVERRIDES = 0;
pub const _PSHED_PI_ERR_READING_PCIE_OVERRIDES_PshedPiErrReadingPcieOverridesNoMemory:
_PSHED_PI_ERR_READING_PCIE_OVERRIDES = 1;
pub const _PSHED_PI_ERR_READING_PCIE_OVERRIDES_PshedPiErrReadingPcieOverridesQueryErr:
_PSHED_PI_ERR_READING_PCIE_OVERRIDES = 2;
pub const _PSHED_PI_ERR_READING_PCIE_OVERRIDES_PshedPiErrReadingPcieOverridesBadSize:
_PSHED_PI_ERR_READING_PCIE_OVERRIDES = 3;
pub const _PSHED_PI_ERR_READING_PCIE_OVERRIDES_PshedPiErrReadingPcieOverridesBadSignature:
_PSHED_PI_ERR_READING_PCIE_OVERRIDES = 4;
pub const _PSHED_PI_ERR_READING_PCIE_OVERRIDES_PshedPiErrReadingPcieOverridesNoCapOffset:
_PSHED_PI_ERR_READING_PCIE_OVERRIDES = 5;
pub const _PSHED_PI_ERR_READING_PCIE_OVERRIDES_PshedPiErrReadingPcieOverridesNotBinary:
_PSHED_PI_ERR_READING_PCIE_OVERRIDES = 6;
pub type _PSHED_PI_ERR_READING_PCIE_OVERRIDES = core::ffi::c_int;
pub use self::_PSHED_PI_ERR_READING_PCIE_OVERRIDES as PSHED_PI_ERR_READING_PCIE_OVERRIDES;
pub type PPSHED_PI_ERR_READING_PCIE_OVERRIDES = *mut _PSHED_PI_ERR_READING_PCIE_OVERRIDES;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEAP_PCIE_OVERRIDE_INFO {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub Segment: UINT32,
    pub Bus: UINT32,
    pub Device: UINT32,
    pub Function: UINT32,
    pub ValidBits: UINT8,
    pub Reserved: [UINT8; 3usize],
    pub UncorrectableErrorMask: UINT32,
    pub UncorrectableErrorSeverity: UINT32,
    pub CorrectableErrorMask: UINT32,
    pub CapAndControl: UINT32,
}
pub type WHEAP_PCIE_OVERRIDE_INFO = _WHEAP_PCIE_OVERRIDE_INFO;
pub type PWHEAP_PCIE_OVERRIDE_INFO = *mut _WHEAP_PCIE_OVERRIDE_INFO;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEAP_PCIE_READ_OVERRIDES_ERR {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub FailureReason: UINT32,
    pub FailureStatus: NTSTATUS,
}
pub type WHEAP_PCIE_READ_OVERRIDES_ERR = _WHEAP_PCIE_READ_OVERRIDES_ERR;
pub type PWHEAP_PCIE_READ_OVERRIDES_ERR = *mut _WHEAP_PCIE_READ_OVERRIDES_ERR;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEAP_PCIE_CONFIG_INFO {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub Segment: UINT32,
    pub Bus: UINT32,
    pub Device: UINT32,
    pub Function: UINT32,
    pub Offset: UINT32,
    pub Length: UINT32,
    pub Value: UINT64,
    pub Succeeded: UINT8,
    pub Reserved: [UINT8; 3usize],
}
pub type WHEAP_PCIE_CONFIG_INFO = _WHEAP_PCIE_CONFIG_INFO;
pub type PWHEAP_PCIE_CONFIG_INFO = *mut _WHEAP_PCIE_CONFIG_INFO;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_THROTTLE_PCIE_ADD_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub Address: WHEA_PCIE_ADDRESS,
    pub Mask: UINT32,
    pub Updated: BOOLEAN,
    pub Status: NTSTATUS,
}
pub type WHEA_THROTTLE_PCIE_ADD_EVENT = _WHEA_THROTTLE_PCIE_ADD_EVENT;
pub type PWHEA_THROTTLE_PCIE_ADD_EVENT = *mut _WHEA_THROTTLE_PCIE_ADD_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_THROTTLE_MEMORY_ADD_OR_REMOVE_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub SocketId: UINT32,
    pub ChannelId: UINT32,
    pub DimmSlot: UINT32,
}
pub type WHEA_THROTTLE_MEMORY_ADD_OR_REMOVE_EVENT = _WHEA_THROTTLE_MEMORY_ADD_OR_REMOVE_EVENT;
pub type PWHEA_THROTTLE_MEMORY_ADD_OR_REMOVE_EVENT = *mut _WHEA_THROTTLE_MEMORY_ADD_OR_REMOVE_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_THROTTLE_PCIE_REMOVE_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub Address: WHEA_PCIE_ADDRESS,
    pub Mask: UINT32,
}
pub type WHEA_THROTTLE_PCIE_REMOVE_EVENT = _WHEA_THROTTLE_PCIE_REMOVE_EVENT;
pub type PWHEA_THROTTLE_PCIE_REMOVE_EVENT = *mut _WHEA_THROTTLE_PCIE_REMOVE_EVENT;
pub const _WHEA_THROTTLE_TYPE_WheaPcieThrottle: _WHEA_THROTTLE_TYPE = 0;
pub const _WHEA_THROTTLE_TYPE_WheaMemoryThrottle: _WHEA_THROTTLE_TYPE = 1;
pub type _WHEA_THROTTLE_TYPE = core::ffi::c_int;
pub use self::_WHEA_THROTTLE_TYPE as WHEA_THROTTLE_TYPE;
pub type PWHEA_THROTTLE_TYPE = *mut _WHEA_THROTTLE_TYPE;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_THROTTLE_REGISTRY_CORRUPT_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub ThrottleType: WHEA_THROTTLE_TYPE,
}
pub type WHEA_THROTTLE_REGISTRY_CORRUPT_EVENT = _WHEA_THROTTLE_REGISTRY_CORRUPT_EVENT;
pub type PWHEA_THROTTLE_REGISTRY_CORRUPT_EVENT = *mut _WHEA_THROTTLE_REGISTRY_CORRUPT_EVENT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_THROTTLE_ADD_ERR_SRC_FAILED_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
}
pub type WHEA_THROTTLE_ADD_ERR_SRC_FAILED_EVENT = _WHEA_THROTTLE_ADD_ERR_SRC_FAILED_EVENT;
pub type PWHEA_THROTTLE_ADD_ERR_SRC_FAILED_EVENT = *mut _WHEA_THROTTLE_ADD_ERR_SRC_FAILED_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_THROTTLE_REG_DATA_IGNORED_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub ThrottleType: WHEA_THROTTLE_TYPE,
}
pub type WHEA_THROTTLE_REG_DATA_IGNORED_EVENT = _WHEA_THROTTLE_REG_DATA_IGNORED_EVENT;
pub type PWHEA_THROTTLE_REG_DATA_IGNORED_EVENT = *mut _WHEA_THROTTLE_REG_DATA_IGNORED_EVENT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_REGISTER_KEY_NOTIFICATION_FAILED_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
}
pub type WHEA_REGISTER_KEY_NOTIFICATION_FAILED_EVENT = _WHEA_REGISTER_KEY_NOTIFICATION_FAILED_EVENT;
pub type PWHEA_REGISTER_KEY_NOTIFICATION_FAILED_EVENT =
*mut _WHEA_REGISTER_KEY_NOTIFICATION_FAILED_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_MEMORY_THROTTLE_SUMMARY_FAILED_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub Status: NTSTATUS,
}
pub type WHEA_MEMORY_THROTTLE_SUMMARY_FAILED_EVENT = _WHEA_MEMORY_THROTTLE_SUMMARY_FAILED_EVENT;
pub type PWHEA_MEMORY_THROTTLE_SUMMARY_FAILED_EVENT =
*mut _WHEA_MEMORY_THROTTLE_SUMMARY_FAILED_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_PSHED_PI_CPU_BUSES_INIT_FAILED_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub Status: NTSTATUS,
}
pub type WHEA_PSHED_PI_CPU_BUSES_INIT_FAILED_EVENT = _WHEA_PSHED_PI_CPU_BUSES_INIT_FAILED_EVENT;
pub type PWHEA_PSHED_PI_CPU_BUSES_INIT_FAILED_EVENT =
*mut _WHEA_PSHED_PI_CPU_BUSES_INIT_FAILED_EVENT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_PSHED_PI_TRACE_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub Buffer: [CCHAR; 256usize],
}
pub type WHEA_PSHED_PI_TRACE_EVENT = _WHEA_PSHED_PI_TRACE_EVENT;
pub type PWHEA_PSHED_PI_TRACE_EVENT = *mut _WHEA_PSHED_PI_TRACE_EVENT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_SRAS_TABLE_NOT_FOUND {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
}
pub type WHEA_SRAS_TABLE_NOT_FOUND = _WHEA_SRAS_TABLE_NOT_FOUND;
pub type PWHEA_SRAS_TABLE_NOT_FOUND = *mut _WHEA_SRAS_TABLE_NOT_FOUND;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_SRAS_TABLE_ERROR {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
}
pub type WHEA_SRAS_TABLE_ERROR = _WHEA_SRAS_TABLE_ERROR;
pub type PWHEA_SRAS_TABLE_ERROR = *mut _WHEA_SRAS_TABLE_ERROR;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_ACPI_HEADER {
    pub Signature: UINT32,
    pub Length: UINT32,
    pub Revision: UINT8,
    pub Checksum: UINT8,
    pub OemId: [UINT8; 6usize],
    pub OemTableId: UINT64,
    pub OemRevision: UINT32,
    pub CreatorId: UINT32,
    pub CreatorRevision: UINT32,
}
pub type WHEA_ACPI_HEADER = _WHEA_ACPI_HEADER;
pub type PWHEA_ACPI_HEADER = *mut _WHEA_ACPI_HEADER;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _SIGNAL_REG_VALUE {
    pub RegName: [UINT8; 32usize],
    pub MsrAddr: UINT32,
    pub Value: UINT64,
}
pub type SIGNAL_REG_VALUE = _SIGNAL_REG_VALUE;
pub type PSIGNAL_REG_VALUE = *mut _SIGNAL_REG_VALUE;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _EFI_ACPI_RAS_SIGNAL_TABLE {
    pub Header: WHEA_ACPI_HEADER,
    pub NumberRecord: UINT32,
    pub Entries: [SIGNAL_REG_VALUE; 1usize],
}
pub type EFI_ACPI_RAS_SIGNAL_TABLE = _EFI_ACPI_RAS_SIGNAL_TABLE;
pub type PEFI_ACPI_RAS_SIGNAL_TABLE = *mut _EFI_ACPI_RAS_SIGNAL_TABLE;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_SRAS_TABLE_ENTRIES_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub LogNumber: UINT32,
    pub NumberSignals: UINT32,
    pub Data: [UINT8; 1usize],
}
pub type WHEA_SRAS_TABLE_ENTRIES_EVENT = _WHEA_SRAS_TABLE_ENTRIES_EVENT;
pub type PWHEA_SRAS_TABLE_ENTRIES_EVENT = *mut _WHEA_SRAS_TABLE_ENTRIES_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEAP_ROW_FAILURE_EVENT {
    pub WheaEventLogEntry: WHEA_EVENT_LOG_ENTRY,
    pub LowOrderPage: PFN_NUMBER,
    pub HighOrderPage: PFN_NUMBER,
}
pub type WHEAP_ROW_FAILURE_EVENT = _WHEAP_ROW_FAILURE_EVENT;
pub type PWHEAP_ROW_FAILURE_EVENT = *mut _WHEAP_ROW_FAILURE_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _WHEA_GENERIC_ERROR_BLOCKSTATUS {
    pub __bindgen_anon_1: _WHEA_GENERIC_ERROR_BLOCKSTATUS__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_GENERIC_ERROR_BLOCKSTATUS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _WHEA_GENERIC_ERROR_BLOCKSTATUS__bindgen_ty_1 {
    #[inline]
    pub fn UncorrectableError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UncorrectableError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UncorrectableError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_UncorrectableError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CorrectableError(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CorrectableError(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CorrectableError_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CorrectableError_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MultipleUncorrectableErrors(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MultipleUncorrectableErrors(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MultipleUncorrectableErrors_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MultipleUncorrectableErrors_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MultipleCorrectableErrors(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MultipleCorrectableErrors(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MultipleCorrectableErrors_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MultipleCorrectableErrors_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ErrorDataEntryCount(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_ErrorDataEntryCount(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ErrorDataEntryCount_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                10u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ErrorDataEntryCount_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                10u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                18u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                18u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        UncorrectableError: ULONG,
        CorrectableError: ULONG,
        MultipleUncorrectableErrors: ULONG,
        MultipleCorrectableErrors: ULONG,
        ErrorDataEntryCount: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let UncorrectableError: u32 = unsafe { ::core::mem::transmute(UncorrectableError) };
            UncorrectableError as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CorrectableError: u32 = unsafe { ::core::mem::transmute(CorrectableError) };
            CorrectableError as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let MultipleUncorrectableErrors: u32 =
                unsafe { ::core::mem::transmute(MultipleUncorrectableErrors) };
            MultipleUncorrectableErrors as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let MultipleCorrectableErrors: u32 =
                unsafe { ::core::mem::transmute(MultipleCorrectableErrors) };
            MultipleCorrectableErrors as u64
        });
        __bindgen_bitfield_unit.set(4usize, 10u8, {
            let ErrorDataEntryCount: u32 = unsafe { ::core::mem::transmute(ErrorDataEntryCount) };
            ErrorDataEntryCount as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_GENERIC_ERROR_BLOCKSTATUS = _WHEA_GENERIC_ERROR_BLOCKSTATUS;
pub type PWHEA_GENERIC_ERROR_BLOCKSTATUS = *mut _WHEA_GENERIC_ERROR_BLOCKSTATUS;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_GENERIC_ERROR {
    pub BlockStatus: WHEA_GENERIC_ERROR_BLOCKSTATUS,
    pub RawDataOffset: ULONG,
    pub RawDataLength: ULONG,
    pub DataLength: ULONG,
    pub ErrorSeverity: WHEA_ERROR_SEVERITY,
    pub Data: [UCHAR; 1usize],
}
pub type WHEA_GENERIC_ERROR = _WHEA_GENERIC_ERROR;
pub type PWHEA_GENERIC_ERROR = *mut _WHEA_GENERIC_ERROR;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_GENERIC_ERROR_DATA_ENTRY_V1 {
    pub SectionType: GUID,
    pub ErrorSeverity: WHEA_ERROR_SEVERITY,
    pub Revision: WHEA_REVISION,
    pub ValidBits: UCHAR,
    pub Flags: UCHAR,
    pub ErrorDataLength: ULONG,
    pub FRUId: GUID,
    pub FRUText: [UCHAR; 20usize],
    pub Data: [UCHAR; 1usize],
}
pub type WHEA_GENERIC_ERROR_DATA_ENTRY_V1 = _WHEA_GENERIC_ERROR_DATA_ENTRY_V1;
pub type PWHEA_GENERIC_ERROR_DATA_ENTRY_V1 = *mut _WHEA_GENERIC_ERROR_DATA_ENTRY_V1;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WHEA_GENERIC_ERROR_DATA_ENTRY_V2 {
    pub SectionType: GUID,
    pub ErrorSeverity: WHEA_ERROR_SEVERITY,
    pub Revision: WHEA_REVISION,
    pub ValidBits: UCHAR,
    pub Flags: UCHAR,
    pub ErrorDataLength: ULONG,
    pub FRUId: GUID,
    pub FRUText: [UCHAR; 20usize],
    pub Timestamp: WHEA_TIMESTAMP,
    pub Data: [UCHAR; 1usize],
}
pub type WHEA_GENERIC_ERROR_DATA_ENTRY_V2 = _WHEA_GENERIC_ERROR_DATA_ENTRY_V2;
pub type PWHEA_GENERIC_ERROR_DATA_ENTRY_V2 = *mut _WHEA_GENERIC_ERROR_DATA_ENTRY_V2;
pub type WHEA_GENERIC_ERROR_DATA_ENTRY = _WHEA_GENERIC_ERROR_DATA_ENTRY_V2;
pub type PWHEA_GENERIC_ERROR_DATA_ENTRY = *mut _WHEA_GENERIC_ERROR_DATA_ENTRY_V2;
pub type _WHEA_ERROR_SOURCE_CORRECT = ::core::option::Option<
    unsafe extern "C" fn(
        ErrorSource: PWHEA_ERROR_SOURCE_DESCRIPTOR,
        MaximumSectionLength: PULONG,
    ) -> NTSTATUS,
>;
pub type WHEA_ERROR_SOURCE_CORRECT = _WHEA_ERROR_SOURCE_CORRECT;
pub type _WHEA_ERROR_SOURCE_INITIALIZE = ::core::option::Option<
    unsafe extern "C" fn(
        Phase: ULONG,
        ErrorSource: PWHEA_ERROR_SOURCE_DESCRIPTOR,
        Context: PVOID,
    ) -> NTSTATUS,
>;
pub type WHEA_ERROR_SOURCE_INITIALIZE = _WHEA_ERROR_SOURCE_INITIALIZE;
pub type _WHEA_ERROR_SOURCE_CREATE_RECORD = ::core::option::Option<
    unsafe extern "C" fn(
        ErrorSource: PWHEA_ERROR_SOURCE_DESCRIPTOR,
        ErrorPacket: PWHEA_ERROR_PACKET,
        ErrorRecord: PWHEA_ERROR_RECORD,
        BufferSize: ULONG,
        Context: PVOID,
    ) -> NTSTATUS,
>;
pub type WHEA_ERROR_SOURCE_CREATE_RECORD = _WHEA_ERROR_SOURCE_CREATE_RECORD;
pub type _WHEA_ERROR_SOURCE_RECOVER = ::core::option::Option<
    unsafe extern "C" fn(RecoveryContext: PVOID, Severity: PWHEA_ERROR_SEVERITY) -> NTSTATUS,
>;
pub type WHEA_ERROR_SOURCE_RECOVER = _WHEA_ERROR_SOURCE_RECOVER;
pub type _WHEA_ERROR_SOURCE_UNINITIALIZE =
::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
pub type WHEA_ERROR_SOURCE_UNINITIALIZE = _WHEA_ERROR_SOURCE_UNINITIALIZE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_ERROR_SOURCE_CONFIGURATION {
    pub Flags: ULONG,
    pub Correct: WHEA_ERROR_SOURCE_CORRECT,
    pub Initialize: WHEA_ERROR_SOURCE_INITIALIZE,
    pub CreateRecord: WHEA_ERROR_SOURCE_CREATE_RECORD,
    pub Recover: WHEA_ERROR_SOURCE_RECOVER,
    pub Uninitialize: WHEA_ERROR_SOURCE_UNINITIALIZE,
    pub Reserved: PVOID,
}
pub type WHEA_ERROR_SOURCE_CONFIGURATION = _WHEA_ERROR_SOURCE_CONFIGURATION;
pub type PWHEA_ERROR_SOURCE_CONFIGURATION = *mut _WHEA_ERROR_SOURCE_CONFIGURATION;
unsafe extern "C" {
    pub fn WheaAddErrorSourceDeviceDriver(
        Context: PVOID,
        Configuration: PWHEA_ERROR_SOURCE_CONFIGURATION_DEVICE_DRIVER,
        NumberPreallocatedErrorReports: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn WheaAddErrorSourceDeviceDriverV1(
        Context: PVOID,
        Configuration: PWHEA_ERROR_SOURCE_CONFIGURATION_DEVICE_DRIVER,
        NumBuffersToPreallocate: ULONG,
        MaxDataLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn WheaRemoveErrorSourceDeviceDriver(ErrorSourceId: ULONG) -> NTSTATUS;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_REPORT_HW_ERROR_DEVICE_DRIVER_FLAGS {
    pub __bindgen_anon_1: _WHEA_REPORT_HW_ERROR_DEVICE_DRIVER_FLAGS__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_REPORT_HW_ERROR_DEVICE_DRIVER_FLAGS__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _WHEA_REPORT_HW_ERROR_DEVICE_DRIVER_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                32u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                32u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(Reserved: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_REPORT_HW_ERROR_DEVICE_DRIVER_FLAGS = _WHEA_REPORT_HW_ERROR_DEVICE_DRIVER_FLAGS;
pub type PWHEA_REPORT_HW_ERROR_DEVICE_DRIVER_FLAGS = *mut _WHEA_REPORT_HW_ERROR_DEVICE_DRIVER_FLAGS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_PACKET_LOG_DATA {
    pub LogData: [UCHAR; 36usize],
    pub ExtraBytes: [UCHAR; 36usize],
    pub BcParam3: ULONG_PTR,
    pub BcParam4: ULONG_PTR,
    pub LogDataLength: ULONG,
    pub LogTag: USHORT,
    pub Reserved: USHORT,
    pub Flags: WHEA_REPORT_HW_ERROR_DEVICE_DRIVER_FLAGS,
}
pub type WHEA_PACKET_LOG_DATA = _WHEA_PACKET_LOG_DATA;
pub type PWHEA_PACKET_LOG_DATA = *mut _WHEA_PACKET_LOG_DATA;
unsafe extern "C" {
    pub fn WheaReportHwErrorDeviceDriver(
        ErrorSourceId: ULONG,
        DeviceObject: PDEVICE_OBJECT,
        ErrorData: PUCHAR,
        ErrorDataLength: ULONG,
        SectionTypeGuid: LPGUID,
        ErrorSeverity: WHEA_ERROR_SEVERITY,
        DeviceFriendlyName: LPSTR,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn WheaCreateHwErrorReportDeviceDriver(
        ErrorSourceId: ULONG,
        DeviceObject: PDEVICE_OBJECT,
    ) -> WHEA_ERROR_HANDLE;
}
unsafe extern "C" {
    pub fn WheaAddHwErrorReportSectionDeviceDriver(
        ErrorHandle: WHEA_ERROR_HANDLE,
        SectionDataLength: ULONG,
        BufferSet: PWHEA_DRIVER_BUFFER_SET,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn WheaHwErrorReportAbandonDeviceDriver(ErrorHandle: WHEA_ERROR_HANDLE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn WheaHwErrorReportSubmitDeviceDriver(ErrorHandle: WHEA_ERROR_HANDLE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn WheaHwErrorReportSetSeverityDeviceDriver(
        ErrorHandle: WHEA_ERROR_HANDLE,
        ErrorSeverity: WHEA_ERROR_SEVERITY,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn WheaHwErrorReportSetSectionNameDeviceDriver(
        BufferSet: PWHEA_DRIVER_BUFFER_SET,
        NameLength: ULONG,
        Name: PUCHAR,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn WheaReportHwError(ErrorPacket: PWHEA_ERROR_PACKET) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn WheaAddErrorSource(
        ErrorSource: PWHEA_ERROR_SOURCE_DESCRIPTOR,
        Context: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn WheaInitializeRecordHeader(Header: PWHEA_ERROR_RECORD_HEADER) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn WheaConfigureErrorSource(
        SourceType: WHEA_ERROR_SOURCE_TYPE,
        Configuration: PWHEA_ERROR_SOURCE_CONFIGURATION,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn WheaUnconfigureErrorSource(SourceType: WHEA_ERROR_SOURCE_TYPE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn WheaRemoveErrorSource(ErrorSourceId: ULONG);
}
unsafe extern "C" {
    pub fn WheaLogInternalEvent(Entry: PWHEA_EVENT_LOG_ENTRY);
}
unsafe extern "C" {
    pub fn WheaErrorSourceGetState(ErrorSourceId: ULONG) -> WHEA_ERROR_SOURCE_STATE;
}
unsafe extern "C" {
    pub fn WheaIsCriticalState() -> BOOLEAN;
}
pub type _WHEA_SIGNAL_HANDLER_OVERRIDE_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Context: UINT_PTR) -> BOOLEAN>;
pub type WHEA_SIGNAL_HANDLER_OVERRIDE_CALLBACK = _WHEA_SIGNAL_HANDLER_OVERRIDE_CALLBACK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_ERROR_SOURCE_OVERRIDE_SETTINGS {
    pub Type: WHEA_ERROR_SOURCE_TYPE,
    pub MaxRawDataLength: ULONG,
    pub NumRecordsToPreallocate: ULONG,
    pub MaxSectionsPerRecord: ULONG,
}
pub type WHEA_ERROR_SOURCE_OVERRIDE_SETTINGS = _WHEA_ERROR_SOURCE_OVERRIDE_SETTINGS;
pub type PWHEA_ERROR_SOURCE_OVERRIDE_SETTINGS = *mut _WHEA_ERROR_SOURCE_OVERRIDE_SETTINGS;
unsafe extern "C" {
    pub fn WheaSignalHandlerOverride(
        SourceType: WHEA_ERROR_SOURCE_TYPE,
        Context: UINT_PTR,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn WheaUnregisterErrorSourceOverride(
        Type: WHEA_ERROR_SOURCE_TYPE,
        OverrideErrorSourceId: ULONG32,
    );
}
unsafe extern "C" {
    pub fn WheaRegisterErrorSourceOverride(
        OverrideSettings: WHEA_ERROR_SOURCE_OVERRIDE_SETTINGS,
        OverrideConfig: PWHEA_ERROR_SOURCE_CONFIGURATION,
        OverrideCallback: WHEA_SIGNAL_HANDLER_OVERRIDE_CALLBACK,
    ) -> NTSTATUS;
}
pub type PFN_WHEA_HIGH_IRQL_LOG_SEL_EVENT_HANDLER = ::core::option::Option<
    unsafe extern "C" fn(Context: PVOID, OsSelRecord: PIPMI_OS_SEL_RECORD) -> NTSTATUS,
>;
unsafe extern "C" {
    pub fn WheaHighIrqlLogSelEventHandlerRegister(
        Handler: PFN_WHEA_HIGH_IRQL_LOG_SEL_EVENT_HANDLER,
        Context: PVOID,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn WheaHighIrqlLogSelEventHandlerUnregister();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_ERROR_INJECTION_CAPABILITIES {
    pub __bindgen_anon_1: _WHEA_ERROR_INJECTION_CAPABILITIES__bindgen_ty_1,
    pub AsULONG: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_ERROR_INJECTION_CAPABILITIES__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _WHEA_ERROR_INJECTION_CAPABILITIES__bindgen_ty_1 {
    #[inline]
    pub fn ProcessorCorrectable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessorCorrectable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ProcessorCorrectable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ProcessorCorrectable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ProcessorUncorrectableNonFatal(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessorUncorrectableNonFatal(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ProcessorUncorrectableNonFatal_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ProcessorUncorrectableNonFatal_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ProcessorUncorrectableFatal(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProcessorUncorrectableFatal(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ProcessorUncorrectableFatal_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ProcessorUncorrectableFatal_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemoryCorrectable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MemoryCorrectable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemoryCorrectable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemoryCorrectable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemoryUncorrectableNonFatal(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MemoryUncorrectableNonFatal(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemoryUncorrectableNonFatal_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemoryUncorrectableNonFatal_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MemoryUncorrectableFatal(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MemoryUncorrectableFatal(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MemoryUncorrectableFatal_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MemoryUncorrectableFatal_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PCIExpressCorrectable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PCIExpressCorrectable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PCIExpressCorrectable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PCIExpressCorrectable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PCIExpressUncorrectableNonFatal(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PCIExpressUncorrectableNonFatal(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PCIExpressUncorrectableNonFatal_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PCIExpressUncorrectableNonFatal_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PCIExpressUncorrectableFatal(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PCIExpressUncorrectableFatal(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PCIExpressUncorrectableFatal_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PCIExpressUncorrectableFatal_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PlatformCorrectable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PlatformCorrectable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PlatformCorrectable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PlatformCorrectable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PlatformUncorrectableNonFatal(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PlatformUncorrectableNonFatal(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PlatformUncorrectableNonFatal_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PlatformUncorrectableNonFatal_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PlatformUncorrectableFatal(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PlatformUncorrectableFatal(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PlatformUncorrectableFatal_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PlatformUncorrectableFatal_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IA64Corrected(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IA64Corrected(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IA64Corrected_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IA64Corrected_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IA64Recoverable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IA64Recoverable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IA64Recoverable_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IA64Recoverable_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IA64Fatal(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IA64Fatal(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IA64Fatal_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IA64Fatal_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IA64RecoverableCache(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IA64RecoverableCache(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IA64RecoverableCache_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IA64RecoverableCache_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn IA64RecoverableRegFile(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IA64RecoverableRegFile(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn IA64RecoverableRegFile_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_IA64RecoverableRegFile_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                15u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                15u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ProcessorCorrectable: ULONG,
        ProcessorUncorrectableNonFatal: ULONG,
        ProcessorUncorrectableFatal: ULONG,
        MemoryCorrectable: ULONG,
        MemoryUncorrectableNonFatal: ULONG,
        MemoryUncorrectableFatal: ULONG,
        PCIExpressCorrectable: ULONG,
        PCIExpressUncorrectableNonFatal: ULONG,
        PCIExpressUncorrectableFatal: ULONG,
        PlatformCorrectable: ULONG,
        PlatformUncorrectableNonFatal: ULONG,
        PlatformUncorrectableFatal: ULONG,
        IA64Corrected: ULONG,
        IA64Recoverable: ULONG,
        IA64Fatal: ULONG,
        IA64RecoverableCache: ULONG,
        IA64RecoverableRegFile: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ProcessorCorrectable: u32 = unsafe { ::core::mem::transmute(ProcessorCorrectable) };
            ProcessorCorrectable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ProcessorUncorrectableNonFatal: u32 =
                unsafe { ::core::mem::transmute(ProcessorUncorrectableNonFatal) };
            ProcessorUncorrectableNonFatal as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ProcessorUncorrectableFatal: u32 =
                unsafe { ::core::mem::transmute(ProcessorUncorrectableFatal) };
            ProcessorUncorrectableFatal as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let MemoryCorrectable: u32 = unsafe { ::core::mem::transmute(MemoryCorrectable) };
            MemoryCorrectable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let MemoryUncorrectableNonFatal: u32 =
                unsafe { ::core::mem::transmute(MemoryUncorrectableNonFatal) };
            MemoryUncorrectableNonFatal as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let MemoryUncorrectableFatal: u32 =
                unsafe { ::core::mem::transmute(MemoryUncorrectableFatal) };
            MemoryUncorrectableFatal as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PCIExpressCorrectable: u32 =
                unsafe { ::core::mem::transmute(PCIExpressCorrectable) };
            PCIExpressCorrectable as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PCIExpressUncorrectableNonFatal: u32 =
                unsafe { ::core::mem::transmute(PCIExpressUncorrectableNonFatal) };
            PCIExpressUncorrectableNonFatal as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let PCIExpressUncorrectableFatal: u32 =
                unsafe { ::core::mem::transmute(PCIExpressUncorrectableFatal) };
            PCIExpressUncorrectableFatal as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let PlatformCorrectable: u32 = unsafe { ::core::mem::transmute(PlatformCorrectable) };
            PlatformCorrectable as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let PlatformUncorrectableNonFatal: u32 =
                unsafe { ::core::mem::transmute(PlatformUncorrectableNonFatal) };
            PlatformUncorrectableNonFatal as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let PlatformUncorrectableFatal: u32 =
                unsafe { ::core::mem::transmute(PlatformUncorrectableFatal) };
            PlatformUncorrectableFatal as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let IA64Corrected: u32 = unsafe { ::core::mem::transmute(IA64Corrected) };
            IA64Corrected as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let IA64Recoverable: u32 = unsafe { ::core::mem::transmute(IA64Recoverable) };
            IA64Recoverable as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let IA64Fatal: u32 = unsafe { ::core::mem::transmute(IA64Fatal) };
            IA64Fatal as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let IA64RecoverableCache: u32 = unsafe { ::core::mem::transmute(IA64RecoverableCache) };
            IA64RecoverableCache as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let IA64RecoverableRegFile: u32 =
                unsafe { ::core::mem::transmute(IA64RecoverableRegFile) };
            IA64RecoverableRegFile as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_ERROR_INJECTION_CAPABILITIES = _WHEA_ERROR_INJECTION_CAPABILITIES;
pub type PWHEA_ERROR_INJECTION_CAPABILITIES = *mut _WHEA_ERROR_INJECTION_CAPABILITIES;
pub type PFN_IN_USE_PAGE_OFFLINE_NOTIFY = ::core::option::Option<
    unsafe extern "C" fn(
        Page: PFN_NUMBER,
        Flags: BOOLEAN,
        Poisoned: BOOLEAN,
        Context: PVOID,
    ) -> BOOLEAN,
>;
unsafe extern "C" {
    pub fn WheaRegisterInUsePageOfflineNotification(
        Callback: PFN_IN_USE_PAGE_OFFLINE_NOTIFY,
        Context: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn WheaUnregisterInUsePageOfflineNotification(
        Callback: PFN_IN_USE_PAGE_OFFLINE_NOTIFY,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn WheaGetNotifyAllOfflinesPolicy() -> BOOLEAN;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_IN_USE_PAGE_NOTIFY_FLAGS {
    pub Bits: _WHEA_IN_USE_PAGE_NOTIFY_FLAGS__bindgen_ty_1,
    pub AsUCHAR: UINT8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_IN_USE_PAGE_NOTIFY_FLAGS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _WHEA_IN_USE_PAGE_NOTIFY_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn PlatformDirected(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PlatformDirected(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PlatformDirected_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_PlatformDirected_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                5u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NotifyAllOfflines(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_NotifyAllOfflines(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NotifyAllOfflines_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_NotifyAllOfflines_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PageOfflined(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PageOfflined(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PageOfflined_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_PageOfflined_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PlatformDirected: UCHAR,
        Reserved: UCHAR,
        NotifyAllOfflines: UCHAR,
        PageOfflined: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PlatformDirected: u8 = unsafe { ::core::mem::transmute(PlatformDirected) };
            PlatformDirected as u64
        });
        __bindgen_bitfield_unit.set(1usize, 5u8, {
            let Reserved: u8 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let NotifyAllOfflines: u8 = unsafe { ::core::mem::transmute(NotifyAllOfflines) };
            NotifyAllOfflines as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PageOfflined: u8 = unsafe { ::core::mem::transmute(PageOfflined) };
            PageOfflined as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WHEA_IN_USE_PAGE_NOTIFY_FLAGS = _WHEA_IN_USE_PAGE_NOTIFY_FLAGS;
pub type PWHEA_IN_USE_PAGE_NOTIFY_FLAGS = *mut _WHEA_IN_USE_PAGE_NOTIFY_FLAGS;
pub const _WHEA_RECOVERY_CONTEXT_ERROR_TYPE_WheaRecoveryContextErrorTypeMemory:
_WHEA_RECOVERY_CONTEXT_ERROR_TYPE = 1;
pub const _WHEA_RECOVERY_CONTEXT_ERROR_TYPE_WheaRecoveryContextErrorTypePmem:
_WHEA_RECOVERY_CONTEXT_ERROR_TYPE = 2;
pub const _WHEA_RECOVERY_CONTEXT_ERROR_TYPE_WheaRecoveryContextErrorTypeMax:
_WHEA_RECOVERY_CONTEXT_ERROR_TYPE = 3;
pub type _WHEA_RECOVERY_CONTEXT_ERROR_TYPE = core::ffi::c_int;
pub use self::_WHEA_RECOVERY_CONTEXT_ERROR_TYPE as WHEA_RECOVERY_CONTEXT_ERROR_TYPE;
pub type PWHEA_RECOVERY_CONTEXT_ERROR_TYPE = *mut _WHEA_RECOVERY_CONTEXT_ERROR_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WHEA_RECOVERY_CONTEXT {
    pub __bindgen_anon_1: _WHEA_RECOVERY_CONTEXT__bindgen_ty_1,
    pub PartitionId: UINT64,
    pub VpIndex: UINT32,
    pub ErrorType: WHEA_RECOVERY_CONTEXT_ERROR_TYPE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHEA_RECOVERY_CONTEXT__bindgen_ty_1 {
    pub MemoryError: _WHEA_RECOVERY_CONTEXT__bindgen_ty_1__bindgen_ty_1,
    pub PmemError: _WHEA_RECOVERY_CONTEXT__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_RECOVERY_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    pub Address: ULONG_PTR,
    pub Consumed: BOOLEAN,
    pub ErrorCode: UINT16,
    pub ErrorIpValid: BOOLEAN,
    pub RestartIpValid: BOOLEAN,
    pub ClearPoison: BOOLEAN,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_RECOVERY_CONTEXT__bindgen_ty_1__bindgen_ty_2 {
    pub PmemErrInfo: ULONG_PTR,
}
pub type WHEA_RECOVERY_CONTEXT = _WHEA_RECOVERY_CONTEXT;
pub type PWHEA_RECOVERY_CONTEXT = *mut _WHEA_RECOVERY_CONTEXT;
pub type HVL_WHEA_ERROR_NOTIFICATION = ::core::option::Option<
    unsafe extern "C" fn(
        RecoveryContext: PWHEA_RECOVERY_CONTEXT,
        PlatformDirected: BOOLEAN,
        Poisoned: BOOLEAN,
    ) -> NTSTATUS,
>;
pub type PHVL_WHEA_ERROR_NOTIFICATION = HVL_WHEA_ERROR_NOTIFICATION;
unsafe extern "C" {
    pub static mut HvlpWheaErrorNotificationCallback: PHVL_WHEA_ERROR_NOTIFICATION;
}
unsafe extern "C" {
    pub fn HvlRegisterWheaErrorNotification(Callback: PHVL_WHEA_ERROR_NOTIFICATION) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn HvlUnregisterWheaErrorNotification(Callback: PHVL_WHEA_ERROR_NOTIFICATION) -> NTSTATUS;
}
pub type PSHED_PI_GET_ALL_ERROR_SOURCES = ::core::option::Option<
    unsafe extern "C" fn(
        PluginContext: PVOID,
        Count: PULONG,
        ErrorSrcs: *mut PWHEA_ERROR_SOURCE_DESCRIPTOR,
        Length: PULONG,
    ) -> NTSTATUS,
>;
pub type PSHED_PI_GET_ERROR_SOURCE_INFO = ::core::option::Option<
    unsafe extern "C" fn(
        PluginContext: PVOID,
        ErrorSource: PWHEA_ERROR_SOURCE_DESCRIPTOR,
    ) -> NTSTATUS,
>;
pub type PSHED_PI_SET_ERROR_SOURCE_INFO = ::core::option::Option<
    unsafe extern "C" fn(
        PluginContext: PVOID,
        ErrorSource: PWHEA_ERROR_SOURCE_DESCRIPTOR,
    ) -> NTSTATUS,
>;
pub type PSHED_PI_ENABLE_ERROR_SOURCE = ::core::option::Option<
    unsafe extern "C" fn(
        PluginContext: PVOID,
        ErrorSource: PWHEA_ERROR_SOURCE_DESCRIPTOR,
    ) -> NTSTATUS,
>;
pub type PSHED_PI_DISABLE_ERROR_SOURCE = ::core::option::Option<
    unsafe extern "C" fn(
        PluginContext: PVOID,
        ErrorSource: PWHEA_ERROR_SOURCE_DESCRIPTOR,
    ) -> NTSTATUS,
>;
pub type PSHED_PI_WRITE_ERROR_RECORD = ::core::option::Option<
    unsafe extern "C" fn(
        PluginContext: PVOID,
        Flags: ULONG,
        RecordLength: ULONG,
        ErrorRecord: PWHEA_ERROR_RECORD,
    ) -> NTSTATUS,
>;
pub type PSHED_PI_READ_ERROR_RECORD = ::core::option::Option<
    unsafe extern "C" fn(
        PluginContext: PVOID,
        Flags: ULONG,
        ErrorRecordId: ULONGLONG,
        NextErrorRecordId: PULONGLONG,
        RecordLength: PULONG,
        ErrorRecord: PWHEA_ERROR_RECORD,
    ) -> NTSTATUS,
>;
pub type PSHED_PI_CLEAR_ERROR_RECORD = ::core::option::Option<
    unsafe extern "C" fn(PluginContext: PVOID, Flags: ULONG, ErrorRecordId: ULONGLONG) -> NTSTATUS,
>;
pub type PSHED_PI_RETRIEVE_ERROR_INFO = ::core::option::Option<
    unsafe extern "C" fn(
        PluginContext: PVOID,
        ErrorSource: PWHEA_ERROR_SOURCE_DESCRIPTOR,
        BufferLength: ULONGLONG,
        Packet: PWHEA_ERROR_PACKET,
    ) -> NTSTATUS,
>;
pub type PSHED_PI_FINALIZE_ERROR_RECORD = ::core::option::Option<
    unsafe extern "C" fn(
        PluginContext: PVOID,
        ErrorSource: PWHEA_ERROR_SOURCE_DESCRIPTOR,
        BufferLength: ULONG,
        ErrorRecord: PWHEA_ERROR_RECORD,
    ) -> NTSTATUS,
>;
pub type PSHED_PI_CLEAR_ERROR_STATUS = ::core::option::Option<
    unsafe extern "C" fn(
        PluginContext: PVOID,
        ErrorSource: PWHEA_ERROR_SOURCE_DESCRIPTOR,
        BufferLength: ULONG,
        ErrorRecord: PWHEA_ERROR_RECORD,
    ) -> NTSTATUS,
>;
pub type PSHED_PI_ATTEMPT_ERROR_RECOVERY = ::core::option::Option<
    unsafe extern "C" fn(
        PluginContext: PVOID,
        BufferLength: ULONG,
        ErrorRecord: PWHEA_ERROR_RECORD,
    ) -> NTSTATUS,
>;
pub type PSHED_PI_GET_INJECTION_CAPABILITIES = ::core::option::Option<
    unsafe extern "C" fn(
        PluginContext: PVOID,
        Capabilities: PWHEA_ERROR_INJECTION_CAPABILITIES,
    ) -> NTSTATUS,
>;
pub type PSHED_PI_INJECT_ERROR = ::core::option::Option<
    unsafe extern "C" fn(
        PluginContext: PVOID,
        ErrorType: ULONGLONG,
        Parameter1: ULONGLONG,
        Parameter2: ULONGLONG,
        Parameter3: ULONGLONG,
        Parameter4: ULONGLONG,
    ) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_PSHED_PLUGIN_CALLBACKS {
    pub GetAllErrorSources: PSHED_PI_GET_ALL_ERROR_SOURCES,
    pub Reserved: PVOID,
    pub GetErrorSourceInfo: PSHED_PI_GET_ERROR_SOURCE_INFO,
    pub SetErrorSourceInfo: PSHED_PI_SET_ERROR_SOURCE_INFO,
    pub EnableErrorSource: PSHED_PI_ENABLE_ERROR_SOURCE,
    pub DisableErrorSource: PSHED_PI_DISABLE_ERROR_SOURCE,
    pub WriteErrorRecord: PSHED_PI_WRITE_ERROR_RECORD,
    pub ReadErrorRecord: PSHED_PI_READ_ERROR_RECORD,
    pub ClearErrorRecord: PSHED_PI_CLEAR_ERROR_RECORD,
    pub RetrieveErrorInfo: PSHED_PI_RETRIEVE_ERROR_INFO,
    pub FinalizeErrorRecord: PSHED_PI_FINALIZE_ERROR_RECORD,
    pub ClearErrorStatus: PSHED_PI_CLEAR_ERROR_STATUS,
    pub AttemptRecovery: PSHED_PI_ATTEMPT_ERROR_RECOVERY,
    pub GetInjectionCapabilities: PSHED_PI_GET_INJECTION_CAPABILITIES,
    pub InjectError: PSHED_PI_INJECT_ERROR,
}
pub type WHEA_PSHED_PLUGIN_CALLBACKS = _WHEA_PSHED_PLUGIN_CALLBACKS;
pub type PWHEA_PSHED_PLUGIN_CALLBACKS = *mut _WHEA_PSHED_PLUGIN_CALLBACKS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_PSHED_PLUGIN_REGISTRATION_PACKET_V1 {
    pub Length: ULONG,
    pub Version: ULONG,
    pub Context: PVOID,
    pub FunctionalAreaMask: ULONG,
    pub Reserved: ULONG,
    pub Callbacks: WHEA_PSHED_PLUGIN_CALLBACKS,
}
pub type WHEA_PSHED_PLUGIN_REGISTRATION_PACKET_V1 = _WHEA_PSHED_PLUGIN_REGISTRATION_PACKET_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHEA_PSHED_PLUGIN_REGISTRATION_PACKET_V2 {
    pub Length: ULONG,
    pub Version: ULONG,
    pub Context: PVOID,
    pub FunctionalAreaMask: ULONG,
    pub Reserved: ULONG,
    pub Callbacks: WHEA_PSHED_PLUGIN_CALLBACKS,
    pub PluginHandle: PVOID,
}
pub type WHEA_PSHED_PLUGIN_REGISTRATION_PACKET_V2 = _WHEA_PSHED_PLUGIN_REGISTRATION_PACKET_V2;
pub type WHEA_PSHED_PLUGIN_REGISTRATION_PACKET = WHEA_PSHED_PLUGIN_REGISTRATION_PACKET_V2;
pub type PWHEA_PSHED_PLUGIN_REGISTRATION_PACKET = *mut WHEA_PSHED_PLUGIN_REGISTRATION_PACKET;
unsafe extern "C" {
    pub fn PshedAllocateMemory(Size: ULONG) -> PVOID;
}
unsafe extern "C" {
    pub fn PshedFreeMemory(Address: PVOID);
}
unsafe extern "C" {
    pub fn PshedIsSystemWheaEnabled() -> BOOLEAN;
}
unsafe extern "C" {
    pub fn PshedRegisterPlugin(Packet: PWHEA_PSHED_PLUGIN_REGISTRATION_PACKET) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PshedUnregisterPlugin(PluginHandle: PVOID);
}
unsafe extern "C" {
    pub fn PshedSynchronizeExecution(
        ErrorSource: PWHEA_ERROR_SOURCE_DESCRIPTOR,
        SynchronizeRoutine: PKSYNCHRONIZE_ROUTINE,
        SynchronizeContext: PVOID,
    ) -> BOOLEAN;
}
pub const _SOC_SUBSYSTEM_TYPE_SOC_SUBSYS_WIRELESS_MODEM: _SOC_SUBSYSTEM_TYPE = 0;
pub const _SOC_SUBSYSTEM_TYPE_SOC_SUBSYS_AUDIO_DSP: _SOC_SUBSYSTEM_TYPE = 1;
pub const _SOC_SUBSYSTEM_TYPE_SOC_SUBSYS_WIRELSS_CONNECTIVITY: _SOC_SUBSYSTEM_TYPE = 2;
pub const _SOC_SUBSYSTEM_TYPE_SOC_SUBSYS_SENSORS: _SOC_SUBSYSTEM_TYPE = 3;
pub const _SOC_SUBSYSTEM_TYPE_SOC_SUBSYS_COMPUTE_DSP: _SOC_SUBSYSTEM_TYPE = 4;
pub const _SOC_SUBSYSTEM_TYPE_SOC_SUBSYS_SECURE_PROC: _SOC_SUBSYSTEM_TYPE = 5;
pub const _SOC_SUBSYSTEM_TYPE_SOC_SUBSYS_VENDOR_DEFINED: _SOC_SUBSYSTEM_TYPE = 65536;
pub type _SOC_SUBSYSTEM_TYPE = core::ffi::c_int;
pub use self::_SOC_SUBSYSTEM_TYPE as SOC_SUBSYSTEM_TYPE;
pub type PSOC_SUBSYSTEM_TYPE = *mut _SOC_SUBSYSTEM_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SOC_SUBSYSTEM_FAILURE_DETAILS {
    pub SubsysType: SOC_SUBSYSTEM_TYPE,
    pub FirmwareVersion: ULONG64,
    pub HardwareVersion: ULONG64,
    pub UnifiedFailureRegionSize: ULONG,
    pub UnifiedFailureRegion: [CHAR; 1usize],
}
pub type SOC_SUBSYSTEM_FAILURE_DETAILS = _SOC_SUBSYSTEM_FAILURE_DETAILS;
pub type PSOC_SUBSYSTEM_FAILURE_DETAILS = *mut _SOC_SUBSYSTEM_FAILURE_DETAILS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CPTABLEINFO {
    pub CodePage: USHORT,
    pub MaximumCharacterSize: USHORT,
    pub DefaultChar: USHORT,
    pub UniDefaultChar: USHORT,
    pub TransDefaultChar: USHORT,
    pub TransUniDefaultChar: USHORT,
    pub DBCSCodePage: USHORT,
    pub LeadByte: [UCHAR; 12usize],
    pub MultiByteTable: PUSHORT,
    pub WideCharTable: PVOID,
    pub DBCSRanges: PUSHORT,
    pub DBCSOffsets: PUSHORT,
}
pub type CPTABLEINFO = _CPTABLEINFO;
pub type PCPTABLEINFO = *mut _CPTABLEINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NLSTABLEINFO {
    pub OemTableInfo: CPTABLEINFO,
    pub AnsiTableInfo: CPTABLEINFO,
    pub UpperCaseTable: PUSHORT,
    pub LowerCaseTable: PUSHORT,
}
pub type NLSTABLEINFO = _NLSTABLEINFO;
pub type PNLSTABLEINFO = *mut _NLSTABLEINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_NLS_STATE {
    pub DefaultAcpTableInfo: CPTABLEINFO,
    pub DefaultOemTableInfo: CPTABLEINFO,
    pub ActiveCodePageData: PUSHORT,
    pub OemCodePageData: PUSHORT,
    pub LeadByteInfo: PUSHORT,
    pub OemLeadByteInfo: PUSHORT,
    pub CaseMappingData: PUSHORT,
    pub UnicodeUpcaseTable844: PUSHORT,
    pub UnicodeLowercaseTable844: PUSHORT,
}
pub type RTL_NLS_STATE = _RTL_NLS_STATE;
pub type PRTL_NLS_STATE = *mut _RTL_NLS_STATE;
pub type LSA_UNICODE_STRING = UNICODE_STRING;
pub type PLSA_UNICODE_STRING = *mut UNICODE_STRING;
pub type LSA_STRING = STRING;
pub type PLSA_STRING = *mut STRING;
pub type LSA_OBJECT_ATTRIBUTES = OBJECT_ATTRIBUTES;
pub type PLSA_OBJECT_ATTRIBUTES = *mut OBJECT_ATTRIBUTES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID_IDENTIFIER_AUTHORITY {
    pub Value: [UCHAR; 6usize],
}
pub type SID_IDENTIFIER_AUTHORITY = _SID_IDENTIFIER_AUTHORITY;
pub type PSID_IDENTIFIER_AUTHORITY = *mut _SID_IDENTIFIER_AUTHORITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID {
    pub Revision: UCHAR,
    pub SubAuthorityCount: UCHAR,
    pub IdentifierAuthority: SID_IDENTIFIER_AUTHORITY,
    pub SubAuthority: [ULONG; 1usize],
}
pub type SID = _SID;
pub type PISID = *mut _SID;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SE_SID {
    pub Sid: SID,
    pub Buffer: [UCHAR; 68usize],
}
pub type SE_SID = _SE_SID;
pub type PSE_SID = *mut _SE_SID;
pub const _SID_NAME_USE_SidTypeUser: _SID_NAME_USE = 1;
pub const _SID_NAME_USE_SidTypeGroup: _SID_NAME_USE = 2;
pub const _SID_NAME_USE_SidTypeDomain: _SID_NAME_USE = 3;
pub const _SID_NAME_USE_SidTypeAlias: _SID_NAME_USE = 4;
pub const _SID_NAME_USE_SidTypeWellKnownGroup: _SID_NAME_USE = 5;
pub const _SID_NAME_USE_SidTypeDeletedAccount: _SID_NAME_USE = 6;
pub const _SID_NAME_USE_SidTypeInvalid: _SID_NAME_USE = 7;
pub const _SID_NAME_USE_SidTypeUnknown: _SID_NAME_USE = 8;
pub const _SID_NAME_USE_SidTypeComputer: _SID_NAME_USE = 9;
pub const _SID_NAME_USE_SidTypeLabel: _SID_NAME_USE = 10;
pub const _SID_NAME_USE_SidTypeLogonSession: _SID_NAME_USE = 11;
pub type _SID_NAME_USE = core::ffi::c_int;
pub use self::_SID_NAME_USE as SID_NAME_USE;
pub type PSID_NAME_USE = *mut _SID_NAME_USE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID_AND_ATTRIBUTES {
    pub Sid: PSID,
    pub Attributes: ULONG,
}
pub type SID_AND_ATTRIBUTES = _SID_AND_ATTRIBUTES;
pub type PSID_AND_ATTRIBUTES = *mut _SID_AND_ATTRIBUTES;
pub type SID_AND_ATTRIBUTES_ARRAY = [SID_AND_ATTRIBUTES; 1usize];
pub type PSID_AND_ATTRIBUTES_ARRAY = *mut SID_AND_ATTRIBUTES_ARRAY;
pub type SID_HASH_ENTRY = ULONG_PTR;
pub type PSID_HASH_ENTRY = *mut ULONG_PTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID_AND_ATTRIBUTES_HASH {
    pub SidCount: ULONG,
    pub SidAttr: PSID_AND_ATTRIBUTES,
    pub Hash: [SID_HASH_ENTRY; 32usize],
}
pub type SID_AND_ATTRIBUTES_HASH = _SID_AND_ATTRIBUTES_HASH;
pub type PSID_AND_ATTRIBUTES_HASH = *mut _SID_AND_ATTRIBUTES_HASH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACE_HEADER {
    pub AceType: UCHAR,
    pub AceFlags: UCHAR,
    pub AceSize: USHORT,
}
pub type ACE_HEADER = _ACE_HEADER;
pub type PACE_HEADER = *mut ACE_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACCESS_ALLOWED_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: ULONG,
}
pub type ACCESS_ALLOWED_ACE = _ACCESS_ALLOWED_ACE;
pub type PACCESS_ALLOWED_ACE = *mut ACCESS_ALLOWED_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACCESS_DENIED_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: ULONG,
}
pub type ACCESS_DENIED_ACE = _ACCESS_DENIED_ACE;
pub type PACCESS_DENIED_ACE = *mut ACCESS_DENIED_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_AUDIT_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: ULONG,
}
pub type SYSTEM_AUDIT_ACE = _SYSTEM_AUDIT_ACE;
pub type PSYSTEM_AUDIT_ACE = *mut SYSTEM_AUDIT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ALARM_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: ULONG,
}
pub type SYSTEM_ALARM_ACE = _SYSTEM_ALARM_ACE;
pub type PSYSTEM_ALARM_ACE = *mut SYSTEM_ALARM_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_RESOURCE_ATTRIBUTE_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: ULONG,
}
pub type SYSTEM_RESOURCE_ATTRIBUTE_ACE = _SYSTEM_RESOURCE_ATTRIBUTE_ACE;
pub type PSYSTEM_RESOURCE_ATTRIBUTE_ACE = *mut _SYSTEM_RESOURCE_ATTRIBUTE_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_SCOPED_POLICY_ID_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: ULONG,
}
pub type SYSTEM_SCOPED_POLICY_ID_ACE = _SYSTEM_SCOPED_POLICY_ID_ACE;
pub type PSYSTEM_SCOPED_POLICY_ID_ACE = *mut _SYSTEM_SCOPED_POLICY_ID_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_MANDATORY_LABEL_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: ULONG,
}
pub type SYSTEM_MANDATORY_LABEL_ACE = _SYSTEM_MANDATORY_LABEL_ACE;
pub type PSYSTEM_MANDATORY_LABEL_ACE = *mut _SYSTEM_MANDATORY_LABEL_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_PROCESS_TRUST_LABEL_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: ULONG,
}
pub type SYSTEM_PROCESS_TRUST_LABEL_ACE = _SYSTEM_PROCESS_TRUST_LABEL_ACE;
pub type PSYSTEM_PROCESS_TRUST_LABEL_ACE = *mut _SYSTEM_PROCESS_TRUST_LABEL_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ACCESS_FILTER_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: ULONG,
}
pub type SYSTEM_ACCESS_FILTER_ACE = _SYSTEM_ACCESS_FILTER_ACE;
pub type PSYSTEM_ACCESS_FILTER_ACE = *mut _SYSTEM_ACCESS_FILTER_ACE;
pub type SECURITY_DESCRIPTOR_CONTROL = USHORT;
pub type PSECURITY_DESCRIPTOR_CONTROL = *mut USHORT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_DESCRIPTOR_RELATIVE {
    pub Revision: UCHAR,
    pub Sbz1: UCHAR,
    pub Control: SECURITY_DESCRIPTOR_CONTROL,
    pub Owner: ULONG,
    pub Group: ULONG,
    pub Sacl: ULONG,
    pub Dacl: ULONG,
}
pub type SECURITY_DESCRIPTOR_RELATIVE = _SECURITY_DESCRIPTOR_RELATIVE;
pub type PISECURITY_DESCRIPTOR_RELATIVE = *mut _SECURITY_DESCRIPTOR_RELATIVE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_DESCRIPTOR {
    pub Revision: UCHAR,
    pub Sbz1: UCHAR,
    pub Control: SECURITY_DESCRIPTOR_CONTROL,
    pub Owner: PSID,
    pub Group: PSID,
    pub Sacl: PACL,
    pub Dacl: PACL,
}
pub type SECURITY_DESCRIPTOR = _SECURITY_DESCRIPTOR;
pub type PISECURITY_DESCRIPTOR = *mut _SECURITY_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_OBJECT_AI_PARAMS {
    pub Size: ULONG,
    pub ConstraintMask: ULONG,
}
pub type SECURITY_OBJECT_AI_PARAMS = _SECURITY_OBJECT_AI_PARAMS;
pub type PSECURITY_OBJECT_AI_PARAMS = *mut _SECURITY_OBJECT_AI_PARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_TYPE_LIST {
    pub Level: USHORT,
    pub Sbz: USHORT,
    pub ObjectType: *mut GUID,
}
pub type OBJECT_TYPE_LIST = _OBJECT_TYPE_LIST;
pub type POBJECT_TYPE_LIST = *mut _OBJECT_TYPE_LIST;
pub const _AUDIT_EVENT_TYPE_AuditEventObjectAccess: _AUDIT_EVENT_TYPE = 0;
pub const _AUDIT_EVENT_TYPE_AuditEventDirectoryServiceAccess: _AUDIT_EVENT_TYPE = 1;
pub type _AUDIT_EVENT_TYPE = core::ffi::c_int;
pub use self::_AUDIT_EVENT_TYPE as AUDIT_EVENT_TYPE;
pub type PAUDIT_EVENT_TYPE = *mut _AUDIT_EVENT_TYPE;
pub const _ACCESS_REASON_TYPE_AccessReasonNone: _ACCESS_REASON_TYPE = 0;
pub const _ACCESS_REASON_TYPE_AccessReasonAllowedAce: _ACCESS_REASON_TYPE = 65536;
pub const _ACCESS_REASON_TYPE_AccessReasonDeniedAce: _ACCESS_REASON_TYPE = 131072;
pub const _ACCESS_REASON_TYPE_AccessReasonAllowedParentAce: _ACCESS_REASON_TYPE = 196608;
pub const _ACCESS_REASON_TYPE_AccessReasonDeniedParentAce: _ACCESS_REASON_TYPE = 262144;
pub const _ACCESS_REASON_TYPE_AccessReasonNotGrantedByCape: _ACCESS_REASON_TYPE = 327680;
pub const _ACCESS_REASON_TYPE_AccessReasonNotGrantedByParentCape: _ACCESS_REASON_TYPE = 393216;
pub const _ACCESS_REASON_TYPE_AccessReasonNotGrantedToAppContainer: _ACCESS_REASON_TYPE = 458752;
pub const _ACCESS_REASON_TYPE_AccessReasonMissingPrivilege: _ACCESS_REASON_TYPE = 1048576;
pub const _ACCESS_REASON_TYPE_AccessReasonFromPrivilege: _ACCESS_REASON_TYPE = 2097152;
pub const _ACCESS_REASON_TYPE_AccessReasonIntegrityLevel: _ACCESS_REASON_TYPE = 3145728;
pub const _ACCESS_REASON_TYPE_AccessReasonOwnership: _ACCESS_REASON_TYPE = 4194304;
pub const _ACCESS_REASON_TYPE_AccessReasonNullDacl: _ACCESS_REASON_TYPE = 5242880;
pub const _ACCESS_REASON_TYPE_AccessReasonEmptyDacl: _ACCESS_REASON_TYPE = 6291456;
pub const _ACCESS_REASON_TYPE_AccessReasonNoSD: _ACCESS_REASON_TYPE = 7340032;
pub const _ACCESS_REASON_TYPE_AccessReasonNoGrant: _ACCESS_REASON_TYPE = 8388608;
pub const _ACCESS_REASON_TYPE_AccessReasonTrustLabel: _ACCESS_REASON_TYPE = 9437184;
pub const _ACCESS_REASON_TYPE_AccessReasonFilterAce: _ACCESS_REASON_TYPE = 10485760;
pub type _ACCESS_REASON_TYPE = core::ffi::c_int;
pub use self::_ACCESS_REASON_TYPE as ACCESS_REASON_TYPE;
pub type ACCESS_REASON = ULONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACCESS_REASONS {
    pub Data: [ACCESS_REASON; 32usize],
}
pub type ACCESS_REASONS = _ACCESS_REASONS;
pub type PACCESS_REASONS = *mut _ACCESS_REASONS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_SECURITY_DESCRIPTOR {
    pub Size: ULONG,
    pub Flags: ULONG,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
}
pub type SE_SECURITY_DESCRIPTOR = _SE_SECURITY_DESCRIPTOR;
pub type PSE_SECURITY_DESCRIPTOR = *mut _SE_SECURITY_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_ACCESS_REQUEST {
    pub Size: ULONG,
    pub SeSecurityDescriptor: PSE_SECURITY_DESCRIPTOR,
    pub DesiredAccess: ACCESS_MASK,
    pub PreviouslyGrantedAccess: ACCESS_MASK,
    pub PrincipalSelfSid: PSID,
    pub GenericMapping: PGENERIC_MAPPING,
    pub ObjectTypeListCount: ULONG,
    pub ObjectTypeList: POBJECT_TYPE_LIST,
}
pub type SE_ACCESS_REQUEST = _SE_ACCESS_REQUEST;
pub type PSE_ACCESS_REQUEST = *mut _SE_ACCESS_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_ACCESS_REPLY {
    pub Size: ULONG,
    pub ResultListCount: ULONG,
    pub GrantedAccess: PACCESS_MASK,
    pub AccessStatus: PNTSTATUS,
    pub AccessReason: PACCESS_REASONS,
    pub Privileges: *mut PPRIVILEGE_SET,
}
pub type SE_ACCESS_REPLY = _SE_ACCESS_REPLY;
pub type PSE_ACCESS_REPLY = *mut _SE_ACCESS_REPLY;
pub const _SE_AUDIT_OPERATION_AuditPrivilegeObject: _SE_AUDIT_OPERATION = 0;
pub const _SE_AUDIT_OPERATION_AuditPrivilegeService: _SE_AUDIT_OPERATION = 1;
pub const _SE_AUDIT_OPERATION_AuditAccessCheck: _SE_AUDIT_OPERATION = 2;
pub const _SE_AUDIT_OPERATION_AuditOpenObject: _SE_AUDIT_OPERATION = 3;
pub const _SE_AUDIT_OPERATION_AuditOpenObjectWithTransaction: _SE_AUDIT_OPERATION = 4;
pub const _SE_AUDIT_OPERATION_AuditCloseObject: _SE_AUDIT_OPERATION = 5;
pub const _SE_AUDIT_OPERATION_AuditDeleteObject: _SE_AUDIT_OPERATION = 6;
pub const _SE_AUDIT_OPERATION_AuditOpenObjectForDelete: _SE_AUDIT_OPERATION = 7;
pub const _SE_AUDIT_OPERATION_AuditOpenObjectForDeleteWithTransaction: _SE_AUDIT_OPERATION = 8;
pub const _SE_AUDIT_OPERATION_AuditCloseNonObject: _SE_AUDIT_OPERATION = 9;
pub const _SE_AUDIT_OPERATION_AuditOpenNonObject: _SE_AUDIT_OPERATION = 10;
pub const _SE_AUDIT_OPERATION_AuditObjectReference: _SE_AUDIT_OPERATION = 11;
pub const _SE_AUDIT_OPERATION_AuditHandleCreation: _SE_AUDIT_OPERATION = 12;
pub type _SE_AUDIT_OPERATION = core::ffi::c_int;
pub use self::_SE_AUDIT_OPERATION as SE_AUDIT_OPERATION;
pub type PSE_AUDIT_OPERATION = *mut _SE_AUDIT_OPERATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_AUDIT_INFO {
    pub Size: ULONG,
    pub AuditType: AUDIT_EVENT_TYPE,
    pub AuditOperation: SE_AUDIT_OPERATION,
    pub AuditFlags: ULONG,
    pub SubsystemName: UNICODE_STRING,
    pub ObjectTypeName: UNICODE_STRING,
    pub ObjectName: UNICODE_STRING,
    pub HandleId: PVOID,
    pub TransactionId: *mut GUID,
    pub OperationId: *mut LUID,
    pub ObjectCreation: BOOLEAN,
    pub GenerateOnClose: BOOLEAN,
}
pub type SE_AUDIT_INFO = _SE_AUDIT_INFO;
pub type PSE_AUDIT_INFO = *mut _SE_AUDIT_INFO;
pub const _TOKEN_TYPE_TokenPrimary: _TOKEN_TYPE = 1;
pub const _TOKEN_TYPE_TokenImpersonation: _TOKEN_TYPE = 2;
pub type _TOKEN_TYPE = core::ffi::c_int;
pub use self::_TOKEN_TYPE as TOKEN_TYPE;
pub type PTOKEN_TYPE = *mut TOKEN_TYPE;
pub const _TOKEN_ELEVATION_TYPE_TokenElevationTypeDefault: _TOKEN_ELEVATION_TYPE = 1;
pub const _TOKEN_ELEVATION_TYPE_TokenElevationTypeFull: _TOKEN_ELEVATION_TYPE = 2;
pub const _TOKEN_ELEVATION_TYPE_TokenElevationTypeLimited: _TOKEN_ELEVATION_TYPE = 3;
pub type _TOKEN_ELEVATION_TYPE = core::ffi::c_int;
pub use self::_TOKEN_ELEVATION_TYPE as TOKEN_ELEVATION_TYPE;
pub type PTOKEN_ELEVATION_TYPE = *mut _TOKEN_ELEVATION_TYPE;
pub const _TOKEN_INFORMATION_CLASS_TokenUser: _TOKEN_INFORMATION_CLASS = 1;
pub const _TOKEN_INFORMATION_CLASS_TokenGroups: _TOKEN_INFORMATION_CLASS = 2;
pub const _TOKEN_INFORMATION_CLASS_TokenPrivileges: _TOKEN_INFORMATION_CLASS = 3;
pub const _TOKEN_INFORMATION_CLASS_TokenOwner: _TOKEN_INFORMATION_CLASS = 4;
pub const _TOKEN_INFORMATION_CLASS_TokenPrimaryGroup: _TOKEN_INFORMATION_CLASS = 5;
pub const _TOKEN_INFORMATION_CLASS_TokenDefaultDacl: _TOKEN_INFORMATION_CLASS = 6;
pub const _TOKEN_INFORMATION_CLASS_TokenSource: _TOKEN_INFORMATION_CLASS = 7;
pub const _TOKEN_INFORMATION_CLASS_TokenType: _TOKEN_INFORMATION_CLASS = 8;
pub const _TOKEN_INFORMATION_CLASS_TokenImpersonationLevel: _TOKEN_INFORMATION_CLASS = 9;
pub const _TOKEN_INFORMATION_CLASS_TokenStatistics: _TOKEN_INFORMATION_CLASS = 10;
pub const _TOKEN_INFORMATION_CLASS_TokenRestrictedSids: _TOKEN_INFORMATION_CLASS = 11;
pub const _TOKEN_INFORMATION_CLASS_TokenSessionId: _TOKEN_INFORMATION_CLASS = 12;
pub const _TOKEN_INFORMATION_CLASS_TokenGroupsAndPrivileges: _TOKEN_INFORMATION_CLASS = 13;
pub const _TOKEN_INFORMATION_CLASS_TokenSessionReference: _TOKEN_INFORMATION_CLASS = 14;
pub const _TOKEN_INFORMATION_CLASS_TokenSandBoxInert: _TOKEN_INFORMATION_CLASS = 15;
pub const _TOKEN_INFORMATION_CLASS_TokenAuditPolicy: _TOKEN_INFORMATION_CLASS = 16;
pub const _TOKEN_INFORMATION_CLASS_TokenOrigin: _TOKEN_INFORMATION_CLASS = 17;
pub const _TOKEN_INFORMATION_CLASS_TokenElevationType: _TOKEN_INFORMATION_CLASS = 18;
pub const _TOKEN_INFORMATION_CLASS_TokenLinkedToken: _TOKEN_INFORMATION_CLASS = 19;
pub const _TOKEN_INFORMATION_CLASS_TokenElevation: _TOKEN_INFORMATION_CLASS = 20;
pub const _TOKEN_INFORMATION_CLASS_TokenHasRestrictions: _TOKEN_INFORMATION_CLASS = 21;
pub const _TOKEN_INFORMATION_CLASS_TokenAccessInformation: _TOKEN_INFORMATION_CLASS = 22;
pub const _TOKEN_INFORMATION_CLASS_TokenVirtualizationAllowed: _TOKEN_INFORMATION_CLASS = 23;
pub const _TOKEN_INFORMATION_CLASS_TokenVirtualizationEnabled: _TOKEN_INFORMATION_CLASS = 24;
pub const _TOKEN_INFORMATION_CLASS_TokenIntegrityLevel: _TOKEN_INFORMATION_CLASS = 25;
pub const _TOKEN_INFORMATION_CLASS_TokenUIAccess: _TOKEN_INFORMATION_CLASS = 26;
pub const _TOKEN_INFORMATION_CLASS_TokenMandatoryPolicy: _TOKEN_INFORMATION_CLASS = 27;
pub const _TOKEN_INFORMATION_CLASS_TokenLogonSid: _TOKEN_INFORMATION_CLASS = 28;
pub const _TOKEN_INFORMATION_CLASS_TokenIsAppContainer: _TOKEN_INFORMATION_CLASS = 29;
pub const _TOKEN_INFORMATION_CLASS_TokenCapabilities: _TOKEN_INFORMATION_CLASS = 30;
pub const _TOKEN_INFORMATION_CLASS_TokenAppContainerSid: _TOKEN_INFORMATION_CLASS = 31;
pub const _TOKEN_INFORMATION_CLASS_TokenAppContainerNumber: _TOKEN_INFORMATION_CLASS = 32;
pub const _TOKEN_INFORMATION_CLASS_TokenUserClaimAttributes: _TOKEN_INFORMATION_CLASS = 33;
pub const _TOKEN_INFORMATION_CLASS_TokenDeviceClaimAttributes: _TOKEN_INFORMATION_CLASS = 34;
pub const _TOKEN_INFORMATION_CLASS_TokenRestrictedUserClaimAttributes: _TOKEN_INFORMATION_CLASS =
    35;
pub const _TOKEN_INFORMATION_CLASS_TokenRestrictedDeviceClaimAttributes: _TOKEN_INFORMATION_CLASS =
    36;
pub const _TOKEN_INFORMATION_CLASS_TokenDeviceGroups: _TOKEN_INFORMATION_CLASS = 37;
pub const _TOKEN_INFORMATION_CLASS_TokenRestrictedDeviceGroups: _TOKEN_INFORMATION_CLASS = 38;
pub const _TOKEN_INFORMATION_CLASS_TokenSecurityAttributes: _TOKEN_INFORMATION_CLASS = 39;
pub const _TOKEN_INFORMATION_CLASS_TokenIsRestricted: _TOKEN_INFORMATION_CLASS = 40;
pub const _TOKEN_INFORMATION_CLASS_TokenProcessTrustLevel: _TOKEN_INFORMATION_CLASS = 41;
pub const _TOKEN_INFORMATION_CLASS_TokenPrivateNameSpace: _TOKEN_INFORMATION_CLASS = 42;
pub const _TOKEN_INFORMATION_CLASS_TokenSingletonAttributes: _TOKEN_INFORMATION_CLASS = 43;
pub const _TOKEN_INFORMATION_CLASS_TokenBnoIsolation: _TOKEN_INFORMATION_CLASS = 44;
pub const _TOKEN_INFORMATION_CLASS_TokenChildProcessFlags: _TOKEN_INFORMATION_CLASS = 45;
pub const _TOKEN_INFORMATION_CLASS_TokenIsLessPrivilegedAppContainer: _TOKEN_INFORMATION_CLASS = 46;
pub const _TOKEN_INFORMATION_CLASS_TokenIsSandboxed: _TOKEN_INFORMATION_CLASS = 47;
pub const _TOKEN_INFORMATION_CLASS_TokenIsAppSilo: _TOKEN_INFORMATION_CLASS = 48;
pub const _TOKEN_INFORMATION_CLASS_MaxTokenInfoClass: _TOKEN_INFORMATION_CLASS = 49;
pub type _TOKEN_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_TOKEN_INFORMATION_CLASS as TOKEN_INFORMATION_CLASS;
pub type PTOKEN_INFORMATION_CLASS = *mut _TOKEN_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_USER {
    pub User: SID_AND_ATTRIBUTES,
}
pub type TOKEN_USER = _TOKEN_USER;
pub type PTOKEN_USER = *mut _TOKEN_USER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SE_TOKEN_USER {
    pub __bindgen_anon_1: _SE_TOKEN_USER__bindgen_ty_1,
    pub __bindgen_anon_2: _SE_TOKEN_USER__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SE_TOKEN_USER__bindgen_ty_1 {
    pub TokenUser: TOKEN_USER,
    pub User: SID_AND_ATTRIBUTES,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SE_TOKEN_USER__bindgen_ty_2 {
    pub Sid: SID,
    pub Buffer: [UCHAR; 68usize],
}
pub type SE_TOKEN_USER = _SE_TOKEN_USER;
pub type PSE_TOKEN_USER = _SE_TOKEN_USER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_GROUPS {
    pub GroupCount: ULONG,
    pub Groups: [SID_AND_ATTRIBUTES; 1usize],
}
pub type TOKEN_GROUPS = _TOKEN_GROUPS;
pub type PTOKEN_GROUPS = *mut _TOKEN_GROUPS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_PRIVILEGES {
    pub PrivilegeCount: ULONG,
    pub Privileges: [LUID_AND_ATTRIBUTES; 1usize],
}
pub type TOKEN_PRIVILEGES = _TOKEN_PRIVILEGES;
pub type PTOKEN_PRIVILEGES = *mut _TOKEN_PRIVILEGES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_OWNER {
    pub Owner: PSID,
}
pub type TOKEN_OWNER = _TOKEN_OWNER;
pub type PTOKEN_OWNER = *mut _TOKEN_OWNER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_PRIMARY_GROUP {
    pub PrimaryGroup: PSID,
}
pub type TOKEN_PRIMARY_GROUP = _TOKEN_PRIMARY_GROUP;
pub type PTOKEN_PRIMARY_GROUP = *mut _TOKEN_PRIMARY_GROUP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_DEFAULT_DACL {
    pub DefaultDacl: PACL,
}
pub type TOKEN_DEFAULT_DACL = _TOKEN_DEFAULT_DACL;
pub type PTOKEN_DEFAULT_DACL = *mut _TOKEN_DEFAULT_DACL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_USER_CLAIMS {
    pub UserClaims: PCLAIMS_BLOB,
}
pub type TOKEN_USER_CLAIMS = _TOKEN_USER_CLAIMS;
pub type PTOKEN_USER_CLAIMS = *mut _TOKEN_USER_CLAIMS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_DEVICE_CLAIMS {
    pub DeviceClaims: PCLAIMS_BLOB,
}
pub type TOKEN_DEVICE_CLAIMS = _TOKEN_DEVICE_CLAIMS;
pub type PTOKEN_DEVICE_CLAIMS = *mut _TOKEN_DEVICE_CLAIMS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_GROUPS_AND_PRIVILEGES {
    pub SidCount: ULONG,
    pub SidLength: ULONG,
    pub Sids: PSID_AND_ATTRIBUTES,
    pub RestrictedSidCount: ULONG,
    pub RestrictedSidLength: ULONG,
    pub RestrictedSids: PSID_AND_ATTRIBUTES,
    pub PrivilegeCount: ULONG,
    pub PrivilegeLength: ULONG,
    pub Privileges: PLUID_AND_ATTRIBUTES,
    pub AuthenticationId: LUID,
}
pub type TOKEN_GROUPS_AND_PRIVILEGES = _TOKEN_GROUPS_AND_PRIVILEGES;
pub type PTOKEN_GROUPS_AND_PRIVILEGES = *mut _TOKEN_GROUPS_AND_PRIVILEGES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_LINKED_TOKEN {
    pub LinkedToken: HANDLE,
}
pub type TOKEN_LINKED_TOKEN = _TOKEN_LINKED_TOKEN;
pub type PTOKEN_LINKED_TOKEN = *mut _TOKEN_LINKED_TOKEN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_ELEVATION {
    pub TokenIsElevated: ULONG,
}
pub type TOKEN_ELEVATION = _TOKEN_ELEVATION;
pub type PTOKEN_ELEVATION = *mut _TOKEN_ELEVATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_MANDATORY_LABEL {
    pub Label: SID_AND_ATTRIBUTES,
}
pub type TOKEN_MANDATORY_LABEL = _TOKEN_MANDATORY_LABEL;
pub type PTOKEN_MANDATORY_LABEL = *mut _TOKEN_MANDATORY_LABEL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_MANDATORY_POLICY {
    pub Policy: ULONG,
}
pub type TOKEN_MANDATORY_POLICY = _TOKEN_MANDATORY_POLICY;
pub type PTOKEN_MANDATORY_POLICY = *mut _TOKEN_MANDATORY_POLICY;
pub type PSECURITY_ATTRIBUTES_OPAQUE = PVOID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_ACCESS_INFORMATION {
    pub SidHash: PSID_AND_ATTRIBUTES_HASH,
    pub RestrictedSidHash: PSID_AND_ATTRIBUTES_HASH,
    pub Privileges: PTOKEN_PRIVILEGES,
    pub AuthenticationId: LUID,
    pub TokenType: TOKEN_TYPE,
    pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    pub MandatoryPolicy: TOKEN_MANDATORY_POLICY,
    pub Flags: ULONG,
    pub AppContainerNumber: ULONG,
    pub PackageSid: PSID,
    pub CapabilitiesHash: PSID_AND_ATTRIBUTES_HASH,
    pub TrustLevelSid: PSID,
    pub SecurityAttributes: PSECURITY_ATTRIBUTES_OPAQUE,
}
pub type TOKEN_ACCESS_INFORMATION = _TOKEN_ACCESS_INFORMATION;
pub type PTOKEN_ACCESS_INFORMATION = *mut _TOKEN_ACCESS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_AUDIT_POLICY {
    pub PerUserPolicy: [UCHAR; 30usize],
}
pub type TOKEN_AUDIT_POLICY = _TOKEN_AUDIT_POLICY;
pub type PTOKEN_AUDIT_POLICY = *mut _TOKEN_AUDIT_POLICY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_SOURCE {
    pub SourceName: [CHAR; 8usize],
    pub SourceIdentifier: LUID,
}
pub type TOKEN_SOURCE = _TOKEN_SOURCE;
pub type PTOKEN_SOURCE = *mut _TOKEN_SOURCE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TOKEN_STATISTICS {
    pub TokenId: LUID,
    pub AuthenticationId: LUID,
    pub ExpirationTime: LARGE_INTEGER,
    pub TokenType: TOKEN_TYPE,
    pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    pub DynamicCharged: ULONG,
    pub DynamicAvailable: ULONG,
    pub GroupCount: ULONG,
    pub PrivilegeCount: ULONG,
    pub ModifiedId: LUID,
}
pub type TOKEN_STATISTICS = _TOKEN_STATISTICS;
pub type PTOKEN_STATISTICS = *mut _TOKEN_STATISTICS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_CONTROL {
    pub TokenId: LUID,
    pub AuthenticationId: LUID,
    pub ModifiedId: LUID,
    pub TokenSource: TOKEN_SOURCE,
}
pub type TOKEN_CONTROL = _TOKEN_CONTROL;
pub type PTOKEN_CONTROL = *mut _TOKEN_CONTROL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_ORIGIN {
    pub OriginatingLogonSession: LUID,
}
pub type TOKEN_ORIGIN = _TOKEN_ORIGIN;
pub type PTOKEN_ORIGIN = *mut _TOKEN_ORIGIN;
pub const _MANDATORY_LEVEL_MandatoryLevelUntrusted: _MANDATORY_LEVEL = 0;
pub const _MANDATORY_LEVEL_MandatoryLevelLow: _MANDATORY_LEVEL = 1;
pub const _MANDATORY_LEVEL_MandatoryLevelMedium: _MANDATORY_LEVEL = 2;
pub const _MANDATORY_LEVEL_MandatoryLevelHigh: _MANDATORY_LEVEL = 3;
pub const _MANDATORY_LEVEL_MandatoryLevelSystem: _MANDATORY_LEVEL = 4;
pub const _MANDATORY_LEVEL_MandatoryLevelSecureProcess: _MANDATORY_LEVEL = 5;
pub const _MANDATORY_LEVEL_MandatoryLevelCount: _MANDATORY_LEVEL = 6;
pub type _MANDATORY_LEVEL = core::ffi::c_int;
pub use self::_MANDATORY_LEVEL as MANDATORY_LEVEL;
pub type PMANDATORY_LEVEL = *mut _MANDATORY_LEVEL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_APPCONTAINER_INFORMATION {
    pub TokenAppContainer: PSID,
}
pub type TOKEN_APPCONTAINER_INFORMATION = _TOKEN_APPCONTAINER_INFORMATION;
pub type PTOKEN_APPCONTAINER_INFORMATION = *mut _TOKEN_APPCONTAINER_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_SID_INFORMATION {
    pub Sid: PSID,
}
pub type TOKEN_SID_INFORMATION = _TOKEN_SID_INFORMATION;
pub type PTOKEN_SID_INFORMATION = *mut _TOKEN_SID_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_BNO_ISOLATION_INFORMATION {
    pub IsolationPrefix: PWSTR,
    pub IsolationEnabled: BOOLEAN,
}
pub type TOKEN_BNO_ISOLATION_INFORMATION = _TOKEN_BNO_ISOLATION_INFORMATION;
pub type PTOKEN_BNO_ISOLATION_INFORMATION = *mut _TOKEN_BNO_ISOLATION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE {
    pub Version: ULONG64,
    pub Name: PWSTR,
}
pub type CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE = _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE;
pub type PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE = *mut _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE {
    pub pValue: PVOID,
    pub ValueLength: ULONG,
}
pub type CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE = _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;
pub type PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE =
*mut _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CLAIM_SECURITY_ATTRIBUTE_V1 {
    pub Name: PWSTR,
    pub ValueType: USHORT,
    pub Reserved: USHORT,
    pub Flags: ULONG,
    pub ValueCount: ULONG,
    pub Values: _CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1 {
    pub pInt64: PLONG64,
    pub pUint64: PULONG64,
    pub ppString: *mut PWSTR,
    pub pFqbn: PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE,
    pub pOctetString: PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE,
}
pub type CLAIM_SECURITY_ATTRIBUTE_V1 = _CLAIM_SECURITY_ATTRIBUTE_V1;
pub type PCLAIM_SECURITY_ATTRIBUTE_V1 = *mut _CLAIM_SECURITY_ATTRIBUTE_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 {
    pub Name: ULONG,
    pub ValueType: USHORT,
    pub Reserved: USHORT,
    pub Flags: ULONG,
    pub ValueCount: ULONG,
    pub Values: _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1 {
    pub pInt64: [ULONG; 1usize],
    pub pUint64: [ULONG; 1usize],
    pub ppString: [ULONG; 1usize],
    pub pFqbn: [ULONG; 1usize],
    pub pOctetString: [ULONG; 1usize],
}
pub type CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 = _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1;
pub type PCLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 = *mut _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CLAIM_SECURITY_ATTRIBUTES_INFORMATION {
    pub Version: USHORT,
    pub Reserved: USHORT,
    pub AttributeCount: ULONG,
    pub Attribute: _CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1 {
    pub pAttributeV1: PCLAIM_SECURITY_ATTRIBUTE_V1,
}
pub type CLAIM_SECURITY_ATTRIBUTES_INFORMATION = _CLAIM_SECURITY_ATTRIBUTES_INFORMATION;
pub type PCLAIM_SECURITY_ATTRIBUTES_INFORMATION = *mut _CLAIM_SECURITY_ATTRIBUTES_INFORMATION;
unsafe extern "C" {
    pub fn NtOpenThreadToken(
        ThreadHandle: HANDLE,
        DesiredAccess: ACCESS_MASK,
        OpenAsSelf: BOOLEAN,
        TokenHandle: PHANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtOpenThreadTokenEx(
        ThreadHandle: HANDLE,
        DesiredAccess: ACCESS_MASK,
        OpenAsSelf: BOOLEAN,
        HandleAttributes: ULONG,
        TokenHandle: PHANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtOpenProcessToken(
        ProcessHandle: HANDLE,
        DesiredAccess: ACCESS_MASK,
        TokenHandle: PHANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtOpenProcessTokenEx(
        ProcessHandle: HANDLE,
        DesiredAccess: ACCESS_MASK,
        HandleAttributes: ULONG,
        TokenHandle: PHANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtOpenJobObjectToken(
        JobHandle: HANDLE,
        DesiredAccess: ACCESS_MASK,
        TokenHandle: PHANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtDuplicateToken(
        ExistingTokenHandle: HANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        EffectiveOnly: BOOLEAN,
        TokenType: TOKEN_TYPE,
        NewTokenHandle: PHANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtFilterToken(
        ExistingTokenHandle: HANDLE,
        Flags: ULONG,
        SidsToDisable: PTOKEN_GROUPS,
        PrivilegesToDelete: PTOKEN_PRIVILEGES,
        RestrictedSids: PTOKEN_GROUPS,
        NewTokenHandle: PHANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtImpersonateAnonymousToken(ThreadHandle: HANDLE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtQueryInformationToken(
        TokenHandle: HANDLE,
        TokenInformationClass: TOKEN_INFORMATION_CLASS,
        TokenInformation: PVOID,
        TokenInformationLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtSetInformationToken(
        TokenHandle: HANDLE,
        TokenInformationClass: TOKEN_INFORMATION_CLASS,
        TokenInformation: PVOID,
        TokenInformationLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtAdjustPrivilegesToken(
        TokenHandle: HANDLE,
        DisableAllPrivileges: BOOLEAN,
        NewState: PTOKEN_PRIVILEGES,
        BufferLength: ULONG,
        PreviousState: PTOKEN_PRIVILEGES,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtAdjustGroupsToken(
        TokenHandle: HANDLE,
        ResetToDefault: BOOLEAN,
        NewState: PTOKEN_GROUPS,
        BufferLength: ULONG,
        PreviousState: PTOKEN_GROUPS,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtPrivilegeCheck(
        ClientToken: HANDLE,
        RequiredPrivileges: PPRIVILEGE_SET,
        Result: PBOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtAccessCheckAndAuditAlarm(
        SubsystemName: PUNICODE_STRING,
        HandleId: PVOID,
        ObjectTypeName: PUNICODE_STRING,
        ObjectName: PUNICODE_STRING,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        DesiredAccess: ACCESS_MASK,
        GenericMapping: PGENERIC_MAPPING,
        ObjectCreation: BOOLEAN,
        GrantedAccess: PACCESS_MASK,
        AccessStatus: PNTSTATUS,
        GenerateOnClose: PBOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtAccessCheckByTypeAndAuditAlarm(
        SubsystemName: PUNICODE_STRING,
        HandleId: PVOID,
        ObjectTypeName: PUNICODE_STRING,
        ObjectName: PUNICODE_STRING,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        PrincipalSelfSid: PSID,
        DesiredAccess: ACCESS_MASK,
        AuditType: AUDIT_EVENT_TYPE,
        Flags: ULONG,
        ObjectTypeList: POBJECT_TYPE_LIST,
        ObjectTypeListLength: ULONG,
        GenericMapping: PGENERIC_MAPPING,
        ObjectCreation: BOOLEAN,
        GrantedAccess: PACCESS_MASK,
        AccessStatus: PNTSTATUS,
        GenerateOnClose: PBOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtAccessCheckByTypeResultListAndAuditAlarm(
        SubsystemName: PUNICODE_STRING,
        HandleId: PVOID,
        ObjectTypeName: PUNICODE_STRING,
        ObjectName: PUNICODE_STRING,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        PrincipalSelfSid: PSID,
        DesiredAccess: ACCESS_MASK,
        AuditType: AUDIT_EVENT_TYPE,
        Flags: ULONG,
        ObjectTypeList: POBJECT_TYPE_LIST,
        ObjectTypeListLength: ULONG,
        GenericMapping: PGENERIC_MAPPING,
        ObjectCreation: BOOLEAN,
        GrantedAccess: PACCESS_MASK,
        AccessStatus: PNTSTATUS,
        GenerateOnClose: PBOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtAccessCheckByTypeResultListAndAuditAlarmByHandle(
        SubsystemName: PUNICODE_STRING,
        HandleId: PVOID,
        ClientToken: HANDLE,
        ObjectTypeName: PUNICODE_STRING,
        ObjectName: PUNICODE_STRING,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        PrincipalSelfSid: PSID,
        DesiredAccess: ACCESS_MASK,
        AuditType: AUDIT_EVENT_TYPE,
        Flags: ULONG,
        ObjectTypeList: POBJECT_TYPE_LIST,
        ObjectTypeListLength: ULONG,
        GenericMapping: PGENERIC_MAPPING,
        ObjectCreation: BOOLEAN,
        GrantedAccess: PACCESS_MASK,
        AccessStatus: PNTSTATUS,
        GenerateOnClose: PBOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtOpenObjectAuditAlarm(
        SubsystemName: PUNICODE_STRING,
        HandleId: PVOID,
        ObjectTypeName: PUNICODE_STRING,
        ObjectName: PUNICODE_STRING,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        ClientToken: HANDLE,
        DesiredAccess: ACCESS_MASK,
        GrantedAccess: ACCESS_MASK,
        Privileges: PPRIVILEGE_SET,
        ObjectCreation: BOOLEAN,
        AccessGranted: BOOLEAN,
        GenerateOnClose: PBOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtPrivilegeObjectAuditAlarm(
        SubsystemName: PUNICODE_STRING,
        HandleId: PVOID,
        ClientToken: HANDLE,
        DesiredAccess: ACCESS_MASK,
        Privileges: PPRIVILEGE_SET,
        AccessGranted: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtCloseObjectAuditAlarm(
        SubsystemName: PUNICODE_STRING,
        HandleId: PVOID,
        GenerateOnClose: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtDeleteObjectAuditAlarm(
        SubsystemName: PUNICODE_STRING,
        HandleId: PVOID,
        GenerateOnClose: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtPrivilegedServiceAuditAlarm(
        SubsystemName: PUNICODE_STRING,
        ServiceName: PUNICODE_STRING,
        ClientToken: HANDLE,
        Privileges: PPRIVILEGE_SET,
        AccessGranted: BOOLEAN,
    ) -> NTSTATUS;
}
pub type PRTL_HEAP_COMMIT_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(arg1: PVOID, arg2: *mut PVOID, arg3: PSIZE_T) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_HEAP_PARAMETERS {
    pub Length: ULONG,
    pub SegmentReserve: SIZE_T,
    pub SegmentCommit: SIZE_T,
    pub DeCommitFreeBlockThreshold: SIZE_T,
    pub DeCommitTotalFreeThreshold: SIZE_T,
    pub MaximumAllocationSize: SIZE_T,
    pub VirtualMemoryThreshold: SIZE_T,
    pub InitialCommit: SIZE_T,
    pub InitialReserve: SIZE_T,
    pub CommitRoutine: PRTL_HEAP_COMMIT_ROUTINE,
    pub Reserved: [SIZE_T; 2usize],
}
pub type RTL_HEAP_PARAMETERS = _RTL_HEAP_PARAMETERS;
pub type PRTL_HEAP_PARAMETERS = *mut _RTL_HEAP_PARAMETERS;
pub const _RTL_MEMORY_TYPE_MemoryTypePaged: _RTL_MEMORY_TYPE = 0;
pub const _RTL_MEMORY_TYPE_MemoryTypeNonPaged: _RTL_MEMORY_TYPE = 1;
pub const _RTL_MEMORY_TYPE_MemoryType64KPage: _RTL_MEMORY_TYPE = 2;
pub const _RTL_MEMORY_TYPE_MemoryTypeLargePage: _RTL_MEMORY_TYPE = 3;
pub const _RTL_MEMORY_TYPE_MemoryTypeHugePage: _RTL_MEMORY_TYPE = 4;
pub const _RTL_MEMORY_TYPE_MemoryTypeCustom: _RTL_MEMORY_TYPE = 5;
pub const _RTL_MEMORY_TYPE_MemoryTypeMax: _RTL_MEMORY_TYPE = 6;
pub type _RTL_MEMORY_TYPE = core::ffi::c_int;
pub use self::_RTL_MEMORY_TYPE as RTL_MEMORY_TYPE;
pub type PRTL_MEMORY_TYPE = *mut _RTL_MEMORY_TYPE;
pub const _HEAP_MEMORY_INFO_CLASS_HeapMemoryBasicInformation: _HEAP_MEMORY_INFO_CLASS = 0;
pub type _HEAP_MEMORY_INFO_CLASS = core::ffi::c_int;
pub use self::_HEAP_MEMORY_INFO_CLASS as HEAP_MEMORY_INFO_CLASS;
pub type ALLOCATE_VIRTUAL_MEMORY_EX_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        CallbackContext: HANDLE,
        ProcessHandle: HANDLE,
        BaseAddress: *mut PVOID,
        RegionSize: PSIZE_T,
        AllocationType: ULONG,
        PageProtection: ULONG,
        ExtendedParameters: PMEM_EXTENDED_PARAMETER,
        ExtendedParameterCount: ULONG,
    ) -> NTSTATUS,
>;
pub type PALLOCATE_VIRTUAL_MEMORY_EX_CALLBACK = ALLOCATE_VIRTUAL_MEMORY_EX_CALLBACK;
pub type FREE_VIRTUAL_MEMORY_EX_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        CallbackContext: HANDLE,
        ProcessHandle: HANDLE,
        BaseAddress: *mut PVOID,
        RegionSize: PSIZE_T,
        FreeType: ULONG,
    ) -> NTSTATUS,
>;
pub type PFREE_VIRTUAL_MEMORY_EX_CALLBACK = FREE_VIRTUAL_MEMORY_EX_CALLBACK;
pub type QUERY_VIRTUAL_MEMORY_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        CallbackContext: HANDLE,
        ProcessHandle: HANDLE,
        BaseAddress: PVOID,
        MemoryInformationClass: HEAP_MEMORY_INFO_CLASS,
        MemoryInformation: PVOID,
        MemoryInformationLength: SIZE_T,
        ReturnLength: PSIZE_T,
    ) -> NTSTATUS,
>;
pub type PQUERY_VIRTUAL_MEMORY_CALLBACK = QUERY_VIRTUAL_MEMORY_CALLBACK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_SEGMENT_HEAP_VA_CALLBACKS {
    pub CallbackContext: HANDLE,
    pub AllocateVirtualMemory: PALLOCATE_VIRTUAL_MEMORY_EX_CALLBACK,
    pub FreeVirtualMemory: PFREE_VIRTUAL_MEMORY_EX_CALLBACK,
    pub QueryVirtualMemory: PQUERY_VIRTUAL_MEMORY_CALLBACK,
}
pub type RTL_SEGMENT_HEAP_VA_CALLBACKS = _RTL_SEGMENT_HEAP_VA_CALLBACKS;
pub type PRTL_SEGMENT_HEAP_VA_CALLBACKS = *mut _RTL_SEGMENT_HEAP_VA_CALLBACKS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_SEGMENT_HEAP_MEMORY_SOURCE {
    pub Flags: ULONG,
    pub MemoryTypeMask: ULONG,
    pub NumaNode: ULONG,
    pub __bindgen_anon_1: _RTL_SEGMENT_HEAP_MEMORY_SOURCE__bindgen_ty_1,
    pub Reserved: [SIZE_T; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_SEGMENT_HEAP_MEMORY_SOURCE__bindgen_ty_1 {
    pub PartitionHandle: HANDLE,
    pub Callbacks: *mut RTL_SEGMENT_HEAP_VA_CALLBACKS,
}
pub type RTL_SEGMENT_HEAP_MEMORY_SOURCE = _RTL_SEGMENT_HEAP_MEMORY_SOURCE;
pub type PRTL_SEGMENT_HEAP_MEMORY_SOURCE = *mut _RTL_SEGMENT_HEAP_MEMORY_SOURCE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_SEGMENT_HEAP_PARAMETERS {
    pub Version: USHORT,
    pub Size: USHORT,
    pub Flags: ULONG,
    pub MemorySource: RTL_SEGMENT_HEAP_MEMORY_SOURCE,
    pub Reserved: [SIZE_T; 4usize],
}
pub type RTL_SEGMENT_HEAP_PARAMETERS = _RTL_SEGMENT_HEAP_PARAMETERS;
pub type PRTL_SEGMENT_HEAP_PARAMETERS = *mut _RTL_SEGMENT_HEAP_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_HEAP_MEMORY_LIMIT_DATA {
    pub CommitLimitBytes: SIZE_T,
    pub CommitLimitFailureCode: ULONG_PTR,
    pub MaxAllocationSizeBytes: SIZE_T,
    pub AllocationLimitFailureCode: ULONG_PTR,
}
pub type RTL_HEAP_MEMORY_LIMIT_DATA = _RTL_HEAP_MEMORY_LIMIT_DATA;
pub type PRTL_HEAP_MEMORY_LIMIT_DATA = *mut _RTL_HEAP_MEMORY_LIMIT_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_HEAP_MEMORY_LIMIT_INFO {
    pub Version: ULONG,
    pub Data: RTL_HEAP_MEMORY_LIMIT_DATA,
}
pub type RTL_HEAP_MEMORY_LIMIT_INFO = _RTL_HEAP_MEMORY_LIMIT_INFO;
pub type PRTL_HEAP_MEMORY_LIMIT_INFO = *mut _RTL_HEAP_MEMORY_LIMIT_INFO;
unsafe extern "C" {
    pub fn RtlCreateHeap(
        Flags: ULONG,
        HeapBase: PVOID,
        ReserveSize: SIZE_T,
        CommitSize: SIZE_T,
        Lock: PVOID,
        Parameters: PRTL_HEAP_PARAMETERS,
    ) -> PVOID;
}
unsafe extern "C" {
    pub fn RtlDestroyHeap(HeapHandle: PVOID) -> PVOID;
}
unsafe extern "C" {
    pub fn RtlAllocateHeap(HeapHandle: PVOID, Flags: ULONG, Size: SIZE_T) -> PVOID;
}
unsafe extern "C" {
    pub fn RtlFreeHeap(HeapHandle: PVOID, Flags: ULONG, BaseAddress: PVOID) -> LOGICAL;
}
unsafe extern "C" {
    pub fn RtlRandom(Seed: PULONG) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlRandomEx(Seed: PULONG) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlInitUnicodeStringEx(
        DestinationString: PUNICODE_STRING,
        SourceString: PCWSTR,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlCreateUnicodeString(
        DestinationString: PUNICODE_STRING,
        SourceString: PCWSTR,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlPrefixString(
        String1: *const STRING,
        String2: *const STRING,
        CaseInSensitive: BOOLEAN,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlAppendStringToString(Destination: PSTRING, Source: *const STRING) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlOemStringToUnicodeString(
        DestinationString: PUNICODE_STRING,
        SourceString: PCOEM_STRING,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlUnicodeStringToOemString(
        DestinationString: POEM_STRING,
        SourceString: PCUNICODE_STRING,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlUpcaseUnicodeStringToOemString(
        DestinationString: POEM_STRING,
        SourceString: PCUNICODE_STRING,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlOemStringToCountedUnicodeString(
        DestinationString: PUNICODE_STRING,
        SourceString: PCOEM_STRING,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlUnicodeStringToCountedOemString(
        DestinationString: POEM_STRING,
        SourceString: PCUNICODE_STRING,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlUpcaseUnicodeStringToCountedOemString(
        DestinationString: POEM_STRING,
        SourceString: PCUNICODE_STRING,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlValidateUnicodeString(Flags: ULONG, String: PCUNICODE_STRING) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlDuplicateUnicodeString(
        Flags: ULONG,
        StringIn: PCUNICODE_STRING,
        StringOut: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlDowncaseUnicodeString(
        DestinationString: PUNICODE_STRING,
        SourceString: PCUNICODE_STRING,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlFreeOemString(OemString: POEM_STRING);
}
unsafe extern "C" {
    pub fn RtlxUnicodeStringToOemSize(UnicodeString: PCUNICODE_STRING) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlxOemStringToUnicodeSize(OemString: PCOEM_STRING) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlMultiByteToUnicodeN(
        UnicodeString: PWCH,
        MaxBytesInUnicodeString: ULONG,
        BytesInUnicodeString: PULONG,
        MultiByteString: *const CHAR,
        BytesInMultiByteString: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlMultiByteToUnicodeSize(
        BytesInUnicodeString: PULONG,
        MultiByteString: *const CHAR,
        BytesInMultiByteString: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlUnicodeToMultiByteSize(
        BytesInMultiByteString: PULONG,
        UnicodeString: PCWCH,
        BytesInUnicodeString: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlUnicodeToMultiByteN(
        MultiByteString: PCHAR,
        MaxBytesInMultiByteString: ULONG,
        BytesInMultiByteString: PULONG,
        UnicodeString: PCWCH,
        BytesInUnicodeString: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlUpcaseUnicodeToMultiByteN(
        MultiByteString: PCHAR,
        MaxBytesInMultiByteString: ULONG,
        BytesInMultiByteString: PULONG,
        UnicodeString: PCWCH,
        BytesInUnicodeString: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlOemToUnicodeN(
        UnicodeString: PWCH,
        MaxBytesInUnicodeString: ULONG,
        BytesInUnicodeString: PULONG,
        OemString: PCCH,
        BytesInOemString: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlUnicodeToOemN(
        OemString: PCHAR,
        MaxBytesInOemString: ULONG,
        BytesInOemString: PULONG,
        UnicodeString: PCWCH,
        BytesInUnicodeString: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlUpcaseUnicodeToOemN(
        OemString: PCHAR,
        MaxBytesInOemString: ULONG,
        BytesInOemString: PULONG,
        UnicodeString: PCWCH,
        BytesInUnicodeString: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlNormalizeString(
        NormForm: ULONG,
        SourceString: PCWSTR,
        SourceStringLength: LONG,
        DestinationString: PWSTR,
        DestinationStringLength: PLONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlIsNormalizedString(
        NormForm: ULONG,
        SourceString: PCWSTR,
        SourceStringLength: LONG,
        Normalized: PBOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlIdnToAscii(
        Flags: ULONG,
        SourceString: PCWSTR,
        SourceStringLength: LONG,
        DestinationString: PWSTR,
        DestinationStringLength: PLONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlIdnToUnicode(
        Flags: ULONG,
        SourceString: PCWSTR,
        SourceStringLength: LONG,
        DestinationString: PWSTR,
        DestinationStringLength: PLONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlIdnToNameprepUnicode(
        Flags: ULONG,
        SourceString: PCWSTR,
        SourceStringLength: LONG,
        DestinationString: PWSTR,
        DestinationStringLength: PLONG,
    ) -> NTSTATUS;
}
pub type PRTL_ALLOCATE_STRING_ROUTINE =
::core::option::Option<unsafe extern "C" fn(arg1: SIZE_T) -> PVOID>;
pub type PRTL_REALLOCATE_STRING_ROUTINE =
::core::option::Option<unsafe extern "C" fn(arg1: SIZE_T, arg2: PVOID) -> PVOID>;
pub type PRTL_FREE_STRING_ROUTINE = ::core::option::Option<unsafe extern "C" fn(arg1: PVOID)>;
unsafe extern "C" {
    pub static RtlAllocateStringRoutine: PRTL_ALLOCATE_STRING_ROUTINE;
}
unsafe extern "C" {
    pub static RtlFreeStringRoutine: PRTL_FREE_STRING_ROUTINE;
}
unsafe extern "C" {
    pub static RtlReallocateStringRoutine: PRTL_REALLOCATE_STRING_ROUTINE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GENERATE_NAME_CONTEXT {
    pub Checksum: USHORT,
    pub ChecksumInserted: BOOLEAN,
    pub NameLength: UCHAR,
    pub NameBuffer: [WCHAR; 8usize],
    pub ExtensionLength: ULONG,
    pub ExtensionBuffer: [WCHAR; 4usize],
    pub LastIndexValue: ULONG,
}
pub type GENERATE_NAME_CONTEXT = _GENERATE_NAME_CONTEXT;
pub type PGENERATE_NAME_CONTEXT = *mut GENERATE_NAME_CONTEXT;
unsafe extern "C" {
    pub fn RtlGenerate8dot3Name(
        Name: PCUNICODE_STRING,
        AllowExtendedCharacters: BOOLEAN,
        Context: PGENERATE_NAME_CONTEXT,
        Name8dot3: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlIsNameLegalDOS8Dot3(
        Name: PCUNICODE_STRING,
        OemName: POEM_STRING,
        NameContainsSpaces: PBOOLEAN,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlIsValidOemCharacter(Char: PWCHAR) -> BOOLEAN;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PREFIX_TABLE_ENTRY {
    pub NodeTypeCode: CSHORT,
    pub NameLength: CSHORT,
    pub NextPrefixTree: *mut _PREFIX_TABLE_ENTRY,
    pub Links: RTL_SPLAY_LINKS,
    pub Prefix: PSTRING,
}
pub type PREFIX_TABLE_ENTRY = _PREFIX_TABLE_ENTRY;
pub type PPREFIX_TABLE_ENTRY = *mut PREFIX_TABLE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PREFIX_TABLE {
    pub NodeTypeCode: CSHORT,
    pub NameLength: CSHORT,
    pub NextPrefixTree: PPREFIX_TABLE_ENTRY,
}
pub type PREFIX_TABLE = _PREFIX_TABLE;
pub type PPREFIX_TABLE = *mut PREFIX_TABLE;
unsafe extern "C" {
    pub fn PfxInitialize(PrefixTable: PPREFIX_TABLE);
}
unsafe extern "C" {
    pub fn PfxInsertPrefix(
        PrefixTable: PPREFIX_TABLE,
        Prefix: PSTRING,
        PrefixTableEntry: PPREFIX_TABLE_ENTRY,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn PfxRemovePrefix(PrefixTable: PPREFIX_TABLE, PrefixTableEntry: PPREFIX_TABLE_ENTRY);
}
unsafe extern "C" {
    pub fn PfxFindPrefix(PrefixTable: PPREFIX_TABLE, FullName: PSTRING) -> PPREFIX_TABLE_ENTRY;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UNICODE_PREFIX_TABLE_ENTRY {
    pub NodeTypeCode: CSHORT,
    pub NameLength: CSHORT,
    pub NextPrefixTree: *mut _UNICODE_PREFIX_TABLE_ENTRY,
    pub CaseMatch: *mut _UNICODE_PREFIX_TABLE_ENTRY,
    pub Links: RTL_SPLAY_LINKS,
    pub Prefix: PUNICODE_STRING,
}
pub type UNICODE_PREFIX_TABLE_ENTRY = _UNICODE_PREFIX_TABLE_ENTRY;
pub type PUNICODE_PREFIX_TABLE_ENTRY = *mut UNICODE_PREFIX_TABLE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UNICODE_PREFIX_TABLE {
    pub NodeTypeCode: CSHORT,
    pub NameLength: CSHORT,
    pub NextPrefixTree: PUNICODE_PREFIX_TABLE_ENTRY,
    pub LastNextEntry: PUNICODE_PREFIX_TABLE_ENTRY,
}
pub type UNICODE_PREFIX_TABLE = _UNICODE_PREFIX_TABLE;
pub type PUNICODE_PREFIX_TABLE = *mut UNICODE_PREFIX_TABLE;
unsafe extern "C" {
    pub fn RtlInitializeUnicodePrefix(PrefixTable: PUNICODE_PREFIX_TABLE);
}
unsafe extern "C" {
    pub fn RtlInsertUnicodePrefix(
        PrefixTable: PUNICODE_PREFIX_TABLE,
        Prefix: PUNICODE_STRING,
        PrefixTableEntry: PUNICODE_PREFIX_TABLE_ENTRY,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlRemoveUnicodePrefix(
        PrefixTable: PUNICODE_PREFIX_TABLE,
        PrefixTableEntry: PUNICODE_PREFIX_TABLE_ENTRY,
    );
}
unsafe extern "C" {
    pub fn RtlFindUnicodePrefix(
        PrefixTable: PUNICODE_PREFIX_TABLE,
        FullName: PCUNICODE_STRING,
        CaseInsensitiveIndex: ULONG,
    ) -> PUNICODE_PREFIX_TABLE_ENTRY;
}
unsafe extern "C" {
    pub fn RtlNextUnicodePrefix(
        PrefixTable: PUNICODE_PREFIX_TABLE,
        Restart: BOOLEAN,
    ) -> PUNICODE_PREFIX_TABLE_ENTRY;
}
pub type COMPRESSED_DATA_INFO = _COMPRESSED_DATA_INFO;
pub type PCOMPRESSED_DATA_INFO = *mut COMPRESSED_DATA_INFO;
unsafe extern "C" {
    pub fn RtlGetCompressionWorkSpaceSize(
        CompressionFormatAndEngine: USHORT,
        CompressBufferWorkSpaceSize: PULONG,
        CompressFragmentWorkSpaceSize: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlCompressBuffer(
        CompressionFormatAndEngine: USHORT,
        UncompressedBuffer: PUCHAR,
        UncompressedBufferSize: ULONG,
        CompressedBuffer: PUCHAR,
        CompressedBufferSize: ULONG,
        UncompressedChunkSize: ULONG,
        FinalCompressedSize: PULONG,
        WorkSpace: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlDecompressBuffer(
        CompressionFormat: USHORT,
        UncompressedBuffer: PUCHAR,
        UncompressedBufferSize: ULONG,
        CompressedBuffer: PUCHAR,
        CompressedBufferSize: ULONG,
        FinalUncompressedSize: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlDecompressBufferEx(
        CompressionFormat: USHORT,
        UncompressedBuffer: PUCHAR,
        UncompressedBufferSize: ULONG,
        CompressedBuffer: PUCHAR,
        CompressedBufferSize: ULONG,
        FinalUncompressedSize: PULONG,
        WorkSpace: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlDecompressBufferEx2(
        CompressionFormat: USHORT,
        UncompressedBuffer: PUCHAR,
        UncompressedBufferSize: ULONG,
        CompressedBuffer: PUCHAR,
        CompressedBufferSize: ULONG,
        UncompressedChunkSize: ULONG,
        FinalUncompressedSize: PULONG,
        WorkSpace: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlDecompressFragment(
        CompressionFormat: USHORT,
        UncompressedFragment: PUCHAR,
        UncompressedFragmentSize: ULONG,
        CompressedBuffer: PUCHAR,
        CompressedBufferSize: ULONG,
        FragmentOffset: ULONG,
        FinalUncompressedSize: PULONG,
        WorkSpace: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlDecompressFragmentEx(
        CompressionFormat: USHORT,
        UncompressedFragment: PUCHAR,
        UncompressedFragmentSize: ULONG,
        CompressedBuffer: PUCHAR,
        CompressedBufferSize: ULONG,
        FragmentOffset: ULONG,
        UncompressedChunkSize: ULONG,
        FinalUncompressedSize: PULONG,
        WorkSpace: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlDescribeChunk(
        CompressionFormat: USHORT,
        CompressedBuffer: *mut PUCHAR,
        EndOfCompressedBufferPlus1: PUCHAR,
        ChunkBuffer: *mut PUCHAR,
        ChunkSize: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlReserveChunk(
        CompressionFormat: USHORT,
        CompressedBuffer: *mut PUCHAR,
        EndOfCompressedBufferPlus1: PUCHAR,
        ChunkBuffer: *mut PUCHAR,
        ChunkSize: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlDecompressChunks(
        UncompressedBuffer: PUCHAR,
        UncompressedBufferSize: ULONG,
        CompressedBuffer: PUCHAR,
        CompressedBufferSize: ULONG,
        CompressedTail: PUCHAR,
        CompressedTailSize: ULONG,
        CompressedDataInfo: PCOMPRESSED_DATA_INFO,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlCompressChunks(
        UncompressedBuffer: PUCHAR,
        UncompressedBufferSize: ULONG,
        CompressedBuffer: PUCHAR,
        CompressedBufferSize: ULONG,
        CompressedDataInfo: PCOMPRESSED_DATA_INFO,
        CompressedDataInfoLength: ULONG,
        WorkSpace: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlCompareMemoryUlong(Source: PVOID, Length: SIZE_T, Pattern: ULONG) -> SIZE_T;
}
unsafe extern "C" {
    pub fn RtlTimeToSecondsSince1980(Time: PLARGE_INTEGER, ElapsedSeconds: PULONG) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlSecondsSince1980ToTime(ElapsedSeconds: ULONG, Time: PLARGE_INTEGER);
}
unsafe extern "C" {
    pub fn RtlTimeToSecondsSince1970(Time: PLARGE_INTEGER, ElapsedSeconds: PULONG) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlSecondsSince1970ToTime(ElapsedSeconds: ULONG, Time: PLARGE_INTEGER);
}
unsafe extern "C" {
    pub fn RtlValidSid(Sid: PSID) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlEqualSid(Sid1: PSID, Sid2: PSID) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlEqualPrefixSid(Sid1: PSID, Sid2: PSID) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlLengthRequiredSid(SubAuthorityCount: ULONG) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlFreeSid(Sid: PSID) -> PVOID;
}
unsafe extern "C" {
    pub fn RtlAllocateAndInitializeSid(
        IdentifierAuthority: PSID_IDENTIFIER_AUTHORITY,
        SubAuthorityCount: UCHAR,
        SubAuthority0: ULONG,
        SubAuthority1: ULONG,
        SubAuthority2: ULONG,
        SubAuthority3: ULONG,
        SubAuthority4: ULONG,
        SubAuthority5: ULONG,
        SubAuthority6: ULONG,
        SubAuthority7: ULONG,
        Sid: *mut PSID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlAllocateAndInitializeSidEx(
        IdentifierAuthority: PSID_IDENTIFIER_AUTHORITY,
        SubAuthorityCount: UCHAR,
        SubAuthorities: PULONG,
        Sid: *mut PSID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlInitializeSid(
        Sid: PSID,
        IdentifierAuthority: PSID_IDENTIFIER_AUTHORITY,
        SubAuthorityCount: UCHAR,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlInitializeSidEx(
        Sid: PSID,
        IdentifierAuthority: PSID_IDENTIFIER_AUTHORITY,
        SubAuthorityCount: UCHAR,
        ...
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlIdentifierAuthoritySid(Sid: PSID) -> PSID_IDENTIFIER_AUTHORITY;
}
unsafe extern "C" {
    pub fn RtlSubAuthoritySid(Sid: PSID, SubAuthority: ULONG) -> PULONG;
}
unsafe extern "C" {
    pub fn RtlSubAuthorityCountSid(Sid: PSID) -> PUCHAR;
}
unsafe extern "C" {
    pub fn RtlLengthSid(Sid: PSID) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlCopySid(
        DestinationSidLength: ULONG,
        DestinationSid: PSID,
        SourceSid: PSID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlCreateServiceSid(
        ServiceName: PUNICODE_STRING,
        ServiceSid: PSID,
        ServiceSidLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlGetSaclSecurityDescriptor(
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        SaclPresent: PBOOLEAN,
        Sacl: *mut PACL,
        SaclDefaulted: PBOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlReplaceSidInSd(
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        OldSid: PSID,
        NewSid: PSID,
        NumChanges: *mut ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlCreateVirtualAccountSid(
        Name: PCUNICODE_STRING,
        BaseSubAuthority: ULONG,
        Sid: PSID,
        SidLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlConvertSidToUnicodeString(
        UnicodeString: PUNICODE_STRING,
        Sid: PSID,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlCopyLuid(DestinationLuid: PLUID, SourceLuid: PLUID);
}
unsafe extern "C" {
    pub fn RtlCreateAcl(Acl: PACL, AclLength: ULONG, AclRevision: ULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlAddAce(
        Acl: PACL,
        AceRevision: ULONG,
        StartingAceIndex: ULONG,
        AceList: PVOID,
        AceListLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlDeleteAce(Acl: PACL, AceIndex: ULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlGetAce(Acl: PACL, AceIndex: ULONG, Ace: *mut PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlAddAccessAllowedAce(
        Acl: PACL,
        AceRevision: ULONG,
        AccessMask: ACCESS_MASK,
        Sid: PSID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlAddAccessAllowedAceEx(
        Acl: PACL,
        AceRevision: ULONG,
        AceFlags: ULONG,
        AccessMask: ACCESS_MASK,
        Sid: PSID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlCreateSecurityDescriptorRelative(
        SecurityDescriptor: PISECURITY_DESCRIPTOR_RELATIVE,
        Revision: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlGetDaclSecurityDescriptor(
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        DaclPresent: PBOOLEAN,
        Dacl: *mut PACL,
        DaclDefaulted: PBOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlSetOwnerSecurityDescriptor(
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        Owner: PSID,
        OwnerDefaulted: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlSetGroupSecurityDescriptor(
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        Group: PSID,
        GroupDefaulted: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlGetGroupSecurityDescriptor(
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        Group: *mut PSID,
        GroupDefaulted: PBOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlAbsoluteToSelfRelativeSD(
        AbsoluteSecurityDescriptor: PSECURITY_DESCRIPTOR,
        SelfRelativeSecurityDescriptor: PSECURITY_DESCRIPTOR,
        BufferLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlSelfRelativeToAbsoluteSD(
        SelfRelativeSecurityDescriptor: PSECURITY_DESCRIPTOR,
        AbsoluteSecurityDescriptor: PSECURITY_DESCRIPTOR,
        AbsoluteSecurityDescriptorSize: PULONG,
        Dacl: PACL,
        DaclSize: PULONG,
        Sacl: PACL,
        SaclSize: PULONG,
        Owner: PSID,
        OwnerSize: PULONG,
        PrimaryGroup: PSID,
        PrimaryGroupSize: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlGetOwnerSecurityDescriptor(
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        Owner: *mut PSID,
        OwnerDefaulted: PBOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlNtStatusToDosError(Status: NTSTATUS) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlNtStatusToDosErrorNoTeb(Status: NTSTATUS) -> ULONG;
}
unsafe extern "C" {
    pub fn RtlCustomCPToUnicodeN(
        CustomCP: PCPTABLEINFO,
        UnicodeString: PWCH,
        MaxBytesInUnicodeString: ULONG,
        BytesInUnicodeString: PULONG,
        CustomCPString: PCH,
        BytesInCustomCPString: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlUnicodeToCustomCPN(
        CustomCP: PCPTABLEINFO,
        CustomCPString: PCH,
        MaxBytesInCustomCPString: ULONG,
        BytesInCustomCPString: PULONG,
        UnicodeString: PWCH,
        BytesInUnicodeString: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlUpcaseUnicodeToCustomCPN(
        CustomCP: PCPTABLEINFO,
        CustomCPString: PCH,
        MaxBytesInCustomCPString: ULONG,
        BytesInCustomCPString: PULONG,
        UnicodeString: PWCH,
        BytesInUnicodeString: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlInitCodePageTable(TableBase: PUSHORT, CodePageTable: PCPTABLEINFO);
}
unsafe extern "C" {
    pub fn RtlCreateSystemVolumeInformationFolder(VolumeRootPath: PCUNICODE_STRING) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlCompareAltitudes(Altitude1: PCUNICODE_STRING, Altitude2: PCUNICODE_STRING) -> LONG;
}
unsafe extern "C" {
    pub fn RtlQueryPackageIdentity(
        TokenObject: PVOID,
        PackageFullName: PWSTR,
        PackageSize: PSIZE_T,
        AppId: PWSTR,
        AppIdSize: PSIZE_T,
        Packaged: PBOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlQueryPackageIdentityEx(
        TokenObject: PVOID,
        PackageFullName: PWSTR,
        PackageSize: PSIZE_T,
        AppId: PWSTR,
        AppIdSize: PSIZE_T,
        DynamicId: LPGUID,
        Flags: PULONG64,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlIsNonEmptyDirectoryReparsePointAllowed(ReparseTag: ULONG) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlIsCloudFilesPlaceholder(FileAttributes: ULONG, ReparseTag: ULONG) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlIsPartialPlaceholder(FileAttributes: ULONG, ReparseTag: ULONG) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlIsPartialPlaceholderFileHandle(
        FileHandle: HANDLE,
        IsPartialPlaceholder: PBOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlIsPartialPlaceholderFileInfo(
        InfoBuffer: *const core::ffi::c_void,
        InfoClass: FILE_INFORMATION_CLASS,
        IsPartialPlaceholder: PBOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn RtlQueryThreadPlaceholderCompatibilityMode() -> CHAR;
}
unsafe extern "C" {
    pub fn RtlSetThreadPlaceholderCompatibilityMode(Mode: CHAR) -> CHAR;
}
unsafe extern "C" {
    pub fn RtlQueryProcessPlaceholderCompatibilityMode() -> CHAR;
}
unsafe extern "C" {
    pub fn RtlSetProcessPlaceholderCompatibilityMode(Mode: CHAR) -> CHAR;
}
unsafe extern "C" {
    pub fn RtlCaptureStackBackTrace(
        FramesToSkip: ULONG,
        FramesToCapture: ULONG,
        BackTrace: *mut PVOID,
        BackTraceHash: PULONG,
    ) -> USHORT;
}
unsafe extern "C" {
    pub fn RtlCaptureContext(ContextRecord: PCONTEXT);
}
unsafe extern "C" {
    pub fn RtlCaptureContext2(ContextRecord: PCONTEXT);
}
unsafe extern "C" {
    pub fn NtSetInformationThread(
        ThreadHandle: HANDLE,
        ThreadInformationClass: THREADINFOCLASS,
        ThreadInformation: PVOID,
        ThreadInformationLength: ULONG,
    ) -> NTSTATUS;
}
pub type LSA_OPERATIONAL_MODE = ULONG;
pub type PLSA_OPERATIONAL_MODE = *mut ULONG;
pub const _SECURITY_LOGON_TYPE_UndefinedLogonType: _SECURITY_LOGON_TYPE = 0;
pub const _SECURITY_LOGON_TYPE_Interactive: _SECURITY_LOGON_TYPE = 2;
pub const _SECURITY_LOGON_TYPE_Network: _SECURITY_LOGON_TYPE = 3;
pub const _SECURITY_LOGON_TYPE_Batch: _SECURITY_LOGON_TYPE = 4;
pub const _SECURITY_LOGON_TYPE_Service: _SECURITY_LOGON_TYPE = 5;
pub const _SECURITY_LOGON_TYPE_Proxy: _SECURITY_LOGON_TYPE = 6;
pub const _SECURITY_LOGON_TYPE_Unlock: _SECURITY_LOGON_TYPE = 7;
pub const _SECURITY_LOGON_TYPE_NetworkCleartext: _SECURITY_LOGON_TYPE = 8;
pub const _SECURITY_LOGON_TYPE_NewCredentials: _SECURITY_LOGON_TYPE = 9;
pub const _SECURITY_LOGON_TYPE_RemoteInteractive: _SECURITY_LOGON_TYPE = 10;
pub const _SECURITY_LOGON_TYPE_CachedInteractive: _SECURITY_LOGON_TYPE = 11;
pub const _SECURITY_LOGON_TYPE_CachedRemoteInteractive: _SECURITY_LOGON_TYPE = 12;
pub const _SECURITY_LOGON_TYPE_CachedUnlock: _SECURITY_LOGON_TYPE = 13;
pub type _SECURITY_LOGON_TYPE = core::ffi::c_int;
pub use self::_SECURITY_LOGON_TYPE as SECURITY_LOGON_TYPE;
pub type PSECURITY_LOGON_TYPE = *mut _SECURITY_LOGON_TYPE;
unsafe extern "C" {
    pub fn LsaRegisterLogonProcess(
        LogonProcessName: PLSA_STRING,
        LsaHandle: PHANDLE,
        SecurityMode: PLSA_OPERATIONAL_MODE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn LsaLogonUser(
        LsaHandle: HANDLE,
        OriginName: PLSA_STRING,
        LogonType: SECURITY_LOGON_TYPE,
        AuthenticationPackage: ULONG,
        AuthenticationInformation: PVOID,
        AuthenticationInformationLength: ULONG,
        LocalGroups: PTOKEN_GROUPS,
        SourceContext: PTOKEN_SOURCE,
        ProfileBuffer: *mut PVOID,
        ProfileBufferLength: PULONG,
        LogonId: PLUID,
        Token: PHANDLE,
        Quotas: PQUOTA_LIMITS,
        SubStatus: PNTSTATUS,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn LsaFreeReturnBuffer(Buffer: PVOID) -> NTSTATUS;
}
pub const _MSV1_0_LOGON_SUBMIT_TYPE_MsV1_0InteractiveLogon: _MSV1_0_LOGON_SUBMIT_TYPE = 2;
pub const _MSV1_0_LOGON_SUBMIT_TYPE_MsV1_0Lm20Logon: _MSV1_0_LOGON_SUBMIT_TYPE = 3;
pub const _MSV1_0_LOGON_SUBMIT_TYPE_MsV1_0NetworkLogon: _MSV1_0_LOGON_SUBMIT_TYPE = 4;
pub const _MSV1_0_LOGON_SUBMIT_TYPE_MsV1_0SubAuthLogon: _MSV1_0_LOGON_SUBMIT_TYPE = 5;
pub const _MSV1_0_LOGON_SUBMIT_TYPE_MsV1_0WorkstationUnlockLogon: _MSV1_0_LOGON_SUBMIT_TYPE = 7;
pub const _MSV1_0_LOGON_SUBMIT_TYPE_MsV1_0S4ULogon: _MSV1_0_LOGON_SUBMIT_TYPE = 12;
pub const _MSV1_0_LOGON_SUBMIT_TYPE_MsV1_0VirtualLogon: _MSV1_0_LOGON_SUBMIT_TYPE = 82;
pub const _MSV1_0_LOGON_SUBMIT_TYPE_MsV1_0NoElevationLogon: _MSV1_0_LOGON_SUBMIT_TYPE = 83;
pub const _MSV1_0_LOGON_SUBMIT_TYPE_MsV1_0LuidLogon: _MSV1_0_LOGON_SUBMIT_TYPE = 84;
pub type _MSV1_0_LOGON_SUBMIT_TYPE = core::ffi::c_int;
pub use self::_MSV1_0_LOGON_SUBMIT_TYPE as MSV1_0_LOGON_SUBMIT_TYPE;
pub type PMSV1_0_LOGON_SUBMIT_TYPE = *mut _MSV1_0_LOGON_SUBMIT_TYPE;
pub const _MSV1_0_PROFILE_BUFFER_TYPE_MsV1_0InteractiveProfile: _MSV1_0_PROFILE_BUFFER_TYPE = 2;
pub const _MSV1_0_PROFILE_BUFFER_TYPE_MsV1_0Lm20LogonProfile: _MSV1_0_PROFILE_BUFFER_TYPE = 3;
pub const _MSV1_0_PROFILE_BUFFER_TYPE_MsV1_0SmartCardProfile: _MSV1_0_PROFILE_BUFFER_TYPE = 4;
pub type _MSV1_0_PROFILE_BUFFER_TYPE = core::ffi::c_int;
pub use self::_MSV1_0_PROFILE_BUFFER_TYPE as MSV1_0_PROFILE_BUFFER_TYPE;
pub type PMSV1_0_PROFILE_BUFFER_TYPE = *mut _MSV1_0_PROFILE_BUFFER_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MSV1_0_INTERACTIVE_LOGON {
    pub MessageType: MSV1_0_LOGON_SUBMIT_TYPE,
    pub LogonDomainName: UNICODE_STRING,
    pub UserName: UNICODE_STRING,
    pub Password: UNICODE_STRING,
}
pub type MSV1_0_INTERACTIVE_LOGON = _MSV1_0_INTERACTIVE_LOGON;
pub type PMSV1_0_INTERACTIVE_LOGON = *mut _MSV1_0_INTERACTIVE_LOGON;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MSV1_0_INTERACTIVE_PROFILE {
    pub MessageType: MSV1_0_PROFILE_BUFFER_TYPE,
    pub LogonCount: USHORT,
    pub BadPasswordCount: USHORT,
    pub LogonTime: LARGE_INTEGER,
    pub LogoffTime: LARGE_INTEGER,
    pub KickOffTime: LARGE_INTEGER,
    pub PasswordLastSet: LARGE_INTEGER,
    pub PasswordCanChange: LARGE_INTEGER,
    pub PasswordMustChange: LARGE_INTEGER,
    pub LogonScript: UNICODE_STRING,
    pub HomeDirectory: UNICODE_STRING,
    pub FullName: UNICODE_STRING,
    pub ProfilePath: UNICODE_STRING,
    pub HomeDirectoryDrive: UNICODE_STRING,
    pub LogonServer: UNICODE_STRING,
    pub UserFlags: ULONG,
}
pub type MSV1_0_INTERACTIVE_PROFILE = _MSV1_0_INTERACTIVE_PROFILE;
pub type PMSV1_0_INTERACTIVE_PROFILE = *mut _MSV1_0_INTERACTIVE_PROFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MSV1_0_LM20_LOGON {
    pub MessageType: MSV1_0_LOGON_SUBMIT_TYPE,
    pub LogonDomainName: UNICODE_STRING,
    pub UserName: UNICODE_STRING,
    pub Workstation: UNICODE_STRING,
    pub ChallengeToClient: [UCHAR; 8usize],
    pub CaseSensitiveChallengeResponse: STRING,
    pub CaseInsensitiveChallengeResponse: STRING,
    pub ParameterControl: ULONG,
}
pub type MSV1_0_LM20_LOGON = _MSV1_0_LM20_LOGON;
pub type PMSV1_0_LM20_LOGON = *mut _MSV1_0_LM20_LOGON;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MSV1_0_SUBAUTH_LOGON {
    pub MessageType: MSV1_0_LOGON_SUBMIT_TYPE,
    pub LogonDomainName: UNICODE_STRING,
    pub UserName: UNICODE_STRING,
    pub Workstation: UNICODE_STRING,
    pub ChallengeToClient: [UCHAR; 8usize],
    pub AuthenticationInfo1: STRING,
    pub AuthenticationInfo2: STRING,
    pub ParameterControl: ULONG,
    pub SubAuthPackageId: ULONG,
}
pub type MSV1_0_SUBAUTH_LOGON = _MSV1_0_SUBAUTH_LOGON;
pub type PMSV1_0_SUBAUTH_LOGON = *mut _MSV1_0_SUBAUTH_LOGON;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MSV1_0_S4U_LOGON {
    pub MessageType: MSV1_0_LOGON_SUBMIT_TYPE,
    pub Flags: ULONG,
    pub UserPrincipalName: UNICODE_STRING,
    pub DomainName: UNICODE_STRING,
}
pub type MSV1_0_S4U_LOGON = _MSV1_0_S4U_LOGON;
pub type PMSV1_0_S4U_LOGON = *mut _MSV1_0_S4U_LOGON;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MSV1_0_LM20_LOGON_PROFILE {
    pub MessageType: MSV1_0_PROFILE_BUFFER_TYPE,
    pub KickOffTime: LARGE_INTEGER,
    pub LogoffTime: LARGE_INTEGER,
    pub UserFlags: ULONG,
    pub UserSessionKey: [UCHAR; 16usize],
    pub LogonDomainName: UNICODE_STRING,
    pub LanmanSessionKey: [UCHAR; 8usize],
    pub LogonServer: UNICODE_STRING,
    pub UserParameters: UNICODE_STRING,
}
pub type MSV1_0_LM20_LOGON_PROFILE = _MSV1_0_LM20_LOGON_PROFILE;
pub type PMSV1_0_LM20_LOGON_PROFILE = *mut _MSV1_0_LM20_LOGON_PROFILE;
pub const _MSV1_0_CREDENTIAL_KEY_TYPE_InvalidCredKey: _MSV1_0_CREDENTIAL_KEY_TYPE = 0;
pub const _MSV1_0_CREDENTIAL_KEY_TYPE_DeprecatedIUMCredKey: _MSV1_0_CREDENTIAL_KEY_TYPE = 1;
pub const _MSV1_0_CREDENTIAL_KEY_TYPE_DomainUserCredKey: _MSV1_0_CREDENTIAL_KEY_TYPE = 2;
pub const _MSV1_0_CREDENTIAL_KEY_TYPE_LocalUserCredKey: _MSV1_0_CREDENTIAL_KEY_TYPE = 3;
pub const _MSV1_0_CREDENTIAL_KEY_TYPE_ExternallySuppliedCredKey: _MSV1_0_CREDENTIAL_KEY_TYPE = 4;
pub type _MSV1_0_CREDENTIAL_KEY_TYPE = core::ffi::c_int;
pub use self::_MSV1_0_CREDENTIAL_KEY_TYPE as MSV1_0_CREDENTIAL_KEY_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MSV1_0_CREDENTIAL_KEY {
    pub Data: [UCHAR; 20usize],
}
pub type MSV1_0_CREDENTIAL_KEY = _MSV1_0_CREDENTIAL_KEY;
pub type PMSV1_0_CREDENTIAL_KEY = *mut _MSV1_0_CREDENTIAL_KEY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MSV1_0_SUPPLEMENTAL_CREDENTIAL {
    pub Version: ULONG,
    pub Flags: ULONG,
    pub LmPassword: [UCHAR; 16usize],
    pub NtPassword: [UCHAR; 16usize],
}
pub type MSV1_0_SUPPLEMENTAL_CREDENTIAL = _MSV1_0_SUPPLEMENTAL_CREDENTIAL;
pub type PMSV1_0_SUPPLEMENTAL_CREDENTIAL = *mut _MSV1_0_SUPPLEMENTAL_CREDENTIAL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MSV1_0_SUPPLEMENTAL_CREDENTIAL_V2 {
    pub Version: ULONG,
    pub Flags: ULONG,
    pub NtPassword: [UCHAR; 16usize],
    pub CredentialKey: MSV1_0_CREDENTIAL_KEY,
}
pub type MSV1_0_SUPPLEMENTAL_CREDENTIAL_V2 = _MSV1_0_SUPPLEMENTAL_CREDENTIAL_V2;
pub type PMSV1_0_SUPPLEMENTAL_CREDENTIAL_V2 = *mut _MSV1_0_SUPPLEMENTAL_CREDENTIAL_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MSV1_0_SUPPLEMENTAL_CREDENTIAL_V3 {
    pub Version: ULONG,
    pub Flags: ULONG,
    pub CredentialKeyType: MSV1_0_CREDENTIAL_KEY_TYPE,
    pub NtPassword: [UCHAR; 16usize],
    pub CredentialKey: MSV1_0_CREDENTIAL_KEY,
    pub ShaPassword: [UCHAR; 20usize],
}
pub type MSV1_0_SUPPLEMENTAL_CREDENTIAL_V3 = _MSV1_0_SUPPLEMENTAL_CREDENTIAL_V3;
pub type PMSV1_0_SUPPLEMENTAL_CREDENTIAL_V3 = *mut _MSV1_0_SUPPLEMENTAL_CREDENTIAL_V3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MSV1_0_IUM_SUPPLEMENTAL_CREDENTIAL {
    pub Version: ULONG,
    pub EncryptedCredsSize: ULONG,
    pub EncryptedCreds: [UCHAR; 1usize],
}
pub type MSV1_0_IUM_SUPPLEMENTAL_CREDENTIAL = _MSV1_0_IUM_SUPPLEMENTAL_CREDENTIAL;
pub type PMSV1_0_IUM_SUPPLEMENTAL_CREDENTIAL = *mut _MSV1_0_IUM_SUPPLEMENTAL_CREDENTIAL;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _MSV1_0_REMOTE_SUPPLEMENTAL_CREDENTIAL {
    pub Version: ULONG,
    pub Flags: ULONG,
    pub CredentialKey: MSV1_0_CREDENTIAL_KEY,
    pub CredentialKeyType: MSV1_0_CREDENTIAL_KEY_TYPE,
    pub EncryptedCredsSize: ULONG,
    pub EncryptedCreds: [UCHAR; 1usize],
}
pub type MSV1_0_REMOTE_SUPPLEMENTAL_CREDENTIAL = _MSV1_0_REMOTE_SUPPLEMENTAL_CREDENTIAL;
pub type PMSV1_0_REMOTE_SUPPLEMENTAL_CREDENTIAL = *mut _MSV1_0_REMOTE_SUPPLEMENTAL_CREDENTIAL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MSV1_0_NTLM3_RESPONSE {
    pub Response: [UCHAR; 16usize],
    pub RespType: UCHAR,
    pub HiRespType: UCHAR,
    pub Flags: USHORT,
    pub MsgWord: ULONG,
    pub TimeStamp: ULONGLONG,
    pub ChallengeFromClient: [UCHAR; 8usize],
    pub AvPairsOff: ULONG,
    pub Buffer: [UCHAR; 1usize],
}
pub type MSV1_0_NTLM3_RESPONSE = _MSV1_0_NTLM3_RESPONSE;
pub type PMSV1_0_NTLM3_RESPONSE = *mut _MSV1_0_NTLM3_RESPONSE;
pub const MSV1_0_AVID_MsvAvEOL: MSV1_0_AVID = 0;
pub const MSV1_0_AVID_MsvAvNbComputerName: MSV1_0_AVID = 1;
pub const MSV1_0_AVID_MsvAvNbDomainName: MSV1_0_AVID = 2;
pub const MSV1_0_AVID_MsvAvDnsComputerName: MSV1_0_AVID = 3;
pub const MSV1_0_AVID_MsvAvDnsDomainName: MSV1_0_AVID = 4;
pub const MSV1_0_AVID_MsvAvDnsTreeName: MSV1_0_AVID = 5;
pub const MSV1_0_AVID_MsvAvFlags: MSV1_0_AVID = 6;
pub const MSV1_0_AVID_MsvAvTimestamp: MSV1_0_AVID = 7;
pub const MSV1_0_AVID_MsvAvRestrictions: MSV1_0_AVID = 8;
pub const MSV1_0_AVID_MsvAvTargetName: MSV1_0_AVID = 9;
pub const MSV1_0_AVID_MsvAvChannelBindings: MSV1_0_AVID = 10;
pub type MSV1_0_AVID = core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MSV1_0_AV_PAIR {
    pub AvId: USHORT,
    pub AvLen: USHORT,
}
pub type MSV1_0_AV_PAIR = _MSV1_0_AV_PAIR;
pub type PMSV1_0_AV_PAIR = *mut _MSV1_0_AV_PAIR;
pub const _MSV1_0_PROTOCOL_MESSAGE_TYPE_MsV1_0Lm20ChallengeRequest: _MSV1_0_PROTOCOL_MESSAGE_TYPE =
    0;
pub const _MSV1_0_PROTOCOL_MESSAGE_TYPE_MsV1_0Lm20GetChallengeResponse:
_MSV1_0_PROTOCOL_MESSAGE_TYPE = 1;
pub const _MSV1_0_PROTOCOL_MESSAGE_TYPE_MsV1_0EnumerateUsers: _MSV1_0_PROTOCOL_MESSAGE_TYPE = 2;
pub const _MSV1_0_PROTOCOL_MESSAGE_TYPE_MsV1_0GetUserInfo: _MSV1_0_PROTOCOL_MESSAGE_TYPE = 3;
pub const _MSV1_0_PROTOCOL_MESSAGE_TYPE_MsV1_0ReLogonUsers: _MSV1_0_PROTOCOL_MESSAGE_TYPE = 4;
pub const _MSV1_0_PROTOCOL_MESSAGE_TYPE_MsV1_0ChangePassword: _MSV1_0_PROTOCOL_MESSAGE_TYPE = 5;
pub const _MSV1_0_PROTOCOL_MESSAGE_TYPE_MsV1_0ChangeCachedPassword: _MSV1_0_PROTOCOL_MESSAGE_TYPE =
    6;
pub const _MSV1_0_PROTOCOL_MESSAGE_TYPE_MsV1_0GenericPassthrough: _MSV1_0_PROTOCOL_MESSAGE_TYPE = 7;
pub const _MSV1_0_PROTOCOL_MESSAGE_TYPE_MsV1_0CacheLogon: _MSV1_0_PROTOCOL_MESSAGE_TYPE = 8;
pub const _MSV1_0_PROTOCOL_MESSAGE_TYPE_MsV1_0SubAuth: _MSV1_0_PROTOCOL_MESSAGE_TYPE = 9;
pub const _MSV1_0_PROTOCOL_MESSAGE_TYPE_MsV1_0DeriveCredential: _MSV1_0_PROTOCOL_MESSAGE_TYPE = 10;
pub const _MSV1_0_PROTOCOL_MESSAGE_TYPE_MsV1_0CacheLookup: _MSV1_0_PROTOCOL_MESSAGE_TYPE = 11;
pub const _MSV1_0_PROTOCOL_MESSAGE_TYPE_MsV1_0SetProcessOption: _MSV1_0_PROTOCOL_MESSAGE_TYPE = 12;
pub const _MSV1_0_PROTOCOL_MESSAGE_TYPE_MsV1_0ConfigLocalAliases: _MSV1_0_PROTOCOL_MESSAGE_TYPE =
    13;
pub const _MSV1_0_PROTOCOL_MESSAGE_TYPE_MsV1_0ClearCachedCredentials:
_MSV1_0_PROTOCOL_MESSAGE_TYPE = 14;
pub const _MSV1_0_PROTOCOL_MESSAGE_TYPE_MsV1_0LookupToken: _MSV1_0_PROTOCOL_MESSAGE_TYPE = 15;
pub const _MSV1_0_PROTOCOL_MESSAGE_TYPE_MsV1_0ValidateAuth: _MSV1_0_PROTOCOL_MESSAGE_TYPE = 16;
pub const _MSV1_0_PROTOCOL_MESSAGE_TYPE_MsV1_0CacheLookupEx: _MSV1_0_PROTOCOL_MESSAGE_TYPE = 17;
pub const _MSV1_0_PROTOCOL_MESSAGE_TYPE_MsV1_0GetCredentialKey: _MSV1_0_PROTOCOL_MESSAGE_TYPE = 18;
pub const _MSV1_0_PROTOCOL_MESSAGE_TYPE_MsV1_0SetThreadOption: _MSV1_0_PROTOCOL_MESSAGE_TYPE = 19;
pub const _MSV1_0_PROTOCOL_MESSAGE_TYPE_MsV1_0DecryptDpapiMasterKey: _MSV1_0_PROTOCOL_MESSAGE_TYPE =
    20;
pub const _MSV1_0_PROTOCOL_MESSAGE_TYPE_MsV1_0GetStrongCredentialKey:
_MSV1_0_PROTOCOL_MESSAGE_TYPE = 21;
pub const _MSV1_0_PROTOCOL_MESSAGE_TYPE_MsV1_0TransferCred: _MSV1_0_PROTOCOL_MESSAGE_TYPE = 22;
pub const _MSV1_0_PROTOCOL_MESSAGE_TYPE_MsV1_0ProvisionTbal: _MSV1_0_PROTOCOL_MESSAGE_TYPE = 23;
pub const _MSV1_0_PROTOCOL_MESSAGE_TYPE_MsV1_0DeleteTbalSecrets: _MSV1_0_PROTOCOL_MESSAGE_TYPE = 24;
pub type _MSV1_0_PROTOCOL_MESSAGE_TYPE = core::ffi::c_int;
pub use self::_MSV1_0_PROTOCOL_MESSAGE_TYPE as MSV1_0_PROTOCOL_MESSAGE_TYPE;
pub type PMSV1_0_PROTOCOL_MESSAGE_TYPE = *mut _MSV1_0_PROTOCOL_MESSAGE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MSV1_0_LM20_CHALLENGE_REQUEST {
    pub MessageType: MSV1_0_PROTOCOL_MESSAGE_TYPE,
}
pub type MSV1_0_LM20_CHALLENGE_REQUEST = _MSV1_0_LM20_CHALLENGE_REQUEST;
pub type PMSV1_0_LM20_CHALLENGE_REQUEST = *mut _MSV1_0_LM20_CHALLENGE_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MSV1_0_LM20_CHALLENGE_RESPONSE {
    pub MessageType: MSV1_0_PROTOCOL_MESSAGE_TYPE,
    pub ChallengeToClient: [UCHAR; 8usize],
}
pub type MSV1_0_LM20_CHALLENGE_RESPONSE = _MSV1_0_LM20_CHALLENGE_RESPONSE;
pub type PMSV1_0_LM20_CHALLENGE_RESPONSE = *mut _MSV1_0_LM20_CHALLENGE_RESPONSE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MSV1_0_GETCHALLENRESP_REQUEST_V1 {
    pub MessageType: MSV1_0_PROTOCOL_MESSAGE_TYPE,
    pub ParameterControl: ULONG,
    pub LogonId: LUID,
    pub Password: UNICODE_STRING,
    pub ChallengeToClient: [UCHAR; 8usize],
}
pub type MSV1_0_GETCHALLENRESP_REQUEST_V1 = _MSV1_0_GETCHALLENRESP_REQUEST_V1;
pub type PMSV1_0_GETCHALLENRESP_REQUEST_V1 = *mut _MSV1_0_GETCHALLENRESP_REQUEST_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MSV1_0_GETCHALLENRESP_REQUEST {
    pub MessageType: MSV1_0_PROTOCOL_MESSAGE_TYPE,
    pub ParameterControl: ULONG,
    pub LogonId: LUID,
    pub Password: UNICODE_STRING,
    pub ChallengeToClient: [UCHAR; 8usize],
    pub UserName: UNICODE_STRING,
    pub LogonDomainName: UNICODE_STRING,
    pub ServerName: UNICODE_STRING,
}
pub type MSV1_0_GETCHALLENRESP_REQUEST = _MSV1_0_GETCHALLENRESP_REQUEST;
pub type PMSV1_0_GETCHALLENRESP_REQUEST = *mut _MSV1_0_GETCHALLENRESP_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MSV1_0_GETCHALLENRESP_RESPONSE {
    pub MessageType: MSV1_0_PROTOCOL_MESSAGE_TYPE,
    pub CaseSensitiveChallengeResponse: STRING,
    pub CaseInsensitiveChallengeResponse: STRING,
    pub UserName: UNICODE_STRING,
    pub LogonDomainName: UNICODE_STRING,
    pub UserSessionKey: [UCHAR; 16usize],
    pub LanmanSessionKey: [UCHAR; 8usize],
}
pub type MSV1_0_GETCHALLENRESP_RESPONSE = _MSV1_0_GETCHALLENRESP_RESPONSE;
pub type PMSV1_0_GETCHALLENRESP_RESPONSE = *mut _MSV1_0_GETCHALLENRESP_RESPONSE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MSV1_0_ENUMUSERS_REQUEST {
    pub MessageType: MSV1_0_PROTOCOL_MESSAGE_TYPE,
}
pub type MSV1_0_ENUMUSERS_REQUEST = _MSV1_0_ENUMUSERS_REQUEST;
pub type PMSV1_0_ENUMUSERS_REQUEST = *mut _MSV1_0_ENUMUSERS_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MSV1_0_ENUMUSERS_RESPONSE {
    pub MessageType: MSV1_0_PROTOCOL_MESSAGE_TYPE,
    pub NumberOfLoggedOnUsers: ULONG,
    pub LogonIds: PLUID,
    pub EnumHandles: PULONG,
}
pub type MSV1_0_ENUMUSERS_RESPONSE = _MSV1_0_ENUMUSERS_RESPONSE;
pub type PMSV1_0_ENUMUSERS_RESPONSE = *mut _MSV1_0_ENUMUSERS_RESPONSE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MSV1_0_GETUSERINFO_REQUEST {
    pub MessageType: MSV1_0_PROTOCOL_MESSAGE_TYPE,
    pub LogonId: LUID,
}
pub type MSV1_0_GETUSERINFO_REQUEST = _MSV1_0_GETUSERINFO_REQUEST;
pub type PMSV1_0_GETUSERINFO_REQUEST = *mut _MSV1_0_GETUSERINFO_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MSV1_0_GETUSERINFO_RESPONSE {
    pub MessageType: MSV1_0_PROTOCOL_MESSAGE_TYPE,
    pub UserSid: PSID,
    pub UserName: UNICODE_STRING,
    pub LogonDomainName: UNICODE_STRING,
    pub LogonServer: UNICODE_STRING,
    pub LogonType: SECURITY_LOGON_TYPE,
}
pub type MSV1_0_GETUSERINFO_RESPONSE = _MSV1_0_GETUSERINFO_RESPONSE;
pub type PMSV1_0_GETUSERINFO_RESPONSE = *mut _MSV1_0_GETUSERINFO_RESPONSE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_ID_128 {
    pub Identifier: [UCHAR; 16usize],
}
pub type FILE_ID_128 = _FILE_ID_128;
pub type PFILE_ID_128 = *mut _FILE_ID_128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_NOTIFY_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub Action: ULONG,
    pub FileNameLength: ULONG,
    pub FileName: [WCHAR; 1usize],
}
pub type FILE_NOTIFY_INFORMATION = _FILE_NOTIFY_INFORMATION;
pub type PFILE_NOTIFY_INFORMATION = *mut _FILE_NOTIFY_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_NOTIFY_EXTENDED_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub Action: ULONG,
    pub CreationTime: LARGE_INTEGER,
    pub LastModificationTime: LARGE_INTEGER,
    pub LastChangeTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub AllocatedLength: LARGE_INTEGER,
    pub FileSize: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub __bindgen_anon_1: _FILE_NOTIFY_EXTENDED_INFORMATION__bindgen_ty_1,
    pub FileId: LARGE_INTEGER,
    pub ParentFileId: LARGE_INTEGER,
    pub FileNameLength: ULONG,
    pub FileName: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_NOTIFY_EXTENDED_INFORMATION__bindgen_ty_1 {
    pub ReparsePointTag: ULONG,
    pub EaSize: ULONG,
}
pub type FILE_NOTIFY_EXTENDED_INFORMATION = _FILE_NOTIFY_EXTENDED_INFORMATION;
pub type PFILE_NOTIFY_EXTENDED_INFORMATION = *mut _FILE_NOTIFY_EXTENDED_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_NOTIFY_FULL_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub Action: ULONG,
    pub CreationTime: LARGE_INTEGER,
    pub LastModificationTime: LARGE_INTEGER,
    pub LastChangeTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub AllocatedLength: LARGE_INTEGER,
    pub FileSize: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub __bindgen_anon_1: _FILE_NOTIFY_FULL_INFORMATION__bindgen_ty_1,
    pub FileId: LARGE_INTEGER,
    pub ParentFileId: LARGE_INTEGER,
    pub FileNameLength: USHORT,
    pub FileNameFlags: UCHAR,
    pub Reserved: UCHAR,
    pub FileName: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_NOTIFY_FULL_INFORMATION__bindgen_ty_1 {
    pub ReparsePointTag: ULONG,
    pub EaSize: ULONG,
}
pub type FILE_NOTIFY_FULL_INFORMATION = _FILE_NOTIFY_FULL_INFORMATION;
pub type PFILE_NOTIFY_FULL_INFORMATION = *mut _FILE_NOTIFY_FULL_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_INFORMATION_DEFINITION {
    pub Class: FILE_INFORMATION_CLASS,
    pub NextEntryOffset: ULONG,
    pub FileNameLengthOffset: ULONG,
    pub FileNameOffset: ULONG,
}
pub type FILE_INFORMATION_DEFINITION = _FILE_INFORMATION_DEFINITION;
pub type PFILE_INFORMATION_DEFINITION = *mut _FILE_INFORMATION_DEFINITION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_DIRECTORY_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub FileNameLength: ULONG,
    pub FileName: [WCHAR; 1usize],
}
pub type FILE_DIRECTORY_INFORMATION = _FILE_DIRECTORY_INFORMATION;
pub type PFILE_DIRECTORY_INFORMATION = *mut _FILE_DIRECTORY_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FULL_DIR_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub FileNameLength: ULONG,
    pub EaSize: ULONG,
    pub FileName: [WCHAR; 1usize],
}
pub type FILE_FULL_DIR_INFORMATION = _FILE_FULL_DIR_INFORMATION;
pub type PFILE_FULL_DIR_INFORMATION = *mut _FILE_FULL_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_FULL_DIR_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub FileNameLength: ULONG,
    pub EaSize: ULONG,
    pub FileId: LARGE_INTEGER,
    pub FileName: [WCHAR; 1usize],
}
pub type FILE_ID_FULL_DIR_INFORMATION = _FILE_ID_FULL_DIR_INFORMATION;
pub type PFILE_ID_FULL_DIR_INFORMATION = *mut _FILE_ID_FULL_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_BOTH_DIR_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub FileNameLength: ULONG,
    pub EaSize: ULONG,
    pub ShortNameLength: CCHAR,
    pub ShortName: [WCHAR; 12usize],
    pub FileName: [WCHAR; 1usize],
}
pub type FILE_BOTH_DIR_INFORMATION = _FILE_BOTH_DIR_INFORMATION;
pub type PFILE_BOTH_DIR_INFORMATION = *mut _FILE_BOTH_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_BOTH_DIR_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub FileNameLength: ULONG,
    pub EaSize: ULONG,
    pub ShortNameLength: CCHAR,
    pub ShortName: [WCHAR; 12usize],
    pub FileId: LARGE_INTEGER,
    pub FileName: [WCHAR; 1usize],
}
pub type FILE_ID_BOTH_DIR_INFORMATION = _FILE_ID_BOTH_DIR_INFORMATION;
pub type PFILE_ID_BOTH_DIR_INFORMATION = *mut _FILE_ID_BOTH_DIR_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_NAMES_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub FileNameLength: ULONG,
    pub FileName: [WCHAR; 1usize],
}
pub type FILE_NAMES_INFORMATION = _FILE_NAMES_INFORMATION;
pub type PFILE_NAMES_INFORMATION = *mut _FILE_NAMES_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_GLOBAL_TX_DIR_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub FileNameLength: ULONG,
    pub FileId: LARGE_INTEGER,
    pub LockingTransactionId: GUID,
    pub TxInfoFlags: ULONG,
    pub FileName: [WCHAR; 1usize],
}
pub type FILE_ID_GLOBAL_TX_DIR_INFORMATION = _FILE_ID_GLOBAL_TX_DIR_INFORMATION;
pub type PFILE_ID_GLOBAL_TX_DIR_INFORMATION = *mut _FILE_ID_GLOBAL_TX_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_EXTD_DIR_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub FileNameLength: ULONG,
    pub EaSize: ULONG,
    pub ReparsePointTag: ULONG,
    pub FileId: FILE_ID_128,
    pub FileName: [WCHAR; 1usize],
}
pub type FILE_ID_EXTD_DIR_INFORMATION = _FILE_ID_EXTD_DIR_INFORMATION;
pub type PFILE_ID_EXTD_DIR_INFORMATION = *mut _FILE_ID_EXTD_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_EXTD_BOTH_DIR_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub FileNameLength: ULONG,
    pub EaSize: ULONG,
    pub ReparsePointTag: ULONG,
    pub FileId: FILE_ID_128,
    pub ShortNameLength: CCHAR,
    pub ShortName: [WCHAR; 12usize],
    pub FileName: [WCHAR; 1usize],
}
pub type FILE_ID_EXTD_BOTH_DIR_INFORMATION = _FILE_ID_EXTD_BOTH_DIR_INFORMATION;
pub type PFILE_ID_EXTD_BOTH_DIR_INFORMATION = *mut _FILE_ID_EXTD_BOTH_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_64_EXTD_DIR_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub FileNameLength: ULONG,
    pub EaSize: ULONG,
    pub ReparsePointTag: ULONG,
    pub FileId: LARGE_INTEGER,
    pub FileName: [WCHAR; 1usize],
}
pub type FILE_ID_64_EXTD_DIR_INFORMATION = _FILE_ID_64_EXTD_DIR_INFORMATION;
pub type PFILE_ID_64_EXTD_DIR_INFORMATION = *mut _FILE_ID_64_EXTD_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_64_EXTD_BOTH_DIR_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub FileNameLength: ULONG,
    pub EaSize: ULONG,
    pub ReparsePointTag: ULONG,
    pub FileId: LARGE_INTEGER,
    pub ShortNameLength: CCHAR,
    pub ShortName: [WCHAR; 12usize],
    pub FileName: [WCHAR; 1usize],
}
pub type FILE_ID_64_EXTD_BOTH_DIR_INFORMATION = _FILE_ID_64_EXTD_BOTH_DIR_INFORMATION;
pub type PFILE_ID_64_EXTD_BOTH_DIR_INFORMATION = *mut _FILE_ID_64_EXTD_BOTH_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_ALL_EXTD_DIR_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub FileNameLength: ULONG,
    pub EaSize: ULONG,
    pub ReparsePointTag: ULONG,
    pub FileId: LARGE_INTEGER,
    pub FileId128: FILE_ID_128,
    pub FileName: [WCHAR; 1usize],
}
pub type FILE_ID_ALL_EXTD_DIR_INFORMATION = _FILE_ID_ALL_EXTD_DIR_INFORMATION;
pub type PFILE_ID_ALL_EXTD_DIR_INFORMATION = *mut _FILE_ID_ALL_EXTD_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_ALL_EXTD_BOTH_DIR_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub FileNameLength: ULONG,
    pub EaSize: ULONG,
    pub ReparsePointTag: ULONG,
    pub FileId: LARGE_INTEGER,
    pub FileId128: FILE_ID_128,
    pub ShortNameLength: CCHAR,
    pub ShortName: [WCHAR; 12usize],
    pub FileName: [WCHAR; 1usize],
}
pub type FILE_ID_ALL_EXTD_BOTH_DIR_INFORMATION = _FILE_ID_ALL_EXTD_BOTH_DIR_INFORMATION;
pub type PFILE_ID_ALL_EXTD_BOTH_DIR_INFORMATION = *mut _FILE_ID_ALL_EXTD_BOTH_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_OBJECTID_INFORMATION {
    pub FileReference: LONGLONG,
    pub ObjectId: [UCHAR; 16usize],
    pub __bindgen_anon_1: _FILE_OBJECTID_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_OBJECTID_INFORMATION__bindgen_ty_1 {
    pub __bindgen_anon_1: _FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1,
    pub ExtendedInfo: [UCHAR; 48usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub BirthVolumeId: [UCHAR; 16usize],
    pub BirthObjectId: [UCHAR; 16usize],
    pub DomainId: [UCHAR; 16usize],
}
pub type FILE_OBJECTID_INFORMATION = _FILE_OBJECTID_INFORMATION;
pub type PFILE_OBJECTID_INFORMATION = *mut _FILE_OBJECTID_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_INTERNAL_INFORMATION {
    pub IndexNumber: LARGE_INTEGER,
}
pub type FILE_INTERNAL_INFORMATION = _FILE_INTERNAL_INFORMATION;
pub type PFILE_INTERNAL_INFORMATION = *mut _FILE_INTERNAL_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_ID_INFORMATION {
    pub VolumeSerialNumber: ULONGLONG,
    pub FileId: FILE_ID_128,
}
pub type FILE_ID_INFORMATION = _FILE_ID_INFORMATION;
pub type PFILE_ID_INFORMATION = *mut _FILE_ID_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_EA_INFORMATION {
    pub EaSize: ULONG,
}
pub type FILE_EA_INFORMATION = _FILE_EA_INFORMATION;
pub type PFILE_EA_INFORMATION = *mut _FILE_EA_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_ACCESS_INFORMATION {
    pub AccessFlags: ACCESS_MASK,
}
pub type FILE_ACCESS_INFORMATION = _FILE_ACCESS_INFORMATION;
pub type PFILE_ACCESS_INFORMATION = *mut _FILE_ACCESS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_MODE_INFORMATION {
    pub Mode: ULONG,
}
pub type FILE_MODE_INFORMATION = _FILE_MODE_INFORMATION;
pub type PFILE_MODE_INFORMATION = *mut _FILE_MODE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ALL_INFORMATION {
    pub BasicInformation: FILE_BASIC_INFORMATION,
    pub StandardInformation: FILE_STANDARD_INFORMATION,
    pub InternalInformation: FILE_INTERNAL_INFORMATION,
    pub EaInformation: FILE_EA_INFORMATION,
    pub AccessInformation: FILE_ACCESS_INFORMATION,
    pub PositionInformation: FILE_POSITION_INFORMATION,
    pub ModeInformation: FILE_MODE_INFORMATION,
    pub AlignmentInformation: FILE_ALIGNMENT_INFORMATION,
    pub NameInformation: FILE_NAME_INFORMATION,
}
pub type FILE_ALL_INFORMATION = _FILE_ALL_INFORMATION;
pub type PFILE_ALL_INFORMATION = *mut _FILE_ALL_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STAT_INFORMATION {
    pub FileId: LARGE_INTEGER,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub ReparseTag: ULONG,
    pub NumberOfLinks: ULONG,
    pub EffectiveAccess: ACCESS_MASK,
}
pub type FILE_STAT_INFORMATION = _FILE_STAT_INFORMATION;
pub type PFILE_STAT_INFORMATION = *mut _FILE_STAT_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STAT_LX_INFORMATION {
    pub FileId: LARGE_INTEGER,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub ReparseTag: ULONG,
    pub NumberOfLinks: ULONG,
    pub EffectiveAccess: ACCESS_MASK,
    pub LxFlags: ULONG,
    pub LxUid: ULONG,
    pub LxGid: ULONG,
    pub LxMode: ULONG,
    pub LxDeviceIdMajor: ULONG,
    pub LxDeviceIdMinor: ULONG,
}
pub type FILE_STAT_LX_INFORMATION = _FILE_STAT_LX_INFORMATION;
pub type PFILE_STAT_LX_INFORMATION = *mut _FILE_STAT_LX_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_CASE_SENSITIVE_INFORMATION {
    pub Flags: ULONG,
}
pub type FILE_CASE_SENSITIVE_INFORMATION = _FILE_CASE_SENSITIVE_INFORMATION;
pub type PFILE_CASE_SENSITIVE_INFORMATION = *mut _FILE_CASE_SENSITIVE_INFORMATION;
pub const _FILE_KNOWN_FOLDER_TYPE_KnownFolderNone: _FILE_KNOWN_FOLDER_TYPE = 0;
pub const _FILE_KNOWN_FOLDER_TYPE_KnownFolderDesktop: _FILE_KNOWN_FOLDER_TYPE = 1;
pub const _FILE_KNOWN_FOLDER_TYPE_KnownFolderDocuments: _FILE_KNOWN_FOLDER_TYPE = 2;
pub const _FILE_KNOWN_FOLDER_TYPE_KnownFolderDownloads: _FILE_KNOWN_FOLDER_TYPE = 3;
pub const _FILE_KNOWN_FOLDER_TYPE_KnownFolderMusic: _FILE_KNOWN_FOLDER_TYPE = 4;
pub const _FILE_KNOWN_FOLDER_TYPE_KnownFolderPictures: _FILE_KNOWN_FOLDER_TYPE = 5;
pub const _FILE_KNOWN_FOLDER_TYPE_KnownFolderVideos: _FILE_KNOWN_FOLDER_TYPE = 6;
pub const _FILE_KNOWN_FOLDER_TYPE_KnownFolderOther: _FILE_KNOWN_FOLDER_TYPE = 7;
pub const _FILE_KNOWN_FOLDER_TYPE_KnownFolderMax: _FILE_KNOWN_FOLDER_TYPE = 7;
pub type _FILE_KNOWN_FOLDER_TYPE = core::ffi::c_int;
pub use self::_FILE_KNOWN_FOLDER_TYPE as FILE_KNOWN_FOLDER_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_KNOWN_FOLDER_INFORMATION {
    pub Type: FILE_KNOWN_FOLDER_TYPE,
}
pub type FILE_KNOWN_FOLDER_INFORMATION = _FILE_KNOWN_FOLDER_INFORMATION;
pub type PFILE_KNOWN_FOLDER_INFORMATION = *mut _FILE_KNOWN_FOLDER_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ALLOCATION_INFORMATION {
    pub AllocationSize: LARGE_INTEGER,
}
pub type FILE_ALLOCATION_INFORMATION = _FILE_ALLOCATION_INFORMATION;
pub type PFILE_ALLOCATION_INFORMATION = *mut _FILE_ALLOCATION_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_COMPRESSION_INFORMATION {
    pub CompressedFileSize: LARGE_INTEGER,
    pub CompressionFormat: USHORT,
    pub CompressionUnitShift: UCHAR,
    pub ChunkShift: UCHAR,
    pub ClusterShift: UCHAR,
    pub Reserved: [UCHAR; 3usize],
}
pub type FILE_COMPRESSION_INFORMATION = _FILE_COMPRESSION_INFORMATION;
pub type PFILE_COMPRESSION_INFORMATION = *mut _FILE_COMPRESSION_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_LINK_INFORMATION {
    pub __bindgen_anon_1: _FILE_LINK_INFORMATION__bindgen_ty_1,
    pub RootDirectory: HANDLE,
    pub FileNameLength: ULONG,
    pub FileName: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_LINK_INFORMATION__bindgen_ty_1 {
    pub ReplaceIfExists: BOOLEAN,
    pub Flags: ULONG,
}
pub type FILE_LINK_INFORMATION = _FILE_LINK_INFORMATION;
pub type PFILE_LINK_INFORMATION = *mut _FILE_LINK_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_MOVE_CLUSTER_INFORMATION {
    pub ClusterCount: ULONG,
    pub RootDirectory: HANDLE,
    pub FileNameLength: ULONG,
    pub FileName: [WCHAR; 1usize],
}
pub type FILE_MOVE_CLUSTER_INFORMATION = _FILE_MOVE_CLUSTER_INFORMATION;
pub type PFILE_MOVE_CLUSTER_INFORMATION = *mut _FILE_MOVE_CLUSTER_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_RENAME_INFORMATION {
    pub __bindgen_anon_1: _FILE_RENAME_INFORMATION__bindgen_ty_1,
    pub RootDirectory: HANDLE,
    pub FileNameLength: ULONG,
    pub FileName: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_RENAME_INFORMATION__bindgen_ty_1 {
    pub ReplaceIfExists: BOOLEAN,
    pub Flags: ULONG,
}
pub type FILE_RENAME_INFORMATION = _FILE_RENAME_INFORMATION;
pub type PFILE_RENAME_INFORMATION = *mut _FILE_RENAME_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STREAM_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub StreamNameLength: ULONG,
    pub StreamSize: LARGE_INTEGER,
    pub StreamAllocationSize: LARGE_INTEGER,
    pub StreamName: [WCHAR; 1usize],
}
pub type FILE_STREAM_INFORMATION = _FILE_STREAM_INFORMATION;
pub type PFILE_STREAM_INFORMATION = *mut _FILE_STREAM_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_TRACKING_INFORMATION {
    pub DestinationFile: HANDLE,
    pub ObjectInformationLength: ULONG,
    pub ObjectInformation: [CHAR; 1usize],
}
pub type FILE_TRACKING_INFORMATION = _FILE_TRACKING_INFORMATION;
pub type PFILE_TRACKING_INFORMATION = *mut _FILE_TRACKING_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_COMPLETION_INFORMATION {
    pub Port: HANDLE,
    pub Key: PVOID,
}
pub type FILE_COMPLETION_INFORMATION = _FILE_COMPLETION_INFORMATION;
pub type PFILE_COMPLETION_INFORMATION = *mut _FILE_COMPLETION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PIPE_INFORMATION {
    pub ReadMode: ULONG,
    pub CompletionMode: ULONG,
}
pub type FILE_PIPE_INFORMATION = _FILE_PIPE_INFORMATION;
pub type PFILE_PIPE_INFORMATION = *mut _FILE_PIPE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PIPE_LOCAL_INFORMATION {
    pub NamedPipeType: ULONG,
    pub NamedPipeConfiguration: ULONG,
    pub MaximumInstances: ULONG,
    pub CurrentInstances: ULONG,
    pub InboundQuota: ULONG,
    pub ReadDataAvailable: ULONG,
    pub OutboundQuota: ULONG,
    pub WriteQuotaAvailable: ULONG,
    pub NamedPipeState: ULONG,
    pub NamedPipeEnd: ULONG,
}
pub type FILE_PIPE_LOCAL_INFORMATION = _FILE_PIPE_LOCAL_INFORMATION;
pub type PFILE_PIPE_LOCAL_INFORMATION = *mut _FILE_PIPE_LOCAL_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_PIPE_REMOTE_INFORMATION {
    pub CollectDataTime: LARGE_INTEGER,
    pub MaximumCollectionCount: ULONG,
}
pub type FILE_PIPE_REMOTE_INFORMATION = _FILE_PIPE_REMOTE_INFORMATION;
pub type PFILE_PIPE_REMOTE_INFORMATION = *mut _FILE_PIPE_REMOTE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_MAILSLOT_QUERY_INFORMATION {
    pub MaximumMessageSize: ULONG,
    pub MailslotQuota: ULONG,
    pub NextMessageSize: ULONG,
    pub MessagesAvailable: ULONG,
    pub ReadTimeout: LARGE_INTEGER,
}
pub type FILE_MAILSLOT_QUERY_INFORMATION = _FILE_MAILSLOT_QUERY_INFORMATION;
pub type PFILE_MAILSLOT_QUERY_INFORMATION = *mut _FILE_MAILSLOT_QUERY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_MAILSLOT_SET_INFORMATION {
    pub ReadTimeout: PLARGE_INTEGER,
}
pub type FILE_MAILSLOT_SET_INFORMATION = _FILE_MAILSLOT_SET_INFORMATION;
pub type PFILE_MAILSLOT_SET_INFORMATION = *mut _FILE_MAILSLOT_SET_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_REPARSE_POINT_INFORMATION {
    pub FileReference: LONGLONG,
    pub Tag: ULONG,
}
pub type FILE_REPARSE_POINT_INFORMATION = _FILE_REPARSE_POINT_INFORMATION;
pub type PFILE_REPARSE_POINT_INFORMATION = *mut _FILE_REPARSE_POINT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_LINK_ENTRY_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub ParentFileId: LONGLONG,
    pub FileNameLength: ULONG,
    pub FileName: [WCHAR; 1usize],
}
pub type FILE_LINK_ENTRY_INFORMATION = _FILE_LINK_ENTRY_INFORMATION;
pub type PFILE_LINK_ENTRY_INFORMATION = *mut _FILE_LINK_ENTRY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_LINKS_INFORMATION {
    pub BytesNeeded: ULONG,
    pub EntriesReturned: ULONG,
    pub Entry: FILE_LINK_ENTRY_INFORMATION,
}
pub type FILE_LINKS_INFORMATION = _FILE_LINKS_INFORMATION;
pub type PFILE_LINKS_INFORMATION = *mut _FILE_LINKS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_LINK_ENTRY_FULL_ID_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub ParentFileId: FILE_ID_128,
    pub FileNameLength: ULONG,
    pub FileName: [WCHAR; 1usize],
}
pub type FILE_LINK_ENTRY_FULL_ID_INFORMATION = _FILE_LINK_ENTRY_FULL_ID_INFORMATION;
pub type PFILE_LINK_ENTRY_FULL_ID_INFORMATION = *mut _FILE_LINK_ENTRY_FULL_ID_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_LINKS_FULL_ID_INFORMATION {
    pub BytesNeeded: ULONG,
    pub EntriesReturned: ULONG,
    pub Entry: FILE_LINK_ENTRY_FULL_ID_INFORMATION,
}
pub type FILE_LINKS_FULL_ID_INFORMATION = _FILE_LINKS_FULL_ID_INFORMATION;
pub type PFILE_LINKS_FULL_ID_INFORMATION = *mut _FILE_LINKS_FULL_ID_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_NETWORK_PHYSICAL_NAME_INFORMATION {
    pub FileNameLength: ULONG,
    pub FileName: [WCHAR; 1usize],
}
pub type FILE_NETWORK_PHYSICAL_NAME_INFORMATION = _FILE_NETWORK_PHYSICAL_NAME_INFORMATION;
pub type PFILE_NETWORK_PHYSICAL_NAME_INFORMATION = *mut _FILE_NETWORK_PHYSICAL_NAME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_STANDARD_LINK_INFORMATION {
    pub NumberOfAccessibleLinks: ULONG,
    pub TotalNumberOfLinks: ULONG,
    pub DeletePending: BOOLEAN,
    pub Directory: BOOLEAN,
}
pub type FILE_STANDARD_LINK_INFORMATION = _FILE_STANDARD_LINK_INFORMATION;
pub type PFILE_STANDARD_LINK_INFORMATION = *mut _FILE_STANDARD_LINK_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_GET_EA_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub EaNameLength: UCHAR,
    pub EaName: [CHAR; 1usize],
}
pub type FILE_GET_EA_INFORMATION = _FILE_GET_EA_INFORMATION;
pub type PFILE_GET_EA_INFORMATION = *mut _FILE_GET_EA_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_REMOTE_PROTOCOL_INFORMATION {
    pub StructureVersion: USHORT,
    pub StructureSize: USHORT,
    pub Protocol: ULONG,
    pub ProtocolMajorVersion: USHORT,
    pub ProtocolMinorVersion: USHORT,
    pub ProtocolRevision: USHORT,
    pub Reserved: USHORT,
    pub Flags: ULONG,
    pub GenericReserved: _FILE_REMOTE_PROTOCOL_INFORMATION__bindgen_ty_1,
    pub ProtocolSpecific: _FILE_REMOTE_PROTOCOL_INFORMATION__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_REMOTE_PROTOCOL_INFORMATION__bindgen_ty_1 {
    pub Reserved: [ULONG; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_REMOTE_PROTOCOL_INFORMATION__bindgen_ty_2 {
    pub Smb2: _FILE_REMOTE_PROTOCOL_INFORMATION__bindgen_ty_2__bindgen_ty_1,
    pub Reserved: [ULONG; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_REMOTE_PROTOCOL_INFORMATION__bindgen_ty_2__bindgen_ty_1 {
    pub Server: _FILE_REMOTE_PROTOCOL_INFORMATION__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub Share: _FILE_REMOTE_PROTOCOL_INFORMATION__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_REMOTE_PROTOCOL_INFORMATION__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub Capabilities: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_REMOTE_PROTOCOL_INFORMATION__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    pub Capabilities: ULONG,
    pub CachingFlags: ULONG,
    pub ShareType: UCHAR,
    pub Reserved0: [UCHAR; 3usize],
    pub Reserved1: ULONG,
}
pub type FILE_REMOTE_PROTOCOL_INFORMATION = _FILE_REMOTE_PROTOCOL_INFORMATION;
pub type PFILE_REMOTE_PROTOCOL_INFORMATION = *mut _FILE_REMOTE_PROTOCOL_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_GET_QUOTA_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub SidLength: ULONG,
    pub Sid: SID,
}
pub type FILE_GET_QUOTA_INFORMATION = _FILE_GET_QUOTA_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_QUOTA_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub SidLength: ULONG,
    pub ChangeTime: LARGE_INTEGER,
    pub QuotaUsed: LARGE_INTEGER,
    pub QuotaThreshold: LARGE_INTEGER,
    pub QuotaLimit: LARGE_INTEGER,
    pub Sid: SID,
}
pub type FILE_QUOTA_INFORMATION = _FILE_QUOTA_INFORMATION;
pub type PFILE_QUOTA_INFORMATION = *mut _FILE_QUOTA_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_VOLUME_NAME_INFORMATION {
    pub DeviceNameLength: ULONG,
    pub DeviceName: [WCHAR; 1usize],
}
pub type FILE_VOLUME_NAME_INFORMATION = _FILE_VOLUME_NAME_INFORMATION;
pub type PFILE_VOLUME_NAME_INFORMATION = *mut _FILE_VOLUME_NAME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FS_ATTRIBUTE_INFORMATION {
    pub FileSystemAttributes: ULONG,
    pub MaximumComponentNameLength: LONG,
    pub FileSystemNameLength: ULONG,
    pub FileSystemName: [WCHAR; 1usize],
}
pub type FILE_FS_ATTRIBUTE_INFORMATION = _FILE_FS_ATTRIBUTE_INFORMATION;
pub type PFILE_FS_ATTRIBUTE_INFORMATION = *mut _FILE_FS_ATTRIBUTE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FS_DRIVER_PATH_INFORMATION {
    pub DriverInPath: BOOLEAN,
    pub DriverNameLength: ULONG,
    pub DriverName: [WCHAR; 1usize],
}
pub type FILE_FS_DRIVER_PATH_INFORMATION = _FILE_FS_DRIVER_PATH_INFORMATION;
pub type PFILE_FS_DRIVER_PATH_INFORMATION = *mut _FILE_FS_DRIVER_PATH_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FS_VOLUME_FLAGS_INFORMATION {
    pub Flags: ULONG,
}
pub type FILE_FS_VOLUME_FLAGS_INFORMATION = _FILE_FS_VOLUME_FLAGS_INFORMATION;
pub type PFILE_FS_VOLUME_FLAGS_INFORMATION = *mut _FILE_FS_VOLUME_FLAGS_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FS_CONTROL_INFORMATION {
    pub FreeSpaceStartFiltering: LARGE_INTEGER,
    pub FreeSpaceThreshold: LARGE_INTEGER,
    pub FreeSpaceStopFiltering: LARGE_INTEGER,
    pub DefaultQuotaThreshold: LARGE_INTEGER,
    pub DefaultQuotaLimit: LARGE_INTEGER,
    pub FileSystemControlFlags: ULONG,
}
pub type FILE_FS_CONTROL_INFORMATION = _FILE_FS_CONTROL_INFORMATION;
pub type PFILE_FS_CONTROL_INFORMATION = *mut _FILE_FS_CONTROL_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FS_DATA_COPY_INFORMATION {
    pub NumberOfCopies: ULONG,
}
pub type FILE_FS_DATA_COPY_INFORMATION = _FILE_FS_DATA_COPY_INFORMATION;
pub type PFILE_FS_DATA_COPY_INFORMATION = *mut _FILE_FS_DATA_COPY_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_END_OF_FILE_INFORMATION_EX {
    pub EndOfFile: LARGE_INTEGER,
    pub PagingFileSizeInMM: LARGE_INTEGER,
    pub PagingFileMaxSize: LARGE_INTEGER,
    pub Flags: ULONG,
}
pub type FILE_END_OF_FILE_INFORMATION_EX = _FILE_END_OF_FILE_INFORMATION_EX;
pub type PFILE_END_OF_FILE_INFORMATION_EX = *mut _FILE_END_OF_FILE_INFORMATION_EX;
unsafe extern "C" {
    pub fn NtCreateFile(
        FileHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        AllocationSize: PLARGE_INTEGER,
        FileAttributes: ULONG,
        ShareAccess: ULONG,
        CreateDisposition: ULONG,
        CreateOptions: ULONG,
        EaBuffer: PVOID,
        EaLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtDeviceIoControlFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        IoControlCode: ULONG,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtFsControlFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FsControlCode: ULONG,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtLockFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        ByteOffset: PLARGE_INTEGER,
        Length: PLARGE_INTEGER,
        Key: ULONG,
        FailImmediately: BOOLEAN,
        ExclusiveLock: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtOpenFile(
        FileHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        ShareAccess: ULONG,
        OpenOptions: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtQueryDirectoryFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FileInformation: PVOID,
        Length: ULONG,
        FileInformationClass: FILE_INFORMATION_CLASS,
        ReturnSingleEntry: BOOLEAN,
        FileName: PUNICODE_STRING,
        RestartScan: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtQueryDirectoryFileEx(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FileInformation: PVOID,
        Length: ULONG,
        FileInformationClass: FILE_INFORMATION_CLASS,
        QueryFlags: ULONG,
        FileName: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtQueryInformationByName(
        ObjectAttributes: POBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FileInformation: PVOID,
        Length: ULONG,
        FileInformationClass: FILE_INFORMATION_CLASS,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtQueryInformationFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FileInformation: PVOID,
        Length: ULONG,
        FileInformationClass: FILE_INFORMATION_CLASS,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtQueryQuotaInformationFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Buffer: PVOID,
        Length: ULONG,
        ReturnSingleEntry: BOOLEAN,
        SidList: PVOID,
        SidListLength: ULONG,
        StartSid: PSID,
        RestartScan: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtQueryVolumeInformationFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FsInformation: PVOID,
        Length: ULONG,
        FsInformationClass: FS_INFORMATION_CLASS,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtReadFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Buffer: PVOID,
        Length: ULONG,
        ByteOffset: PLARGE_INTEGER,
        Key: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtSetInformationFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FileInformation: PVOID,
        Length: ULONG,
        FileInformationClass: FILE_INFORMATION_CLASS,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtSetQuotaInformationFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Buffer: PVOID,
        Length: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtSetVolumeInformationFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FsInformation: PVOID,
        Length: ULONG,
        FsInformationClass: FS_INFORMATION_CLASS,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtWriteFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Buffer: PVOID,
        Length: ULONG,
        ByteOffset: PLARGE_INTEGER,
        Key: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtUnlockFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        ByteOffset: PLARGE_INTEGER,
        Length: PLARGE_INTEGER,
        Key: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtFlushBuffersFileEx(
        FileHandle: HANDLE,
        Flags: ULONG,
        Parameters: PVOID,
        ParametersSize: ULONG,
        IoStatusBlock: PIO_STATUS_BLOCK,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PATHNAME_BUFFER {
    pub PathNameLength: ULONG,
    pub Name: [WCHAR; 1usize],
}
pub type PATHNAME_BUFFER = _PATHNAME_BUFFER;
pub type PPATHNAME_BUFFER = *mut _PATHNAME_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_QUERY_FAT_BPB_BUFFER {
    pub First0x24BytesOfBootSector: [UCHAR; 36usize],
}
pub type FSCTL_QUERY_FAT_BPB_BUFFER = _FSCTL_QUERY_FAT_BPB_BUFFER;
pub type PFSCTL_QUERY_FAT_BPB_BUFFER = *mut _FSCTL_QUERY_FAT_BPB_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NTFS_VOLUME_DATA_BUFFER {
    pub VolumeSerialNumber: LARGE_INTEGER,
    pub NumberSectors: LARGE_INTEGER,
    pub TotalClusters: LARGE_INTEGER,
    pub FreeClusters: LARGE_INTEGER,
    pub TotalReserved: LARGE_INTEGER,
    pub BytesPerSector: ULONG,
    pub BytesPerCluster: ULONG,
    pub BytesPerFileRecordSegment: ULONG,
    pub ClustersPerFileRecordSegment: ULONG,
    pub MftValidDataLength: LARGE_INTEGER,
    pub MftStartLcn: LARGE_INTEGER,
    pub Mft2StartLcn: LARGE_INTEGER,
    pub MftZoneStart: LARGE_INTEGER,
    pub MftZoneEnd: LARGE_INTEGER,
}
pub type PNTFS_VOLUME_DATA_BUFFER = *mut NTFS_VOLUME_DATA_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NTFS_EXTENDED_VOLUME_DATA {
    pub ByteCount: ULONG,
    pub MajorVersion: USHORT,
    pub MinorVersion: USHORT,
    pub BytesPerPhysicalSector: ULONG,
    pub LfsMajorVersion: USHORT,
    pub LfsMinorVersion: USHORT,
    pub MaxDeviceTrimExtentCount: ULONG,
    pub MaxDeviceTrimByteCount: ULONG,
    pub MaxVolumeTrimExtentCount: ULONG,
    pub MaxVolumeTrimByteCount: ULONG,
}
pub type PNTFS_EXTENDED_VOLUME_DATA = *mut NTFS_EXTENDED_VOLUME_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct REFS_VOLUME_DATA_BUFFER {
    pub ByteCount: ULONG,
    pub MajorVersion: ULONG,
    pub MinorVersion: ULONG,
    pub BytesPerPhysicalSector: ULONG,
    pub VolumeSerialNumber: LARGE_INTEGER,
    pub NumberSectors: LARGE_INTEGER,
    pub TotalClusters: LARGE_INTEGER,
    pub FreeClusters: LARGE_INTEGER,
    pub TotalReserved: LARGE_INTEGER,
    pub BytesPerSector: ULONG,
    pub BytesPerCluster: ULONG,
    pub MaximumSizeOfResidentFile: LARGE_INTEGER,
    pub FastTierDataFillRatio: USHORT,
    pub SlowTierDataFillRatio: USHORT,
    pub DestagesFastTierToSlowTierRate: ULONG,
    pub MetadataChecksumType: USHORT,
    pub Reserved0: [UCHAR; 6usize],
    pub Reserved: [LARGE_INTEGER; 8usize],
}
pub type PREFS_VOLUME_DATA_BUFFER = *mut REFS_VOLUME_DATA_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct STARTING_LCN_INPUT_BUFFER {
    pub StartingLcn: LARGE_INTEGER,
}
pub type PSTARTING_LCN_INPUT_BUFFER = *mut STARTING_LCN_INPUT_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct STARTING_LCN_INPUT_BUFFER_EX {
    pub StartingLcn: LARGE_INTEGER,
    pub Flags: ULONG,
}
pub type PSTARTING_LCN_INPUT_BUFFER_EX = *mut STARTING_LCN_INPUT_BUFFER_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VOLUME_BITMAP_BUFFER {
    pub StartingLcn: LARGE_INTEGER,
    pub BitmapSize: LARGE_INTEGER,
    pub Buffer: [UCHAR; 1usize],
}
pub type PVOLUME_BITMAP_BUFFER = *mut VOLUME_BITMAP_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct STARTING_VCN_INPUT_BUFFER {
    pub StartingVcn: LARGE_INTEGER,
}
pub type PSTARTING_VCN_INPUT_BUFFER = *mut STARTING_VCN_INPUT_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RETRIEVAL_POINTERS_BUFFER {
    pub ExtentCount: ULONG,
    pub StartingVcn: LARGE_INTEGER,
    pub Extents: [RETRIEVAL_POINTERS_BUFFER__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RETRIEVAL_POINTERS_BUFFER__bindgen_ty_1 {
    pub NextVcn: LARGE_INTEGER,
    pub Lcn: LARGE_INTEGER,
}
pub type PRETRIEVAL_POINTERS_BUFFER = *mut RETRIEVAL_POINTERS_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER {
    pub ExtentCount: ULONG,
    pub StartingVcn: LARGE_INTEGER,
    pub Extents: [RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER__bindgen_ty_1 {
    pub NextVcn: LARGE_INTEGER,
    pub Lcn: LARGE_INTEGER,
    pub ReferenceCount: ULONG,
}
pub type PRETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER = *mut RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RETRIEVAL_POINTER_COUNT {
    pub ExtentCount: ULONG,
}
pub type PRETRIEVAL_POINTER_COUNT = *mut RETRIEVAL_POINTER_COUNT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NTFS_FILE_RECORD_INPUT_BUFFER {
    pub FileReferenceNumber: LARGE_INTEGER,
}
pub type PNTFS_FILE_RECORD_INPUT_BUFFER = *mut NTFS_FILE_RECORD_INPUT_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NTFS_FILE_RECORD_OUTPUT_BUFFER {
    pub FileReferenceNumber: LARGE_INTEGER,
    pub FileRecordLength: ULONG,
    pub FileRecordBuffer: [UCHAR; 1usize],
}
pub type PNTFS_FILE_RECORD_OUTPUT_BUFFER = *mut NTFS_FILE_RECORD_OUTPUT_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MOVE_FILE_DATA {
    pub FileHandle: HANDLE,
    pub StartingVcn: LARGE_INTEGER,
    pub StartingLcn: LARGE_INTEGER,
    pub ClusterCount: ULONG,
}
pub type PMOVE_FILE_DATA = *mut MOVE_FILE_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MOVE_FILE_RECORD_DATA {
    pub FileHandle: HANDLE,
    pub SourceFileRecord: LARGE_INTEGER,
    pub TargetFileRecord: LARGE_INTEGER,
}
pub type PMOVE_FILE_RECORD_DATA = *mut MOVE_FILE_RECORD_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MOVE_FILE_DATA32 {
    pub FileHandle: UINT32,
    pub StartingVcn: LARGE_INTEGER,
    pub StartingLcn: LARGE_INTEGER,
    pub ClusterCount: ULONG,
}
pub type MOVE_FILE_DATA32 = _MOVE_FILE_DATA32;
pub type PMOVE_FILE_DATA32 = *mut _MOVE_FILE_DATA32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FIND_BY_SID_DATA {
    pub Restart: ULONG,
    pub Sid: SID,
}
pub type PFIND_BY_SID_DATA = *mut FIND_BY_SID_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FIND_BY_SID_OUTPUT {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub FileNameLength: ULONG,
    pub FileName: [WCHAR; 1usize],
}
pub type PFIND_BY_SID_OUTPUT = *mut FIND_BY_SID_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MFT_ENUM_DATA_V0 {
    pub StartFileReferenceNumber: ULONGLONG,
    pub LowUsn: USN,
    pub HighUsn: USN,
}
pub type PMFT_ENUM_DATA_V0 = *mut MFT_ENUM_DATA_V0;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MFT_ENUM_DATA_V1 {
    pub StartFileReferenceNumber: ULONGLONG,
    pub LowUsn: USN,
    pub HighUsn: USN,
    pub MinMajorVersion: USHORT,
    pub MaxMajorVersion: USHORT,
}
pub type PMFT_ENUM_DATA_V1 = *mut MFT_ENUM_DATA_V1;
pub type MFT_ENUM_DATA = MFT_ENUM_DATA_V1;
pub type PMFT_ENUM_DATA = *mut MFT_ENUM_DATA_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CREATE_USN_JOURNAL_DATA {
    pub MaximumSize: ULONGLONG,
    pub AllocationDelta: ULONGLONG,
}
pub type PCREATE_USN_JOURNAL_DATA = *mut CREATE_USN_JOURNAL_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct READ_FILE_USN_DATA {
    pub MinMajorVersion: USHORT,
    pub MaxMajorVersion: USHORT,
}
pub type PREAD_FILE_USN_DATA = *mut READ_FILE_USN_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct READ_USN_JOURNAL_DATA_V0 {
    pub StartUsn: USN,
    pub ReasonMask: ULONG,
    pub ReturnOnlyOnClose: ULONG,
    pub Timeout: ULONGLONG,
    pub BytesToWaitFor: ULONGLONG,
    pub UsnJournalID: ULONGLONG,
}
pub type PREAD_USN_JOURNAL_DATA_V0 = *mut READ_USN_JOURNAL_DATA_V0;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct READ_USN_JOURNAL_DATA_V1 {
    pub StartUsn: USN,
    pub ReasonMask: ULONG,
    pub ReturnOnlyOnClose: ULONG,
    pub Timeout: ULONGLONG,
    pub BytesToWaitFor: ULONGLONG,
    pub UsnJournalID: ULONGLONG,
    pub MinMajorVersion: USHORT,
    pub MaxMajorVersion: USHORT,
}
pub type PREAD_USN_JOURNAL_DATA_V1 = *mut READ_USN_JOURNAL_DATA_V1;
pub type READ_USN_JOURNAL_DATA = READ_USN_JOURNAL_DATA_V1;
pub type PREAD_USN_JOURNAL_DATA = *mut READ_USN_JOURNAL_DATA_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USN_TRACK_MODIFIED_RANGES {
    pub Flags: ULONG,
    pub Unused: ULONG,
    pub ChunkSize: ULONGLONG,
    pub FileSizeThreshold: LONGLONG,
}
pub type PUSN_TRACK_MODIFIED_RANGES = *mut USN_TRACK_MODIFIED_RANGES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USN_RANGE_TRACK_OUTPUT {
    pub Usn: USN,
}
pub type PUSN_RANGE_TRACK_OUTPUT = *mut USN_RANGE_TRACK_OUTPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct USN_RECORD_V2 {
    pub RecordLength: ULONG,
    pub MajorVersion: USHORT,
    pub MinorVersion: USHORT,
    pub FileReferenceNumber: ULONGLONG,
    pub ParentFileReferenceNumber: ULONGLONG,
    pub Usn: USN,
    pub TimeStamp: LARGE_INTEGER,
    pub Reason: ULONG,
    pub SourceInfo: ULONG,
    pub SecurityId: ULONG,
    pub FileAttributes: ULONG,
    pub FileNameLength: USHORT,
    pub FileNameOffset: USHORT,
    pub FileName: [WCHAR; 1usize],
}
pub type PUSN_RECORD_V2 = *mut USN_RECORD_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct USN_RECORD_V3 {
    pub RecordLength: ULONG,
    pub MajorVersion: USHORT,
    pub MinorVersion: USHORT,
    pub FileReferenceNumber: FILE_ID_128,
    pub ParentFileReferenceNumber: FILE_ID_128,
    pub Usn: USN,
    pub TimeStamp: LARGE_INTEGER,
    pub Reason: ULONG,
    pub SourceInfo: ULONG,
    pub SecurityId: ULONG,
    pub FileAttributes: ULONG,
    pub FileNameLength: USHORT,
    pub FileNameOffset: USHORT,
    pub FileName: [WCHAR; 1usize],
}
pub type PUSN_RECORD_V3 = *mut USN_RECORD_V3;
pub type USN_RECORD = USN_RECORD_V2;
pub type PUSN_RECORD = *mut USN_RECORD_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USN_RECORD_COMMON_HEADER {
    pub RecordLength: ULONG,
    pub MajorVersion: USHORT,
    pub MinorVersion: USHORT,
}
pub type PUSN_RECORD_COMMON_HEADER = *mut USN_RECORD_COMMON_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USN_RECORD_EXTENT {
    pub Offset: LONGLONG,
    pub Length: LONGLONG,
}
pub type PUSN_RECORD_EXTENT = *mut USN_RECORD_EXTENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USN_RECORD_V4 {
    pub Header: USN_RECORD_COMMON_HEADER,
    pub FileReferenceNumber: FILE_ID_128,
    pub ParentFileReferenceNumber: FILE_ID_128,
    pub Usn: USN,
    pub Reason: ULONG,
    pub SourceInfo: ULONG,
    pub RemainingExtents: ULONG,
    pub NumberOfExtents: USHORT,
    pub ExtentSize: USHORT,
    pub Extents: [USN_RECORD_EXTENT; 1usize],
}
pub type PUSN_RECORD_V4 = *mut USN_RECORD_V4;
#[repr(C)]
#[derive(Copy, Clone)]
pub union USN_RECORD_UNION {
    pub Header: USN_RECORD_COMMON_HEADER,
    pub V2: USN_RECORD_V2,
    pub V3: USN_RECORD_V3,
    pub V4: USN_RECORD_V4,
}
pub type PUSN_RECORD_UNION = *mut USN_RECORD_UNION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USN_JOURNAL_DATA_V0 {
    pub UsnJournalID: ULONGLONG,
    pub FirstUsn: USN,
    pub NextUsn: USN,
    pub LowestValidUsn: USN,
    pub MaxUsn: USN,
    pub MaximumSize: ULONGLONG,
    pub AllocationDelta: ULONGLONG,
}
pub type PUSN_JOURNAL_DATA_V0 = *mut USN_JOURNAL_DATA_V0;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USN_JOURNAL_DATA_V1 {
    pub UsnJournalID: ULONGLONG,
    pub FirstUsn: USN,
    pub NextUsn: USN,
    pub LowestValidUsn: USN,
    pub MaxUsn: USN,
    pub MaximumSize: ULONGLONG,
    pub AllocationDelta: ULONGLONG,
    pub MinSupportedMajorVersion: USHORT,
    pub MaxSupportedMajorVersion: USHORT,
}
pub type PUSN_JOURNAL_DATA_V1 = *mut USN_JOURNAL_DATA_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USN_JOURNAL_DATA_V2 {
    pub UsnJournalID: ULONGLONG,
    pub FirstUsn: USN,
    pub NextUsn: USN,
    pub LowestValidUsn: USN,
    pub MaxUsn: USN,
    pub MaximumSize: ULONGLONG,
    pub AllocationDelta: ULONGLONG,
    pub MinSupportedMajorVersion: USHORT,
    pub MaxSupportedMajorVersion: USHORT,
    pub Flags: ULONG,
    pub RangeTrackChunkSize: ULONGLONG,
    pub RangeTrackFileSizeThreshold: LONGLONG,
}
pub type PUSN_JOURNAL_DATA_V2 = *mut USN_JOURNAL_DATA_V2;
pub type USN_JOURNAL_DATA = USN_JOURNAL_DATA_V1;
pub type PUSN_JOURNAL_DATA = *mut USN_JOURNAL_DATA_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DELETE_USN_JOURNAL_DATA {
    pub UsnJournalID: ULONGLONG,
    pub DeleteFlags: ULONG,
}
pub type PDELETE_USN_JOURNAL_DATA = *mut DELETE_USN_JOURNAL_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MARK_HANDLE_INFO {
    pub __bindgen_anon_1: _MARK_HANDLE_INFO__bindgen_ty_1,
    pub VolumeHandle: HANDLE,
    pub HandleInfo: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MARK_HANDLE_INFO__bindgen_ty_1 {
    pub UsnSourceInfo: ULONG,
    pub CopyNumber: ULONG,
}
pub type MARK_HANDLE_INFO = _MARK_HANDLE_INFO;
pub type PMARK_HANDLE_INFO = *mut _MARK_HANDLE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MARK_HANDLE_INFO32 {
    pub __bindgen_anon_1: _MARK_HANDLE_INFO32__bindgen_ty_1,
    pub VolumeHandle: UINT32,
    pub HandleInfo: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MARK_HANDLE_INFO32__bindgen_ty_1 {
    pub UsnSourceInfo: ULONG,
    pub CopyNumber: ULONG,
}
pub type MARK_HANDLE_INFO32 = _MARK_HANDLE_INFO32;
pub type PMARK_HANDLE_INFO32 = *mut _MARK_HANDLE_INFO32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BULK_SECURITY_TEST_DATA {
    pub DesiredAccess: ACCESS_MASK,
    pub SecurityIds: [ULONG; 1usize],
}
pub type PBULK_SECURITY_TEST_DATA = *mut BULK_SECURITY_TEST_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PREFETCH {
    pub Type: ULONG,
    pub Count: ULONG,
    pub Prefetch: [ULONGLONG; 1usize],
}
pub type FILE_PREFETCH = _FILE_PREFETCH;
pub type PFILE_PREFETCH = *mut _FILE_PREFETCH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PREFETCH_EX {
    pub Type: ULONG,
    pub Count: ULONG,
    pub Context: PVOID,
    pub Prefetch: [ULONGLONG; 1usize],
}
pub type FILE_PREFETCH_EX = _FILE_PREFETCH_EX;
pub type PFILE_PREFETCH_EX = *mut _FILE_PREFETCH_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILESYSTEM_STATISTICS {
    pub FileSystemType: USHORT,
    pub Version: USHORT,
    pub SizeOfCompleteStructure: ULONG,
    pub UserFileReads: ULONG,
    pub UserFileReadBytes: ULONG,
    pub UserDiskReads: ULONG,
    pub UserFileWrites: ULONG,
    pub UserFileWriteBytes: ULONG,
    pub UserDiskWrites: ULONG,
    pub MetaDataReads: ULONG,
    pub MetaDataReadBytes: ULONG,
    pub MetaDataDiskReads: ULONG,
    pub MetaDataWrites: ULONG,
    pub MetaDataWriteBytes: ULONG,
    pub MetaDataDiskWrites: ULONG,
}
pub type FILESYSTEM_STATISTICS = _FILESYSTEM_STATISTICS;
pub type PFILESYSTEM_STATISTICS = *mut _FILESYSTEM_STATISTICS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FAT_STATISTICS {
    pub CreateHits: ULONG,
    pub SuccessfulCreates: ULONG,
    pub FailedCreates: ULONG,
    pub NonCachedReads: ULONG,
    pub NonCachedReadBytes: ULONG,
    pub NonCachedWrites: ULONG,
    pub NonCachedWriteBytes: ULONG,
    pub NonCachedDiskReads: ULONG,
    pub NonCachedDiskWrites: ULONG,
}
pub type FAT_STATISTICS = _FAT_STATISTICS;
pub type PFAT_STATISTICS = *mut _FAT_STATISTICS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXFAT_STATISTICS {
    pub CreateHits: ULONG,
    pub SuccessfulCreates: ULONG,
    pub FailedCreates: ULONG,
    pub NonCachedReads: ULONG,
    pub NonCachedReadBytes: ULONG,
    pub NonCachedWrites: ULONG,
    pub NonCachedWriteBytes: ULONG,
    pub NonCachedDiskReads: ULONG,
    pub NonCachedDiskWrites: ULONG,
}
pub type EXFAT_STATISTICS = _EXFAT_STATISTICS;
pub type PEXFAT_STATISTICS = *mut _EXFAT_STATISTICS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NTFS_STATISTICS {
    pub LogFileFullExceptions: ULONG,
    pub OtherExceptions: ULONG,
    pub MftReads: ULONG,
    pub MftReadBytes: ULONG,
    pub MftWrites: ULONG,
    pub MftWriteBytes: ULONG,
    pub MftWritesUserLevel: _NTFS_STATISTICS__bindgen_ty_1,
    pub MftWritesFlushForLogFileFull: USHORT,
    pub MftWritesLazyWriter: USHORT,
    pub MftWritesUserRequest: USHORT,
    pub Mft2Writes: ULONG,
    pub Mft2WriteBytes: ULONG,
    pub Mft2WritesUserLevel: _NTFS_STATISTICS__bindgen_ty_2,
    pub Mft2WritesFlushForLogFileFull: USHORT,
    pub Mft2WritesLazyWriter: USHORT,
    pub Mft2WritesUserRequest: USHORT,
    pub RootIndexReads: ULONG,
    pub RootIndexReadBytes: ULONG,
    pub RootIndexWrites: ULONG,
    pub RootIndexWriteBytes: ULONG,
    pub BitmapReads: ULONG,
    pub BitmapReadBytes: ULONG,
    pub BitmapWrites: ULONG,
    pub BitmapWriteBytes: ULONG,
    pub BitmapWritesFlushForLogFileFull: USHORT,
    pub BitmapWritesLazyWriter: USHORT,
    pub BitmapWritesUserRequest: USHORT,
    pub BitmapWritesUserLevel: _NTFS_STATISTICS__bindgen_ty_3,
    pub MftBitmapReads: ULONG,
    pub MftBitmapReadBytes: ULONG,
    pub MftBitmapWrites: ULONG,
    pub MftBitmapWriteBytes: ULONG,
    pub MftBitmapWritesFlushForLogFileFull: USHORT,
    pub MftBitmapWritesLazyWriter: USHORT,
    pub MftBitmapWritesUserRequest: USHORT,
    pub MftBitmapWritesUserLevel: _NTFS_STATISTICS__bindgen_ty_4,
    pub UserIndexReads: ULONG,
    pub UserIndexReadBytes: ULONG,
    pub UserIndexWrites: ULONG,
    pub UserIndexWriteBytes: ULONG,
    pub LogFileReads: ULONG,
    pub LogFileReadBytes: ULONG,
    pub LogFileWrites: ULONG,
    pub LogFileWriteBytes: ULONG,
    pub Allocate: _NTFS_STATISTICS__bindgen_ty_5,
    pub DiskResourcesExhausted: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NTFS_STATISTICS__bindgen_ty_1 {
    pub Write: USHORT,
    pub Create: USHORT,
    pub SetInfo: USHORT,
    pub Flush: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NTFS_STATISTICS__bindgen_ty_2 {
    pub Write: USHORT,
    pub Create: USHORT,
    pub SetInfo: USHORT,
    pub Flush: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NTFS_STATISTICS__bindgen_ty_3 {
    pub Write: USHORT,
    pub Create: USHORT,
    pub SetInfo: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NTFS_STATISTICS__bindgen_ty_4 {
    pub Write: USHORT,
    pub Create: USHORT,
    pub SetInfo: USHORT,
    pub Flush: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NTFS_STATISTICS__bindgen_ty_5 {
    pub Calls: ULONG,
    pub Clusters: ULONG,
    pub Hints: ULONG,
    pub RunsReturned: ULONG,
    pub HintsHonored: ULONG,
    pub HintsClusters: ULONG,
    pub Cache: ULONG,
    pub CacheClusters: ULONG,
    pub CacheMiss: ULONG,
    pub CacheMissClusters: ULONG,
}
pub type NTFS_STATISTICS = _NTFS_STATISTICS;
pub type PNTFS_STATISTICS = *mut _NTFS_STATISTICS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILESYSTEM_STATISTICS_EX {
    pub FileSystemType: USHORT,
    pub Version: USHORT,
    pub SizeOfCompleteStructure: ULONG,
    pub UserFileReads: ULONGLONG,
    pub UserFileReadBytes: ULONGLONG,
    pub UserDiskReads: ULONGLONG,
    pub UserFileWrites: ULONGLONG,
    pub UserFileWriteBytes: ULONGLONG,
    pub UserDiskWrites: ULONGLONG,
    pub MetaDataReads: ULONGLONG,
    pub MetaDataReadBytes: ULONGLONG,
    pub MetaDataDiskReads: ULONGLONG,
    pub MetaDataWrites: ULONGLONG,
    pub MetaDataWriteBytes: ULONGLONG,
    pub MetaDataDiskWrites: ULONGLONG,
}
pub type FILESYSTEM_STATISTICS_EX = _FILESYSTEM_STATISTICS_EX;
pub type PFILESYSTEM_STATISTICS_EX = *mut _FILESYSTEM_STATISTICS_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NTFS_STATISTICS_EX {
    pub LogFileFullExceptions: ULONG,
    pub OtherExceptions: ULONG,
    pub MftReads: ULONGLONG,
    pub MftReadBytes: ULONGLONG,
    pub MftWrites: ULONGLONG,
    pub MftWriteBytes: ULONGLONG,
    pub MftWritesUserLevel: _NTFS_STATISTICS_EX__bindgen_ty_1,
    pub MftWritesFlushForLogFileFull: ULONG,
    pub MftWritesLazyWriter: ULONG,
    pub MftWritesUserRequest: ULONG,
    pub Mft2Writes: ULONGLONG,
    pub Mft2WriteBytes: ULONGLONG,
    pub Mft2WritesUserLevel: _NTFS_STATISTICS_EX__bindgen_ty_2,
    pub Mft2WritesFlushForLogFileFull: ULONG,
    pub Mft2WritesLazyWriter: ULONG,
    pub Mft2WritesUserRequest: ULONG,
    pub RootIndexReads: ULONGLONG,
    pub RootIndexReadBytes: ULONGLONG,
    pub RootIndexWrites: ULONGLONG,
    pub RootIndexWriteBytes: ULONGLONG,
    pub BitmapReads: ULONGLONG,
    pub BitmapReadBytes: ULONGLONG,
    pub BitmapWrites: ULONGLONG,
    pub BitmapWriteBytes: ULONGLONG,
    pub BitmapWritesFlushForLogFileFull: ULONG,
    pub BitmapWritesLazyWriter: ULONG,
    pub BitmapWritesUserRequest: ULONG,
    pub BitmapWritesUserLevel: _NTFS_STATISTICS_EX__bindgen_ty_3,
    pub MftBitmapReads: ULONGLONG,
    pub MftBitmapReadBytes: ULONGLONG,
    pub MftBitmapWrites: ULONGLONG,
    pub MftBitmapWriteBytes: ULONGLONG,
    pub MftBitmapWritesFlushForLogFileFull: ULONG,
    pub MftBitmapWritesLazyWriter: ULONG,
    pub MftBitmapWritesUserRequest: ULONG,
    pub MftBitmapWritesUserLevel: _NTFS_STATISTICS_EX__bindgen_ty_4,
    pub UserIndexReads: ULONGLONG,
    pub UserIndexReadBytes: ULONGLONG,
    pub UserIndexWrites: ULONGLONG,
    pub UserIndexWriteBytes: ULONGLONG,
    pub LogFileReads: ULONGLONG,
    pub LogFileReadBytes: ULONGLONG,
    pub LogFileWrites: ULONGLONG,
    pub LogFileWriteBytes: ULONGLONG,
    pub Allocate: _NTFS_STATISTICS_EX__bindgen_ty_5,
    pub DiskResourcesExhausted: ULONG,
    pub VolumeTrimCount: ULONGLONG,
    pub VolumeTrimTime: ULONGLONG,
    pub VolumeTrimByteCount: ULONGLONG,
    pub FileLevelTrimCount: ULONGLONG,
    pub FileLevelTrimTime: ULONGLONG,
    pub FileLevelTrimByteCount: ULONGLONG,
    pub VolumeTrimSkippedCount: ULONGLONG,
    pub VolumeTrimSkippedByteCount: ULONGLONG,
    pub NtfsFillStatInfoFromMftRecordCalledCount: ULONGLONG,
    pub NtfsFillStatInfoFromMftRecordBailedBecauseOfAttributeListCount: ULONGLONG,
    pub NtfsFillStatInfoFromMftRecordBailedBecauseOfNonResReparsePointCount: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NTFS_STATISTICS_EX__bindgen_ty_1 {
    pub Write: ULONG,
    pub Create: ULONG,
    pub SetInfo: ULONG,
    pub Flush: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NTFS_STATISTICS_EX__bindgen_ty_2 {
    pub Write: ULONG,
    pub Create: ULONG,
    pub SetInfo: ULONG,
    pub Flush: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NTFS_STATISTICS_EX__bindgen_ty_3 {
    pub Write: ULONG,
    pub Create: ULONG,
    pub SetInfo: ULONG,
    pub Flush: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NTFS_STATISTICS_EX__bindgen_ty_4 {
    pub Write: ULONG,
    pub Create: ULONG,
    pub SetInfo: ULONG,
    pub Flush: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NTFS_STATISTICS_EX__bindgen_ty_5 {
    pub Calls: ULONG,
    pub RunsReturned: ULONG,
    pub Hints: ULONG,
    pub HintsHonored: ULONG,
    pub Cache: ULONG,
    pub CacheMiss: ULONG,
    pub Clusters: ULONGLONG,
    pub HintsClusters: ULONGLONG,
    pub CacheClusters: ULONGLONG,
    pub CacheMissClusters: ULONGLONG,
}
pub type NTFS_STATISTICS_EX = _NTFS_STATISTICS_EX;
pub type PNTFS_STATISTICS_EX = *mut _NTFS_STATISTICS_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_OBJECTID_BUFFER {
    pub ObjectId: [UCHAR; 16usize],
    pub __bindgen_anon_1: _FILE_OBJECTID_BUFFER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_OBJECTID_BUFFER__bindgen_ty_1 {
    pub __bindgen_anon_1: _FILE_OBJECTID_BUFFER__bindgen_ty_1__bindgen_ty_1,
    pub ExtendedInfo: [UCHAR; 48usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_OBJECTID_BUFFER__bindgen_ty_1__bindgen_ty_1 {
    pub BirthVolumeId: [UCHAR; 16usize],
    pub BirthObjectId: [UCHAR; 16usize],
    pub DomainId: [UCHAR; 16usize],
}
pub type FILE_OBJECTID_BUFFER = _FILE_OBJECTID_BUFFER;
pub type PFILE_OBJECTID_BUFFER = *mut _FILE_OBJECTID_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_SET_SPARSE_BUFFER {
    pub SetSparse: BOOLEAN,
}
pub type FILE_SET_SPARSE_BUFFER = _FILE_SET_SPARSE_BUFFER;
pub type PFILE_SET_SPARSE_BUFFER = *mut _FILE_SET_SPARSE_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ZERO_DATA_INFORMATION {
    pub FileOffset: LARGE_INTEGER,
    pub BeyondFinalZero: LARGE_INTEGER,
}
pub type FILE_ZERO_DATA_INFORMATION = _FILE_ZERO_DATA_INFORMATION;
pub type PFILE_ZERO_DATA_INFORMATION = *mut _FILE_ZERO_DATA_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ZERO_DATA_INFORMATION_EX {
    pub FileOffset: LARGE_INTEGER,
    pub BeyondFinalZero: LARGE_INTEGER,
    pub Flags: ULONG,
}
pub type FILE_ZERO_DATA_INFORMATION_EX = _FILE_ZERO_DATA_INFORMATION_EX;
pub type PFILE_ZERO_DATA_INFORMATION_EX = *mut _FILE_ZERO_DATA_INFORMATION_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ALLOCATED_RANGE_BUFFER {
    pub FileOffset: LARGE_INTEGER,
    pub Length: LARGE_INTEGER,
}
pub type FILE_ALLOCATED_RANGE_BUFFER = _FILE_ALLOCATED_RANGE_BUFFER;
pub type PFILE_ALLOCATED_RANGE_BUFFER = *mut _FILE_ALLOCATED_RANGE_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCRYPTION_BUFFER {
    pub EncryptionOperation: ULONG,
    pub Private: [UCHAR; 1usize],
}
pub type ENCRYPTION_BUFFER = _ENCRYPTION_BUFFER;
pub type PENCRYPTION_BUFFER = *mut _ENCRYPTION_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DECRYPTION_STATUS_BUFFER {
    pub NoEncryptedStreams: BOOLEAN,
}
pub type DECRYPTION_STATUS_BUFFER = _DECRYPTION_STATUS_BUFFER;
pub type PDECRYPTION_STATUS_BUFFER = *mut _DECRYPTION_STATUS_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REQUEST_RAW_ENCRYPTED_DATA {
    pub FileOffset: LONGLONG,
    pub Length: ULONG,
}
pub type REQUEST_RAW_ENCRYPTED_DATA = _REQUEST_RAW_ENCRYPTED_DATA;
pub type PREQUEST_RAW_ENCRYPTED_DATA = *mut _REQUEST_RAW_ENCRYPTED_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCRYPTED_DATA_INFO {
    pub StartingFileOffset: ULONGLONG,
    pub OutputBufferOffset: ULONG,
    pub BytesWithinFileSize: ULONG,
    pub BytesWithinValidDataLength: ULONG,
    pub CompressionFormat: USHORT,
    pub DataUnitShift: UCHAR,
    pub ChunkShift: UCHAR,
    pub ClusterShift: UCHAR,
    pub EncryptionFormat: UCHAR,
    pub NumberOfDataBlocks: USHORT,
    pub DataBlockSize: [ULONG; 1usize],
}
pub type ENCRYPTED_DATA_INFO = _ENCRYPTED_DATA_INFO;
pub type PENCRYPTED_DATA_INFO = *mut _ENCRYPTED_DATA_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXTENDED_ENCRYPTED_DATA_INFO {
    pub ExtendedCode: ULONG,
    pub Length: ULONG,
    pub Flags: ULONG,
    pub Reserved: ULONG,
}
pub type EXTENDED_ENCRYPTED_DATA_INFO = _EXTENDED_ENCRYPTED_DATA_INFO;
pub type PEXTENDED_ENCRYPTED_DATA_INFO = *mut _EXTENDED_ENCRYPTED_DATA_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PLEX_READ_DATA_REQUEST {
    pub ByteOffset: LARGE_INTEGER,
    pub ByteLength: ULONG,
    pub PlexNumber: ULONG,
}
pub type PLEX_READ_DATA_REQUEST = _PLEX_READ_DATA_REQUEST;
pub type PPLEX_READ_DATA_REQUEST = *mut _PLEX_READ_DATA_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SI_COPYFILE {
    pub SourceFileNameLength: ULONG,
    pub DestinationFileNameLength: ULONG,
    pub Flags: ULONG,
    pub FileNameBuffer: [WCHAR; 1usize],
}
pub type SI_COPYFILE = _SI_COPYFILE;
pub type PSI_COPYFILE = *mut _SI_COPYFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_MAKE_COMPATIBLE_BUFFER {
    pub CloseDisc: BOOLEAN,
}
pub type FILE_MAKE_COMPATIBLE_BUFFER = _FILE_MAKE_COMPATIBLE_BUFFER;
pub type PFILE_MAKE_COMPATIBLE_BUFFER = *mut _FILE_MAKE_COMPATIBLE_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_SET_DEFECT_MGMT_BUFFER {
    pub Disable: BOOLEAN,
}
pub type FILE_SET_DEFECT_MGMT_BUFFER = _FILE_SET_DEFECT_MGMT_BUFFER;
pub type PFILE_SET_DEFECT_MGMT_BUFFER = *mut _FILE_SET_DEFECT_MGMT_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_QUERY_SPARING_BUFFER {
    pub SparingUnitBytes: ULONG,
    pub SoftwareSparing: BOOLEAN,
    pub TotalSpareBlocks: ULONG,
    pub FreeSpareBlocks: ULONG,
}
pub type FILE_QUERY_SPARING_BUFFER = _FILE_QUERY_SPARING_BUFFER;
pub type PFILE_QUERY_SPARING_BUFFER = *mut _FILE_QUERY_SPARING_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_QUERY_ON_DISK_VOL_INFO_BUFFER {
    pub DirectoryCount: LARGE_INTEGER,
    pub FileCount: LARGE_INTEGER,
    pub FsFormatMajVersion: USHORT,
    pub FsFormatMinVersion: USHORT,
    pub FsFormatName: [WCHAR; 12usize],
    pub FormatTime: LARGE_INTEGER,
    pub LastUpdateTime: LARGE_INTEGER,
    pub CopyrightInfo: [WCHAR; 34usize],
    pub AbstractInfo: [WCHAR; 34usize],
    pub FormattingImplementationInfo: [WCHAR; 34usize],
    pub LastModifyingImplementationInfo: [WCHAR; 34usize],
}
pub type FILE_QUERY_ON_DISK_VOL_INFO_BUFFER = _FILE_QUERY_ON_DISK_VOL_INFO_BUFFER;
pub type PFILE_QUERY_ON_DISK_VOL_INFO_BUFFER = *mut _FILE_QUERY_ON_DISK_VOL_INFO_BUFFER;
pub type CLSN = ULONGLONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_INITIATE_REPAIR_OUTPUT_BUFFER {
    pub Hint1: ULONGLONG,
    pub Hint2: ULONGLONG,
    pub Clsn: CLSN,
    pub Status: NTSTATUS,
}
pub type FILE_INITIATE_REPAIR_OUTPUT_BUFFER = _FILE_INITIATE_REPAIR_OUTPUT_BUFFER;
pub type PFILE_INITIATE_REPAIR_OUTPUT_BUFFER = *mut _FILE_INITIATE_REPAIR_OUTPUT_BUFFER;
pub const _SHRINK_VOLUME_REQUEST_TYPES_ShrinkPrepare: _SHRINK_VOLUME_REQUEST_TYPES = 1;
pub const _SHRINK_VOLUME_REQUEST_TYPES_ShrinkCommit: _SHRINK_VOLUME_REQUEST_TYPES = 2;
pub const _SHRINK_VOLUME_REQUEST_TYPES_ShrinkAbort: _SHRINK_VOLUME_REQUEST_TYPES = 3;
pub type _SHRINK_VOLUME_REQUEST_TYPES = core::ffi::c_int;
pub use self::_SHRINK_VOLUME_REQUEST_TYPES as SHRINK_VOLUME_REQUEST_TYPES;
pub type PSHRINK_VOLUME_REQUEST_TYPES = *mut _SHRINK_VOLUME_REQUEST_TYPES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHRINK_VOLUME_INFORMATION {
    pub ShrinkRequestType: SHRINK_VOLUME_REQUEST_TYPES,
    pub Flags: ULONGLONG,
    pub NewNumberOfSectors: LONGLONG,
}
pub type SHRINK_VOLUME_INFORMATION = _SHRINK_VOLUME_INFORMATION;
pub type PSHRINK_VOLUME_INFORMATION = *mut _SHRINK_VOLUME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TXFS_MODIFY_RM {
    pub Flags: ULONG,
    pub LogContainerCountMax: ULONG,
    pub LogContainerCountMin: ULONG,
    pub LogContainerCount: ULONG,
    pub LogGrowthIncrement: ULONG,
    pub LogAutoShrinkPercentage: ULONG,
    pub Reserved: ULONGLONG,
    pub LoggingMode: USHORT,
}
pub type TXFS_MODIFY_RM = _TXFS_MODIFY_RM;
pub type PTXFS_MODIFY_RM = *mut _TXFS_MODIFY_RM;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TXFS_QUERY_RM_INFORMATION {
    pub BytesRequired: ULONG,
    pub TailLsn: ULONGLONG,
    pub CurrentLsn: ULONGLONG,
    pub ArchiveTailLsn: ULONGLONG,
    pub LogContainerSize: ULONGLONG,
    pub HighestVirtualClock: LARGE_INTEGER,
    pub LogContainerCount: ULONG,
    pub LogContainerCountMax: ULONG,
    pub LogContainerCountMin: ULONG,
    pub LogGrowthIncrement: ULONG,
    pub LogAutoShrinkPercentage: ULONG,
    pub Flags: ULONG,
    pub LoggingMode: USHORT,
    pub Reserved: USHORT,
    pub RmState: ULONG,
    pub LogCapacity: ULONGLONG,
    pub LogFree: ULONGLONG,
    pub TopsSize: ULONGLONG,
    pub TopsUsed: ULONGLONG,
    pub TransactionCount: ULONGLONG,
    pub OnePCCount: ULONGLONG,
    pub TwoPCCount: ULONGLONG,
    pub NumberLogFileFull: ULONGLONG,
    pub OldestTransactionAge: ULONGLONG,
    pub RMName: GUID,
    pub TmLogPathOffset: ULONG,
}
pub type TXFS_QUERY_RM_INFORMATION = _TXFS_QUERY_RM_INFORMATION;
pub type PTXFS_QUERY_RM_INFORMATION = *mut _TXFS_QUERY_RM_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TXFS_ROLLFORWARD_REDO_INFORMATION {
    pub LastVirtualClock: LARGE_INTEGER,
    pub LastRedoLsn: ULONGLONG,
    pub HighestRecoveryLsn: ULONGLONG,
    pub Flags: ULONG,
}
pub type TXFS_ROLLFORWARD_REDO_INFORMATION = _TXFS_ROLLFORWARD_REDO_INFORMATION;
pub type PTXFS_ROLLFORWARD_REDO_INFORMATION = *mut _TXFS_ROLLFORWARD_REDO_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TXFS_START_RM_INFORMATION {
    pub Flags: ULONG,
    pub LogContainerSize: ULONGLONG,
    pub LogContainerCountMin: ULONG,
    pub LogContainerCountMax: ULONG,
    pub LogGrowthIncrement: ULONG,
    pub LogAutoShrinkPercentage: ULONG,
    pub TmLogPathOffset: ULONG,
    pub TmLogPathLength: USHORT,
    pub LoggingMode: USHORT,
    pub LogPathLength: USHORT,
    pub Reserved: USHORT,
    pub LogPath: [WCHAR; 1usize],
}
pub type TXFS_START_RM_INFORMATION = _TXFS_START_RM_INFORMATION;
pub type PTXFS_START_RM_INFORMATION = *mut _TXFS_START_RM_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TXFS_GET_METADATA_INFO_OUT {
    pub TxfFileId: _TXFS_GET_METADATA_INFO_OUT__bindgen_ty_1,
    pub LockingTransaction: GUID,
    pub LastLsn: ULONGLONG,
    pub TransactionState: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TXFS_GET_METADATA_INFO_OUT__bindgen_ty_1 {
    pub LowPart: LONGLONG,
    pub HighPart: LONGLONG,
}
pub type TXFS_GET_METADATA_INFO_OUT = _TXFS_GET_METADATA_INFO_OUT;
pub type PTXFS_GET_METADATA_INFO_OUT = *mut _TXFS_GET_METADATA_INFO_OUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY {
    pub Offset: ULONGLONG,
    pub NameFlags: ULONG,
    pub FileId: LONGLONG,
    pub Reserved1: ULONG,
    pub Reserved2: ULONG,
    pub Reserved3: LONGLONG,
    pub FileName: [WCHAR; 1usize],
}
pub type TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY = _TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY;
pub type PTXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY = *mut _TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TXFS_LIST_TRANSACTION_LOCKED_FILES {
    pub KtmTransaction: GUID,
    pub NumberOfFiles: ULONGLONG,
    pub BufferSizeRequired: ULONGLONG,
    pub Offset: ULONGLONG,
}
pub type TXFS_LIST_TRANSACTION_LOCKED_FILES = _TXFS_LIST_TRANSACTION_LOCKED_FILES;
pub type PTXFS_LIST_TRANSACTION_LOCKED_FILES = *mut _TXFS_LIST_TRANSACTION_LOCKED_FILES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TXFS_LIST_TRANSACTIONS_ENTRY {
    pub TransactionId: GUID,
    pub TransactionState: ULONG,
    pub Reserved1: ULONG,
    pub Reserved2: ULONG,
    pub Reserved3: LONGLONG,
}
pub type TXFS_LIST_TRANSACTIONS_ENTRY = _TXFS_LIST_TRANSACTIONS_ENTRY;
pub type PTXFS_LIST_TRANSACTIONS_ENTRY = *mut _TXFS_LIST_TRANSACTIONS_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TXFS_LIST_TRANSACTIONS {
    pub NumberOfTransactions: ULONGLONG,
    pub BufferSizeRequired: ULONGLONG,
}
pub type TXFS_LIST_TRANSACTIONS = _TXFS_LIST_TRANSACTIONS;
pub type PTXFS_LIST_TRANSACTIONS = *mut _TXFS_LIST_TRANSACTIONS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TXFS_READ_BACKUP_INFORMATION_OUT {
    pub __bindgen_anon_1: _TXFS_READ_BACKUP_INFORMATION_OUT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TXFS_READ_BACKUP_INFORMATION_OUT__bindgen_ty_1 {
    pub BufferLength: ULONG,
    pub Buffer: [UCHAR; 1usize],
}
pub type TXFS_READ_BACKUP_INFORMATION_OUT = _TXFS_READ_BACKUP_INFORMATION_OUT;
pub type PTXFS_READ_BACKUP_INFORMATION_OUT = *mut _TXFS_READ_BACKUP_INFORMATION_OUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TXFS_WRITE_BACKUP_INFORMATION {
    pub Buffer: [UCHAR; 1usize],
}
pub type TXFS_WRITE_BACKUP_INFORMATION = _TXFS_WRITE_BACKUP_INFORMATION;
pub type PTXFS_WRITE_BACKUP_INFORMATION = *mut _TXFS_WRITE_BACKUP_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TXFS_GET_TRANSACTED_VERSION {
    pub ThisBaseVersion: ULONG,
    pub LatestVersion: ULONG,
    pub ThisMiniVersion: USHORT,
    pub FirstMiniVersion: USHORT,
    pub LatestMiniVersion: USHORT,
}
pub type TXFS_GET_TRANSACTED_VERSION = _TXFS_GET_TRANSACTED_VERSION;
pub type PTXFS_GET_TRANSACTED_VERSION = *mut _TXFS_GET_TRANSACTED_VERSION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TXFS_SAVEPOINT_INFORMATION {
    pub KtmTransaction: HANDLE,
    pub ActionCode: ULONG,
    pub SavepointId: ULONG,
}
pub type TXFS_SAVEPOINT_INFORMATION = _TXFS_SAVEPOINT_INFORMATION;
pub type PTXFS_SAVEPOINT_INFORMATION = *mut _TXFS_SAVEPOINT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TXFS_CREATE_MINIVERSION_INFO {
    pub StructureVersion: USHORT,
    pub StructureLength: USHORT,
    pub BaseVersion: ULONG,
    pub MiniVersion: USHORT,
}
pub type TXFS_CREATE_MINIVERSION_INFO = _TXFS_CREATE_MINIVERSION_INFO;
pub type PTXFS_CREATE_MINIVERSION_INFO = *mut _TXFS_CREATE_MINIVERSION_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TXFS_TRANSACTION_ACTIVE_INFO {
    pub TransactionsActiveAtSnapshot: BOOLEAN,
}
pub type TXFS_TRANSACTION_ACTIVE_INFO = _TXFS_TRANSACTION_ACTIVE_INFO;
pub type PTXFS_TRANSACTION_ACTIVE_INFO = *mut _TXFS_TRANSACTION_ACTIVE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _BOOT_AREA_INFO {
    pub BootSectorCount: ULONG,
    pub BootSectors: [_BOOT_AREA_INFO__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _BOOT_AREA_INFO__bindgen_ty_1 {
    pub Offset: LARGE_INTEGER,
}
pub type BOOT_AREA_INFO = _BOOT_AREA_INFO;
pub type PBOOT_AREA_INFO = *mut _BOOT_AREA_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RETRIEVAL_POINTER_BASE {
    pub FileAreaOffset: LARGE_INTEGER,
}
pub type RETRIEVAL_POINTER_BASE = _RETRIEVAL_POINTER_BASE;
pub type PRETRIEVAL_POINTER_BASE = *mut _RETRIEVAL_POINTER_BASE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FS_PERSISTENT_VOLUME_INFORMATION {
    pub VolumeFlags: ULONG,
    pub FlagMask: ULONG,
    pub Version: ULONG,
    pub Reserved: ULONG,
}
pub type FILE_FS_PERSISTENT_VOLUME_INFORMATION = _FILE_FS_PERSISTENT_VOLUME_INFORMATION;
pub type PFILE_FS_PERSISTENT_VOLUME_INFORMATION = *mut _FILE_FS_PERSISTENT_VOLUME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_SYSTEM_RECOGNITION_INFORMATION {
    pub FileSystem: [CHAR; 9usize],
}
pub type FILE_SYSTEM_RECOGNITION_INFORMATION = _FILE_SYSTEM_RECOGNITION_INFORMATION;
pub type PFILE_SYSTEM_RECOGNITION_INFORMATION = *mut _FILE_SYSTEM_RECOGNITION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REQUEST_OPLOCK_INPUT_BUFFER {
    pub StructureVersion: USHORT,
    pub StructureLength: USHORT,
    pub RequestedOplockLevel: ULONG,
    pub Flags: ULONG,
}
pub type REQUEST_OPLOCK_INPUT_BUFFER = _REQUEST_OPLOCK_INPUT_BUFFER;
pub type PREQUEST_OPLOCK_INPUT_BUFFER = *mut _REQUEST_OPLOCK_INPUT_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REQUEST_OPLOCK_OUTPUT_BUFFER {
    pub StructureVersion: USHORT,
    pub StructureLength: USHORT,
    pub OriginalOplockLevel: ULONG,
    pub NewOplockLevel: ULONG,
    pub Flags: ULONG,
    pub AccessMode: ACCESS_MASK,
    pub ShareMode: USHORT,
}
pub type REQUEST_OPLOCK_OUTPUT_BUFFER = _REQUEST_OPLOCK_OUTPUT_BUFFER;
pub type PREQUEST_OPLOCK_OUTPUT_BUFFER = *mut _REQUEST_OPLOCK_OUTPUT_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VIRTUAL_STORAGE_TYPE {
    pub DeviceId: ULONG,
    pub VendorId: GUID,
}
pub type VIRTUAL_STORAGE_TYPE = _VIRTUAL_STORAGE_TYPE;
pub type PVIRTUAL_STORAGE_TYPE = *mut _VIRTUAL_STORAGE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST {
    pub RequestLevel: ULONG,
    pub RequestFlags: ULONG,
}
pub type STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST = _STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST;
pub type PSTORAGE_QUERY_DEPENDENT_VOLUME_REQUEST = *mut _STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY {
    pub EntryLength: ULONG,
    pub DependencyTypeFlags: ULONG,
    pub ProviderSpecificFlags: ULONG,
    pub VirtualStorageType: VIRTUAL_STORAGE_TYPE,
}
pub type STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY = _STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY;
pub type PSTORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY =
*mut _STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY {
    pub EntryLength: ULONG,
    pub DependencyTypeFlags: ULONG,
    pub ProviderSpecificFlags: ULONG,
    pub VirtualStorageType: VIRTUAL_STORAGE_TYPE,
    pub AncestorLevel: ULONG,
    pub HostVolumeNameOffset: ULONG,
    pub HostVolumeNameSize: ULONG,
    pub DependentVolumeNameOffset: ULONG,
    pub DependentVolumeNameSize: ULONG,
    pub RelativePathOffset: ULONG,
    pub RelativePathSize: ULONG,
    pub DependentDeviceNameOffset: ULONG,
    pub DependentDeviceNameSize: ULONG,
}
pub type STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY = _STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY;
pub type PSTORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY =
*mut _STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY;
#[repr(C)]
pub struct _STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE {
    pub ResponseLevel: ULONG,
    pub NumberEntries: ULONG,
    pub __bindgen_anon_1: _STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE__bindgen_ty_1,
}
#[repr(C)]
pub struct _STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE__bindgen_ty_1 {
    pub Lev1Depends: __BindgenUnionField<[STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY; 0usize]>,
    pub Lev2Depends: __BindgenUnionField<[STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY; 0usize]>,
    pub bindgen_union_field: u32,
}
pub type STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE = _STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE;
pub type PSTORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE = *mut _STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SD_CHANGE_MACHINE_SID_INPUT {
    pub CurrentMachineSIDOffset: USHORT,
    pub CurrentMachineSIDLength: USHORT,
    pub NewMachineSIDOffset: USHORT,
    pub NewMachineSIDLength: USHORT,
}
pub type SD_CHANGE_MACHINE_SID_INPUT = _SD_CHANGE_MACHINE_SID_INPUT;
pub type PSD_CHANGE_MACHINE_SID_INPUT = *mut _SD_CHANGE_MACHINE_SID_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SD_CHANGE_MACHINE_SID_OUTPUT {
    pub NumSDChangedSuccess: ULONGLONG,
    pub NumSDChangedFail: ULONGLONG,
    pub NumSDUnused: ULONGLONG,
    pub NumSDTotal: ULONGLONG,
    pub NumMftSDChangedSuccess: ULONGLONG,
    pub NumMftSDChangedFail: ULONGLONG,
    pub NumMftSDTotal: ULONGLONG,
}
pub type SD_CHANGE_MACHINE_SID_OUTPUT = _SD_CHANGE_MACHINE_SID_OUTPUT;
pub type PSD_CHANGE_MACHINE_SID_OUTPUT = *mut _SD_CHANGE_MACHINE_SID_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SD_QUERY_STATS_INPUT {
    pub Reserved: ULONG,
}
pub type SD_QUERY_STATS_INPUT = _SD_QUERY_STATS_INPUT;
pub type PSD_QUERY_STATS_INPUT = *mut _SD_QUERY_STATS_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SD_QUERY_STATS_OUTPUT {
    pub SdsStreamSize: ULONGLONG,
    pub SdsAllocationSize: ULONGLONG,
    pub SiiStreamSize: ULONGLONG,
    pub SiiAllocationSize: ULONGLONG,
    pub SdhStreamSize: ULONGLONG,
    pub SdhAllocationSize: ULONGLONG,
    pub NumSDTotal: ULONGLONG,
    pub NumSDUnused: ULONGLONG,
}
pub type SD_QUERY_STATS_OUTPUT = _SD_QUERY_STATS_OUTPUT;
pub type PSD_QUERY_STATS_OUTPUT = *mut _SD_QUERY_STATS_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SD_ENUM_SDS_INPUT {
    pub StartingOffset: ULONGLONG,
    pub MaxSDEntriesToReturn: ULONGLONG,
}
pub type SD_ENUM_SDS_INPUT = _SD_ENUM_SDS_INPUT;
pub type PSD_ENUM_SDS_INPUT = *mut _SD_ENUM_SDS_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SD_ENUM_SDS_ENTRY {
    pub Hash: ULONG,
    pub SecurityId: ULONG,
    pub Offset: ULONGLONG,
    pub Length: ULONG,
    pub Descriptor: [UCHAR; 1usize],
}
pub type SD_ENUM_SDS_ENTRY = _SD_ENUM_SDS_ENTRY;
pub type PSD_ENUM_SDS_ENTRY = *mut _SD_ENUM_SDS_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SD_ENUM_SDS_OUTPUT {
    pub NextOffset: ULONGLONG,
    pub NumSDEntriesReturned: ULONGLONG,
    pub NumSDBytesReturned: ULONGLONG,
    pub SDEntry: [SD_ENUM_SDS_ENTRY; 1usize],
}
pub type SD_ENUM_SDS_OUTPUT = _SD_ENUM_SDS_OUTPUT;
pub type PSD_ENUM_SDS_OUTPUT = *mut _SD_ENUM_SDS_OUTPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SD_GLOBAL_CHANGE_INPUT {
    pub Flags: ULONG,
    pub ChangeType: ULONG,
    pub __bindgen_anon_1: _SD_GLOBAL_CHANGE_INPUT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SD_GLOBAL_CHANGE_INPUT__bindgen_ty_1 {
    pub SdChange: SD_CHANGE_MACHINE_SID_INPUT,
    pub SdQueryStats: SD_QUERY_STATS_INPUT,
    pub SdEnumSds: SD_ENUM_SDS_INPUT,
}
pub type SD_GLOBAL_CHANGE_INPUT = _SD_GLOBAL_CHANGE_INPUT;
pub type PSD_GLOBAL_CHANGE_INPUT = *mut _SD_GLOBAL_CHANGE_INPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SD_GLOBAL_CHANGE_OUTPUT {
    pub Flags: ULONG,
    pub ChangeType: ULONG,
    pub __bindgen_anon_1: _SD_GLOBAL_CHANGE_OUTPUT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SD_GLOBAL_CHANGE_OUTPUT__bindgen_ty_1 {
    pub SdChange: SD_CHANGE_MACHINE_SID_OUTPUT,
    pub SdQueryStats: SD_QUERY_STATS_OUTPUT,
    pub SdEnumSds: SD_ENUM_SDS_OUTPUT,
}
pub type SD_GLOBAL_CHANGE_OUTPUT = _SD_GLOBAL_CHANGE_OUTPUT;
pub type PSD_GLOBAL_CHANGE_OUTPUT = *mut _SD_GLOBAL_CHANGE_OUTPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LOOKUP_STREAM_FROM_CLUSTER_INPUT {
    pub Flags: ULONG,
    pub NumberOfClusters: ULONG,
    pub Cluster: [LARGE_INTEGER; 1usize],
}
pub type LOOKUP_STREAM_FROM_CLUSTER_INPUT = _LOOKUP_STREAM_FROM_CLUSTER_INPUT;
pub type PLOOKUP_STREAM_FROM_CLUSTER_INPUT = *mut _LOOKUP_STREAM_FROM_CLUSTER_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LOOKUP_STREAM_FROM_CLUSTER_OUTPUT {
    pub Offset: ULONG,
    pub NumberOfMatches: ULONG,
    pub BufferSizeRequired: ULONG,
}
pub type LOOKUP_STREAM_FROM_CLUSTER_OUTPUT = _LOOKUP_STREAM_FROM_CLUSTER_OUTPUT;
pub type PLOOKUP_STREAM_FROM_CLUSTER_OUTPUT = *mut _LOOKUP_STREAM_FROM_CLUSTER_OUTPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LOOKUP_STREAM_FROM_CLUSTER_ENTRY {
    pub OffsetToNext: ULONG,
    pub Flags: ULONG,
    pub Reserved: LARGE_INTEGER,
    pub Cluster: LARGE_INTEGER,
    pub FileName: [WCHAR; 1usize],
}
pub type LOOKUP_STREAM_FROM_CLUSTER_ENTRY = _LOOKUP_STREAM_FROM_CLUSTER_ENTRY;
pub type PLOOKUP_STREAM_FROM_CLUSTER_ENTRY = *mut _LOOKUP_STREAM_FROM_CLUSTER_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_TYPE_NOTIFICATION_INPUT {
    pub Flags: ULONG,
    pub NumFileTypeIDs: ULONG,
    pub FileTypeID: [GUID; 1usize],
}
pub type FILE_TYPE_NOTIFICATION_INPUT = _FILE_TYPE_NOTIFICATION_INPUT;
pub type PFILE_TYPE_NOTIFICATION_INPUT = *mut _FILE_TYPE_NOTIFICATION_INPUT;
unsafe extern "C" {
    pub static FILE_TYPE_NOTIFICATION_GUID_PAGE_FILE: GUID;
}
unsafe extern "C" {
    pub static FILE_TYPE_NOTIFICATION_GUID_HIBERNATION_FILE: GUID;
}
unsafe extern "C" {
    pub static FILE_TYPE_NOTIFICATION_GUID_CRASHDUMP_FILE: GUID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CSV_MGMT_LOCK {
    pub Flags: ULONG,
}
pub type CSV_MGMT_LOCK = _CSV_MGMT_LOCK;
pub type PCSV_MGMT_LOCK = *mut _CSV_MGMT_LOCK;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CSV_NAMESPACE_INFO {
    pub Version: ULONG,
    pub DeviceNumber: ULONG,
    pub StartingOffset: LARGE_INTEGER,
    pub SectorSize: ULONG,
}
pub type CSV_NAMESPACE_INFO = _CSV_NAMESPACE_INFO;
pub type PCSV_NAMESPACE_INFO = *mut _CSV_NAMESPACE_INFO;
pub const _CSV_CONTROL_OP_CsvControlStartRedirectFile: _CSV_CONTROL_OP = 2;
pub const _CSV_CONTROL_OP_CsvControlStopRedirectFile: _CSV_CONTROL_OP = 3;
pub const _CSV_CONTROL_OP_CsvControlQueryRedirectState: _CSV_CONTROL_OP = 4;
pub const _CSV_CONTROL_OP_CsvControlQueryFileRevision: _CSV_CONTROL_OP = 6;
pub const _CSV_CONTROL_OP_CsvControlQueryMdsPath: _CSV_CONTROL_OP = 8;
pub const _CSV_CONTROL_OP_CsvControlQueryFileRevisionFileId128: _CSV_CONTROL_OP = 9;
pub const _CSV_CONTROL_OP_CsvControlQueryVolumeRedirectState: _CSV_CONTROL_OP = 10;
pub const _CSV_CONTROL_OP_CsvControlEnableUSNRangeModificationTracking: _CSV_CONTROL_OP = 13;
pub const _CSV_CONTROL_OP_CsvControlMarkHandleLocalVolumeMount: _CSV_CONTROL_OP = 14;
pub const _CSV_CONTROL_OP_CsvControlUnmarkHandleLocalVolumeMount: _CSV_CONTROL_OP = 15;
pub const _CSV_CONTROL_OP_CsvControlGetCsvFsMdsPathV2: _CSV_CONTROL_OP = 18;
pub const _CSV_CONTROL_OP_CsvControlDisableCaching: _CSV_CONTROL_OP = 19;
pub const _CSV_CONTROL_OP_CsvControlEnableCaching: _CSV_CONTROL_OP = 20;
pub const _CSV_CONTROL_OP_CsvControlStartForceDFO: _CSV_CONTROL_OP = 21;
pub const _CSV_CONTROL_OP_CsvControlStopForceDFO: _CSV_CONTROL_OP = 22;
pub const _CSV_CONTROL_OP_CsvControlQueryMdsPathNoPause: _CSV_CONTROL_OP = 23;
pub const _CSV_CONTROL_OP_CsvControlSetVolumeId: _CSV_CONTROL_OP = 24;
pub const _CSV_CONTROL_OP_CsvControlQueryVolumeId: _CSV_CONTROL_OP = 25;
pub type _CSV_CONTROL_OP = core::ffi::c_int;
pub use self::_CSV_CONTROL_OP as CSV_CONTROL_OP;
pub type PCSV_CONTROL_OP = *mut _CSV_CONTROL_OP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CSV_CONTROL_PARAM {
    pub Operation: CSV_CONTROL_OP,
    pub Unused: LONGLONG,
}
pub type CSV_CONTROL_PARAM = _CSV_CONTROL_PARAM;
pub type PCSV_CONTROL_PARAM = *mut _CSV_CONTROL_PARAM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CSV_QUERY_REDIRECT_STATE {
    pub MdsNodeId: ULONG,
    pub DsNodeId: ULONG,
    pub FileRedirected: BOOLEAN,
}
pub type CSV_QUERY_REDIRECT_STATE = _CSV_QUERY_REDIRECT_STATE;
pub type PCSV_QUERY_REDIRECT_STATE = *mut _CSV_QUERY_REDIRECT_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CSV_QUERY_FILE_REVISION {
    pub FileId: LONGLONG,
    pub FileRevision: [LONGLONG; 3usize],
}
pub type CSV_QUERY_FILE_REVISION = _CSV_QUERY_FILE_REVISION;
pub type PCSV_QUERY_FILE_REVISION = *mut _CSV_QUERY_FILE_REVISION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CSV_QUERY_FILE_REVISION_FILE_ID_128 {
    pub FileId: FILE_ID_128,
    pub FileRevision: [LONGLONG; 3usize],
}
pub type CSV_QUERY_FILE_REVISION_FILE_ID_128 = _CSV_QUERY_FILE_REVISION_FILE_ID_128;
pub type PCSV_QUERY_FILE_REVISION_FILE_ID_128 = *mut _CSV_QUERY_FILE_REVISION_FILE_ID_128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CSV_QUERY_MDS_PATH {
    pub MdsNodeId: ULONG,
    pub DsNodeId: ULONG,
    pub PathLength: ULONG,
    pub Path: [WCHAR; 1usize],
}
pub type CSV_QUERY_MDS_PATH = _CSV_QUERY_MDS_PATH;
pub type PCSV_QUERY_MDS_PATH = *mut _CSV_QUERY_MDS_PATH;
pub const _CSVFS_DISK_CONNECTIVITY_CsvFsDiskConnectivityNone: _CSVFS_DISK_CONNECTIVITY = 0;
pub const _CSVFS_DISK_CONNECTIVITY_CsvFsDiskConnectivityMdsNodeOnly: _CSVFS_DISK_CONNECTIVITY = 1;
pub const _CSVFS_DISK_CONNECTIVITY_CsvFsDiskConnectivitySubsetOfNodes: _CSVFS_DISK_CONNECTIVITY = 2;
pub const _CSVFS_DISK_CONNECTIVITY_CsvFsDiskConnectivityAllNodes: _CSVFS_DISK_CONNECTIVITY = 3;
pub type _CSVFS_DISK_CONNECTIVITY = core::ffi::c_int;
pub use self::_CSVFS_DISK_CONNECTIVITY as CSVFS_DISK_CONNECTIVITY;
pub type PCSVFS_DISK_CONNECTIVITY = *mut _CSVFS_DISK_CONNECTIVITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CSV_QUERY_VOLUME_REDIRECT_STATE {
    pub MdsNodeId: ULONG,
    pub DsNodeId: ULONG,
    pub IsDiskConnected: BOOLEAN,
    pub ClusterEnableDirectIo: BOOLEAN,
    pub DiskConnectivity: CSVFS_DISK_CONNECTIVITY,
}
pub type CSV_QUERY_VOLUME_REDIRECT_STATE = _CSV_QUERY_VOLUME_REDIRECT_STATE;
pub type PCSV_QUERY_VOLUME_REDIRECT_STATE = *mut _CSV_QUERY_VOLUME_REDIRECT_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CSV_QUERY_MDS_PATH_V2 {
    pub Version: LONGLONG,
    pub RequiredSize: ULONG,
    pub MdsNodeId: ULONG,
    pub DsNodeId: ULONG,
    pub Flags: ULONG,
    pub DiskConnectivity: CSVFS_DISK_CONNECTIVITY,
    pub VolumeId: GUID,
    pub IpAddressOffset: ULONG,
    pub IpAddressLength: ULONG,
    pub PathOffset: ULONG,
    pub PathLength: ULONG,
}
pub type CSV_QUERY_MDS_PATH_V2 = _CSV_QUERY_MDS_PATH_V2;
pub type PCSV_QUERY_MDS_PATH_V2 = *mut _CSV_QUERY_MDS_PATH_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CSV_SET_VOLUME_ID {
    pub VolumeId: GUID,
}
pub type CSV_SET_VOLUME_ID = _CSV_SET_VOLUME_ID;
pub type PCSV_SET_VOLUME_ID = *mut _CSV_SET_VOLUME_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CSV_QUERY_VOLUME_ID {
    pub VolumeId: GUID,
}
pub type CSV_QUERY_VOLUME_ID = _CSV_QUERY_VOLUME_ID;
pub type PCSV_QUERY_VOLUME_ID = *mut _CSV_QUERY_VOLUME_ID;
pub const _LMR_QUERY_INFO_CLASS_LMRQuerySessionInfo: _LMR_QUERY_INFO_CLASS = 1;
pub type _LMR_QUERY_INFO_CLASS = core::ffi::c_int;
pub use self::_LMR_QUERY_INFO_CLASS as LMR_QUERY_INFO_CLASS;
pub type PLMR_QUERY_INFO_CLASS = *mut _LMR_QUERY_INFO_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LMR_QUERY_INFO_PARAM {
    pub Operation: LMR_QUERY_INFO_CLASS,
}
pub type LMR_QUERY_INFO_PARAM = _LMR_QUERY_INFO_PARAM;
pub type PLMR_QUERY_INFO_PARAM = *mut _LMR_QUERY_INFO_PARAM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LMR_QUERY_SESSION_INFO {
    pub SessionId: UINT64,
}
pub type LMR_QUERY_SESSION_INFO = _LMR_QUERY_SESSION_INFO;
pub type PLMR_QUERY_SESSION_INFO = *mut _LMR_QUERY_SESSION_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT {
    pub VetoedFromAltitudeIntegral: ULONGLONG,
    pub VetoedFromAltitudeDecimal: ULONGLONG,
    pub Reason: [WCHAR; 256usize],
}
pub type CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT = _CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT;
pub type PCSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT = *mut _CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT;
pub const _STORAGE_RESERVE_ID_StorageReserveIdNone: _STORAGE_RESERVE_ID = 0;
pub const _STORAGE_RESERVE_ID_StorageReserveIdHard: _STORAGE_RESERVE_ID = 1;
pub const _STORAGE_RESERVE_ID_StorageReserveIdSoft: _STORAGE_RESERVE_ID = 2;
pub const _STORAGE_RESERVE_ID_StorageReserveIdUpdateScratch: _STORAGE_RESERVE_ID = 3;
pub const _STORAGE_RESERVE_ID_StorageReserveIdMax: _STORAGE_RESERVE_ID = 4;
pub type _STORAGE_RESERVE_ID = core::ffi::c_int;
pub use self::_STORAGE_RESERVE_ID as STORAGE_RESERVE_ID;
pub type PSTORAGE_RESERVE_ID = *mut _STORAGE_RESERVE_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CSV_IS_OWNED_BY_CSVFS {
    pub OwnedByCSVFS: BOOLEAN,
}
pub type CSV_IS_OWNED_BY_CSVFS = _CSV_IS_OWNED_BY_CSVFS;
pub type PCSV_IS_OWNED_BY_CSVFS = *mut _CSV_IS_OWNED_BY_CSVFS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_LEVEL_TRIM_RANGE {
    pub Offset: ULONGLONG,
    pub Length: ULONGLONG,
}
pub type FILE_LEVEL_TRIM_RANGE = _FILE_LEVEL_TRIM_RANGE;
pub type PFILE_LEVEL_TRIM_RANGE = *mut _FILE_LEVEL_TRIM_RANGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_LEVEL_TRIM {
    pub Key: ULONG,
    pub NumRanges: ULONG,
    pub Ranges: [FILE_LEVEL_TRIM_RANGE; 1usize],
}
pub type FILE_LEVEL_TRIM = _FILE_LEVEL_TRIM;
pub type PFILE_LEVEL_TRIM = *mut _FILE_LEVEL_TRIM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_LEVEL_TRIM_OUTPUT {
    pub NumRangesProcessed: ULONG,
}
pub type FILE_LEVEL_TRIM_OUTPUT = _FILE_LEVEL_TRIM_OUTPUT;
pub type PFILE_LEVEL_TRIM_OUTPUT = *mut _FILE_LEVEL_TRIM_OUTPUT;
pub const _QUERY_FILE_LAYOUT_FILTER_TYPE_QUERY_FILE_LAYOUT_FILTER_TYPE_NONE:
_QUERY_FILE_LAYOUT_FILTER_TYPE = 0;
pub const _QUERY_FILE_LAYOUT_FILTER_TYPE_QUERY_FILE_LAYOUT_FILTER_TYPE_CLUSTERS:
_QUERY_FILE_LAYOUT_FILTER_TYPE = 1;
pub const _QUERY_FILE_LAYOUT_FILTER_TYPE_QUERY_FILE_LAYOUT_FILTER_TYPE_FILEID:
_QUERY_FILE_LAYOUT_FILTER_TYPE = 2;
pub const _QUERY_FILE_LAYOUT_FILTER_TYPE_QUERY_FILE_LAYOUT_FILTER_TYPE_STORAGE_RESERVE_ID:
_QUERY_FILE_LAYOUT_FILTER_TYPE = 3;
pub const _QUERY_FILE_LAYOUT_FILTER_TYPE_QUERY_FILE_LAYOUT_NUM_FILTER_TYPES:
_QUERY_FILE_LAYOUT_FILTER_TYPE = 4;
pub type _QUERY_FILE_LAYOUT_FILTER_TYPE = core::ffi::c_int;
pub use self::_QUERY_FILE_LAYOUT_FILTER_TYPE as QUERY_FILE_LAYOUT_FILTER_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CLUSTER_RANGE {
    pub StartingCluster: LARGE_INTEGER,
    pub ClusterCount: LARGE_INTEGER,
}
pub type CLUSTER_RANGE = _CLUSTER_RANGE;
pub type PCLUSTER_RANGE = *mut _CLUSTER_RANGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_REFERENCE_RANGE {
    pub StartingFileReferenceNumber: ULONGLONG,
    pub EndingFileReferenceNumber: ULONGLONG,
}
pub type FILE_REFERENCE_RANGE = _FILE_REFERENCE_RANGE;
pub type PFILE_REFERENCE_RANGE = *mut _FILE_REFERENCE_RANGE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _QUERY_FILE_LAYOUT_INPUT {
    pub __bindgen_anon_1: _QUERY_FILE_LAYOUT_INPUT__bindgen_ty_1,
    pub Flags: ULONG,
    pub FilterType: QUERY_FILE_LAYOUT_FILTER_TYPE,
    pub Reserved: ULONG,
    pub Filter: _QUERY_FILE_LAYOUT_INPUT__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _QUERY_FILE_LAYOUT_INPUT__bindgen_ty_1 {
    pub FilterEntryCount: ULONG,
    pub NumberOfPairs: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _QUERY_FILE_LAYOUT_INPUT__bindgen_ty_2 {
    pub ClusterRanges: [CLUSTER_RANGE; 1usize],
    pub FileReferenceRanges: [FILE_REFERENCE_RANGE; 1usize],
    pub StorageReserveIds: [STORAGE_RESERVE_ID; 1usize],
}
pub type QUERY_FILE_LAYOUT_INPUT = _QUERY_FILE_LAYOUT_INPUT;
pub type PQUERY_FILE_LAYOUT_INPUT = *mut _QUERY_FILE_LAYOUT_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _QUERY_FILE_LAYOUT_OUTPUT {
    pub FileEntryCount: ULONG,
    pub FirstFileOffset: ULONG,
    pub Flags: ULONG,
    pub Reserved: ULONG,
}
pub type QUERY_FILE_LAYOUT_OUTPUT = _QUERY_FILE_LAYOUT_OUTPUT;
pub type PQUERY_FILE_LAYOUT_OUTPUT = *mut _QUERY_FILE_LAYOUT_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_LAYOUT_ENTRY {
    pub Version: ULONG,
    pub NextFileOffset: ULONG,
    pub Flags: ULONG,
    pub FileAttributes: ULONG,
    pub FileReferenceNumber: ULONGLONG,
    pub FirstNameOffset: ULONG,
    pub FirstStreamOffset: ULONG,
    pub ExtraInfoOffset: ULONG,
    pub ExtraInfoLength: ULONG,
}
pub type FILE_LAYOUT_ENTRY = _FILE_LAYOUT_ENTRY;
pub type PFILE_LAYOUT_ENTRY = *mut _FILE_LAYOUT_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_LAYOUT_NAME_ENTRY {
    pub NextNameOffset: ULONG,
    pub Flags: ULONG,
    pub ParentFileReferenceNumber: ULONGLONG,
    pub FileNameLength: ULONG,
    pub Reserved: ULONG,
    pub FileName: [WCHAR; 1usize],
}
pub type FILE_LAYOUT_NAME_ENTRY = _FILE_LAYOUT_NAME_ENTRY;
pub type PFILE_LAYOUT_NAME_ENTRY = *mut _FILE_LAYOUT_NAME_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_LAYOUT_INFO_ENTRY {
    pub BasicInformation: _FILE_LAYOUT_INFO_ENTRY__bindgen_ty_1,
    pub OwnerId: ULONG,
    pub SecurityId: ULONG,
    pub Usn: USN,
    pub StorageReserveId: STORAGE_RESERVE_ID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_LAYOUT_INFO_ENTRY__bindgen_ty_1 {
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub FileAttributes: ULONG,
}
pub type FILE_LAYOUT_INFO_ENTRY = _FILE_LAYOUT_INFO_ENTRY;
pub type PFILE_LAYOUT_INFO_ENTRY = *mut _FILE_LAYOUT_INFO_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STREAM_LAYOUT_ENTRY {
    pub Version: ULONG,
    pub NextStreamOffset: ULONG,
    pub Flags: ULONG,
    pub ExtentInformationOffset: ULONG,
    pub AllocationSize: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub StreamInformationOffset: ULONG,
    pub AttributeTypeCode: ULONG,
    pub AttributeFlags: ULONG,
    pub StreamIdentifierLength: ULONG,
    pub StreamIdentifier: [WCHAR; 1usize],
}
pub type STREAM_LAYOUT_ENTRY = _STREAM_LAYOUT_ENTRY;
pub type PSTREAM_LAYOUT_ENTRY = *mut _STREAM_LAYOUT_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STREAM_EXTENT_ENTRY {
    pub Flags: ULONG,
    pub ExtentInformation: _STREAM_EXTENT_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _STREAM_EXTENT_ENTRY__bindgen_ty_1 {
    pub RetrievalPointers: RETRIEVAL_POINTERS_BUFFER,
}
pub type STREAM_EXTENT_ENTRY = _STREAM_EXTENT_ENTRY;
pub type PSTREAM_EXTENT_ENTRY = *mut _STREAM_EXTENT_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_GET_INTEGRITY_INFORMATION_BUFFER {
    pub ChecksumAlgorithm: USHORT,
    pub Reserved: USHORT,
    pub Flags: ULONG,
    pub ChecksumChunkSizeInBytes: ULONG,
    pub ClusterSizeInBytes: ULONG,
}
pub type FSCTL_GET_INTEGRITY_INFORMATION_BUFFER = _FSCTL_GET_INTEGRITY_INFORMATION_BUFFER;
pub type PFSCTL_GET_INTEGRITY_INFORMATION_BUFFER = *mut _FSCTL_GET_INTEGRITY_INFORMATION_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_SET_INTEGRITY_INFORMATION_BUFFER {
    pub ChecksumAlgorithm: USHORT,
    pub Reserved: USHORT,
    pub Flags: ULONG,
}
pub type FSCTL_SET_INTEGRITY_INFORMATION_BUFFER = _FSCTL_SET_INTEGRITY_INFORMATION_BUFFER;
pub type PFSCTL_SET_INTEGRITY_INFORMATION_BUFFER = *mut _FSCTL_SET_INTEGRITY_INFORMATION_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX {
    pub EnableIntegrity: UCHAR,
    pub KeepIntegrityStateUnchanged: UCHAR,
    pub Reserved: USHORT,
    pub Flags: ULONG,
    pub Version: UCHAR,
    pub Reserved2: [UCHAR; 7usize],
}
pub type FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX = _FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX;
pub type PFSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX =
*mut _FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_OFFLOAD_READ_INPUT {
    pub Size: ULONG,
    pub Flags: ULONG,
    pub TokenTimeToLive: ULONG,
    pub Reserved: ULONG,
    pub FileOffset: ULONGLONG,
    pub CopyLength: ULONGLONG,
}
pub type FSCTL_OFFLOAD_READ_INPUT = _FSCTL_OFFLOAD_READ_INPUT;
pub type PFSCTL_OFFLOAD_READ_INPUT = *mut _FSCTL_OFFLOAD_READ_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_OFFLOAD_READ_OUTPUT {
    pub Size: ULONG,
    pub Flags: ULONG,
    pub TransferLength: ULONGLONG,
    pub Token: [UCHAR; 512usize],
}
pub type FSCTL_OFFLOAD_READ_OUTPUT = _FSCTL_OFFLOAD_READ_OUTPUT;
pub type PFSCTL_OFFLOAD_READ_OUTPUT = *mut _FSCTL_OFFLOAD_READ_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_OFFLOAD_WRITE_INPUT {
    pub Size: ULONG,
    pub Flags: ULONG,
    pub FileOffset: ULONGLONG,
    pub CopyLength: ULONGLONG,
    pub TransferOffset: ULONGLONG,
    pub Token: [UCHAR; 512usize],
}
pub type FSCTL_OFFLOAD_WRITE_INPUT = _FSCTL_OFFLOAD_WRITE_INPUT;
pub type PFSCTL_OFFLOAD_WRITE_INPUT = *mut _FSCTL_OFFLOAD_WRITE_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_OFFLOAD_WRITE_OUTPUT {
    pub Size: ULONG,
    pub Flags: ULONG,
    pub LengthWritten: ULONGLONG,
}
pub type FSCTL_OFFLOAD_WRITE_OUTPUT = _FSCTL_OFFLOAD_WRITE_OUTPUT;
pub type PFSCTL_OFFLOAD_WRITE_OUTPUT = *mut _FSCTL_OFFLOAD_WRITE_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SET_PURGE_FAILURE_MODE_INPUT {
    pub Flags: ULONG,
}
pub type SET_PURGE_FAILURE_MODE_INPUT = _SET_PURGE_FAILURE_MODE_INPUT;
pub type PSET_PURGE_FAILURE_MODE_INPUT = *mut _SET_PURGE_FAILURE_MODE_INPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _REPAIR_COPIES_INPUT {
    pub Size: ULONG,
    pub Flags: ULONG,
    pub FileOffset: LARGE_INTEGER,
    pub Length: ULONG,
    pub SourceCopy: ULONG,
    pub NumberOfRepairCopies: ULONG,
    pub RepairCopies: [ULONG; 1usize],
}
pub type REPAIR_COPIES_INPUT = _REPAIR_COPIES_INPUT;
pub type PREPAIR_COPIES_INPUT = *mut _REPAIR_COPIES_INPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _REPAIR_COPIES_OUTPUT {
    pub Size: ULONG,
    pub Status: NTSTATUS,
    pub ResumeFileOffset: LARGE_INTEGER,
}
pub type REPAIR_COPIES_OUTPUT = _REPAIR_COPIES_OUTPUT;
pub type PREPAIR_COPIES_OUTPUT = *mut _REPAIR_COPIES_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_REGION_INFO {
    pub FileOffset: LONGLONG,
    pub Length: LONGLONG,
    pub Usage: ULONG,
    pub Reserved: ULONG,
}
pub type FILE_REGION_INFO = _FILE_REGION_INFO;
pub type PFILE_REGION_INFO = *mut _FILE_REGION_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_REGION_OUTPUT {
    pub Flags: ULONG,
    pub TotalRegionEntryCount: ULONG,
    pub RegionEntryCount: ULONG,
    pub Reserved: ULONG,
    pub Region: [FILE_REGION_INFO; 1usize],
}
pub type FILE_REGION_OUTPUT = _FILE_REGION_OUTPUT;
pub type PFILE_REGION_OUTPUT = *mut _FILE_REGION_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_REGION_INPUT {
    pub FileOffset: LONGLONG,
    pub Length: LONGLONG,
    pub DesiredUsage: ULONG,
}
pub type FILE_REGION_INPUT = _FILE_REGION_INPUT;
pub type PFILE_REGION_INPUT = *mut _FILE_REGION_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WRITE_USN_REASON_INPUT {
    pub Flags: ULONG,
    pub UsnReasonToWrite: ULONG,
}
pub type WRITE_USN_REASON_INPUT = _WRITE_USN_REASON_INPUT;
pub type PWRITE_USN_REASON_INPUT = *mut _WRITE_USN_REASON_INPUT;
pub const _FILE_STORAGE_TIER_MEDIA_TYPE_FileStorageTierMediaTypeUnspecified:
_FILE_STORAGE_TIER_MEDIA_TYPE = 0;
pub const _FILE_STORAGE_TIER_MEDIA_TYPE_FileStorageTierMediaTypeDisk:
_FILE_STORAGE_TIER_MEDIA_TYPE = 1;
pub const _FILE_STORAGE_TIER_MEDIA_TYPE_FileStorageTierMediaTypeSsd: _FILE_STORAGE_TIER_MEDIA_TYPE =
    2;
pub const _FILE_STORAGE_TIER_MEDIA_TYPE_FileStorageTierMediaTypeScm: _FILE_STORAGE_TIER_MEDIA_TYPE =
    4;
pub const _FILE_STORAGE_TIER_MEDIA_TYPE_FileStorageTierMediaTypeMax: _FILE_STORAGE_TIER_MEDIA_TYPE =
    5;
pub type _FILE_STORAGE_TIER_MEDIA_TYPE = core::ffi::c_int;
pub use self::_FILE_STORAGE_TIER_MEDIA_TYPE as FILE_STORAGE_TIER_MEDIA_TYPE;
pub type PFILE_STORAGE_TIER_MEDIA_TYPE = *mut _FILE_STORAGE_TIER_MEDIA_TYPE;
pub const _FILE_STORAGE_TIER_CLASS_FileStorageTierClassUnspecified: _FILE_STORAGE_TIER_CLASS = 0;
pub const _FILE_STORAGE_TIER_CLASS_FileStorageTierClassCapacity: _FILE_STORAGE_TIER_CLASS = 1;
pub const _FILE_STORAGE_TIER_CLASS_FileStorageTierClassPerformance: _FILE_STORAGE_TIER_CLASS = 2;
pub const _FILE_STORAGE_TIER_CLASS_FileStorageTierClassMax: _FILE_STORAGE_TIER_CLASS = 3;
pub type _FILE_STORAGE_TIER_CLASS = core::ffi::c_int;
pub use self::_FILE_STORAGE_TIER_CLASS as FILE_STORAGE_TIER_CLASS;
pub type PFILE_STORAGE_TIER_CLASS = *mut _FILE_STORAGE_TIER_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_STORAGE_TIER {
    pub Id: GUID,
    pub Name: [WCHAR; 256usize],
    pub Description: [WCHAR; 256usize],
    pub Flags: ULONGLONG,
    pub ProvisionedCapacity: ULONGLONG,
    pub MediaType: FILE_STORAGE_TIER_MEDIA_TYPE,
    pub Class: FILE_STORAGE_TIER_CLASS,
}
pub type FILE_STORAGE_TIER = _FILE_STORAGE_TIER;
pub type PFILE_STORAGE_TIER = *mut _FILE_STORAGE_TIER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_QUERY_STORAGE_CLASSES_OUTPUT {
    pub Version: ULONG,
    pub Size: ULONG,
    pub Flags: ULONG,
    pub TotalNumberOfTiers: ULONG,
    pub NumberOfTiersReturned: ULONG,
    pub Tiers: [FILE_STORAGE_TIER; 1usize],
}
pub type FSCTL_QUERY_STORAGE_CLASSES_OUTPUT = _FSCTL_QUERY_STORAGE_CLASSES_OUTPUT;
pub type PFSCTL_QUERY_STORAGE_CLASSES_OUTPUT = *mut _FSCTL_QUERY_STORAGE_CLASSES_OUTPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STREAM_INFORMATION_ENTRY {
    pub Version: ULONG,
    pub Flags: ULONG,
    pub StreamInformation: _STREAM_INFORMATION_ENTRY__StreamInformation,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _STREAM_INFORMATION_ENTRY__StreamInformation {
    pub DesiredStorageClass: _STREAM_INFORMATION_ENTRY__StreamInformation__DesiredStorageClass,
    pub DataStream: _STREAM_INFORMATION_ENTRY__StreamInformation__DataStream,
    pub Reparse: _STREAM_INFORMATION_ENTRY__StreamInformation__Reparse,
    pub Ea: _STREAM_INFORMATION_ENTRY__StreamInformation__Ea,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STREAM_INFORMATION_ENTRY__StreamInformation__DesiredStorageClass {
    pub Class: FILE_STORAGE_TIER_CLASS,
    pub Flags: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STREAM_INFORMATION_ENTRY__StreamInformation__DataStream {
    pub Length: USHORT,
    pub Flags: USHORT,
    pub Reserved: ULONG,
    pub Vdl: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STREAM_INFORMATION_ENTRY__StreamInformation__Reparse {
    pub Length: USHORT,
    pub Flags: USHORT,
    pub ReparseDataSize: ULONG,
    pub ReparseDataOffset: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STREAM_INFORMATION_ENTRY__StreamInformation__Ea {
    pub Length: USHORT,
    pub Flags: USHORT,
    pub EaSize: ULONG,
    pub EaInformationOffset: ULONG,
}
pub type STREAM_INFORMATION_ENTRY = _STREAM_INFORMATION_ENTRY;
pub type PSTREAM_INFORMATION_ENTRY = *mut _STREAM_INFORMATION_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_QUERY_REGION_INFO_INPUT {
    pub Version: ULONG,
    pub Size: ULONG,
    pub Flags: ULONG,
    pub NumberOfTierIds: ULONG,
    pub TierIds: [GUID; 1usize],
}
pub type FSCTL_QUERY_REGION_INFO_INPUT = _FSCTL_QUERY_REGION_INFO_INPUT;
pub type PFSCTL_QUERY_REGION_INFO_INPUT = *mut _FSCTL_QUERY_REGION_INFO_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_STORAGE_TIER_REGION {
    pub TierId: GUID,
    pub Offset: ULONGLONG,
    pub Length: ULONGLONG,
}
pub type FILE_STORAGE_TIER_REGION = _FILE_STORAGE_TIER_REGION;
pub type PFILE_STORAGE_TIER_REGION = *mut _FILE_STORAGE_TIER_REGION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_QUERY_REGION_INFO_OUTPUT {
    pub Version: ULONG,
    pub Size: ULONG,
    pub Flags: ULONG,
    pub Reserved: ULONG,
    pub Alignment: ULONGLONG,
    pub TotalNumberOfRegions: ULONG,
    pub NumberOfRegionsReturned: ULONG,
    pub Regions: [FILE_STORAGE_TIER_REGION; 1usize],
}
pub type FSCTL_QUERY_REGION_INFO_OUTPUT = _FSCTL_QUERY_REGION_INFO_OUTPUT;
pub type PFSCTL_QUERY_REGION_INFO_OUTPUT = *mut _FSCTL_QUERY_REGION_INFO_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_DESIRED_STORAGE_CLASS_INFORMATION {
    pub Class: FILE_STORAGE_TIER_CLASS,
    pub Flags: ULONG,
}
pub type FILE_DESIRED_STORAGE_CLASS_INFORMATION = _FILE_DESIRED_STORAGE_CLASS_INFORMATION;
pub type PFILE_DESIRED_STORAGE_CLASS_INFORMATION = *mut _FILE_DESIRED_STORAGE_CLASS_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DUPLICATE_EXTENTS_DATA {
    pub FileHandle: HANDLE,
    pub SourceFileOffset: LARGE_INTEGER,
    pub TargetFileOffset: LARGE_INTEGER,
    pub ByteCount: LARGE_INTEGER,
}
pub type DUPLICATE_EXTENTS_DATA = _DUPLICATE_EXTENTS_DATA;
pub type PDUPLICATE_EXTENTS_DATA = *mut _DUPLICATE_EXTENTS_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DUPLICATE_EXTENTS_DATA32 {
    pub FileHandle: UINT32,
    pub SourceFileOffset: LARGE_INTEGER,
    pub TargetFileOffset: LARGE_INTEGER,
    pub ByteCount: LARGE_INTEGER,
}
pub type DUPLICATE_EXTENTS_DATA32 = _DUPLICATE_EXTENTS_DATA32;
pub type PDUPLICATE_EXTENTS_DATA32 = *mut _DUPLICATE_EXTENTS_DATA32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DUPLICATE_EXTENTS_DATA_EX {
    pub Size: SIZE_T,
    pub FileHandle: HANDLE,
    pub SourceFileOffset: LARGE_INTEGER,
    pub TargetFileOffset: LARGE_INTEGER,
    pub ByteCount: LARGE_INTEGER,
    pub Flags: ULONG,
}
pub type DUPLICATE_EXTENTS_DATA_EX = _DUPLICATE_EXTENTS_DATA_EX;
pub type PDUPLICATE_EXTENTS_DATA_EX = *mut _DUPLICATE_EXTENTS_DATA_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DUPLICATE_EXTENTS_DATA_EX32 {
    pub Size: ULONG32,
    pub FileHandle: ULONG32,
    pub SourceFileOffset: LARGE_INTEGER,
    pub TargetFileOffset: LARGE_INTEGER,
    pub ByteCount: LARGE_INTEGER,
    pub Flags: ULONG,
}
pub type DUPLICATE_EXTENTS_DATA_EX32 = _DUPLICATE_EXTENTS_DATA_EX32;
pub type PDUPLICATE_EXTENTS_DATA_EX32 = *mut _DUPLICATE_EXTENTS_DATA_EX32;
pub const _DUPLICATE_EXTENTS_STATE_FileSnapStateInactive: _DUPLICATE_EXTENTS_STATE = 0;
pub const _DUPLICATE_EXTENTS_STATE_FileSnapStateSource: _DUPLICATE_EXTENTS_STATE = 1;
pub const _DUPLICATE_EXTENTS_STATE_FileSnapStateTarget: _DUPLICATE_EXTENTS_STATE = 2;
pub type _DUPLICATE_EXTENTS_STATE = core::ffi::c_int;
pub use self::_DUPLICATE_EXTENTS_STATE as DUPLICATE_EXTENTS_STATE;
pub type PDUPLICATE_EXTENTS_STATE = *mut _DUPLICATE_EXTENTS_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ASYNC_DUPLICATE_EXTENTS_STATUS {
    pub Version: ULONG,
    pub State: DUPLICATE_EXTENTS_STATE,
    pub SourceFileOffset: ULONGLONG,
    pub TargetFileOffset: ULONGLONG,
    pub ByteCount: ULONGLONG,
    pub BytesDuplicated: ULONGLONG,
}
pub type ASYNC_DUPLICATE_EXTENTS_STATUS = _ASYNC_DUPLICATE_EXTENTS_STATUS;
pub type PASYNC_DUPLICATE_EXTENTS_STATUS = *mut _ASYNC_DUPLICATE_EXTENTS_STATUS;
pub const _REFS_SMR_VOLUME_GC_STATE_SmrGcStateInactive: _REFS_SMR_VOLUME_GC_STATE = 0;
pub const _REFS_SMR_VOLUME_GC_STATE_SmrGcStatePaused: _REFS_SMR_VOLUME_GC_STATE = 1;
pub const _REFS_SMR_VOLUME_GC_STATE_SmrGcStateActive: _REFS_SMR_VOLUME_GC_STATE = 2;
pub const _REFS_SMR_VOLUME_GC_STATE_SmrGcStateActiveFullSpeed: _REFS_SMR_VOLUME_GC_STATE = 3;
pub type _REFS_SMR_VOLUME_GC_STATE = core::ffi::c_int;
pub use self::_REFS_SMR_VOLUME_GC_STATE as REFS_SMR_VOLUME_GC_STATE;
pub type PREFS_SMR_VOLUME_GC_STATE = *mut _REFS_SMR_VOLUME_GC_STATE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _REFS_SMR_VOLUME_INFO_OUTPUT {
    pub Version: ULONG,
    pub Flags: ULONG,
    pub SizeOfRandomlyWritableTier: LARGE_INTEGER,
    pub FreeSpaceInRandomlyWritableTier: LARGE_INTEGER,
    pub SizeofSMRTier: LARGE_INTEGER,
    pub FreeSpaceInSMRTier: LARGE_INTEGER,
    pub UsableFreeSpaceInSMRTier: LARGE_INTEGER,
    pub VolumeGcState: REFS_SMR_VOLUME_GC_STATE,
    pub VolumeGcLastStatus: NTSTATUS,
    pub CurrentGcBandFillPercentage: ULONG,
    pub Unused: [ULONGLONG; 6usize],
}
pub type REFS_SMR_VOLUME_INFO_OUTPUT = _REFS_SMR_VOLUME_INFO_OUTPUT;
pub type PREFS_SMR_VOLUME_INFO_OUTPUT = *mut _REFS_SMR_VOLUME_INFO_OUTPUT;
pub const _REFS_SMR_VOLUME_GC_ACTION_SmrGcActionStart: _REFS_SMR_VOLUME_GC_ACTION = 1;
pub const _REFS_SMR_VOLUME_GC_ACTION_SmrGcActionStartFullSpeed: _REFS_SMR_VOLUME_GC_ACTION = 2;
pub const _REFS_SMR_VOLUME_GC_ACTION_SmrGcActionPause: _REFS_SMR_VOLUME_GC_ACTION = 3;
pub const _REFS_SMR_VOLUME_GC_ACTION_SmrGcActionStop: _REFS_SMR_VOLUME_GC_ACTION = 4;
pub type _REFS_SMR_VOLUME_GC_ACTION = core::ffi::c_int;
pub use self::_REFS_SMR_VOLUME_GC_ACTION as REFS_SMR_VOLUME_GC_ACTION;
pub type PREFS_SMR_VOLUME_GC_ACTION = *mut _REFS_SMR_VOLUME_GC_ACTION;
pub const _REFS_SMR_VOLUME_GC_METHOD_SmrGcMethodCompaction: _REFS_SMR_VOLUME_GC_METHOD = 1;
pub const _REFS_SMR_VOLUME_GC_METHOD_SmrGcMethodCompression: _REFS_SMR_VOLUME_GC_METHOD = 2;
pub const _REFS_SMR_VOLUME_GC_METHOD_SmrGcMethodRotation: _REFS_SMR_VOLUME_GC_METHOD = 3;
pub type _REFS_SMR_VOLUME_GC_METHOD = core::ffi::c_int;
pub use self::_REFS_SMR_VOLUME_GC_METHOD as REFS_SMR_VOLUME_GC_METHOD;
pub type PREFS_SMR_VOLUME_GC_METHOD = *mut _REFS_SMR_VOLUME_GC_METHOD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REFS_SMR_VOLUME_GC_PARAMETERS {
    pub Version: ULONG,
    pub Flags: ULONG,
    pub Action: REFS_SMR_VOLUME_GC_ACTION,
    pub Method: REFS_SMR_VOLUME_GC_METHOD,
    pub IoGranularity: ULONG,
    pub CompressionFormat: ULONG,
    pub Unused: [ULONGLONG; 8usize],
}
pub type REFS_SMR_VOLUME_GC_PARAMETERS = _REFS_SMR_VOLUME_GC_PARAMETERS;
pub type PREFS_SMR_VOLUME_GC_PARAMETERS = *mut _REFS_SMR_VOLUME_GC_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER {
    pub OptimalWriteSize: ULONG,
    pub StreamGranularitySize: ULONG,
    pub StreamIdMin: ULONG,
    pub StreamIdMax: ULONG,
}
pub type STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER = _STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER;
pub type PSTREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER = *mut _STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STREAMS_ASSOCIATE_ID_INPUT_BUFFER {
    pub Flags: ULONG,
    pub StreamId: ULONG,
}
pub type STREAMS_ASSOCIATE_ID_INPUT_BUFFER = _STREAMS_ASSOCIATE_ID_INPUT_BUFFER;
pub type PSTREAMS_ASSOCIATE_ID_INPUT_BUFFER = *mut _STREAMS_ASSOCIATE_ID_INPUT_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STREAMS_QUERY_ID_OUTPUT_BUFFER {
    pub StreamId: ULONG,
}
pub type STREAMS_QUERY_ID_OUTPUT_BUFFER = _STREAMS_QUERY_ID_OUTPUT_BUFFER;
pub type PSTREAMS_QUERY_ID_OUTPUT_BUFFER = *mut _STREAMS_QUERY_ID_OUTPUT_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _QUERY_BAD_RANGES_INPUT_RANGE {
    pub StartOffset: ULONGLONG,
    pub LengthInBytes: ULONGLONG,
}
pub type QUERY_BAD_RANGES_INPUT_RANGE = _QUERY_BAD_RANGES_INPUT_RANGE;
pub type PQUERY_BAD_RANGES_INPUT_RANGE = *mut _QUERY_BAD_RANGES_INPUT_RANGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _QUERY_BAD_RANGES_INPUT {
    pub Flags: ULONG,
    pub NumRanges: ULONG,
    pub Ranges: [QUERY_BAD_RANGES_INPUT_RANGE; 1usize],
}
pub type QUERY_BAD_RANGES_INPUT = _QUERY_BAD_RANGES_INPUT;
pub type PQUERY_BAD_RANGES_INPUT = *mut _QUERY_BAD_RANGES_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _QUERY_BAD_RANGES_OUTPUT_RANGE {
    pub Flags: ULONG,
    pub Reserved: ULONG,
    pub StartOffset: ULONGLONG,
    pub LengthInBytes: ULONGLONG,
}
pub type QUERY_BAD_RANGES_OUTPUT_RANGE = _QUERY_BAD_RANGES_OUTPUT_RANGE;
pub type PQUERY_BAD_RANGES_OUTPUT_RANGE = *mut _QUERY_BAD_RANGES_OUTPUT_RANGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _QUERY_BAD_RANGES_OUTPUT {
    pub Flags: ULONG,
    pub NumBadRanges: ULONG,
    pub NextOffsetToLookUp: ULONGLONG,
    pub BadRanges: [QUERY_BAD_RANGES_OUTPUT_RANGE; 1usize],
}
pub type QUERY_BAD_RANGES_OUTPUT = _QUERY_BAD_RANGES_OUTPUT;
pub type PQUERY_BAD_RANGES_OUTPUT = *mut _QUERY_BAD_RANGES_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT {
    pub Flags: ULONG,
    pub AlignmentShift: ULONG,
    pub FileOffsetToAlign: ULONGLONG,
    pub FallbackAlignmentShift: ULONG,
}
pub type SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT = _SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT;
pub type PSET_DAX_ALLOC_ALIGNMENT_HINT_INPUT = *mut _SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT;
pub const _VIRTUAL_STORAGE_BEHAVIOR_CODE_VirtualStorageBehaviorUndefined:
_VIRTUAL_STORAGE_BEHAVIOR_CODE = 0;
pub const _VIRTUAL_STORAGE_BEHAVIOR_CODE_VirtualStorageBehaviorCacheWriteThrough:
_VIRTUAL_STORAGE_BEHAVIOR_CODE = 1;
pub const _VIRTUAL_STORAGE_BEHAVIOR_CODE_VirtualStorageBehaviorCacheWriteBack:
_VIRTUAL_STORAGE_BEHAVIOR_CODE = 2;
pub const _VIRTUAL_STORAGE_BEHAVIOR_CODE_VirtualStorageBehaviorStopIoProcessing:
_VIRTUAL_STORAGE_BEHAVIOR_CODE = 3;
pub const _VIRTUAL_STORAGE_BEHAVIOR_CODE_VirtualStorageBehaviorRestartIoProcessing:
_VIRTUAL_STORAGE_BEHAVIOR_CODE = 4;
pub type _VIRTUAL_STORAGE_BEHAVIOR_CODE = core::ffi::c_int;
pub use self::_VIRTUAL_STORAGE_BEHAVIOR_CODE as VIRTUAL_STORAGE_BEHAVIOR_CODE;
pub type PVIRTUAL_STORAGE_BEHAVIOR_CODE = *mut _VIRTUAL_STORAGE_BEHAVIOR_CODE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT {
    pub Size: ULONG,
    pub BehaviorCode: VIRTUAL_STORAGE_BEHAVIOR_CODE,
}
pub type VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT = _VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT;
pub type PVIRTUAL_STORAGE_SET_BEHAVIOR_INPUT = *mut _VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCRYPTION_KEY_CTRL_INPUT {
    pub HeaderSize: ULONG,
    pub StructureSize: ULONG,
    pub KeyOffset: USHORT,
    pub KeySize: USHORT,
    pub DplLock: ULONG,
    pub DplUserId: ULONGLONG,
    pub DplCredentialId: ULONGLONG,
}
pub type ENCRYPTION_KEY_CTRL_INPUT = _ENCRYPTION_KEY_CTRL_INPUT;
pub type PENCRYPTION_KEY_CTRL_INPUT = *mut _ENCRYPTION_KEY_CTRL_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WOF_EXTERNAL_INFO {
    pub Version: ULONG,
    pub Provider: ULONG,
}
pub type WOF_EXTERNAL_INFO = _WOF_EXTERNAL_INFO;
pub type PWOF_EXTERNAL_INFO = *mut _WOF_EXTERNAL_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WOF_EXTERNAL_FILE_ID {
    pub FileId: FILE_ID_128,
}
pub type WOF_EXTERNAL_FILE_ID = _WOF_EXTERNAL_FILE_ID;
pub type PWOF_EXTERNAL_FILE_ID = *mut _WOF_EXTERNAL_FILE_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WOF_VERSION_INFO {
    pub WofVersion: ULONG,
}
pub type WOF_VERSION_INFO = _WOF_VERSION_INFO;
pub type PWOF_VERSION_INFO = *mut _WOF_VERSION_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WIM_PROVIDER_EXTERNAL_INFO {
    pub Version: ULONG,
    pub Flags: ULONG,
    pub DataSourceId: LARGE_INTEGER,
    pub ResourceHash: [UCHAR; 20usize],
}
pub type WIM_PROVIDER_EXTERNAL_INFO = _WIM_PROVIDER_EXTERNAL_INFO;
pub type PWIM_PROVIDER_EXTERNAL_INFO = *mut _WIM_PROVIDER_EXTERNAL_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WIM_PROVIDER_ADD_OVERLAY_INPUT {
    pub WimType: ULONG,
    pub WimIndex: ULONG,
    pub WimFileNameOffset: ULONG,
    pub WimFileNameLength: ULONG,
}
pub type WIM_PROVIDER_ADD_OVERLAY_INPUT = _WIM_PROVIDER_ADD_OVERLAY_INPUT;
pub type PWIM_PROVIDER_ADD_OVERLAY_INPUT = *mut _WIM_PROVIDER_ADD_OVERLAY_INPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WIM_PROVIDER_UPDATE_OVERLAY_INPUT {
    pub DataSourceId: LARGE_INTEGER,
    pub WimFileNameOffset: ULONG,
    pub WimFileNameLength: ULONG,
}
pub type WIM_PROVIDER_UPDATE_OVERLAY_INPUT = _WIM_PROVIDER_UPDATE_OVERLAY_INPUT;
pub type PWIM_PROVIDER_UPDATE_OVERLAY_INPUT = *mut _WIM_PROVIDER_UPDATE_OVERLAY_INPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WIM_PROVIDER_REMOVE_OVERLAY_INPUT {
    pub DataSourceId: LARGE_INTEGER,
}
pub type WIM_PROVIDER_REMOVE_OVERLAY_INPUT = _WIM_PROVIDER_REMOVE_OVERLAY_INPUT;
pub type PWIM_PROVIDER_REMOVE_OVERLAY_INPUT = *mut _WIM_PROVIDER_REMOVE_OVERLAY_INPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WIM_PROVIDER_SUSPEND_OVERLAY_INPUT {
    pub DataSourceId: LARGE_INTEGER,
}
pub type WIM_PROVIDER_SUSPEND_OVERLAY_INPUT = _WIM_PROVIDER_SUSPEND_OVERLAY_INPUT;
pub type PWIM_PROVIDER_SUSPEND_OVERLAY_INPUT = *mut _WIM_PROVIDER_SUSPEND_OVERLAY_INPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WIM_PROVIDER_OVERLAY_ENTRY {
    pub NextEntryOffset: ULONG,
    pub DataSourceId: LARGE_INTEGER,
    pub WimGuid: GUID,
    pub WimFileNameOffset: ULONG,
    pub WimType: ULONG,
    pub WimIndex: ULONG,
    pub Flags: ULONG,
}
pub type WIM_PROVIDER_OVERLAY_ENTRY = _WIM_PROVIDER_OVERLAY_ENTRY;
pub type PWIM_PROVIDER_OVERLAY_ENTRY = *mut _WIM_PROVIDER_OVERLAY_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PROVIDER_EXTERNAL_INFO_V0 {
    pub Version: ULONG,
    pub Algorithm: ULONG,
}
pub type FILE_PROVIDER_EXTERNAL_INFO_V0 = _FILE_PROVIDER_EXTERNAL_INFO_V0;
pub type PFILE_PROVIDER_EXTERNAL_INFO_V0 = *mut _FILE_PROVIDER_EXTERNAL_INFO_V0;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PROVIDER_EXTERNAL_INFO_V1 {
    pub Version: ULONG,
    pub Algorithm: ULONG,
    pub Flags: ULONG,
}
pub type FILE_PROVIDER_EXTERNAL_INFO_V1 = _FILE_PROVIDER_EXTERNAL_INFO_V1;
pub type PFILE_PROVIDER_EXTERNAL_INFO_V1 = *mut _FILE_PROVIDER_EXTERNAL_INFO_V1;
pub type FILE_PROVIDER_EXTERNAL_INFO = FILE_PROVIDER_EXTERNAL_INFO_V1;
pub type PFILE_PROVIDER_EXTERNAL_INFO = PFILE_PROVIDER_EXTERNAL_INFO_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CONTAINER_VOLUME_STATE {
    pub Flags: ULONG,
}
pub type CONTAINER_VOLUME_STATE = _CONTAINER_VOLUME_STATE;
pub type PCONTAINER_VOLUME_STATE = *mut _CONTAINER_VOLUME_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CONTAINER_ROOT_INFO_INPUT {
    pub Flags: ULONG,
}
pub type CONTAINER_ROOT_INFO_INPUT = _CONTAINER_ROOT_INFO_INPUT;
pub type PCONTAINER_ROOT_INFO_INPUT = *mut _CONTAINER_ROOT_INFO_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CONTAINER_ROOT_INFO_OUTPUT {
    pub ContainerRootIdLength: USHORT,
    pub ContainerRootId: [UCHAR; 1usize],
}
pub type CONTAINER_ROOT_INFO_OUTPUT = _CONTAINER_ROOT_INFO_OUTPUT;
pub type PCONTAINER_ROOT_INFO_OUTPUT = *mut _CONTAINER_ROOT_INFO_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VIRTUALIZATION_INSTANCE_INFO_INPUT {
    pub NumberOfWorkerThreads: ULONG,
    pub Flags: ULONG,
}
pub type VIRTUALIZATION_INSTANCE_INFO_INPUT = _VIRTUALIZATION_INSTANCE_INFO_INPUT;
pub type PVIRTUALIZATION_INSTANCE_INFO_INPUT = *mut _VIRTUALIZATION_INSTANCE_INFO_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VIRTUALIZATION_INSTANCE_INFO_INPUT_EX {
    pub HeaderSize: USHORT,
    pub Flags: ULONG,
    pub NotificationInfoSize: ULONG,
    pub NotificationInfoOffset: USHORT,
    pub ProviderMajorVersion: USHORT,
}
pub type VIRTUALIZATION_INSTANCE_INFO_INPUT_EX = _VIRTUALIZATION_INSTANCE_INFO_INPUT_EX;
pub type PVIRTUALIZATION_INSTANCE_INFO_INPUT_EX = *mut _VIRTUALIZATION_INSTANCE_INFO_INPUT_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VIRTUALIZATION_INSTANCE_INFO_OUTPUT {
    pub VirtualizationInstanceID: GUID,
}
pub type VIRTUALIZATION_INSTANCE_INFO_OUTPUT = _VIRTUALIZATION_INSTANCE_INFO_OUTPUT;
pub type PVIRTUALIZATION_INSTANCE_INFO_OUTPUT = *mut _VIRTUALIZATION_INSTANCE_INFO_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GET_FILTER_FILE_IDENTIFIER_INPUT {
    pub AltitudeLength: USHORT,
    pub Altitude: [WCHAR; 1usize],
}
pub type GET_FILTER_FILE_IDENTIFIER_INPUT = _GET_FILTER_FILE_IDENTIFIER_INPUT;
pub type PGET_FILTER_FILE_IDENTIFIER_INPUT = *mut _GET_FILTER_FILE_IDENTIFIER_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GET_FILTER_FILE_IDENTIFIER_OUTPUT {
    pub FilterFileIdentifierLength: USHORT,
    pub FilterFileIdentifier: [UCHAR; 1usize],
}
pub type GET_FILTER_FILE_IDENTIFIER_OUTPUT = _GET_FILTER_FILE_IDENTIFIER_OUTPUT;
pub type PGET_FILTER_FILE_IDENTIFIER_OUTPUT = *mut _GET_FILTER_FILE_IDENTIFIER_OUTPUT;
pub const _FS_BPIO_OPERATIONS_FS_BPIO_OP_ENABLE: _FS_BPIO_OPERATIONS = 1;
pub const _FS_BPIO_OPERATIONS_FS_BPIO_OP_DISABLE: _FS_BPIO_OPERATIONS = 2;
pub const _FS_BPIO_OPERATIONS_FS_BPIO_OP_QUERY: _FS_BPIO_OPERATIONS = 3;
pub const _FS_BPIO_OPERATIONS_FS_BPIO_OP_VOLUME_STACK_PAUSE: _FS_BPIO_OPERATIONS = 4;
pub const _FS_BPIO_OPERATIONS_FS_BPIO_OP_VOLUME_STACK_RESUME: _FS_BPIO_OPERATIONS = 5;
pub const _FS_BPIO_OPERATIONS_FS_BPIO_OP_STREAM_PAUSE: _FS_BPIO_OPERATIONS = 6;
pub const _FS_BPIO_OPERATIONS_FS_BPIO_OP_STREAM_RESUME: _FS_BPIO_OPERATIONS = 7;
pub const _FS_BPIO_OPERATIONS_FS_BPIO_OP_GET_INFO: _FS_BPIO_OPERATIONS = 8;
pub const _FS_BPIO_OPERATIONS_FS_BPIO_OP_MAX_OPERATION: _FS_BPIO_OPERATIONS = 9;
pub type _FS_BPIO_OPERATIONS = core::ffi::c_int;
pub use self::_FS_BPIO_OPERATIONS as FS_BPIO_OPERATIONS;
pub const _FS_BPIO_INFLAGS_FSBPIO_INFL_None: _FS_BPIO_INFLAGS = 0;
pub const _FS_BPIO_INFLAGS_FSBPIO_INFL_SKIP_STORAGE_STACK_QUERY: _FS_BPIO_INFLAGS = 1;
pub type _FS_BPIO_INFLAGS = core::ffi::c_int;
pub use self::_FS_BPIO_INFLAGS as FS_BPIO_INFLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_BPIO_INPUT {
    pub Operation: FS_BPIO_OPERATIONS,
    pub InFlags: FS_BPIO_INFLAGS,
    pub Reserved1: ULONGLONG,
    pub Reserved2: ULONGLONG,
}
pub type FS_BPIO_INPUT = _FS_BPIO_INPUT;
pub type PFS_BPIO_INPUT = *mut _FS_BPIO_INPUT;
pub const _FS_BPIO_OUTFLAGS_FSBPIO_OUTFL_None: _FS_BPIO_OUTFLAGS = 0;
pub const _FS_BPIO_OUTFLAGS_FSBPIO_OUTFL_VOLUME_STACK_BYPASS_PAUSED: _FS_BPIO_OUTFLAGS = 1;
pub const _FS_BPIO_OUTFLAGS_FSBPIO_OUTFL_STREAM_BYPASS_PAUSED: _FS_BPIO_OUTFLAGS = 2;
pub const _FS_BPIO_OUTFLAGS_FSBPIO_OUTFL_FILTER_ATTACH_BLOCKED: _FS_BPIO_OUTFLAGS = 4;
pub const _FS_BPIO_OUTFLAGS_FSBPIO_OUTFL_COMPATIBLE_STORAGE_DRIVER: _FS_BPIO_OUTFLAGS = 8;
pub type _FS_BPIO_OUTFLAGS = core::ffi::c_int;
pub use self::_FS_BPIO_OUTFLAGS as FS_BPIO_OUTFLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_BPIO_RESULTS {
    pub OpStatus: NTSTATUS,
    pub FailingDriverNameLen: USHORT,
    pub FailingDriverName: [WCHAR; 32usize],
    pub FailureReasonLen: USHORT,
    pub FailureReason: [WCHAR; 128usize],
}
pub type FS_BPIO_RESULTS = _FS_BPIO_RESULTS;
pub type PFS_BPIO_RESULTS = *mut _FS_BPIO_RESULTS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_BPIO_INFO {
    pub ActiveBypassIoCount: ULONG,
    pub StorageDriverNameLen: USHORT,
    pub StorageDriverName: [WCHAR; 32usize],
}
pub type FS_BPIO_INFO = _FS_BPIO_INFO;
pub type PFS_BPIO_INFO = *mut _FS_BPIO_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FS_BPIO_OUTPUT {
    pub Operation: FS_BPIO_OPERATIONS,
    pub OutFlags: FS_BPIO_OUTFLAGS,
    pub Reserved1: ULONGLONG,
    pub Reserved2: ULONGLONG,
    pub __bindgen_anon_1: _FS_BPIO_OUTPUT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FS_BPIO_OUTPUT__bindgen_ty_1 {
    pub Enable: FS_BPIO_RESULTS,
    pub Query: FS_BPIO_RESULTS,
    pub VolumeStackResume: FS_BPIO_RESULTS,
    pub StreamResume: FS_BPIO_RESULTS,
    pub GetInfo: FS_BPIO_INFO,
}
pub type FS_BPIO_OUTPUT = _FS_BPIO_OUTPUT;
pub type PFS_BPIO_OUTPUT = *mut _FS_BPIO_OUTPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _REPARSE_DATA_BUFFER {
    pub ReparseTag: ULONG,
    pub ReparseDataLength: USHORT,
    pub Reserved: USHORT,
    pub __bindgen_anon_1: _REPARSE_DATA_BUFFER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _REPARSE_DATA_BUFFER__bindgen_ty_1 {
    pub SymbolicLinkReparseBuffer: _REPARSE_DATA_BUFFER__bindgen_ty_1__bindgen_ty_1,
    pub MountPointReparseBuffer: _REPARSE_DATA_BUFFER__bindgen_ty_1__bindgen_ty_2,
    pub GenericReparseBuffer: _REPARSE_DATA_BUFFER__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REPARSE_DATA_BUFFER__bindgen_ty_1__bindgen_ty_1 {
    pub SubstituteNameOffset: USHORT,
    pub SubstituteNameLength: USHORT,
    pub PrintNameOffset: USHORT,
    pub PrintNameLength: USHORT,
    pub Flags: ULONG,
    pub PathBuffer: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REPARSE_DATA_BUFFER__bindgen_ty_1__bindgen_ty_2 {
    pub SubstituteNameOffset: USHORT,
    pub SubstituteNameLength: USHORT,
    pub PrintNameOffset: USHORT,
    pub PrintNameLength: USHORT,
    pub PathBuffer: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REPARSE_DATA_BUFFER__bindgen_ty_1__bindgen_ty_3 {
    pub DataBuffer: [UCHAR; 1usize],
}
pub type REPARSE_DATA_BUFFER = _REPARSE_DATA_BUFFER;
pub type PREPARSE_DATA_BUFFER = *mut _REPARSE_DATA_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REPARSE_GUID_DATA_BUFFER {
    pub ReparseTag: ULONG,
    pub ReparseDataLength: USHORT,
    pub Reserved: USHORT,
    pub ReparseGuid: GUID,
    pub GenericReparseBuffer: _REPARSE_GUID_DATA_BUFFER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REPARSE_GUID_DATA_BUFFER__bindgen_ty_1 {
    pub DataBuffer: [UCHAR; 1usize],
}
pub type REPARSE_GUID_DATA_BUFFER = _REPARSE_GUID_DATA_BUFFER;
pub type PREPARSE_GUID_DATA_BUFFER = *mut _REPARSE_GUID_DATA_BUFFER;
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _REPARSE_INDEX_KEY {
    pub FileReparseTag: ULONG,
    pub FileId: LARGE_INTEGER,
}
pub type REPARSE_INDEX_KEY = _REPARSE_INDEX_KEY;
pub type PREPARSE_INDEX_KEY = *mut _REPARSE_INDEX_KEY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _REPARSE_DATA_BUFFER_EX {
    pub Flags: ULONG,
    pub ExistingReparseTag: ULONG,
    pub ExistingReparseGuid: GUID,
    pub Reserved: ULONGLONG,
    pub __bindgen_anon_1: _REPARSE_DATA_BUFFER_EX__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _REPARSE_DATA_BUFFER_EX__bindgen_ty_1 {
    pub ReparseDataBuffer: REPARSE_DATA_BUFFER,
    pub ReparseGuidDataBuffer: REPARSE_GUID_DATA_BUFFER,
}
pub type REPARSE_DATA_BUFFER_EX = _REPARSE_DATA_BUFFER_EX;
pub type PREPARSE_DATA_BUFFER_EX = *mut _REPARSE_DATA_BUFFER_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCRUB_DATA_INPUT {
    pub Size: ULONG,
    pub Flags: ULONG,
    pub MaximumIos: ULONG,
    pub ObjectId: [ULONG; 4usize],
    pub Reserved: [ULONG; 41usize],
    pub ResumeContext: [UCHAR; 1040usize],
}
pub type SCRUB_DATA_INPUT = _SCRUB_DATA_INPUT;
pub type PSCRUB_DATA_INPUT = *mut _SCRUB_DATA_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCRUB_PARITY_EXTENT {
    pub Offset: LONGLONG,
    pub Length: ULONGLONG,
}
pub type SCRUB_PARITY_EXTENT = _SCRUB_PARITY_EXTENT;
pub type PSCRUB_PARITY_EXTENT = *mut _SCRUB_PARITY_EXTENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCRUB_PARITY_EXTENT_DATA {
    pub Size: USHORT,
    pub Flags: USHORT,
    pub NumberOfParityExtents: USHORT,
    pub MaximumNumberOfParityExtents: USHORT,
    pub ParityExtents: [SCRUB_PARITY_EXTENT; 1usize],
}
pub type SCRUB_PARITY_EXTENT_DATA = _SCRUB_PARITY_EXTENT_DATA;
pub type PSCRUB_PARITY_EXTENT_DATA = *mut _SCRUB_PARITY_EXTENT_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCRUB_DATA_OUTPUT {
    pub Size: ULONG,
    pub Flags: ULONG,
    pub Status: ULONG,
    pub ErrorFileOffset: ULONGLONG,
    pub ErrorLength: ULONGLONG,
    pub NumberOfBytesRepaired: ULONGLONG,
    pub NumberOfBytesFailed: ULONGLONG,
    pub InternalFileReference: ULONGLONG,
    pub ResumeContextLength: USHORT,
    pub ParityExtentDataOffset: USHORT,
    pub Reserved: [ULONG; 9usize],
    pub NumberOfMetadataBytesProcessed: ULONGLONG,
    pub NumberOfDataBytesProcessed: ULONGLONG,
    pub TotalNumberOfMetadataBytesInUse: ULONGLONG,
    pub TotalNumberOfDataBytesInUse: ULONGLONG,
    pub DataBytesSkippedDueToNoAllocation: ULONGLONG,
    pub DataBytesSkippedDueToInvalidRun: ULONGLONG,
    pub DataBytesSkippedDueToIntegrityStream: ULONGLONG,
    pub DataBytesSkippedDueToRegionBeingClean: ULONGLONG,
    pub DataBytesSkippedDueToLockConflict: ULONGLONG,
    pub DataBytesSkippedDueToNoScrubDataFlag: ULONGLONG,
    pub DataBytesSkippedDueToNoScrubNonIntegrityStreamFlag: ULONGLONG,
    pub DataBytesScrubbed: ULONGLONG,
    pub ResumeContext: [UCHAR; 1040usize],
}
pub type SCRUB_DATA_OUTPUT = _SCRUB_DATA_OUTPUT;
pub type PSCRUB_DATA_OUTPUT = *mut _SCRUB_DATA_OUTPUT;
pub const _SharedVirtualDiskSupportType_SharedVirtualDisksUnsupported:
_SharedVirtualDiskSupportType = 0;
pub const _SharedVirtualDiskSupportType_SharedVirtualDisksSupported: _SharedVirtualDiskSupportType =
    1;
pub const _SharedVirtualDiskSupportType_SharedVirtualDiskSnapshotsSupported:
_SharedVirtualDiskSupportType = 3;
pub const _SharedVirtualDiskSupportType_SharedVirtualDiskCDPSnapshotsSupported:
_SharedVirtualDiskSupportType = 7;
pub type _SharedVirtualDiskSupportType = core::ffi::c_int;
pub use self::_SharedVirtualDiskSupportType as SharedVirtualDiskSupportType;
pub const _SharedVirtualDiskHandleState_SharedVirtualDiskHandleStateNone:
_SharedVirtualDiskHandleState = 0;
pub const _SharedVirtualDiskHandleState_SharedVirtualDiskHandleStateFileShared:
_SharedVirtualDiskHandleState = 1;
pub const _SharedVirtualDiskHandleState_SharedVirtualDiskHandleStateHandleShared:
_SharedVirtualDiskHandleState = 3;
pub type _SharedVirtualDiskHandleState = core::ffi::c_int;
pub use self::_SharedVirtualDiskHandleState as SharedVirtualDiskHandleState;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHARED_VIRTUAL_DISK_SUPPORT {
    pub SharedVirtualDiskSupport: SharedVirtualDiskSupportType,
    pub HandleState: SharedVirtualDiskHandleState,
}
pub type SHARED_VIRTUAL_DISK_SUPPORT = _SHARED_VIRTUAL_DISK_SUPPORT;
pub type PSHARED_VIRTUAL_DISK_SUPPORT = *mut _SHARED_VIRTUAL_DISK_SUPPORT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REARRANGE_FILE_DATA {
    pub SourceStartingOffset: ULONGLONG,
    pub TargetOffset: ULONGLONG,
    pub SourceFileHandle: HANDLE,
    pub Length: ULONG,
    pub Flags: ULONG,
}
pub type REARRANGE_FILE_DATA = _REARRANGE_FILE_DATA;
pub type PREARRANGE_FILE_DATA = *mut _REARRANGE_FILE_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REARRANGE_FILE_DATA32 {
    pub SourceStartingOffset: ULONGLONG,
    pub TargetOffset: ULONGLONG,
    pub SourceFileHandle: UINT32,
    pub Length: ULONG,
    pub Flags: ULONG,
}
pub type REARRANGE_FILE_DATA32 = _REARRANGE_FILE_DATA32;
pub type PREARRANGE_FILE_DATA32 = *mut _REARRANGE_FILE_DATA32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHUFFLE_FILE_DATA {
    pub StartingOffset: LONGLONG,
    pub Length: LONGLONG,
    pub Flags: ULONG,
}
pub type SHUFFLE_FILE_DATA = _SHUFFLE_FILE_DATA;
pub type PSHUFFLE_FILE_DATA = *mut _SHUFFLE_FILE_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PIPE_ASSIGN_EVENT_BUFFER {
    pub EventHandle: HANDLE,
    pub KeyValue: ULONG,
}
pub type FILE_PIPE_ASSIGN_EVENT_BUFFER = _FILE_PIPE_ASSIGN_EVENT_BUFFER;
pub type PFILE_PIPE_ASSIGN_EVENT_BUFFER = *mut _FILE_PIPE_ASSIGN_EVENT_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PIPE_PEEK_BUFFER {
    pub NamedPipeState: ULONG,
    pub ReadDataAvailable: ULONG,
    pub NumberOfMessages: ULONG,
    pub MessageLength: ULONG,
    pub Data: [CHAR; 1usize],
}
pub type FILE_PIPE_PEEK_BUFFER = _FILE_PIPE_PEEK_BUFFER;
pub type PFILE_PIPE_PEEK_BUFFER = *mut _FILE_PIPE_PEEK_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PIPE_EVENT_BUFFER {
    pub NamedPipeState: ULONG,
    pub EntryType: ULONG,
    pub ByteCount: ULONG,
    pub KeyValue: ULONG,
    pub NumberRequests: ULONG,
}
pub type FILE_PIPE_EVENT_BUFFER = _FILE_PIPE_EVENT_BUFFER;
pub type PFILE_PIPE_EVENT_BUFFER = *mut _FILE_PIPE_EVENT_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_PIPE_WAIT_FOR_BUFFER {
    pub Timeout: LARGE_INTEGER,
    pub NameLength: ULONG,
    pub TimeoutSpecified: BOOLEAN,
    pub Name: [WCHAR; 1usize],
}
pub type FILE_PIPE_WAIT_FOR_BUFFER = _FILE_PIPE_WAIT_FOR_BUFFER;
pub type PFILE_PIPE_WAIT_FOR_BUFFER = *mut _FILE_PIPE_WAIT_FOR_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PIPE_CLIENT_PROCESS_BUFFER {
    pub ClientSession: PVOID,
    pub ClientProcess: PVOID,
}
pub type FILE_PIPE_CLIENT_PROCESS_BUFFER = _FILE_PIPE_CLIENT_PROCESS_BUFFER;
pub type PFILE_PIPE_CLIENT_PROCESS_BUFFER = *mut _FILE_PIPE_CLIENT_PROCESS_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PIPE_CLIENT_PROCESS_BUFFER_V2 {
    pub ClientSession: ULONGLONG,
    pub ClientProcess: PVOID,
}
pub type FILE_PIPE_CLIENT_PROCESS_BUFFER_V2 = _FILE_PIPE_CLIENT_PROCESS_BUFFER_V2;
pub type PFILE_PIPE_CLIENT_PROCESS_BUFFER_V2 = *mut _FILE_PIPE_CLIENT_PROCESS_BUFFER_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PIPE_CLIENT_PROCESS_BUFFER_EX {
    pub ClientSession: PVOID,
    pub ClientProcess: PVOID,
    pub ClientComputerNameLength: USHORT,
    pub ClientComputerBuffer: [WCHAR; 16usize],
}
pub type FILE_PIPE_CLIENT_PROCESS_BUFFER_EX = _FILE_PIPE_CLIENT_PROCESS_BUFFER_EX;
pub type PFILE_PIPE_CLIENT_PROCESS_BUFFER_EX = *mut _FILE_PIPE_CLIENT_PROCESS_BUFFER_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PIPE_SILO_ARRIVAL_INPUT {
    pub JobHandle: HANDLE,
}
pub type FILE_PIPE_SILO_ARRIVAL_INPUT = _FILE_PIPE_SILO_ARRIVAL_INPUT;
pub type PFILE_PIPE_SILO_ARRIVAL_INPUT = *mut _FILE_PIPE_SILO_ARRIVAL_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PIPE_CREATE_SYMLINK_INPUT {
    pub NameOffset: USHORT,
    pub NameLength: USHORT,
    pub SubstituteNameOffset: USHORT,
    pub SubstituteNameLength: USHORT,
    pub Flags: ULONG,
}
pub type FILE_PIPE_CREATE_SYMLINK_INPUT = _FILE_PIPE_CREATE_SYMLINK_INPUT;
pub type PFILE_PIPE_CREATE_SYMLINK_INPUT = *mut _FILE_PIPE_CREATE_SYMLINK_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PIPE_DELETE_SYMLINK_INPUT {
    pub NameOffset: USHORT,
    pub NameLength: USHORT,
}
pub type FILE_PIPE_DELETE_SYMLINK_INPUT = _FILE_PIPE_DELETE_SYMLINK_INPUT;
pub type PFILE_PIPE_DELETE_SYMLINK_INPUT = *mut _FILE_PIPE_DELETE_SYMLINK_INPUT;
pub const _LINK_TRACKING_INFORMATION_TYPE_NtfsLinkTrackingInformation:
_LINK_TRACKING_INFORMATION_TYPE = 0;
pub const _LINK_TRACKING_INFORMATION_TYPE_DfsLinkTrackingInformation:
_LINK_TRACKING_INFORMATION_TYPE = 1;
pub type _LINK_TRACKING_INFORMATION_TYPE = core::ffi::c_int;
pub use self::_LINK_TRACKING_INFORMATION_TYPE as LINK_TRACKING_INFORMATION_TYPE;
pub type PLINK_TRACKING_INFORMATION_TYPE = *mut _LINK_TRACKING_INFORMATION_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LINK_TRACKING_INFORMATION {
    pub Type: LINK_TRACKING_INFORMATION_TYPE,
    pub VolumeId: [UCHAR; 16usize],
}
pub type LINK_TRACKING_INFORMATION = _LINK_TRACKING_INFORMATION;
pub type PLINK_TRACKING_INFORMATION = *mut _LINK_TRACKING_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REMOTE_LINK_TRACKING_INFORMATION_ {
    pub TargetFileObject: PVOID,
    pub TargetLinkTrackingInformationLength: ULONG,
    pub TargetLinkTrackingInformationBuffer: [UCHAR; 1usize],
}
pub type REMOTE_LINK_TRACKING_INFORMATION = _REMOTE_LINK_TRACKING_INFORMATION_;
pub type PREMOTE_LINK_TRACKING_INFORMATION = *mut _REMOTE_LINK_TRACKING_INFORMATION_;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VCN_RANGE_INPUT_BUFFER {
    pub StartingVcn: LARGE_INTEGER,
    pub ClusterCount: LARGE_INTEGER,
}
pub type VCN_RANGE_INPUT_BUFFER = _VCN_RANGE_INPUT_BUFFER;
pub type PVCN_RANGE_INPUT_BUFFER = *mut _VCN_RANGE_INPUT_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EXTENT_READ_CACHE_INFO_BUFFER {
    pub AllocatedCache: LARGE_INTEGER,
    pub PopulatedCache: LARGE_INTEGER,
    pub InErrorCache: LARGE_INTEGER,
}
pub type EXTENT_READ_CACHE_INFO_BUFFER = _EXTENT_READ_CACHE_INFO_BUFFER;
pub type PEXTENT_READ_CACHE_INFO_BUFFER = *mut _EXTENT_READ_CACHE_INFO_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REFS_VOLUME_COUNTER_INFO_INPUT_BUFFER {
    pub ResetCounters: BOOLEAN,
}
pub type REFS_VOLUME_COUNTER_INFO_INPUT_BUFFER = _REFS_VOLUME_COUNTER_INFO_INPUT_BUFFER;
pub type PREFS_VOLUME_COUNTER_INFO_INPUT_BUFFER = *mut _REFS_VOLUME_COUNTER_INFO_INPUT_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VOLUME_REFS_INFO_BUFFER {
    pub CacheSizeInBytes: LARGE_INTEGER,
    pub AllocatedCacheInBytes: LARGE_INTEGER,
    pub PopulatedCacheInBytes: LARGE_INTEGER,
    pub InErrorCacheInBytes: LARGE_INTEGER,
    pub MemoryUsedForCacheMetadata: LARGE_INTEGER,
    pub CacheLineSize: ULONG,
    pub CacheTransactionsOutstanding: LONG,
    pub CacheLinesFree: LONG,
    pub CacheLinesInError: LONG,
    pub CacheHitsInBytes: LARGE_INTEGER,
    pub CacheMissesInBytes: LARGE_INTEGER,
    pub CachePopulationUpdatesInBytes: LARGE_INTEGER,
    pub CacheWriteThroughUpdatesInBytes: LARGE_INTEGER,
    pub CacheInvalidationsInBytes: LARGE_INTEGER,
    pub CacheOverReadsInBytes: LARGE_INTEGER,
    pub MetadataWrittenBytes: LARGE_INTEGER,
    pub CacheHitCounter: LONG,
    pub CacheMissCounter: LONG,
    pub CacheLineAllocationCounter: LONG,
    pub CacheInvalidationsCounter: LONG,
    pub CachePopulationUpdatesCounter: LONG,
    pub CacheWriteThroughUpdatesCounter: LONG,
    pub MaxCacheTransactionsOutstanding: LONG,
    pub DataWritesReallocationCount: LONGLONG,
    pub DataInPlaceWriteCount: LONGLONG,
    pub MetadataAllocationsFastTierCount: LONGLONG,
    pub MetadataAllocationsSlowTierCount: LONGLONG,
    pub DataAllocationsFastTierCount: LONGLONG,
    pub DataAllocationsSlowTierCount: LONGLONG,
    pub DestagesSlowTierToFastTier: LONGLONG,
    pub DestagesFastTierToSlowTier: LONGLONG,
    pub SlowTierDataFillRatio: LONG,
    pub FastTierDataFillRatio: LONG,
    pub SlowTierMetadataFillRatio: LONG,
    pub FastTierMetadataFillRatio: LONG,
    pub SlowToFastDestageReadLatency: LONGLONG,
    pub SlowToFastDestageReadLatencyBase: LONG,
    pub SlowToFastDestageWriteLatency: LONGLONG,
    pub SlowToFastDestageWriteLatencyBase: LONG,
    pub FastToSlowDestageReadLatency: LONGLONG,
    pub FastToSlowDestageReadLatencyBase: LONG,
    pub FastToSlowDestageWriteLatency: LONGLONG,
    pub FastToSlowDestageWriteLatencyBase: LONG,
    pub SlowTierContainerFillRatio: LONGLONG,
    pub SlowTierContainerFillRatioBase: LONG,
    pub FastTierContainerFillRatio: LONGLONG,
    pub FastTierContainerFillRatioBase: LONG,
    pub Unused1: LONG,
    pub Unused2: LONG,
    pub Unused3: LONG,
    pub Unused4: LONG,
    pub TreeUpdateCount: LONGLONG,
    pub CheckpointCount: LONGLONG,
    pub LogWriteCount: LONGLONG,
    pub LogFillRatio: LONG,
    pub ReadCacheInvalidationsForOverwrite: LONG,
    pub ReadCacheInvalidationsForReuse: LONG,
    pub ReadCacheInvalidationsGeneral: LONG,
    pub ReadCacheChecksOnMount: LONG,
    pub ReadCacheIssuesOnMount: LONG,
    pub TrimLatency: LONGLONG,
    pub TrimLatencyBase: LONG,
    pub DataCompactionCount: LONGLONG,
    pub CompactionReadLatency: LONGLONG,
    pub CompactionReadLatencyBase: LONG,
    pub CompactionWriteLatency: LONGLONG,
    pub CompactionWriteLatencyBase: LONG,
    pub DataInPlaceWriteClusterCount: LARGE_INTEGER,
    pub CompactionFailedDueToIneligibleContainer: LONG,
    pub CompactionFailedDueToMaxFragmentation: LONG,
    pub CompactedContainerFillRatio: LONGLONG,
    pub CompactedContainerFillRatioBase: LONG,
    pub ContainerMoveRetryCount: LONG,
    pub ContainerMoveFailedDueToIneligibleContainer: LONG,
    pub CompactionFailureCount: LONG,
    pub ContainerMoveFailureCount: LONG,
    pub NumberOfDirtyMetadataPages: LARGE_INTEGER,
    pub NumberOfDirtyTableListEntries: LONG,
    pub NumberOfDeleteQueueEntries: LONG,
    pub MAAFilteredViewSize: LONG,
    pub MAAFilteredViewInsertions: LONG,
    pub MAAFilteredViewDeletions: LONG,
    pub MAAFilteredViewCollisions: LONG,
    pub MAAFilteredViewPurges: LONG,
    pub MAARegionsVisitedPerAllocationSum: LONGLONG,
    pub MAARegionsVisitedPerAllocationBase: LONG,
    pub MAAMaxRegionsVisitedPerAllocation: LONG,
    pub TreeUpdateLatencyExclusive: LONGLONG,
    pub TreeUpdateLatencyTotal: LONGLONG,
    pub TreeUpdateLatencyBase: LONG,
    pub CheckpointLatencyTreeUpdateExclusive: LONGLONG,
    pub CheckpointLatencyTreeUpdateTotal: LONGLONG,
    pub CheckpointLatencyTreeUpdateBase: LONG,
    pub CheckpointLatencyTotal: LONGLONG,
    pub CheckpointLatencyTotalBase: LONG,
}
pub type VOLUME_REFS_INFO_BUFFER = _VOLUME_REFS_INFO_BUFFER;
pub type PVOLUME_REFS_INFO_BUFFER = *mut _VOLUME_REFS_INFO_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _QUERY_DIRECT_ACCESS_EXTENTS {
    pub FileOffset: LONGLONG,
    pub Length: LONGLONG,
    pub Flags: ULONG,
    pub Reserved: ULONG,
}
pub type QUERY_DIRECT_ACCESS_EXTENTS = _QUERY_DIRECT_ACCESS_EXTENTS;
pub type PQUERY_DIRECT_ACCESS_EXTENTS = *mut _QUERY_DIRECT_ACCESS_EXTENTS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FSCTL_GHOST_FILE_EXTENTS_INPUT_BUFFER {
    pub FileOffset: LARGE_INTEGER,
    pub ByteCount: LARGE_INTEGER,
    pub RecallOwnerGuid: GUID,
    pub RecallMetadataBufferSize: ULONG,
    pub RecallMetadataBuffer: [UCHAR; 1usize],
}
pub type FSCTL_GHOST_FILE_EXTENTS_INPUT_BUFFER = _FSCTL_GHOST_FILE_EXTENTS_INPUT_BUFFER;
pub type PFSCTL_GHOST_FILE_EXTENTS_INPUT_BUFFER = *mut _FSCTL_GHOST_FILE_EXTENTS_INPUT_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FSCTL_QUERY_GHOSTED_FILE_EXTENTS_INPUT_RANGE {
    pub FileOffset: LARGE_INTEGER,
    pub ByteCount: LARGE_INTEGER,
}
pub type FSCTL_QUERY_GHOSTED_FILE_EXTENTS_INPUT_RANGE =
_FSCTL_QUERY_GHOSTED_FILE_EXTENTS_INPUT_RANGE;
pub type PFSCTL_QUERY_GHOSTED_FILE_EXTENTS_INPUT_RANGE =
*mut _FSCTL_QUERY_GHOSTED_FILE_EXTENTS_INPUT_RANGE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GHOSTED_FILE_EXTENT {
    pub FileOffset: LARGE_INTEGER,
    pub ByteCount: LARGE_INTEGER,
    pub RecallOwnerGuid: GUID,
    pub NextEntryOffset: ULONG,
    pub RecallMetadataBufferSize: ULONG,
    pub RecallMetadataBuffer: [UCHAR; 1usize],
}
pub type GHOSTED_FILE_EXTENT = _GHOSTED_FILE_EXTENT;
pub type PGHOSTED_FILE_EXTENT = *mut _GHOSTED_FILE_EXTENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_QUERY_GHOSTED_FILE_EXTENTS_OUTPUT {
    pub ExtentCount: ULONG,
    pub TotalExtentCount: ULONG,
    pub Extents: [UCHAR; 1usize],
}
pub type FSCTL_QUERY_GHOSTED_FILE_EXTENTS_OUTPUT = _FSCTL_QUERY_GHOSTED_FILE_EXTENTS_OUTPUT;
pub type PFSCTL_QUERY_GHOSTED_FILE_EXTENTS_OUTPUT = *mut _FSCTL_QUERY_GHOSTED_FILE_EXTENTS_OUTPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FSCTL_UNMAP_SPACE_INPUT_BUFFER {
    pub BytesToUnmap: LARGE_INTEGER,
}
pub type FSCTL_UNMAP_SPACE_INPUT_BUFFER = _FSCTL_UNMAP_SPACE_INPUT_BUFFER;
pub type PFSCTL_UNMAP_SPACE_INPUT_BUFFER = *mut _FSCTL_UNMAP_SPACE_INPUT_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FSCTL_UNMAP_SPACE_OUTPUT {
    pub BytesUnmapped: LARGE_INTEGER,
}
pub type FSCTL_UNMAP_SPACE_OUTPUT = _FSCTL_UNMAP_SPACE_OUTPUT;
pub type PFSCTL_UNMAP_SPACE_OUTPUT = *mut _FSCTL_UNMAP_SPACE_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_QUERY_VOLUME_NUMA_INFO_OUTPUT {
    pub NumaNode: ULONG,
}
pub type FSCTL_QUERY_VOLUME_NUMA_INFO_OUTPUT = _FSCTL_QUERY_VOLUME_NUMA_INFO_OUTPUT;
pub type PFSCTL_QUERY_VOLUME_NUMA_INFO_OUTPUT = *mut _FSCTL_QUERY_VOLUME_NUMA_INFO_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REFS_DEALLOCATE_RANGES_RANGE {
    pub StartOfRange: ULONGLONG,
    pub CountOfRange: ULONGLONG,
}
pub type REFS_DEALLOCATE_RANGES_RANGE = _REFS_DEALLOCATE_RANGES_RANGE;
pub type PREFS_DEALLOCATE_RANGES_RANGE = *mut _REFS_DEALLOCATE_RANGES_RANGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REFS_DEALLOCATE_RANGES_INPUT_BUFFER {
    pub RangeCount: ULONG,
    pub Ranges: [REFS_DEALLOCATE_RANGES_RANGE; 1usize],
}
pub type REFS_DEALLOCATE_RANGES_INPUT_BUFFER = _REFS_DEALLOCATE_RANGES_INPUT_BUFFER;
pub type PREFS_DEALLOCATE_RANGES_INPUT_BUFFER = *mut _REFS_DEALLOCATE_RANGES_INPUT_BUFFER;
pub const _REFS_DEALLOCATE_RANGES_ALLOCATOR_REFS_DEALLOCATE_RANGES_ALLOCATOR_NONE:
_REFS_DEALLOCATE_RANGES_ALLOCATOR = 0;
pub const _REFS_DEALLOCATE_RANGES_ALLOCATOR_REFS_DEALLOCATE_RANGES_ALLOCATOR_SAA:
_REFS_DEALLOCATE_RANGES_ALLOCATOR = 1;
pub const _REFS_DEALLOCATE_RANGES_ALLOCATOR_REFS_DEALLOCATE_RANGES_ALLOCATOR_CAA:
_REFS_DEALLOCATE_RANGES_ALLOCATOR = 2;
pub const _REFS_DEALLOCATE_RANGES_ALLOCATOR_REFS_DEALLOCATE_RANGES_ALLOCATOR_MAA:
_REFS_DEALLOCATE_RANGES_ALLOCATOR = 3;
pub type _REFS_DEALLOCATE_RANGES_ALLOCATOR = core::ffi::c_int;
pub use self::_REFS_DEALLOCATE_RANGES_ALLOCATOR as REFS_DEALLOCATE_RANGES_ALLOCATOR;
pub type PREFS_DEALLOCATE_RANGES_ALLOCATOR = *mut _REFS_DEALLOCATE_RANGES_ALLOCATOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REFS_DEALLOCATE_RANGES_INPUT_BUFFER_EX {
    pub RangeCount: ULONG,
    pub Allocator: REFS_DEALLOCATE_RANGES_ALLOCATOR,
    pub StreamReserveUpdateCount: LONGLONG,
    pub OffsetToRanges: ULONG,
    pub OffsetToLeakCounts: ULONG,
    pub Reserved: [ULONGLONG; 2usize],
}
pub type REFS_DEALLOCATE_RANGES_INPUT_BUFFER_EX = _REFS_DEALLOCATE_RANGES_INPUT_BUFFER_EX;
pub type PREFS_DEALLOCATE_RANGES_INPUT_BUFFER_EX = *mut _REFS_DEALLOCATE_RANGES_INPUT_BUFFER_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REFS_REMOVE_HARDLINK_BACKPOINTER {
    pub ParentDirectory: ULONGLONG,
    pub Reserved: ULONGLONG,
    pub FileName: [WCHAR; 1usize],
}
pub type REFS_REMOVE_HARDLINK_BACKPOINTER = _REFS_REMOVE_HARDLINK_BACKPOINTER;
pub type PREFS_REMOVE_HARDLINK_BACKPOINTER = *mut _REFS_REMOVE_HARDLINK_BACKPOINTER;
pub const _REFS_STREAM_EXTENT_PROPERTIES_REFS_STREAM_EXTENT_PROPERTY_VALID:
_REFS_STREAM_EXTENT_PROPERTIES = 16;
pub const _REFS_STREAM_EXTENT_PROPERTIES_REFS_STREAM_EXTENT_PROPERTY_STREAM_RESERVED:
_REFS_STREAM_EXTENT_PROPERTIES = 32;
pub const _REFS_STREAM_EXTENT_PROPERTIES_REFS_STREAM_EXTENT_PROPERTY_CRC32:
_REFS_STREAM_EXTENT_PROPERTIES = 128;
pub const _REFS_STREAM_EXTENT_PROPERTIES_REFS_STREAM_EXTENT_PROPERTY_CRC64:
_REFS_STREAM_EXTENT_PROPERTIES = 256;
pub const _REFS_STREAM_EXTENT_PROPERTIES_REFS_STREAM_EXTENT_PROPERTY_GHOSTED:
_REFS_STREAM_EXTENT_PROPERTIES = 512;
pub const _REFS_STREAM_EXTENT_PROPERTIES_REFS_STREAM_EXTENT_PROPERTY_READONLY:
_REFS_STREAM_EXTENT_PROPERTIES = 1024;
pub const _REFS_STREAM_EXTENT_PROPERTIES_REFS_STREAM_EXTENT_PROPERTY_SPARSE:
_REFS_STREAM_EXTENT_PROPERTIES = 8;
pub type _REFS_STREAM_EXTENT_PROPERTIES = core::ffi::c_int;
pub type REFS_STREAM_EXTENT_PROPERTIES = USHORT;
pub type PREFS_STREAM_EXTENT_PROPERTIES = *mut REFS_STREAM_EXTENT_PROPERTIES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REFS_STREAM_EXTENT {
    pub Vcn: LONGLONG,
    pub Lcn: LONGLONG,
    pub Length: LONGLONG,
    pub Properties: REFS_STREAM_EXTENT_PROPERTIES,
}
pub type REFS_STREAM_EXTENT = _REFS_STREAM_EXTENT;
pub type PREFS_STREAM_EXTENT = *mut _REFS_STREAM_EXTENT;
pub const _REFS_STREAM_SNAPSHOT_OPERATION_REFS_STREAM_SNAPSHOT_OPERATION_INVALID:
_REFS_STREAM_SNAPSHOT_OPERATION = 0;
pub const _REFS_STREAM_SNAPSHOT_OPERATION_REFS_STREAM_SNAPSHOT_OPERATION_CREATE:
_REFS_STREAM_SNAPSHOT_OPERATION = 1;
pub const _REFS_STREAM_SNAPSHOT_OPERATION_REFS_STREAM_SNAPSHOT_OPERATION_LIST:
_REFS_STREAM_SNAPSHOT_OPERATION = 2;
pub const _REFS_STREAM_SNAPSHOT_OPERATION_REFS_STREAM_SNAPSHOT_OPERATION_QUERY_DELTAS:
_REFS_STREAM_SNAPSHOT_OPERATION = 3;
pub const _REFS_STREAM_SNAPSHOT_OPERATION_REFS_STREAM_SNAPSHOT_OPERATION_REVERT:
_REFS_STREAM_SNAPSHOT_OPERATION = 4;
pub const _REFS_STREAM_SNAPSHOT_OPERATION_REFS_STREAM_SNAPSHOT_OPERATION_SET_SHADOW_BTREE:
_REFS_STREAM_SNAPSHOT_OPERATION = 5;
pub const _REFS_STREAM_SNAPSHOT_OPERATION_REFS_STREAM_SNAPSHOT_OPERATION_CLEAR_SHADOW_BTREE:
_REFS_STREAM_SNAPSHOT_OPERATION = 6;
pub const _REFS_STREAM_SNAPSHOT_OPERATION_REFS_STREAM_SNAPSHOT_OPERATION_MAX:
_REFS_STREAM_SNAPSHOT_OPERATION = 6;
pub type _REFS_STREAM_SNAPSHOT_OPERATION = core::ffi::c_int;
pub use self::_REFS_STREAM_SNAPSHOT_OPERATION as REFS_STREAM_SNAPSHOT_OPERATION;
pub type PREFS_STREAM_SNAPSHOT_OPERATION = *mut _REFS_STREAM_SNAPSHOT_OPERATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REFS_STREAM_SNAPSHOT_MANAGEMENT_INPUT_BUFFER {
    pub Operation: REFS_STREAM_SNAPSHOT_OPERATION,
    pub SnapshotNameLength: USHORT,
    pub OperationInputBufferLength: USHORT,
    pub Reserved: [ULONGLONG; 2usize],
    pub NameAndInputBuffer: [USHORT; 1usize],
}
pub type REFS_STREAM_SNAPSHOT_MANAGEMENT_INPUT_BUFFER =
_REFS_STREAM_SNAPSHOT_MANAGEMENT_INPUT_BUFFER;
pub type PREFS_STREAM_SNAPSHOT_MANAGEMENT_INPUT_BUFFER =
*mut _REFS_STREAM_SNAPSHOT_MANAGEMENT_INPUT_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REFS_STREAM_SNAPSHOT_LIST_OUTPUT_BUFFER_ENTRY {
    pub NextEntryOffset: ULONG,
    pub SnapshotNameLength: USHORT,
    pub SnapshotCreationTime: ULONGLONG,
    pub StreamSize: ULONGLONG,
    pub StreamAllocationSize: ULONGLONG,
    pub Reserved: [ULONGLONG; 2usize],
    pub SnapshotName: [WCHAR; 1usize],
}
pub type REFS_STREAM_SNAPSHOT_LIST_OUTPUT_BUFFER_ENTRY =
_REFS_STREAM_SNAPSHOT_LIST_OUTPUT_BUFFER_ENTRY;
pub type PREFS_STREAM_SNAPSHOT_LIST_OUTPUT_BUFFER_ENTRY =
*mut _REFS_STREAM_SNAPSHOT_LIST_OUTPUT_BUFFER_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REFS_STREAM_SNAPSHOT_LIST_OUTPUT_BUFFER {
    pub EntryCount: ULONG,
    pub BufferSizeRequiredForQuery: ULONG,
    pub Reserved: [ULONG; 2usize],
    pub Entries: [REFS_STREAM_SNAPSHOT_LIST_OUTPUT_BUFFER_ENTRY; 1usize],
}
pub type REFS_STREAM_SNAPSHOT_LIST_OUTPUT_BUFFER = _REFS_STREAM_SNAPSHOT_LIST_OUTPUT_BUFFER;
pub type PREFS_STREAM_SNAPSHOT_LIST_OUTPUT_BUFFER = *mut _REFS_STREAM_SNAPSHOT_LIST_OUTPUT_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REFS_STREAM_SNAPSHOT_QUERY_DELTAS_INPUT_BUFFER {
    pub StartingVcn: LONGLONG,
    pub Flags: ULONG,
    pub Reserved: ULONG,
}
pub type REFS_STREAM_SNAPSHOT_QUERY_DELTAS_INPUT_BUFFER =
_REFS_STREAM_SNAPSHOT_QUERY_DELTAS_INPUT_BUFFER;
pub type PREFS_STREAM_SNAPSHOT_QUERY_DELTAS_INPUT_BUFFER =
*mut _REFS_STREAM_SNAPSHOT_QUERY_DELTAS_INPUT_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REFS_STREAM_SNAPSHOT_QUERY_DELTAS_OUTPUT_BUFFER {
    pub ExtentCount: ULONG,
    pub Reserved: [ULONG; 2usize],
    pub Extents: [REFS_STREAM_EXTENT; 1usize],
}
pub type REFS_STREAM_SNAPSHOT_QUERY_DELTAS_OUTPUT_BUFFER =
_REFS_STREAM_SNAPSHOT_QUERY_DELTAS_OUTPUT_BUFFER;
pub type PREFS_STREAM_SNAPSHOT_QUERY_DELTAS_OUTPUT_BUFFER =
*mut _REFS_STREAM_SNAPSHOT_QUERY_DELTAS_OUTPUT_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SET_CACHED_RUNS_STATE_INPUT_BUFFER {
    pub Enable: BOOLEAN,
}
pub type SET_CACHED_RUNS_STATE_INPUT_BUFFER = _SET_CACHED_RUNS_STATE_INPUT_BUFFER;
pub type PSET_CACHED_RUNS_STATE_INPUT_BUFFER = *mut _SET_CACHED_RUNS_STATE_INPUT_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_STORAGE_RESERVE_ID_INFORMATION {
    pub StorageReserveId: STORAGE_RESERVE_ID,
}
pub type FILE_STORAGE_RESERVE_ID_INFORMATION = _FILE_STORAGE_RESERVE_ID_INFORMATION;
pub type PFILE_STORAGE_RESERVE_ID_INFORMATION = *mut _FILE_STORAGE_RESERVE_ID_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NETWORK_APP_INSTANCE_EA {
    pub AppInstanceID: GUID,
    pub CsvFlags: ULONG,
}
pub type NETWORK_APP_INSTANCE_EA = _NETWORK_APP_INSTANCE_EA;
pub type PNETWORK_APP_INSTANCE_EA = *mut _NETWORK_APP_INSTANCE_EA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SMB_SHARE_FLUSH_AND_PURGE_INPUT {
    pub Version: USHORT,
}
pub type SMB_SHARE_FLUSH_AND_PURGE_INPUT = _SMB_SHARE_FLUSH_AND_PURGE_INPUT;
pub type PSMB_SHARE_FLUSH_AND_PURGE_INPUT = *mut _SMB_SHARE_FLUSH_AND_PURGE_INPUT;
pub type PCSMB_SHARE_FLUSH_AND_PURGE_INPUT = *const _SMB_SHARE_FLUSH_AND_PURGE_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SMB_SHARE_FLUSH_AND_PURGE_OUTPUT {
    pub cEntriesPurged: ULONG,
}
pub type SMB_SHARE_FLUSH_AND_PURGE_OUTPUT = _SMB_SHARE_FLUSH_AND_PURGE_OUTPUT;
pub type PSMB_SHARE_FLUSH_AND_PURGE_OUTPUT = *mut _SMB_SHARE_FLUSH_AND_PURGE_OUTPUT;
pub type PCSMB_SHARE_FLUSH_AND_PURGE_OUTPUT = *const _SMB_SHARE_FLUSH_AND_PURGE_OUTPUT;
unsafe extern "C" {
    pub fn NtCopyFileChunk(
        SourceHandle: HANDLE,
        DestHandle: HANDLE,
        Event: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Length: ULONG,
        SourceOffset: PLARGE_INTEGER,
        DestOffset: PLARGE_INTEGER,
        SourceKey: PULONG,
        DestKey: PULONG,
        Flags: ULONG,
    ) -> NTSTATUS;
}
pub const _OBJECT_INFORMATION_CLASS_ObjectBasicInformation: _OBJECT_INFORMATION_CLASS = 0;
pub const _OBJECT_INFORMATION_CLASS_ObjectTypeInformation: _OBJECT_INFORMATION_CLASS = 2;
pub type _OBJECT_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_OBJECT_INFORMATION_CLASS as OBJECT_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PUBLIC_OBJECT_BASIC_INFORMATION {
    pub Attributes: ULONG,
    pub GrantedAccess: ACCESS_MASK,
    pub HandleCount: ULONG,
    pub PointerCount: ULONG,
    pub Reserved: [ULONG; 10usize],
}
pub type PUBLIC_OBJECT_BASIC_INFORMATION = _PUBLIC_OBJECT_BASIC_INFORMATION;
pub type PPUBLIC_OBJECT_BASIC_INFORMATION = *mut _PUBLIC_OBJECT_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __PUBLIC_OBJECT_TYPE_INFORMATION {
    pub TypeName: UNICODE_STRING,
    pub Reserved: [ULONG; 22usize],
}
pub type PUBLIC_OBJECT_TYPE_INFORMATION = __PUBLIC_OBJECT_TYPE_INFORMATION;
pub type PPUBLIC_OBJECT_TYPE_INFORMATION = *mut __PUBLIC_OBJECT_TYPE_INFORMATION;
unsafe extern "C" {
    pub fn NtQueryObject(
        Handle: HANDLE,
        ObjectInformationClass: OBJECT_INFORMATION_CLASS,
        ObjectInformation: PVOID,
        ObjectInformationLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtSetSecurityObject(
        Handle: HANDLE,
        SecurityInformation: SECURITY_INFORMATION,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtQuerySecurityObject(
        Handle: HANDLE,
        SecurityInformation: SECURITY_INFORMATION,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        Length: ULONG,
        LengthNeeded: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtClose(Handle: HANDLE) -> NTSTATUS;
}
pub const _MEMORY_INFORMATION_CLASS_MemoryBasicInformation: _MEMORY_INFORMATION_CLASS = 0;
pub type _MEMORY_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_MEMORY_INFORMATION_CLASS as MEMORY_INFORMATION_CLASS;
pub const _VIRTUAL_MEMORY_INFORMATION_CLASS_VmPrefetchInformation:
_VIRTUAL_MEMORY_INFORMATION_CLASS = 0;
pub type _VIRTUAL_MEMORY_INFORMATION_CLASS = core::ffi::c_int;
pub use self::_VIRTUAL_MEMORY_INFORMATION_CLASS as VIRTUAL_MEMORY_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_BASIC_INFORMATION {
    pub BaseAddress: PVOID,
    pub AllocationBase: PVOID,
    pub AllocationProtect: ULONG,
    pub PartitionId: USHORT,
    pub RegionSize: SIZE_T,
    pub State: ULONG,
    pub Protect: ULONG,
    pub Type: ULONG,
}
pub type MEMORY_BASIC_INFORMATION = _MEMORY_BASIC_INFORMATION;
pub type PMEMORY_BASIC_INFORMATION = *mut _MEMORY_BASIC_INFORMATION;
unsafe extern "C" {
    pub fn NtCreateSection(
        SectionHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        MaximumSize: PLARGE_INTEGER,
        SectionPageProtection: ULONG,
        AllocationAttributes: ULONG,
        FileHandle: HANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtCreateSectionEx(
        SectionHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        MaximumSize: PLARGE_INTEGER,
        SectionPageProtection: ULONG,
        AllocationAttributes: ULONG,
        FileHandle: HANDLE,
        ExtendedParameters: PMEM_EXTENDED_PARAMETER,
        ExtendedParameterCount: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtAllocateVirtualMemory(
        ProcessHandle: HANDLE,
        BaseAddress: *mut PVOID,
        ZeroBits: ULONG_PTR,
        RegionSize: PSIZE_T,
        AllocationType: ULONG,
        Protect: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtFreeVirtualMemory(
        ProcessHandle: HANDLE,
        BaseAddress: *mut PVOID,
        RegionSize: PSIZE_T,
        FreeType: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn NtQueryVirtualMemory(
        ProcessHandle: HANDLE,
        BaseAddress: PVOID,
        MemoryInformationClass: MEMORY_INFORMATION_CLASS,
        MemoryInformation: PVOID,
        MemoryInformationLength: SIZE_T,
        ReturnLength: PSIZE_T,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_RANGE_ENTRY {
    pub VirtualAddress: PVOID,
    pub NumberOfBytes: SIZE_T,
}
pub type MEMORY_RANGE_ENTRY = _MEMORY_RANGE_ENTRY;
pub type PMEMORY_RANGE_ENTRY = *mut _MEMORY_RANGE_ENTRY;
unsafe extern "C" {
    pub fn NtSetInformationVirtualMemory(
        ProcessHandle: HANDLE,
        VmInformationClass: VIRTUAL_MEMORY_INFORMATION_CLASS,
        NumberOfEntries: ULONG_PTR,
        VirtualAddresses: PMEMORY_RANGE_ENTRY,
        VmInformation: PVOID,
        VmInformationLength: ULONG,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_CLIENT_CONTEXT {
    pub SecurityQos: SECURITY_QUALITY_OF_SERVICE,
    pub ClientToken: PACCESS_TOKEN,
    pub DirectlyAccessClientToken: BOOLEAN,
    pub DirectAccessEffectiveOnly: BOOLEAN,
    pub ServerIsRemote: BOOLEAN,
    pub ClientTokenControl: TOKEN_CONTROL,
}
pub type SECURITY_CLIENT_CONTEXT = _SECURITY_CLIENT_CONTEXT;
pub type PSECURITY_CLIENT_CONTEXT = *mut _SECURITY_CLIENT_CONTEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KAPC_STATE {
    pub ApcListHead: [LIST_ENTRY; 2usize],
    pub Process: *mut _KPROCESS,
    pub __bindgen_anon_1: _KAPC_STATE__bindgen_ty_1,
    pub KernelApcPending: BOOLEAN,
    pub __bindgen_anon_2: _KAPC_STATE__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KAPC_STATE__bindgen_ty_1 {
    pub InProgressFlags: UCHAR,
    pub __bindgen_anon_1: _KAPC_STATE__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KAPC_STATE__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _KAPC_STATE__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn KernelApcInProgress(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_KernelApcInProgress(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn KernelApcInProgress_raw(this: *const Self) -> BOOLEAN {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_KernelApcInProgress_raw(this: *mut Self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SpecialApcInProgress(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SpecialApcInProgress(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SpecialApcInProgress_raw(this: *const Self) -> BOOLEAN {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_SpecialApcInProgress_raw(this: *mut Self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        KernelApcInProgress: BOOLEAN,
        SpecialApcInProgress: BOOLEAN,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let KernelApcInProgress: u8 = unsafe { ::core::mem::transmute(KernelApcInProgress) };
            KernelApcInProgress as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SpecialApcInProgress: u8 = unsafe { ::core::mem::transmute(SpecialApcInProgress) };
            SpecialApcInProgress as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KAPC_STATE__bindgen_ty_2 {
    pub UserApcPendingAll: BOOLEAN,
    pub __bindgen_anon_1: _KAPC_STATE__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KAPC_STATE__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _KAPC_STATE__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn SpecialUserApcPending(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SpecialUserApcPending(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SpecialUserApcPending_raw(this: *const Self) -> BOOLEAN {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_SpecialUserApcPending_raw(this: *mut Self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn UserApcPending(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_UserApcPending(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn UserApcPending_raw(this: *const Self) -> BOOLEAN {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_UserApcPending_raw(this: *mut Self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SpecialUserApcPending: BOOLEAN,
        UserApcPending: BOOLEAN,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SpecialUserApcPending: u8 =
                unsafe { ::core::mem::transmute(SpecialUserApcPending) };
            SpecialUserApcPending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let UserApcPending: u8 = unsafe { ::core::mem::transmute(UserApcPending) };
            UserApcPending as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type KAPC_STATE = _KAPC_STATE;
pub type PKAPC_STATE = *mut _KAPC_STATE;
pub type PRKAPC_STATE = *mut _KAPC_STATE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KQUEUE {
    pub Header: DISPATCHER_HEADER,
    pub EntryListHead: LIST_ENTRY,
    pub CurrentCount: ULONG,
    pub MaximumCount: ULONG,
    pub ThreadListHead: LIST_ENTRY,
}
pub type KQUEUE = _KQUEUE;
pub type PKQUEUE = *mut _KQUEUE;
pub type PRKQUEUE = *mut _KQUEUE;
unsafe extern "C" {
    pub fn KeInitializeMutant(Mutant: PRKMUTANT, InitialOwner: BOOLEAN);
}
unsafe extern "C" {
    pub fn KeQueryOwnerMutant(Mutant: PKMUTANT, ClientId: PCLIENT_ID);
}
unsafe extern "C" {
    pub fn KeReadStateMutant(Mutant: PRKMUTANT) -> LONG;
}
unsafe extern "C" {
    pub fn KeReleaseMutant(
        Mutant: PRKMUTANT,
        Increment: KPRIORITY,
        Abandoned: BOOLEAN,
        Wait: BOOLEAN,
    ) -> LONG;
}
unsafe extern "C" {
    pub fn KeInitializeQueue(Queue: PRKQUEUE, Count: ULONG);
}
unsafe extern "C" {
    pub fn KeReadStateQueue(Queue: PRKQUEUE) -> LONG;
}
unsafe extern "C" {
    pub fn KeInsertQueue(Queue: PRKQUEUE, Entry: PLIST_ENTRY) -> LONG;
}
unsafe extern "C" {
    pub fn KeInsertHeadQueue(Queue: PRKQUEUE, Entry: PLIST_ENTRY) -> LONG;
}
unsafe extern "C" {
    pub fn KeRemoveQueue(
        Queue: PRKQUEUE,
        WaitMode: KPROCESSOR_MODE,
        Timeout: PLARGE_INTEGER,
    ) -> PLIST_ENTRY;
}
unsafe extern "C" {
    pub fn KeRemoveQueueEx(
        Queue: PKQUEUE,
        WaitMode: KPROCESSOR_MODE,
        Alertable: BOOLEAN,
        Timeout: PLARGE_INTEGER,
        EntryArray: *mut PLIST_ENTRY,
        Count: ULONG,
    ) -> ULONG;
}
unsafe extern "C" {
    pub fn KeRundownQueue(Queue: PRKQUEUE) -> PLIST_ENTRY;
}
unsafe extern "C" {
    pub fn KeAttachProcess(Process: PRKPROCESS);
}
unsafe extern "C" {
    pub fn KeDetachProcess();
}
unsafe extern "C" {
    pub fn KeStackAttachProcess(PROCESS: PRKPROCESS, ApcState: PRKAPC_STATE);
}
unsafe extern "C" {
    pub fn KeUnstackDetachProcess(ApcState: PRKAPC_STATE);
}
unsafe extern "C" {
    pub fn KeSetIdealProcessorThread(Thread: PKTHREAD, Processor: UCHAR) -> UCHAR;
}
unsafe extern "C" {
    pub fn KeSetKernelStackSwapEnable(Enable: BOOLEAN) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn KeAcquireQueuedSpinLock(Number: KSPIN_LOCK_QUEUE_NUMBER) -> KIRQL;
}
unsafe extern "C" {
    pub fn KeReleaseQueuedSpinLock(Number: KSPIN_LOCK_QUEUE_NUMBER, OldIrql: KIRQL);
}
unsafe extern "C" {
    pub fn KeTryToAcquireQueuedSpinLock(
        Number: KSPIN_LOCK_QUEUE_NUMBER,
        OldIrql: PKIRQL,
    ) -> LOGICAL;
}
unsafe extern "C" {
    pub fn KeAcquireSpinLockRaiseToSynch(SpinLock: PKSPIN_LOCK) -> KIRQL;
}
unsafe extern "C" {
    pub fn ExQueryPoolBlockSize(PoolBlock: PVOID, QuotaCharged: PBOOLEAN) -> SIZE_T;
}
unsafe extern "C" {
    pub fn InterlockedPushListSList(
        ListHead: PSLIST_HEADER,
        List: PSLIST_ENTRY,
        ListEnd: PSLIST_ENTRY,
        Count: ULONG,
    ) -> PSLIST_ENTRY;
}
unsafe extern "C" {
    pub fn ExAdjustLookasideDepth();
}
unsafe extern "C" {
    pub fn ExDisableResourceBoostLite(Resource: PERESOURCE);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_EXPORTS {
    pub SeCreateTokenPrivilege: LUID,
    pub SeAssignPrimaryTokenPrivilege: LUID,
    pub SeLockMemoryPrivilege: LUID,
    pub SeIncreaseQuotaPrivilege: LUID,
    pub SeUnsolicitedInputPrivilege: LUID,
    pub SeTcbPrivilege: LUID,
    pub SeSecurityPrivilege: LUID,
    pub SeTakeOwnershipPrivilege: LUID,
    pub SeLoadDriverPrivilege: LUID,
    pub SeCreatePagefilePrivilege: LUID,
    pub SeIncreaseBasePriorityPrivilege: LUID,
    pub SeSystemProfilePrivilege: LUID,
    pub SeSystemtimePrivilege: LUID,
    pub SeProfileSingleProcessPrivilege: LUID,
    pub SeCreatePermanentPrivilege: LUID,
    pub SeBackupPrivilege: LUID,
    pub SeRestorePrivilege: LUID,
    pub SeShutdownPrivilege: LUID,
    pub SeDebugPrivilege: LUID,
    pub SeAuditPrivilege: LUID,
    pub SeSystemEnvironmentPrivilege: LUID,
    pub SeChangeNotifyPrivilege: LUID,
    pub SeRemoteShutdownPrivilege: LUID,
    pub SeNullSid: PSID,
    pub SeWorldSid: PSID,
    pub SeLocalSid: PSID,
    pub SeCreatorOwnerSid: PSID,
    pub SeCreatorGroupSid: PSID,
    pub SeNtAuthoritySid: PSID,
    pub SeDialupSid: PSID,
    pub SeNetworkSid: PSID,
    pub SeBatchSid: PSID,
    pub SeInteractiveSid: PSID,
    pub SeLocalSystemSid: PSID,
    pub SeAliasAdminsSid: PSID,
    pub SeAliasUsersSid: PSID,
    pub SeAliasGuestsSid: PSID,
    pub SeAliasPowerUsersSid: PSID,
    pub SeAliasAccountOpsSid: PSID,
    pub SeAliasSystemOpsSid: PSID,
    pub SeAliasPrintOpsSid: PSID,
    pub SeAliasBackupOpsSid: PSID,
    pub SeAuthenticatedUsersSid: PSID,
    pub SeRestrictedSid: PSID,
    pub SeAnonymousLogonSid: PSID,
    pub SeUndockPrivilege: LUID,
    pub SeSyncAgentPrivilege: LUID,
    pub SeEnableDelegationPrivilege: LUID,
    pub SeLocalServiceSid: PSID,
    pub SeNetworkServiceSid: PSID,
    pub SeManageVolumePrivilege: LUID,
    pub SeImpersonatePrivilege: LUID,
    pub SeCreateGlobalPrivilege: LUID,
    pub SeTrustedCredManAccessPrivilege: LUID,
    pub SeRelabelPrivilege: LUID,
    pub SeIncreaseWorkingSetPrivilege: LUID,
    pub SeTimeZonePrivilege: LUID,
    pub SeCreateSymbolicLinkPrivilege: LUID,
    pub SeIUserSid: PSID,
    pub SeUntrustedMandatorySid: PSID,
    pub SeLowMandatorySid: PSID,
    pub SeMediumMandatorySid: PSID,
    pub SeHighMandatorySid: PSID,
    pub SeSystemMandatorySid: PSID,
    pub SeOwnerRightsSid: PSID,
    pub SeAllAppPackagesSid: PSID,
    pub SeUserModeDriversSid: PSID,
    pub SeProcTrustWinTcbSid: PSID,
    pub SeTrustedInstallerSid: PSID,
    pub SeDelegateSessionUserImpersonatePrivilege: LUID,
    pub SeAppSiloSid: PSID,
    pub SeAppSiloVolumeRootMinimalCapabilitySid: PSID,
    pub SeAppSiloProfilesRootMinimalCapabilitySid: PSID,
}
pub type SE_EXPORTS = _SE_EXPORTS;
pub type PSE_EXPORTS = *mut _SE_EXPORTS;
pub type SE_LOGON_SESSION_TERMINATED_ROUTINE =
::core::option::Option<unsafe extern "C" fn(LogonId: PLUID) -> NTSTATUS>;
pub type PSE_LOGON_SESSION_TERMINATED_ROUTINE = SE_LOGON_SESSION_TERMINATED_ROUTINE;
pub type SE_LOGON_SESSION_TERMINATED_ROUTINE_EX = ::core::option::Option<
    unsafe extern "C" fn(LogonId: PLUID, pServerSilo: PESILO, Context: PVOID) -> NTSTATUS,
>;
pub type PSE_LOGON_SESSION_TERMINATED_ROUTINE_EX = SE_LOGON_SESSION_TERMINATED_ROUTINE_EX;
unsafe extern "C" {
    pub fn SeDeleteClientSecurity(ClientContext: PSECURITY_CLIENT_CONTEXT);
}
unsafe extern "C" {
    pub fn SeCaptureSubjectContextEx(
        Thread: PETHREAD,
        Process: PEPROCESS,
        SubjectContext: PSECURITY_SUBJECT_CONTEXT,
    );
}
unsafe extern "C" {
    pub fn SeReportSecurityEventWithSubCategory(
        Flags: ULONG,
        SourceName: PUNICODE_STRING,
        UserSid: PSID,
        AuditParameters: PSE_ADT_PARAMETER_ARRAY,
        AuditSubcategoryId: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeAccessCheckFromState(
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        PrimaryTokenInformation: PTOKEN_ACCESS_INFORMATION,
        ClientTokenInformation: PTOKEN_ACCESS_INFORMATION,
        DesiredAccess: ACCESS_MASK,
        PreviouslyGrantedAccess: ACCESS_MASK,
        Privileges: *mut PPRIVILEGE_SET,
        GenericMapping: PGENERIC_MAPPING,
        AccessMode: KPROCESSOR_MODE,
        GrantedAccess: PACCESS_MASK,
        AccessStatus: PNTSTATUS,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn SeAccessCheckFromStateEx(
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        PrimaryToken: PACCESS_TOKEN,
        ClientToken: PACCESS_TOKEN,
        DesiredAccess: ACCESS_MASK,
        PreviouslyGrantedAccess: ACCESS_MASK,
        Privileges: *mut PPRIVILEGE_SET,
        GenericMapping: PGENERIC_MAPPING,
        AccessMode: KPROCESSOR_MODE,
        GrantedAccess: PACCESS_MASK,
        AccessStatus: PNTSTATUS,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn SeTokenFromAccessInformation(
        AccessInformation: PTOKEN_ACCESS_INFORMATION,
        Token: PACCESS_TOKEN,
        Length: ULONG,
        RequiredLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SePrivilegeCheck(
        RequiredPrivileges: PPRIVILEGE_SET,
        SubjectSecurityContext: PSECURITY_SUBJECT_CONTEXT,
        AccessMode: KPROCESSOR_MODE,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn SeFreePrivileges(Privileges: PPRIVILEGE_SET);
}
unsafe extern "C" {
    pub fn SeOpenObjectAuditAlarm(
        ObjectTypeName: PUNICODE_STRING,
        Object: PVOID,
        AbsoluteObjectName: PUNICODE_STRING,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        AccessState: PACCESS_STATE,
        ObjectCreated: BOOLEAN,
        AccessGranted: BOOLEAN,
        AccessMode: KPROCESSOR_MODE,
        GenerateOnClose: PBOOLEAN,
    );
}
unsafe extern "C" {
    pub fn SeOpenObjectAuditAlarmWithTransaction(
        ObjectTypeName: PUNICODE_STRING,
        Object: PVOID,
        AbsoluteObjectName: PUNICODE_STRING,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        AccessState: PACCESS_STATE,
        ObjectCreated: BOOLEAN,
        AccessGranted: BOOLEAN,
        AccessMode: KPROCESSOR_MODE,
        TransactionId: *mut GUID,
        GenerateOnClose: PBOOLEAN,
    );
}
unsafe extern "C" {
    pub fn SeOpenObjectForDeleteAuditAlarm(
        ObjectTypeName: PUNICODE_STRING,
        Object: PVOID,
        AbsoluteObjectName: PUNICODE_STRING,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        AccessState: PACCESS_STATE,
        ObjectCreated: BOOLEAN,
        AccessGranted: BOOLEAN,
        AccessMode: KPROCESSOR_MODE,
        GenerateOnClose: PBOOLEAN,
    );
}
unsafe extern "C" {
    pub fn SeOpenObjectForDeleteAuditAlarmWithTransaction(
        ObjectTypeName: PUNICODE_STRING,
        Object: PVOID,
        AbsoluteObjectName: PUNICODE_STRING,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        AccessState: PACCESS_STATE,
        ObjectCreated: BOOLEAN,
        AccessGranted: BOOLEAN,
        AccessMode: KPROCESSOR_MODE,
        TransactionId: *mut GUID,
        GenerateOnClose: PBOOLEAN,
    );
}
unsafe extern "C" {
    pub fn SeExamineSacl(
        Sacl: PACL,
        ResourceSacl: PACL,
        Token: PACCESS_TOKEN,
        DesiredAccess: ACCESS_MASK,
        AccessGranted: BOOLEAN,
        GenerateAudit: PBOOLEAN,
        GenerateAlarm: PBOOLEAN,
    );
}
unsafe extern "C" {
    pub fn SeDeleteObjectAuditAlarm(Object: PVOID, Handle: HANDLE);
}
unsafe extern "C" {
    pub fn SeDeleteObjectAuditAlarmWithTransaction(
        Object: PVOID,
        Handle: HANDLE,
        TransactionId: *mut GUID,
    );
}
unsafe extern "C" {
    pub fn SeTokenType(Token: PACCESS_TOKEN) -> TOKEN_TYPE;
}
unsafe extern "C" {
    pub fn SeTokenIsAdmin(Token: PACCESS_TOKEN) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn SeTokenIsRestricted(Token: PACCESS_TOKEN) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn SeTokenIsWriteRestricted(Token: PACCESS_TOKEN) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn SeTokenIsNoChildProcessRestrictionEnforced(
        Token: PACCESS_TOKEN,
        UnlessSecure: PBOOLEAN,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn SeTokenSetNoChildProcessRestricted(
        Token: PACCESS_TOKEN,
        UnlessSecure: BOOLEAN,
        AuditOnly: BOOLEAN,
    );
}
unsafe extern "C" {
    pub fn SeTokenGetNoChildProcessRestricted(
        Token: PACCESS_TOKEN,
        Enforced: PBOOLEAN,
        UnlessSecure: PBOOLEAN,
        AuditOnly: PBOOLEAN,
    );
}
unsafe extern "C" {
    pub fn SeTokenSetRedirectionTrustPolicy(Token: PACCESS_TOKEN, AuditOnly: BOOLEAN);
}
unsafe extern "C" {
    pub fn SeTokenGetRedirectionTrustPolicy(
        Token: PACCESS_TOKEN,
        Enforced: PBOOLEAN,
        AuditOnly: PBOOLEAN,
    );
}
unsafe extern "C" {
    pub fn SeFilterToken(
        ExistingToken: PACCESS_TOKEN,
        Flags: ULONG,
        SidsToDisable: PTOKEN_GROUPS,
        PrivilegesToDelete: PTOKEN_PRIVILEGES,
        RestrictedSids: PTOKEN_GROUPS,
        FilteredToken: *mut PACCESS_TOKEN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeQueryAuthenticationIdToken(Token: PACCESS_TOKEN, AuthenticationId: PLUID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeQueryTokenIntegrity(Token: PACCESS_TOKEN, IntegritySA: PSID_AND_ATTRIBUTES);
}
unsafe extern "C" {
    pub fn SeQuerySessionIdToken(Token: PACCESS_TOKEN, SessionId: PULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeQuerySessionIdTokenEx(
        Token: PACCESS_TOKEN,
        SessionId: PULONG,
        IsServiceSession: PBOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeQueryServerSiloToken(Token: PACCESS_TOKEN, pServerSilo: *mut PESILO) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeSetSessionIdToken(Token: PACCESS_TOKEN, SessionId: ULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeCreateClientSecurity(
        ClientThread: PETHREAD,
        ClientSecurityQos: PSECURITY_QUALITY_OF_SERVICE,
        RemoteSession: BOOLEAN,
        ClientContext: PSECURITY_CLIENT_CONTEXT,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeImpersonateClient(ClientContext: PSECURITY_CLIENT_CONTEXT, ServerThread: PETHREAD);
}
unsafe extern "C" {
    pub fn SeImpersonateClientEx(
        ClientContext: PSECURITY_CLIENT_CONTEXT,
        ServerThread: PETHREAD,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeCreateClientSecurityFromSubjectContext(
        SubjectContext: PSECURITY_SUBJECT_CONTEXT,
        ClientSecurityQos: PSECURITY_QUALITY_OF_SERVICE,
        ServerIsRemote: BOOLEAN,
        ClientContext: PSECURITY_CLIENT_CONTEXT,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeQuerySecurityDescriptorInfo(
        SecurityInformation: PSECURITY_INFORMATION,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        Length: PULONG,
        ObjectsSecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeSetSecurityDescriptorInfo(
        Object: PVOID,
        SecurityInformation: PSECURITY_INFORMATION,
        ModificationDescriptor: PSECURITY_DESCRIPTOR,
        ObjectsSecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
        PoolType: POOL_TYPE,
        GenericMapping: PGENERIC_MAPPING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeSetSecurityDescriptorInfoEx(
        Object: PVOID,
        SecurityInformation: PSECURITY_INFORMATION,
        ModificationDescriptor: PSECURITY_DESCRIPTOR,
        ObjectsSecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
        AutoInheritFlags: ULONG,
        PoolType: POOL_TYPE,
        GenericMapping: PGENERIC_MAPPING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeAppendPrivileges(AccessState: PACCESS_STATE, Privileges: PPRIVILEGE_SET) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeAuditHardLinkCreation(
        FileName: PUNICODE_STRING,
        LinkName: PUNICODE_STRING,
        bSuccess: BOOLEAN,
    );
}
unsafe extern "C" {
    pub fn SeAuditHardLinkCreationWithTransaction(
        FileName: PUNICODE_STRING,
        LinkName: PUNICODE_STRING,
        bSuccess: BOOLEAN,
        TransactionId: *mut GUID,
    );
}
unsafe extern "C" {
    pub fn SeAuditFipsCryptoSelftests(bSuccess: BOOLEAN, SelftestCode: ULONG);
}
unsafe extern "C" {
    pub fn SeAuditTransactionStateChange(
        TransactionId: *mut GUID,
        ResourceManagerId: *mut GUID,
        NewTransactionState: ULONG,
    );
}
unsafe extern "C" {
    pub fn SeAuditingFileEvents(
        AccessGranted: BOOLEAN,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn SeAuditingFileEventsWithContext(
        AccessGranted: BOOLEAN,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        SubjectSecurityContext: PSECURITY_SUBJECT_CONTEXT,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn SeAuditingAnyFileEventsWithContext(
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        SubjectSecurityContext: PSECURITY_SUBJECT_CONTEXT,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn SeAuditingFileEventsWithContextEx(
        AccessGranted: BOOLEAN,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        SubjectSecurityContext: PSECURITY_SUBJECT_CONTEXT,
        StagingEnabled: PBOOLEAN,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn SeAuditingAnyFileEventsWithContextEx(
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        SubjectSecurityContext: PSECURITY_SUBJECT_CONTEXT,
        StagingEnabled: PBOOLEAN,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn SeAdjustAccessStateForTrustLabel(
        ObjectType: PVOID,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        AccessState: PACCESS_STATE,
    );
}
unsafe extern "C" {
    pub fn SeAdjustAccessStateForAccessConstraints(
        ObjectType: PVOID,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        AccessState: PACCESS_STATE,
    );
}
unsafe extern "C" {
    pub fn SeShouldCheckForAccessRightsFromParent(
        ObjectType: PVOID,
        ChildDescriptor: PSECURITY_DESCRIPTOR,
        AccessState: PACCESS_STATE,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn SeAuditingHardLinkEvents(
        AccessGranted: BOOLEAN,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn SeAuditingHardLinkEventsWithContext(
        AccessGranted: BOOLEAN,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        SubjectSecurityContext: PSECURITY_SUBJECT_CONTEXT,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn SeAuditingFileOrGlobalEvents(
        AccessGranted: BOOLEAN,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        SubjectSecurityContext: PSECURITY_SUBJECT_CONTEXT,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn SeSetAccessStateGenericMapping(
        AccessState: PACCESS_STATE,
        GenericMapping: PGENERIC_MAPPING,
    );
}
unsafe extern "C" {
    pub fn SeRegisterLogonSessionTerminatedRoutine(
        CallbackRoutine: PSE_LOGON_SESSION_TERMINATED_ROUTINE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeUnregisterLogonSessionTerminatedRoutine(
        CallbackRoutine: PSE_LOGON_SESSION_TERMINATED_ROUTINE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeRegisterLogonSessionTerminatedRoutineEx(
        CallbackRoutine: PSE_LOGON_SESSION_TERMINATED_ROUTINE_EX,
        Context: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeUnregisterLogonSessionTerminatedRoutineEx(
        CallbackRoutine: PSE_LOGON_SESSION_TERMINATED_ROUTINE_EX,
        Context: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeMarkLogonSessionForTerminationNotification(LogonId: PLUID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeMarkLogonSessionForTerminationNotificationEx(
        LogonId: PLUID,
        pServerSilo: PESILO,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeQueryInformationToken(
        Token: PACCESS_TOKEN,
        TokenInformationClass: TOKEN_INFORMATION_CLASS,
        TokenInformation: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SeLocateProcessImageName(
        Process: PEPROCESS,
        pImageFileName: *mut PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub static mut SeExports: PSE_EXPORTS;
}
unsafe extern "C" {
    pub fn SeExamineGlobalSacl(
        ObjectType: PUNICODE_STRING,
        ResourceSacl: PACL,
        Token: PACCESS_TOKEN,
        DesiredAccess: ACCESS_MASK,
        AccessGranted: BOOLEAN,
        GenerateAudit: PBOOLEAN,
        GenerateAlarm: PBOOLEAN,
    );
}
unsafe extern "C" {
    pub fn SeMaximumAuditMaskFromGlobalSacl(
        ObjectTypeName: PUNICODE_STRING,
        GrantedAccess: ACCESS_MASK,
        Token: PACCESS_TOKEN,
        AuditMask: PACCESS_MASK,
    );
}
unsafe extern "C" {
    pub fn RtlIsSandboxedTokenHandle(TokenHandle: HANDLE, PreviousMode: KPROCESSOR_MODE)
                                     -> BOOLEAN;
}
unsafe extern "C" {
    pub fn RtlIsSandboxedToken(
        Context: PSECURITY_SUBJECT_CONTEXT,
        PreviousMode: KPROCESSOR_MODE,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn SeCheckForCriticalAceRemoval(
        CurrentDescriptor: PSECURITY_DESCRIPTOR,
        NewDescriptor: PSECURITY_DESCRIPTOR,
        SubjectSecurityContext: PSECURITY_SUBJECT_CONTEXT,
        AceRemoved: PBOOLEAN,
    );
}
unsafe extern "C" {
    pub fn SeAdjustObjectSecurity(
        ObjectName: PUNICODE_STRING,
        OriginalDescriptor: PSECURITY_DESCRIPTOR,
        ProposedDescriptor: PSECURITY_DESCRIPTOR,
        SubjectSecurityContext: PSECURITY_SUBJECT_CONTEXT,
        AdjustedDescriptor: *mut PSECURITY_DESCRIPTOR,
        ApplyAdjustedDescriptor: PBOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsAssignImpersonationToken(Thread: PETHREAD, Token: HANDLE) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsReferencePrimaryToken(Process: PEPROCESS) -> PACCESS_TOKEN;
}
unsafe extern "C" {
    pub fn PsDereferencePrimaryToken(PrimaryToken: PACCESS_TOKEN);
}
unsafe extern "C" {
    pub fn PsDereferenceImpersonationToken(ImpersonationToken: PACCESS_TOKEN);
}
unsafe extern "C" {
    pub fn PsReferenceImpersonationToken(
        Thread: PETHREAD,
        CopyOnOpen: PBOOLEAN,
        EffectiveOnly: PBOOLEAN,
        ImpersonationLevel: PSECURITY_IMPERSONATION_LEVEL,
    ) -> PACCESS_TOKEN;
}
unsafe extern "C" {
    pub fn PsGetProcessExitTime() -> LARGE_INTEGER;
}
unsafe extern "C" {
    pub fn PsIsThreadTerminating(Thread: PETHREAD) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn PsImpersonateClient(
        Thread: PETHREAD,
        Token: PACCESS_TOKEN,
        CopyOnOpen: BOOLEAN,
        EffectiveOnly: BOOLEAN,
        ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsDisableImpersonation(
        Thread: PETHREAD,
        ImpersonationState: PSE_IMPERSONATION_STATE,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn PsRestoreImpersonation(Thread: PETHREAD, ImpersonationState: PSE_IMPERSONATION_STATE);
}
unsafe extern "C" {
    pub fn PsRevertToSelf();
}
unsafe extern "C" {
    pub fn PsLookupProcessByProcessId(ProcessId: HANDLE, Process: *mut PEPROCESS) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsLookupThreadByThreadId(ThreadId: HANDLE, Thread: *mut PETHREAD) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsChargePoolQuota(Process: PEPROCESS, PoolType: POOL_TYPE, Amount: ULONG_PTR);
}
unsafe extern "C" {
    pub fn PsChargeProcessPoolQuota(
        Process: PEPROCESS,
        PoolType: POOL_TYPE,
        Amount: ULONG_PTR,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn PsReturnPoolQuota(Process: PEPROCESS, PoolType: POOL_TYPE, Amount: ULONG_PTR);
}
unsafe extern "C" {
    pub fn PsGetThreadProcess(Thread: PETHREAD) -> PEPROCESS;
}
unsafe extern "C" {
    pub fn PsIsSystemThread(Thread: PETHREAD) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn PsUpdateDiskCounters(
        Process: PEPROCESS,
        BytesRead: ULONG64,
        BytesWritten: ULONG64,
        ReadOperationCount: ULONG,
        WriteOperationCount: ULONG,
        FlushOperationCount: ULONG,
    );
}
unsafe extern "C" {
    pub fn PsIsDiskCountersEnabled() -> BOOLEAN;
}
pub type DRIVER_FS_NOTIFICATION = ::core::option::Option<
    unsafe extern "C" fn(DeviceObject: *mut _DEVICE_OBJECT, FsActive: BOOLEAN),
>;
pub type PDRIVER_FS_NOTIFICATION = DRIVER_FS_NOTIFICATION;
pub const _FS_FILTER_SECTION_SYNC_TYPE_SyncTypeOther: _FS_FILTER_SECTION_SYNC_TYPE = 0;
pub const _FS_FILTER_SECTION_SYNC_TYPE_SyncTypeCreateSection: _FS_FILTER_SECTION_SYNC_TYPE = 1;
pub type _FS_FILTER_SECTION_SYNC_TYPE = core::ffi::c_int;
pub use self::_FS_FILTER_SECTION_SYNC_TYPE as FS_FILTER_SECTION_SYNC_TYPE;
pub type PFS_FILTER_SECTION_SYNC_TYPE = *mut _FS_FILTER_SECTION_SYNC_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_FILTER_SECTION_SYNC_OUTPUT {
    pub StructureSize: ULONG,
    pub SizeReturned: ULONG,
    pub Flags: ULONG,
    pub DesiredReadAlignment: ULONG,
}
pub type FS_FILTER_SECTION_SYNC_OUTPUT = _FS_FILTER_SECTION_SYNC_OUTPUT;
pub type PFS_FILTER_SECTION_SYNC_OUTPUT = *mut _FS_FILTER_SECTION_SYNC_OUTPUT;
pub const _FS_FILTER_STREAM_FO_NOTIFICATION_TYPE_NotifyTypeCreate:
_FS_FILTER_STREAM_FO_NOTIFICATION_TYPE = 0;
pub const _FS_FILTER_STREAM_FO_NOTIFICATION_TYPE_NotifyTypeRetired:
_FS_FILTER_STREAM_FO_NOTIFICATION_TYPE = 1;
pub type _FS_FILTER_STREAM_FO_NOTIFICATION_TYPE = core::ffi::c_int;
pub use self::_FS_FILTER_STREAM_FO_NOTIFICATION_TYPE as FS_FILTER_STREAM_FO_NOTIFICATION_TYPE;
pub type PFS_FILTER_STREAM_FO_NOTIFICATION_TYPE = *mut _FS_FILTER_STREAM_FO_NOTIFICATION_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FS_FILTER_PARAMETERS {
    pub AcquireForModifiedPageWriter: _FS_FILTER_PARAMETERS__bindgen_ty_1,
    pub ReleaseForModifiedPageWriter: _FS_FILTER_PARAMETERS__bindgen_ty_2,
    pub AcquireForSectionSynchronization: _FS_FILTER_PARAMETERS__bindgen_ty_3,
    pub QueryOpen: _FS_FILTER_PARAMETERS__bindgen_ty_4,
    pub Others: _FS_FILTER_PARAMETERS__bindgen_ty_5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_FILTER_PARAMETERS__bindgen_ty_1 {
    pub EndingOffset: PLARGE_INTEGER,
    pub ResourceToRelease: *mut PERESOURCE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_FILTER_PARAMETERS__bindgen_ty_2 {
    pub ResourceToRelease: PERESOURCE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_FILTER_PARAMETERS__bindgen_ty_3 {
    pub SyncType: FS_FILTER_SECTION_SYNC_TYPE,
    pub PageProtection: ULONG,
    pub OutputInformation: PFS_FILTER_SECTION_SYNC_OUTPUT,
    pub Flags: ULONG,
    pub AllocationAttributes: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_FILTER_PARAMETERS__bindgen_ty_4 {
    pub Irp: PIRP,
    pub FileInformation: PVOID,
    pub Length: PULONG,
    pub FileInformationClass: FILE_INFORMATION_CLASS,
    pub CompletionStatus: NTSTATUS,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_FILTER_PARAMETERS__bindgen_ty_5 {
    pub Argument1: PVOID,
    pub Argument2: PVOID,
    pub Argument3: PVOID,
    pub Argument4: PVOID,
    pub Argument5: PVOID,
}
pub type FS_FILTER_PARAMETERS = _FS_FILTER_PARAMETERS;
pub type PFS_FILTER_PARAMETERS = *mut _FS_FILTER_PARAMETERS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FS_FILTER_CALLBACK_DATA {
    pub SizeOfFsFilterCallbackData: ULONG,
    pub Operation: UCHAR,
    pub Reserved: UCHAR,
    pub DeviceObject: *mut _DEVICE_OBJECT,
    pub FileObject: *mut _FILE_OBJECT,
    pub Parameters: FS_FILTER_PARAMETERS,
}
pub type FS_FILTER_CALLBACK_DATA = _FS_FILTER_CALLBACK_DATA;
pub type PFS_FILTER_CALLBACK_DATA = *mut _FS_FILTER_CALLBACK_DATA;
pub type PFS_FILTER_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(Data: PFS_FILTER_CALLBACK_DATA, CompletionContext: *mut PVOID) -> NTSTATUS,
>;
pub type PFS_FILTER_COMPLETION_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        Data: PFS_FILTER_CALLBACK_DATA,
        OperationStatus: NTSTATUS,
        CompletionContext: PVOID,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_FILTER_CALLBACKS {
    pub SizeOfFsFilterCallbacks: ULONG,
    pub Reserved: ULONG,
    pub PreAcquireForSectionSynchronization: PFS_FILTER_CALLBACK,
    pub PostAcquireForSectionSynchronization: PFS_FILTER_COMPLETION_CALLBACK,
    pub PreReleaseForSectionSynchronization: PFS_FILTER_CALLBACK,
    pub PostReleaseForSectionSynchronization: PFS_FILTER_COMPLETION_CALLBACK,
    pub PreAcquireForCcFlush: PFS_FILTER_CALLBACK,
    pub PostAcquireForCcFlush: PFS_FILTER_COMPLETION_CALLBACK,
    pub PreReleaseForCcFlush: PFS_FILTER_CALLBACK,
    pub PostReleaseForCcFlush: PFS_FILTER_COMPLETION_CALLBACK,
    pub PreAcquireForModifiedPageWriter: PFS_FILTER_CALLBACK,
    pub PostAcquireForModifiedPageWriter: PFS_FILTER_COMPLETION_CALLBACK,
    pub PreReleaseForModifiedPageWriter: PFS_FILTER_CALLBACK,
    pub PostReleaseForModifiedPageWriter: PFS_FILTER_COMPLETION_CALLBACK,
    pub PreQueryOpen: PFS_FILTER_CALLBACK,
    pub PostQueryOpen: PFS_FILTER_COMPLETION_CALLBACK,
}
pub type FS_FILTER_CALLBACKS = _FS_FILTER_CALLBACKS;
pub type PFS_FILTER_CALLBACKS = *mut _FS_FILTER_CALLBACKS;
unsafe extern "C" {
    pub fn FsRtlRegisterFileSystemFilterCallbacks(
        FilterDriverObject: *mut _DRIVER_OBJECT,
        Callbacks: PFS_FILTER_CALLBACKS,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlNotifyStreamFileObject(
        StreamFileObject: *mut _FILE_OBJECT,
        DeviceObjectHint: *mut _DEVICE_OBJECT,
        NotificationType: FS_FILTER_STREAM_FO_NOTIFICATION_TYPE,
        SafeToRecurse: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub static mut IoStatisticsLock: KSPIN_LOCK;
}
unsafe extern "C" {
    pub static mut IoReadOperationCount: ULONG;
}
unsafe extern "C" {
    pub static mut IoWriteOperationCount: ULONG;
}
unsafe extern "C" {
    pub static mut IoOtherOperationCount: ULONG;
}
unsafe extern "C" {
    pub static mut IoReadTransferCount: LARGE_INTEGER;
}
unsafe extern "C" {
    pub static mut IoWriteTransferCount: LARGE_INTEGER;
}
unsafe extern "C" {
    pub static mut IoOtherTransferCount: LARGE_INTEGER;
}
unsafe extern "C" {
    pub fn IoAcquireVpbSpinLock(Irql: PKIRQL);
}
unsafe extern "C" {
    pub fn IoCheckDesiredAccess(
        DesiredAccess: PACCESS_MASK,
        GrantedAccess: ACCESS_MASK,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoCheckEaBufferValidity(
        EaBuffer: PFILE_FULL_EA_INFORMATION,
        EaLength: ULONG,
        ErrorOffset: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoCheckFunctionAccess(
        GrantedAccess: ACCESS_MASK,
        MajorFunction: UCHAR,
        MinorFunction: UCHAR,
        IoControlCode: ULONG,
        Arg1: PVOID,
        Arg2: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoCheckQuerySetFileInformation(
        FileInformationClass: FILE_INFORMATION_CLASS,
        Length: ULONG,
        SetOperation: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoCheckQuerySetVolumeInformation(
        FsInformationClass: FS_INFORMATION_CLASS,
        Length: ULONG,
        SetOperation: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoCheckQuotaBufferValidity(
        QuotaBuffer: PFILE_QUOTA_INFORMATION,
        QuotaLength: ULONG,
        ErrorOffset: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoCreateStreamFileObject(
        FileObject: PFILE_OBJECT,
        DeviceObject: PDEVICE_OBJECT,
    ) -> PFILE_OBJECT;
}
unsafe extern "C" {
    pub fn IoCreateStreamFileObjectEx(
        FileObject: PFILE_OBJECT,
        DeviceObject: PDEVICE_OBJECT,
        FileHandle: PHANDLE,
    ) -> PFILE_OBJECT;
}
unsafe extern "C" {
    pub fn IoCreateStreamFileObjectLite(
        FileObject: PFILE_OBJECT,
        DeviceObject: PDEVICE_OBJECT,
    ) -> PFILE_OBJECT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_CREATE_STREAM_FILE_OPTIONS {
    pub Size: USHORT,
    pub Flags: USHORT,
    pub TargetDeviceObject: PDEVICE_OBJECT,
}
pub type IO_CREATE_STREAM_FILE_OPTIONS = _IO_CREATE_STREAM_FILE_OPTIONS;
pub type PIO_CREATE_STREAM_FILE_OPTIONS = *mut _IO_CREATE_STREAM_FILE_OPTIONS;
unsafe extern "C" {
    pub fn IoCreateStreamFileObjectEx2(
        CreateOptions: PIO_CREATE_STREAM_FILE_OPTIONS,
        FileObject: PFILE_OBJECT,
        DeviceObject: PDEVICE_OBJECT,
        StreamFileObject: *mut PFILE_OBJECT,
        FileHandle: PHANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoFastQueryNetworkAttributes(
        ObjectAttributes: POBJECT_ATTRIBUTES,
        DesiredAccess: ACCESS_MASK,
        OpenOptions: ULONG,
        IoStatus: PIO_STATUS_BLOCK,
        Buffer: PFILE_NETWORK_OPEN_INFORMATION,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn IoPageRead(
        FileObject: PFILE_OBJECT,
        MemoryDescriptorList: PMDL,
        StartingOffset: PLARGE_INTEGER,
        Event: PKEVENT,
        IoStatusBlock: PIO_STATUS_BLOCK,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoGetAttachedDevice(DeviceObject: PDEVICE_OBJECT) -> PDEVICE_OBJECT;
}
unsafe extern "C" {
    pub fn IoGetBaseFileSystemDeviceObject(FileObject: PFILE_OBJECT) -> PDEVICE_OBJECT;
}
unsafe extern "C" {
    pub fn IoGetDeviceToVerify(Thread: PETHREAD) -> PDEVICE_OBJECT;
}
unsafe extern "C" {
    pub fn IoGetRequestorProcessId(Irp: PIRP) -> ULONG;
}
unsafe extern "C" {
    pub fn IoGetRequestorProcess(Irp: PIRP) -> PEPROCESS;
}
unsafe extern "C" {
    pub fn IoIsOperationSynchronous(Irp: PIRP) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn IoIsSystemThread(Thread: PETHREAD) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn IoIsValidNameGraftingBuffer(Irp: PIRP, ReparseBuffer: PREPARSE_DATA_BUFFER) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn IoQueryFileDosDeviceName(
        FileObject: PFILE_OBJECT,
        ObjectNameInformation: *mut POBJECT_NAME_INFORMATION,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoQueryFileInformation(
        FileObject: PFILE_OBJECT,
        FileInformationClass: FILE_INFORMATION_CLASS,
        Length: ULONG,
        FileInformation: PVOID,
        ReturnedLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoQueryVolumeInformation(
        FileObject: PFILE_OBJECT,
        FsInformationClass: FS_INFORMATION_CLASS,
        Length: ULONG,
        FsInformation: PVOID,
        ReturnedLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoQueueThreadIrp(Irp: PIRP);
}
unsafe extern "C" {
    pub fn IoRegisterFileSystem(DeviceObject: PDEVICE_OBJECT);
}
unsafe extern "C" {
    pub fn IoRegisterFsRegistrationChange(
        DriverObject: PDRIVER_OBJECT,
        DriverNotificationRoutine: PDRIVER_FS_NOTIFICATION,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoRegisterFsRegistrationChangeMountAware(
        DriverObject: PDRIVER_OBJECT,
        DriverNotificationRoutine: PDRIVER_FS_NOTIFICATION,
        SynchronizeWithMounts: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoEnumerateRegisteredFiltersList(
        DriverObjectList: *mut PDRIVER_OBJECT,
        DriverObjectListSize: ULONG,
        ActualNumberDriverObjects: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoReplaceFileObjectName(
        FileObject: PFILE_OBJECT,
        NewFileName: PWSTR,
        FileNameLength: USHORT,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoReleaseVpbSpinLock(Irql: KIRQL);
}
unsafe extern "C" {
    pub fn IoSetDeviceToVerify(Thread: PETHREAD, DeviceObject: PDEVICE_OBJECT);
}
unsafe extern "C" {
    pub fn IoSetInformation(
        FileObject: PFILE_OBJECT,
        FileInformationClass: FILE_INFORMATION_CLASS,
        Length: ULONG,
        FileInformation: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoSynchronousPageWrite(
        FileObject: PFILE_OBJECT,
        MemoryDescriptorList: PMDL,
        StartingOffset: PLARGE_INTEGER,
        Event: PKEVENT,
        IoStatusBlock: PIO_STATUS_BLOCK,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoThreadToProcess(Thread: PETHREAD) -> PEPROCESS;
}
unsafe extern "C" {
    pub fn IoUnregisterFileSystem(DeviceObject: PDEVICE_OBJECT);
}
unsafe extern "C" {
    pub fn IoUnregisterFsRegistrationChange(
        DriverObject: PDRIVER_OBJECT,
        DriverNotificationRoutine: PDRIVER_FS_NOTIFICATION,
    );
}
unsafe extern "C" {
    pub fn IoVerifyVolume(DeviceObject: PDEVICE_OBJECT, AllowRawMount: BOOLEAN) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoGetRequestorSessionId(Irp: PIRP, pSessionId: PULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoEnumerateDeviceObjectList(
        DriverObject: PDRIVER_OBJECT,
        DeviceObjectList: *mut PDEVICE_OBJECT,
        DeviceObjectListSize: ULONG,
        ActualNumberDeviceObjects: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoGetLowerDeviceObject(DeviceObject: PDEVICE_OBJECT) -> PDEVICE_OBJECT;
}
unsafe extern "C" {
    pub fn IoGetDeviceAttachmentBaseRef(DeviceObject: PDEVICE_OBJECT) -> PDEVICE_OBJECT;
}
unsafe extern "C" {
    pub fn IoGetDiskDeviceObject(
        FileSystemDeviceObject: PDEVICE_OBJECT,
        DiskDeviceObject: *mut PDEVICE_OBJECT,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_PRIORITY_INFO {
    pub Size: ULONG,
    pub ThreadPriority: ULONG,
    pub PagePriority: ULONG,
    pub IoPriority: IO_PRIORITY_HINT,
}
pub type IO_PRIORITY_INFO = _IO_PRIORITY_INFO;
pub type PIO_PRIORITY_INFO = *mut _IO_PRIORITY_INFO;
unsafe extern "C" {
    pub fn IoRetrievePriorityInfo(
        Irp: PIRP,
        FileObject: PFILE_OBJECT,
        Thread: PETHREAD,
        PriorityInfo: PIO_PRIORITY_INFO,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoApplyPriorityInfoThread(
        InputPriorityInfo: PIO_PRIORITY_INFO,
        OutputPriorityInfo: PIO_PRIORITY_INFO,
        Thread: PETHREAD,
    ) -> NTSTATUS;
}
pub type PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        SourceContext: *mut _IO_IRP_EXT_TRACK_OFFSET_HEADER,
        TargetContext: *mut _IO_IRP_EXT_TRACK_OFFSET_HEADER,
        RelativeOffset: LONGLONG,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_IRP_EXT_TRACK_OFFSET_HEADER {
    pub Validation: USHORT,
    pub Flags: USHORT,
    pub TrackedOffsetCallback: PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK,
}
pub type IO_IRP_EXT_TRACK_OFFSET_HEADER = _IO_IRP_EXT_TRACK_OFFSET_HEADER;
pub type PIO_IRP_EXT_TRACK_OFFSET_HEADER = *mut _IO_IRP_EXT_TRACK_OFFSET_HEADER;
unsafe extern "C" {
    pub fn IoGetFsTrackOffsetState(
        Irp: PIRP,
        RetFsTrackOffsetBlob: *mut PIO_IRP_EXT_TRACK_OFFSET_HEADER,
        RetTrackedOffset: *mut LONGLONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoSetFsTrackOffsetState(
        Irp: PIRP,
        FsTrackOffsetBlob: PIO_IRP_EXT_TRACK_OFFSET_HEADER,
        TrackedOffset: LONGLONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoClearFsTrackOffsetState(Irp: PIRP) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoIrpHasFsTrackOffsetExtensionType(Irp: PIRP) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn PoQueueShutdownWorkItem(WorkItem: PWORK_QUEUE_ITEM) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmIsRecursiveIoFault() -> BOOLEAN;
}
unsafe extern "C" {
    pub fn MmForceSectionClosed(
        SectionObjectPointer: PSECTION_OBJECT_POINTERS,
        DelayClose: BOOLEAN,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn MmForceSectionClosedEx(
        SectionObjectPointer: PSECTION_OBJECT_POINTERS,
        ForceCloseFlags: ULONG,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn MmGetMaximumFileSectionSize() -> ULONGLONG;
}
pub const _MMFLUSH_TYPE_MmFlushForDelete: _MMFLUSH_TYPE = 0;
pub const _MMFLUSH_TYPE_MmFlushForWrite: _MMFLUSH_TYPE = 1;
pub type _MMFLUSH_TYPE = core::ffi::c_int;
pub use self::_MMFLUSH_TYPE as MMFLUSH_TYPE;
unsafe extern "C" {
    pub fn MmFlushImageSection(
        SectionObjectPointer: PSECTION_OBJECT_POINTERS,
        FlushType: MMFLUSH_TYPE,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn MmCanFileBeTruncated(
        SectionPointer: PSECTION_OBJECT_POINTERS,
        NewFileSize: PLARGE_INTEGER,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn MmSetAddressRangeModified(Address: PVOID, Length: SIZE_T) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn MmIsFileSectionActive(
        FsSectionPointer: PSECTION_OBJECT_POINTERS,
        Flags: ULONG,
        SectionIsActive: PLOGICAL,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _READ_LIST {
    pub FileObject: PFILE_OBJECT,
    pub NumberOfEntries: ULONG,
    pub IsImage: LOGICAL,
    pub List: [FILE_SEGMENT_ELEMENT; 1usize],
}
pub type READ_LIST = _READ_LIST;
pub type PREAD_LIST = *mut _READ_LIST;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MM_PREFETCH_FLAGS {
    pub Flags: _MM_PREFETCH_FLAGS__bindgen_ty_1,
    pub AllFlags: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MM_PREFETCH_FLAGS__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _MM_PREFETCH_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn Priority(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Priority(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Priority_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Priority_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RepurposePriority(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_RepurposePriority(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RepurposePriority_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RepurposePriority_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PriorityProtection(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PriorityProtection(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PriorityProtection_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PriorityProtection_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn MustBeZero(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_MustBeZero(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MustBeZero_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MustBeZero_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CannotBeUsedAsFlags(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_CannotBeUsedAsFlags(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CannotBeUsedAsFlags_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                23u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CannotBeUsedAsFlags_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                23u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Priority: ULONG,
        RepurposePriority: ULONG,
        PriorityProtection: ULONG,
        MustBeZero: ULONG,
        CannotBeUsedAsFlags: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let Priority: u32 = unsafe { ::core::mem::transmute(Priority) };
            Priority as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let RepurposePriority: u32 = unsafe { ::core::mem::transmute(RepurposePriority) };
            RepurposePriority as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PriorityProtection: u32 = unsafe { ::core::mem::transmute(PriorityProtection) };
            PriorityProtection as u64
        });
        __bindgen_bitfield_unit.set(7usize, 2u8, {
            let MustBeZero: u32 = unsafe { ::core::mem::transmute(MustBeZero) };
            MustBeZero as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let CannotBeUsedAsFlags: u32 = unsafe { ::core::mem::transmute(CannotBeUsedAsFlags) };
            CannotBeUsedAsFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type MM_PREFETCH_FLAGS = _MM_PREFETCH_FLAGS;
pub type PMM_PREFETCH_FLAGS = *mut _MM_PREFETCH_FLAGS;
unsafe extern "C" {
    pub fn MmPrefetchPages(NumberOfLists: ULONG, ReadLists: *mut PREAD_LIST) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MmDoesFileHaveUserWritableReferences(SectionPointer: PSECTION_OBJECT_POINTERS) -> ULONG;
}
unsafe extern "C" {
    pub fn MmMdlPagesAreZero(Mdl: PMDL) -> LOGICAL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PHYSICAL_MEMORY_RUN {
    pub BasePage: PFN_NUMBER,
    pub PageCount: PFN_NUMBER,
}
pub type PHYSICAL_MEMORY_RUN = _PHYSICAL_MEMORY_RUN;
pub type PPHYSICAL_MEMORY_RUN = *mut _PHYSICAL_MEMORY_RUN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PHYSICAL_MEMORY_DESCRIPTOR {
    pub NumberOfRuns: ULONG,
    pub NumberOfPages: PFN_NUMBER,
    pub Run: [PHYSICAL_MEMORY_RUN; 1usize],
}
pub type PHYSICAL_MEMORY_DESCRIPTOR = _PHYSICAL_MEMORY_DESCRIPTOR;
pub type PPHYSICAL_MEMORY_DESCRIPTOR = *mut _PHYSICAL_MEMORY_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PHYSICAL_EXTENTS_DESCRIPTOR {
    pub NumberOfRuns: ULONG,
    pub NumberOfValidRuns: ULONG,
    pub Run: [PHYSICAL_MEMORY_RUN; 1usize],
}
pub type PHYSICAL_EXTENTS_DESCRIPTOR = _PHYSICAL_EXTENTS_DESCRIPTOR;
pub type PPHYSICAL_EXTENTS_DESCRIPTOR = *mut _PHYSICAL_EXTENTS_DESCRIPTOR;
unsafe extern "C" {
    pub fn ObInsertObject(
        Object: PVOID,
        PassedAccessState: PACCESS_STATE,
        DesiredAccess: ACCESS_MASK,
        ObjectPointerBias: ULONG,
        NewObject: *mut PVOID,
        Handle: PHANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ObOpenObjectByPointer(
        Object: PVOID,
        HandleAttributes: ULONG,
        PassedAccessState: PACCESS_STATE,
        DesiredAccess: ACCESS_MASK,
        ObjectType: POBJECT_TYPE,
        AccessMode: KPROCESSOR_MODE,
        Handle: PHANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ObOpenObjectByPointerWithTag(
        Object: PVOID,
        HandleAttributes: ULONG,
        PassedAccessState: PACCESS_STATE,
        DesiredAccess: ACCESS_MASK,
        ObjectType: POBJECT_TYPE,
        AccessMode: KPROCESSOR_MODE,
        Tag: ULONG,
        Handle: PHANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ObMakeTemporaryObject(Object: PVOID);
}
unsafe extern "C" {
    pub fn ObQueryNameString(
        Object: PVOID,
        ObjectNameInfo: POBJECT_NAME_INFORMATION,
        Length: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ObIsKernelHandle(Handle: HANDLE) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn ObQueryObjectAuditingByHandle(Handle: HANDLE, GenerateOnClose: PBOOLEAN) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn IoRequestDeviceRemovalForReset(
        PhysicalDeviceObject: PDEVICE_OBJECT,
        Flags: ULONG,
    ) -> NTSTATUS;
}
pub type LBN = ULONG;
pub type PLBN = *mut LBN;
pub type VBN = ULONG;
pub type PVBN = *mut VBN;
pub type OPLOCK = PVOID;
pub type POPLOCK = *mut PVOID;
pub const _FAST_IO_POSSIBLE_FastIoIsNotPossible: _FAST_IO_POSSIBLE = 0;
pub const _FAST_IO_POSSIBLE_FastIoIsPossible: _FAST_IO_POSSIBLE = 1;
pub const _FAST_IO_POSSIBLE_FastIoIsQuestionable: _FAST_IO_POSSIBLE = 2;
pub type _FAST_IO_POSSIBLE = core::ffi::c_int;
pub use self::_FAST_IO_POSSIBLE as FAST_IO_POSSIBLE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FSRTL_COMMON_FCB_HEADER {
    pub NodeTypeCode: CSHORT,
    pub NodeByteSize: CSHORT,
    pub Flags: UCHAR,
    pub IsFastIoPossible: UCHAR,
    pub Flags2: UCHAR,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub Resource: PERESOURCE,
    pub PagingIoResource: PERESOURCE,
    pub AllocationSize: LARGE_INTEGER,
    pub FileSize: LARGE_INTEGER,
    pub ValidDataLength: LARGE_INTEGER,
}
impl _FSRTL_COMMON_FCB_HEADER {
    #[inline]
    pub fn Reserved(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Version(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_Version(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Version_raw(this: *const Self) -> UCHAR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Version_raw(this: *mut Self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(Reserved: UCHAR, Version: UCHAR) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let Reserved: u8 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let Version: u8 = unsafe { ::core::mem::transmute(Version) };
            Version as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type FSRTL_COMMON_FCB_HEADER = _FSRTL_COMMON_FCB_HEADER;
pub type PFSRTL_COMMON_FCB_HEADER = *mut FSRTL_COMMON_FCB_HEADER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FSRTL_ADVANCED_FCB_HEADER {
    pub __bindgen_padding_0: [u64; 6usize],
    pub FastMutex: PFAST_MUTEX,
    pub FilterContexts: LIST_ENTRY,
    pub PushLock: ULONG_PTR,
    pub FileContextSupportPointer: *mut PVOID,
    pub __bindgen_anon_1: _FSRTL_ADVANCED_FCB_HEADER__bindgen_ty_1,
    pub AePushLock: PVOID,
    pub BypassIoOpenCount: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FSRTL_ADVANCED_FCB_HEADER__bindgen_ty_1 {
    pub Oplock: OPLOCK,
    pub ReservedForRemote: PVOID,
}
pub type FSRTL_ADVANCED_FCB_HEADER = _FSRTL_ADVANCED_FCB_HEADER;
pub type PFSRTL_ADVANCED_FCB_HEADER = *mut FSRTL_ADVANCED_FCB_HEADER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EOF_WAIT_BLOCK {
    pub EofWaitLinks: LIST_ENTRY,
    pub Event: KEVENT,
}
pub type EOF_WAIT_BLOCK = _EOF_WAIT_BLOCK;
pub type PEOF_WAIT_BLOCK = *mut EOF_WAIT_BLOCK;
unsafe extern "C" {
    pub fn FsRtlCopyRead(
        FileObject: PFILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        Wait: BOOLEAN,
        LockKey: ULONG,
        Buffer: PVOID,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: PDEVICE_OBJECT,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlCopyWrite(
        FileObject: PFILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        Wait: BOOLEAN,
        LockKey: ULONG,
        Buffer: PVOID,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: PDEVICE_OBJECT,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlMdlReadEx(
        FileObject: PFILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        LockKey: ULONG,
        MdlChain: *mut PMDL,
        IoStatus: PIO_STATUS_BLOCK,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlMdlReadDev(
        FileObject: PFILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        LockKey: ULONG,
        MdlChain: *mut PMDL,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: PDEVICE_OBJECT,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlMdlReadCompleteDev(
        FileObject: PFILE_OBJECT,
        MdlChain: PMDL,
        DeviceObject: PDEVICE_OBJECT,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlPrepareMdlWriteEx(
        FileObject: PFILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        LockKey: ULONG,
        MdlChain: *mut PMDL,
        IoStatus: PIO_STATUS_BLOCK,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlPrepareMdlWriteDev(
        FileObject: PFILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        LockKey: ULONG,
        MdlChain: *mut PMDL,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: PDEVICE_OBJECT,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlMdlWriteCompleteDev(
        FileObject: PFILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        MdlChain: PMDL,
        DeviceObject: PDEVICE_OBJECT,
    ) -> BOOLEAN;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSRTL_AUXILIARY_BUFFER {
    pub Buffer: PVOID,
    pub Length: ULONG,
    pub Flags: ULONG,
    pub Mdl: PMDL,
}
pub type FSRTL_AUXILIARY_BUFFER = _FSRTL_AUXILIARY_BUFFER;
pub type PFSRTL_AUXILIARY_BUFFER = *mut FSRTL_AUXILIARY_BUFFER;
unsafe extern "C" {
    pub fn FsRtlAcquireFileExclusive(FileObject: PFILE_OBJECT);
}
unsafe extern "C" {
    pub fn FsRtlReleaseFile(FileObject: PFILE_OBJECT);
}
unsafe extern "C" {
    pub fn FsRtlGetFileSize(FileObject: PFILE_OBJECT, FileSize: PLARGE_INTEGER) -> NTSTATUS;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_LOCK_INFO {
    pub StartingByte: LARGE_INTEGER,
    pub Length: LARGE_INTEGER,
    pub ExclusiveLock: BOOLEAN,
    pub Key: ULONG,
    pub FileObject: PFILE_OBJECT,
    pub ProcessId: PVOID,
    pub EndingByte: LARGE_INTEGER,
}
pub type FILE_LOCK_INFO = _FILE_LOCK_INFO;
pub type PFILE_LOCK_INFO = *mut FILE_LOCK_INFO;
pub type PCOMPLETE_LOCK_IRP_ROUTINE =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, Irp: PIRP) -> NTSTATUS>;
pub type PUNLOCK_ROUTINE =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, FileLockInfo: PFILE_LOCK_INFO)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_LOCK {
    pub CompleteLockIrpRoutine: PCOMPLETE_LOCK_IRP_ROUTINE,
    pub UnlockRoutine: PUNLOCK_ROUTINE,
    pub FastIoIsQuestionable: BOOLEAN,
    pub SpareC: [BOOLEAN; 3usize],
    pub LockInformation: PVOID,
    pub LastReturnedLockInfo: FILE_LOCK_INFO,
    pub LastReturnedLock: PVOID,
    pub LockRequestsInProgress: LONG,
}
pub type FILE_LOCK = _FILE_LOCK;
pub type PFILE_LOCK = *mut FILE_LOCK;
unsafe extern "C" {
    pub fn FsRtlAllocateFileLock(
        CompleteLockIrpRoutine: PCOMPLETE_LOCK_IRP_ROUTINE,
        UnlockRoutine: PUNLOCK_ROUTINE,
    ) -> PFILE_LOCK;
}
unsafe extern "C" {
    pub fn FsRtlFreeFileLock(FileLock: PFILE_LOCK);
}
unsafe extern "C" {
    pub fn FsRtlInitializeFileLock(
        FileLock: PFILE_LOCK,
        CompleteLockIrpRoutine: PCOMPLETE_LOCK_IRP_ROUTINE,
        UnlockRoutine: PUNLOCK_ROUTINE,
    );
}
unsafe extern "C" {
    pub fn FsRtlUninitializeFileLock(FileLock: PFILE_LOCK);
}
unsafe extern "C" {
    pub fn FsRtlProcessFileLock(FileLock: PFILE_LOCK, Irp: PIRP, Context: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlCheckLockForReadAccess(FileLock: PFILE_LOCK, Irp: PIRP) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlCheckLockForWriteAccess(FileLock: PFILE_LOCK, Irp: PIRP) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlCheckLockForOplockRequest(
        FileLock: PFILE_LOCK,
        AllocationSize: PLARGE_INTEGER,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlFastCheckLockForRead(
        FileLock: PFILE_LOCK,
        StartingByte: PLARGE_INTEGER,
        Length: PLARGE_INTEGER,
        Key: ULONG,
        FileObject: PFILE_OBJECT,
        ProcessId: PVOID,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlFastCheckLockForWrite(
        FileLock: PFILE_LOCK,
        StartingByte: PLARGE_INTEGER,
        Length: PLARGE_INTEGER,
        Key: ULONG,
        FileObject: PVOID,
        ProcessId: PVOID,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlGetNextFileLock(FileLock: PFILE_LOCK, Restart: BOOLEAN) -> PFILE_LOCK_INFO;
}
unsafe extern "C" {
    pub fn FsRtlAreThereCurrentOrInProgressFileLocks(FileLock: PFILE_LOCK) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlAreThereWaitingFileLocks(FileLock: PFILE_LOCK) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlFastUnlockSingle(
        FileLock: PFILE_LOCK,
        FileObject: PFILE_OBJECT,
        FileOffset: *mut LARGE_INTEGER,
        Length: PLARGE_INTEGER,
        ProcessId: PEPROCESS,
        Key: ULONG,
        Context: PVOID,
        AlreadySynchronized: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlFastUnlockAll(
        FileLock: PFILE_LOCK,
        FileObject: PFILE_OBJECT,
        ProcessId: PEPROCESS,
        Context: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlFastUnlockAllByKey(
        FileLock: PFILE_LOCK,
        FileObject: PFILE_OBJECT,
        ProcessId: PEPROCESS,
        Key: ULONG,
        Context: PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlPrivateLock(
        FileLock: PFILE_LOCK,
        FileObject: PFILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: PLARGE_INTEGER,
        ProcessId: PEPROCESS,
        Key: ULONG,
        FailImmediately: BOOLEAN,
        ExclusiveLock: BOOLEAN,
        Iosb: PIO_STATUS_BLOCK,
        Irp: PIRP,
        Context: PVOID,
        AlreadySynchronized: BOOLEAN,
    ) -> BOOLEAN;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TUNNEL {
    pub Mutex: FAST_MUTEX,
    pub Cache: PRTL_SPLAY_LINKS,
    pub TimerQueue: LIST_ENTRY,
    pub NumEntries: USHORT,
}
pub type PTUNNEL = *mut TUNNEL;
unsafe extern "C" {
    pub fn FsRtlInitializeTunnelCache(Cache: *mut TUNNEL);
}
unsafe extern "C" {
    pub fn FsRtlAddToTunnelCache(
        Cache: *mut TUNNEL,
        DirectoryKey: ULONGLONG,
        ShortName: *mut UNICODE_STRING,
        LongName: *mut UNICODE_STRING,
        KeyByShortName: BOOLEAN,
        DataLength: ULONG,
        Data: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    pub fn FsRtlFindInTunnelCache(
        Cache: *mut TUNNEL,
        DirectoryKey: ULONGLONG,
        Name: *mut UNICODE_STRING,
        ShortName: *mut UNICODE_STRING,
        LongName: *mut UNICODE_STRING,
        DataLength: *mut ULONG,
        Data: *mut core::ffi::c_void,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlAddToTunnelCacheEx(
        Cache: *mut TUNNEL,
        DirectoryKey: ULONGLONG,
        ShortName: *mut UNICODE_STRING,
        LongName: *mut UNICODE_STRING,
        Flags: ULONG,
        DataLength: ULONG,
        Data: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    pub fn FsRtlFindInTunnelCacheEx(
        Cache: *mut TUNNEL,
        DirectoryKey: ULONGLONG,
        Name: *mut UNICODE_STRING,
        ShortName: *mut UNICODE_STRING,
        LongName: *mut UNICODE_STRING,
        Flags: ULONG,
        DataLength: *mut ULONG,
        Data: *mut core::ffi::c_void,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlDeleteKeyFromTunnelCache(Cache: *mut TUNNEL, DirectoryKey: ULONGLONG);
}
unsafe extern "C" {
    pub fn FsRtlDeleteTunnelCache(Cache: *mut TUNNEL);
}
pub const _FSRTL_COMPARISON_RESULT_LessThan: _FSRTL_COMPARISON_RESULT = -1;
pub const _FSRTL_COMPARISON_RESULT_EqualTo: _FSRTL_COMPARISON_RESULT = 0;
pub const _FSRTL_COMPARISON_RESULT_GreaterThan: _FSRTL_COMPARISON_RESULT = 1;
pub type _FSRTL_COMPARISON_RESULT = core::ffi::c_int;
pub use self::_FSRTL_COMPARISON_RESULT as FSRTL_COMPARISON_RESULT;
unsafe extern "C" {
    pub static mut FsRtlLegalAnsiCharacterArray: *const *const UCHAR;
}
unsafe extern "C" {
    pub static mut NlsOemLeadByteInfo: *mut PUSHORT;
}
unsafe extern "C" {
    pub fn FsRtlDissectDbcs(
        Path: ANSI_STRING,
        FirstName: PANSI_STRING,
        RemainingName: PANSI_STRING,
    );
}
unsafe extern "C" {
    pub fn FsRtlDoesDbcsContainWildCards(Name: PANSI_STRING) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlIsDbcsInExpression(Expression: PANSI_STRING, Name: PANSI_STRING) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlIsFatDbcsLegal(
        DbcsName: ANSI_STRING,
        WildCardsPermissible: BOOLEAN,
        PathNamePermissible: BOOLEAN,
        LeadingBackslashPermissible: BOOLEAN,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlIsHpfsDbcsLegal(
        DbcsName: ANSI_STRING,
        WildCardsPermissible: BOOLEAN,
        PathNamePermissible: BOOLEAN,
        LeadingBackslashPermissible: BOOLEAN,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlNormalizeNtstatus(Exception: NTSTATUS, GenericException: NTSTATUS) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlIsNtstatusExpected(Exception: NTSTATUS) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlAllocateResource() -> PERESOURCE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BASE_MCB {
    pub MaximumPairCount: ULONG,
    pub PairCount: ULONG,
    pub PoolType: USHORT,
    pub Flags: USHORT,
    pub Mapping: PVOID,
}
pub type BASE_MCB = _BASE_MCB;
pub type PBASE_MCB = *mut _BASE_MCB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_MCB {
    pub GuardedMutex: PKGUARDED_MUTEX,
    pub BaseMcb: BASE_MCB,
}
pub type LARGE_MCB = _LARGE_MCB;
pub type PLARGE_MCB = *mut _LARGE_MCB;
unsafe extern "C" {
    pub fn FsRtlInitializeLargeMcb(Mcb: PLARGE_MCB, PoolType: POOL_TYPE);
}
unsafe extern "C" {
    pub fn FsRtlUninitializeLargeMcb(Mcb: PLARGE_MCB);
}
unsafe extern "C" {
    pub fn FsRtlResetLargeMcb(Mcb: PLARGE_MCB, SelfSynchronized: BOOLEAN);
}
unsafe extern "C" {
    pub fn FsRtlTruncateLargeMcb(Mcb: PLARGE_MCB, Vbn: LONGLONG);
}
unsafe extern "C" {
    pub fn FsRtlAddLargeMcbEntry(
        Mcb: PLARGE_MCB,
        Vbn: LONGLONG,
        Lbn: LONGLONG,
        SectorCount: LONGLONG,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlRemoveLargeMcbEntry(Mcb: PLARGE_MCB, Vbn: LONGLONG, SectorCount: LONGLONG);
}
unsafe extern "C" {
    pub fn FsRtlLookupLargeMcbEntry(
        Mcb: PLARGE_MCB,
        Vbn: LONGLONG,
        Lbn: PLONGLONG,
        SectorCountFromLbn: PLONGLONG,
        StartingLbn: PLONGLONG,
        SectorCountFromStartingLbn: PLONGLONG,
        Index: PULONG,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlLookupLastLargeMcbEntry(Mcb: PLARGE_MCB, Vbn: PLONGLONG, Lbn: PLONGLONG)
                                        -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlLookupLastLargeMcbEntryAndIndex(
        OpaqueMcb: PLARGE_MCB,
        LargeVbn: PLONGLONG,
        LargeLbn: PLONGLONG,
        Index: PULONG,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlNumberOfRunsInLargeMcb(Mcb: PLARGE_MCB) -> ULONG;
}
unsafe extern "C" {
    pub fn FsRtlGetNextLargeMcbEntry(
        Mcb: PLARGE_MCB,
        RunIndex: ULONG,
        Vbn: PLONGLONG,
        Lbn: PLONGLONG,
        SectorCount: PLONGLONG,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlSplitLargeMcb(Mcb: PLARGE_MCB, Vbn: LONGLONG, Amount: LONGLONG) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlInitializeBaseMcb(Mcb: PBASE_MCB, PoolType: POOL_TYPE);
}
unsafe extern "C" {
    pub fn FsRtlInitializeBaseMcbEx(Mcb: PBASE_MCB, PoolType: POOL_TYPE, Flags: USHORT) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlUninitializeBaseMcb(Mcb: PBASE_MCB);
}
unsafe extern "C" {
    pub fn FsRtlResetBaseMcb(Mcb: PBASE_MCB);
}
unsafe extern "C" {
    pub fn FsRtlTruncateBaseMcb(Mcb: PBASE_MCB, Vbn: LONGLONG);
}
unsafe extern "C" {
    pub fn FsRtlAddBaseMcbEntry(
        Mcb: PBASE_MCB,
        Vbn: LONGLONG,
        Lbn: LONGLONG,
        SectorCount: LONGLONG,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlAddBaseMcbEntryEx(
        Mcb: PBASE_MCB,
        Vbn: LONGLONG,
        Lbn: LONGLONG,
        SectorCount: LONGLONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlRemoveBaseMcbEntry(Mcb: PBASE_MCB, Vbn: LONGLONG, SectorCount: LONGLONG)
                                   -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlLookupBaseMcbEntry(
        Mcb: PBASE_MCB,
        Vbn: LONGLONG,
        Lbn: PLONGLONG,
        SectorCountFromLbn: PLONGLONG,
        StartingLbn: PLONGLONG,
        SectorCountFromStartingLbn: PLONGLONG,
        Index: PULONG,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlLookupLastBaseMcbEntry(Mcb: PBASE_MCB, Vbn: PLONGLONG, Lbn: PLONGLONG) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlLookupLastBaseMcbEntryAndIndex(
        OpaqueMcb: PBASE_MCB,
        LargeVbn: PLONGLONG,
        LargeLbn: PLONGLONG,
        Index: PULONG,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlNumberOfRunsInBaseMcb(Mcb: PBASE_MCB) -> ULONG;
}
unsafe extern "C" {
    pub fn FsRtlGetNextBaseMcbEntry(
        Mcb: PBASE_MCB,
        RunIndex: ULONG,
        Vbn: PLONGLONG,
        Lbn: PLONGLONG,
        SectorCount: PLONGLONG,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlSplitBaseMcb(Mcb: PBASE_MCB, Vbn: LONGLONG, Amount: LONGLONG) -> BOOLEAN;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MCB {
    pub DummyFieldThatSizesThisStructureCorrectly: LARGE_MCB,
}
pub type MCB = _MCB;
pub type PMCB = *mut MCB;
unsafe extern "C" {
    pub fn FsRtlInitializeMcb(Mcb: PMCB, PoolType: POOL_TYPE);
}
unsafe extern "C" {
    pub fn FsRtlUninitializeMcb(Mcb: PMCB);
}
unsafe extern "C" {
    pub fn FsRtlTruncateMcb(Mcb: PMCB, Vbn: VBN);
}
unsafe extern "C" {
    pub fn FsRtlAddMcbEntry(Mcb: PMCB, Vbn: VBN, Lbn: LBN, SectorCount: ULONG) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlRemoveMcbEntry(Mcb: PMCB, Vbn: VBN, SectorCount: ULONG);
}
unsafe extern "C" {
    pub fn FsRtlLookupMcbEntry(
        Mcb: PMCB,
        Vbn: VBN,
        Lbn: PLBN,
        SectorCount: PULONG,
        Index: PULONG,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlLookupLastMcbEntry(Mcb: PMCB, Vbn: PVBN, Lbn: PLBN) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlNumberOfRunsInMcb(Mcb: PMCB) -> ULONG;
}
unsafe extern "C" {
    pub fn FsRtlGetNextMcbEntry(
        Mcb: PMCB,
        RunIndex: ULONG,
        Vbn: PVBN,
        Lbn: PLBN,
        SectorCount: PULONG,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlBalanceReads(TargetDevice: PDEVICE_OBJECT) -> NTSTATUS;
}
pub type POPLOCK_WAIT_COMPLETE_ROUTINE =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, Irp: PIRP)>;
pub type POPLOCK_FS_PREPOST_IRP =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, Irp: PIRP)>;
unsafe extern "C" {
    pub fn FsRtlInitializeOplock(Oplock: POPLOCK);
}
unsafe extern "C" {
    pub fn FsRtlUninitializeOplock(Oplock: POPLOCK);
}
unsafe extern "C" {
    pub fn FsRtlOplockFsctrl(Oplock: POPLOCK, Irp: PIRP, OpenCount: ULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlCheckOplock(
        Oplock: POPLOCK,
        Irp: PIRP,
        Context: PVOID,
        CompletionRoutine: POPLOCK_WAIT_COMPLETE_ROUTINE,
        PostIrpRoutine: POPLOCK_FS_PREPOST_IRP,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlCheckOplockEx(
        Oplock: POPLOCK,
        Irp: PIRP,
        Flags: ULONG,
        Context: PVOID,
        CompletionRoutine: POPLOCK_WAIT_COMPLETE_ROUTINE,
        PostIrpRoutine: POPLOCK_FS_PREPOST_IRP,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlCheckUpperOplock(
        Oplock: POPLOCK,
        NewLowerOplockState: ULONG,
        CompletionRoutineContext: PVOID,
        CompletionRoutine: POPLOCK_WAIT_COMPLETE_ROUTINE,
        PrePendRoutine: POPLOCK_FS_PREPOST_IRP,
        Flags: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlUpperOplockFsctrl(
        Oplock: POPLOCK,
        Irp: PIRP,
        OpenCount: ULONG,
        LowerOplockState: ULONG,
        Flags: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlOplockIsFastIoPossible(Oplock: POPLOCK) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlCurrentBatchOplock(Oplock: POPLOCK) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlCurrentOplock(Oplock: POPLOCK) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlOplockBreakToNone(
        Oplock: POPLOCK,
        IrpSp: PIO_STACK_LOCATION,
        Irp: PIRP,
        Context: PVOID,
        CompletionRoutine: POPLOCK_WAIT_COMPLETE_ROUTINE,
        PostIrpRoutine: POPLOCK_FS_PREPOST_IRP,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OPLOCK_KEY_ECP_CONTEXT {
    pub OplockKey: GUID,
    pub Reserved: ULONG,
}
pub type OPLOCK_KEY_ECP_CONTEXT = _OPLOCK_KEY_ECP_CONTEXT;
unsafe extern "C" {
    pub static GUID_ECP_OPLOCK_KEY: GUID;
}
unsafe extern "C" {
    pub fn FsRtlOplockIsSharedRequest(Irp: PIRP) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlOplockBreakH(
        Oplock: POPLOCK,
        Irp: PIRP,
        Flags: ULONG,
        Context: PVOID,
        CompletionRoutine: POPLOCK_WAIT_COMPLETE_ROUTINE,
        PostIrpRoutine: POPLOCK_FS_PREPOST_IRP,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlOplockBreakH2(
        Oplock: POPLOCK,
        Irp: PIRP,
        Flags: ULONG,
        Context: PVOID,
        CompletionRoutine: POPLOCK_WAIT_COMPLETE_ROUTINE,
        PostIrpRoutine: POPLOCK_FS_PREPOST_IRP,
        GrantedAccess: PACCESS_MASK,
        ShareAccess: PUSHORT,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlCurrentOplockH(Oplock: POPLOCK) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlOplockBreakToNoneEx(
        Oplock: POPLOCK,
        Irp: PIRP,
        Flags: ULONG,
        Context: PVOID,
        CompletionRoutine: POPLOCK_WAIT_COMPLETE_ROUTINE,
        PostIrpRoutine: POPLOCK_FS_PREPOST_IRP,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlOplockFsctrlEx(
        Oplock: POPLOCK,
        Irp: PIRP,
        OpenCount: ULONG,
        Flags: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlOplockKeysEqual(Fo1: PFILE_OBJECT, Fo2: PFILE_OBJECT) -> BOOLEAN;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DUAL_OPLOCK_KEY_ECP_CONTEXT {
    pub ParentOplockKey: GUID,
    pub TargetOplockKey: GUID,
    pub ParentOplockKeySet: BOOLEAN,
    pub TargetOplockKeySet: BOOLEAN,
}
pub type DUAL_OPLOCK_KEY_ECP_CONTEXT = _DUAL_OPLOCK_KEY_ECP_CONTEXT;
pub type PDUAL_OPLOCK_KEY_ECP_CONTEXT = *mut _DUAL_OPLOCK_KEY_ECP_CONTEXT;
unsafe extern "C" {
    pub static GUID_ECP_DUAL_OPLOCK_KEY: GUID;
}
unsafe extern "C" {
    pub fn FsRtlNotifyVolumeEvent(FileObject: PFILE_OBJECT, EventCode: ULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlNotifyVolumeEventEx(
        FileObject: PFILE_OBJECT,
        EventCode: ULONG,
        Event: PTARGET_DEVICE_CUSTOM_NOTIFICATION,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REAL_NOTIFY_SYNC {
    _unused: [u8; 0],
}
pub type PNOTIFY_SYNC = *mut _REAL_NOTIFY_SYNC;
pub type PCHECK_FOR_TRAVERSE_ACCESS = ::core::option::Option<
    unsafe extern "C" fn(
        NotifyContext: PVOID,
        TargetContext: PVOID,
        SubjectContext: PSECURITY_SUBJECT_CONTEXT,
    ) -> BOOLEAN,
>;
pub type PFILTER_REPORT_CHANGE = ::core::option::Option<
    unsafe extern "C" fn(NotifyContext: PVOID, FilterContext: PVOID) -> BOOLEAN,
>;
unsafe extern "C" {
    pub fn FsRtlNotifyInitializeSync(NotifySync: *mut PNOTIFY_SYNC);
}
unsafe extern "C" {
    pub fn FsRtlNotifyUninitializeSync(NotifySync: *mut PNOTIFY_SYNC);
}
unsafe extern "C" {
    pub fn FsRtlNotifyFullChangeDirectory(
        NotifySync: PNOTIFY_SYNC,
        NotifyList: PLIST_ENTRY,
        FsContext: PVOID,
        FullDirectoryName: PSTRING,
        WatchTree: BOOLEAN,
        IgnoreBuffer: BOOLEAN,
        CompletionFilter: ULONG,
        NotifyIrp: PIRP,
        TraverseCallback: PCHECK_FOR_TRAVERSE_ACCESS,
        SubjectContext: PSECURITY_SUBJECT_CONTEXT,
    );
}
unsafe extern "C" {
    pub fn FsRtlNotifyFilterChangeDirectory(
        NotifySync: PNOTIFY_SYNC,
        NotifyList: PLIST_ENTRY,
        FsContext: PVOID,
        FullDirectoryName: PSTRING,
        WatchTree: BOOLEAN,
        IgnoreBuffer: BOOLEAN,
        CompletionFilter: ULONG,
        NotifyIrp: PIRP,
        TraverseCallback: PCHECK_FOR_TRAVERSE_ACCESS,
        SubjectContext: PSECURITY_SUBJECT_CONTEXT,
        FilterCallback: PFILTER_REPORT_CHANGE,
    );
}
unsafe extern "C" {
    pub fn FsRtlNotifyFilterReportChange(
        NotifySync: PNOTIFY_SYNC,
        NotifyList: PLIST_ENTRY,
        FullTargetName: PSTRING,
        TargetNameOffset: USHORT,
        StreamName: PSTRING,
        NormalizedParentName: PSTRING,
        FilterMatch: ULONG,
        Action: ULONG,
        TargetContext: PVOID,
        FilterContext: PVOID,
    );
}
unsafe extern "C" {
    pub fn FsRtlNotifyFullReportChange(
        NotifySync: PNOTIFY_SYNC,
        NotifyList: PLIST_ENTRY,
        FullTargetName: PSTRING,
        TargetNameOffset: USHORT,
        StreamName: PSTRING,
        NormalizedParentName: PSTRING,
        FilterMatch: ULONG,
        Action: ULONG,
        TargetContext: PVOID,
    );
}
unsafe extern "C" {
    pub fn FsRtlNotifyCleanup(NotifySync: PNOTIFY_SYNC, NotifyList: PLIST_ENTRY, FsContext: PVOID);
}
unsafe extern "C" {
    pub fn FsRtlNotifyCleanupAll(NotifySync: PNOTIFY_SYNC, NotifyList: PLIST_ENTRY);
}
unsafe extern "C" {
    pub fn FsRtlDissectName(
        Path: UNICODE_STRING,
        FirstName: PUNICODE_STRING,
        RemainingName: PUNICODE_STRING,
    );
}
unsafe extern "C" {
    pub fn FsRtlDoesNameContainWildCards(Name: PUNICODE_STRING) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlAreNamesEqual(
        ConstantNameA: PCUNICODE_STRING,
        ConstantNameB: PCUNICODE_STRING,
        IgnoreCase: BOOLEAN,
        UpcaseTable: PCWCH,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlIsNameInExpression(
        Expression: PUNICODE_STRING,
        Name: PUNICODE_STRING,
        IgnoreCase: BOOLEAN,
        UpcaseTable: PWCH,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlIsNameInUnUpcasedExpression(
        Expression: PUNICODE_STRING,
        Name: PUNICODE_STRING,
        IgnoreCase: BOOLEAN,
        UpcaseTable: PWCH,
    ) -> BOOLEAN;
}
pub type PFSRTL_STACK_OVERFLOW_ROUTINE =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, Event: PKEVENT)>;
unsafe extern "C" {
    pub fn FsRtlPostStackOverflow(
        Context: PVOID,
        Event: PKEVENT,
        StackOverflowRoutine: PFSRTL_STACK_OVERFLOW_ROUTINE,
    );
}
unsafe extern "C" {
    pub fn FsRtlPostPagingFileStackOverflow(
        Context: PVOID,
        Event: PKEVENT,
        StackOverflowRoutine: PFSRTL_STACK_OVERFLOW_ROUTINE,
    );
}
unsafe extern "C" {
    pub fn FsRtlRegisterUncProvider(
        MupHandle: PHANDLE,
        RedirectorDeviceName: PCUNICODE_STRING,
        MailslotsSupported: BOOLEAN,
    ) -> NTSTATUS;
}
pub type FSRTL_UNC_PROVIDER_FLAGS = ULONG;
unsafe extern "C" {
    pub fn FsRtlRegisterUncProviderEx(
        MupHandle: PHANDLE,
        RedirDevName: PCUNICODE_STRING,
        DeviceObject: PDEVICE_OBJECT,
        Flags: FSRTL_UNC_PROVIDER_FLAGS,
    ) -> NTSTATUS;
}
pub type FSRTL_UNC_HARDENING_CAPABILITIES = ULONG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FSRTL_UNC_PROVIDER_REGISTRATION {
    pub Size: USHORT,
    pub Version: USHORT,
    pub __bindgen_anon_1: _FSRTL_UNC_PROVIDER_REGISTRATION__bindgen_ty_1,
    pub __bindgen_anon_2: _FSRTL_UNC_PROVIDER_REGISTRATION__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FSRTL_UNC_PROVIDER_REGISTRATION__bindgen_ty_1 {
    pub ProviderFlags: FSRTL_UNC_PROVIDER_FLAGS,
    pub __bindgen_anon_1: _FSRTL_UNC_PROVIDER_REGISTRATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _FSRTL_UNC_PROVIDER_REGISTRATION__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _FSRTL_UNC_PROVIDER_REGISTRATION__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn MailslotsSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MailslotsSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn MailslotsSupported_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_MailslotsSupported_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CscEnabled(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CscEnabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CscEnabled_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CscEnabled_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DomainSvcAware(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DomainSvcAware(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DomainSvcAware_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DomainSvcAware_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ContainersAware(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ContainersAware(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ContainersAware_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ContainersAware_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MailslotsSupported: ULONG,
        CscEnabled: ULONG,
        DomainSvcAware: ULONG,
        ContainersAware: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let MailslotsSupported: u32 = unsafe { ::core::mem::transmute(MailslotsSupported) };
            MailslotsSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CscEnabled: u32 = unsafe { ::core::mem::transmute(CscEnabled) };
            CscEnabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DomainSvcAware: u32 = unsafe { ::core::mem::transmute(DomainSvcAware) };
            DomainSvcAware as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ContainersAware: u32 = unsafe { ::core::mem::transmute(ContainersAware) };
            ContainersAware as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FSRTL_UNC_PROVIDER_REGISTRATION__bindgen_ty_2 {
    pub HardeningCapabilities: FSRTL_UNC_HARDENING_CAPABILITIES,
    pub __bindgen_anon_1: _FSRTL_UNC_PROVIDER_REGISTRATION__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _FSRTL_UNC_PROVIDER_REGISTRATION__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _FSRTL_UNC_PROVIDER_REGISTRATION__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn SupportsMutualAuth(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SupportsMutualAuth(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SupportsMutualAuth_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SupportsMutualAuth_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SupportsIntegrity(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SupportsIntegrity(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SupportsIntegrity_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SupportsIntegrity_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SupportsPrivacy(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SupportsPrivacy(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SupportsPrivacy_raw(this: *const Self) -> ULONG {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SupportsPrivacy_raw(this: *mut Self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SupportsMutualAuth: ULONG,
        SupportsIntegrity: ULONG,
        SupportsPrivacy: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SupportsMutualAuth: u32 = unsafe { ::core::mem::transmute(SupportsMutualAuth) };
            SupportsMutualAuth as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SupportsIntegrity: u32 = unsafe { ::core::mem::transmute(SupportsIntegrity) };
            SupportsIntegrity as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SupportsPrivacy: u32 = unsafe { ::core::mem::transmute(SupportsPrivacy) };
            SupportsPrivacy as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type FSRTL_UNC_PROVIDER_REGISTRATION = _FSRTL_UNC_PROVIDER_REGISTRATION;
pub type PFSRTL_UNC_PROVIDER_REGISTRATION = *mut _FSRTL_UNC_PROVIDER_REGISTRATION;
unsafe extern "C" {
    pub fn FsRtlRegisterUncProviderEx2(
        RedirDevName: PCUNICODE_STRING,
        DeviceObject: PDEVICE_OBJECT,
        Registration: *const FSRTL_UNC_PROVIDER_REGISTRATION,
        MupHandle: PHANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlDeregisterUncProvider(Handle: HANDLE);
}
unsafe extern "C" {
    pub fn FsRtlCancellableWaitForSingleObject(
        Object: PVOID,
        Timeout: PLARGE_INTEGER,
        Irp: PIRP,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlCancellableWaitForMultipleObjects(
        Count: ULONG,
        ObjectArray: *mut PVOID,
        WaitType: WAIT_TYPE,
        Timeout: PLARGE_INTEGER,
        WaitBlockArray: PKWAIT_BLOCK,
        Irp: PIRP,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlMupGetProviderInfoFromFileObject(
        pFileObject: PFILE_OBJECT,
        Level: ULONG,
        pBuffer: PVOID,
        pBufferSize: PULONG,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSRTL_MUP_PROVIDER_INFO_LEVEL_1 {
    pub ProviderId: ULONG32,
}
pub type FSRTL_MUP_PROVIDER_INFO_LEVEL_1 = _FSRTL_MUP_PROVIDER_INFO_LEVEL_1;
pub type PFSRTL_MUP_PROVIDER_INFO_LEVEL_1 = *mut _FSRTL_MUP_PROVIDER_INFO_LEVEL_1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSRTL_MUP_PROVIDER_INFO_LEVEL_2 {
    pub ProviderId: ULONG32,
    pub ProviderName: UNICODE_STRING,
}
pub type FSRTL_MUP_PROVIDER_INFO_LEVEL_2 = _FSRTL_MUP_PROVIDER_INFO_LEVEL_2;
pub type PFSRTL_MUP_PROVIDER_INFO_LEVEL_2 = *mut _FSRTL_MUP_PROVIDER_INFO_LEVEL_2;
unsafe extern "C" {
    pub fn FsRtlMupGetProviderIdFromName(
        pProviderName: PCUNICODE_STRING,
        pProviderId: PULONG32,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSRTL_PER_FILE_CONTEXT {
    pub Links: LIST_ENTRY,
    pub OwnerId: PVOID,
    pub InstanceId: PVOID,
    pub FreeCallback: PFREE_FUNCTION,
}
pub type FSRTL_PER_FILE_CONTEXT = _FSRTL_PER_FILE_CONTEXT;
pub type PFSRTL_PER_FILE_CONTEXT = *mut _FSRTL_PER_FILE_CONTEXT;
unsafe extern "C" {
    pub fn FsRtlInsertPerFileContext(
        PerFileContextPointer: *mut PVOID,
        Ptr: PFSRTL_PER_FILE_CONTEXT,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlLookupPerFileContext(
        PerFileContextPointer: *mut PVOID,
        OwnerId: PVOID,
        InstanceId: PVOID,
    ) -> PFSRTL_PER_FILE_CONTEXT;
}
unsafe extern "C" {
    pub fn FsRtlRemovePerFileContext(
        PerFileContextPointer: *mut PVOID,
        OwnerId: PVOID,
        InstanceId: PVOID,
    ) -> PFSRTL_PER_FILE_CONTEXT;
}
unsafe extern "C" {
    pub fn FsRtlTeardownPerFileContexts(PerFileContextPointer: *mut PVOID);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSRTL_PER_STREAM_CONTEXT {
    pub Links: LIST_ENTRY,
    pub OwnerId: PVOID,
    pub InstanceId: PVOID,
    pub FreeCallback: PFREE_FUNCTION,
}
pub type FSRTL_PER_STREAM_CONTEXT = _FSRTL_PER_STREAM_CONTEXT;
pub type PFSRTL_PER_STREAM_CONTEXT = *mut _FSRTL_PER_STREAM_CONTEXT;
unsafe extern "C" {
    pub fn FsRtlInsertPerStreamContext(
        PerStreamContext: PFSRTL_ADVANCED_FCB_HEADER,
        Ptr: PFSRTL_PER_STREAM_CONTEXT,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlLookupPerStreamContextInternal(
        StreamContext: PFSRTL_ADVANCED_FCB_HEADER,
        OwnerId: PVOID,
        InstanceId: PVOID,
    ) -> PFSRTL_PER_STREAM_CONTEXT;
}
unsafe extern "C" {
    pub fn FsRtlRemovePerStreamContext(
        StreamContext: PFSRTL_ADVANCED_FCB_HEADER,
        OwnerId: PVOID,
        InstanceId: PVOID,
    ) -> PFSRTL_PER_STREAM_CONTEXT;
}
unsafe extern "C" {
    pub fn FsRtlAllocateAePushLock(PoolType: POOL_TYPE, Tag: ULONG) -> PVOID;
}
unsafe extern "C" {
    pub fn FsRtlFreeAePushLock(AePushLock: PVOID);
}
unsafe extern "C" {
    pub fn FsRtlTeardownPerStreamContexts(AdvancedHeader: PFSRTL_ADVANCED_FCB_HEADER);
}
pub type PFN_FSRTLTEARDOWNPERSTREAMCONTEXTS =
::core::option::Option<unsafe extern "C" fn(AdvancedHeader: PFSRTL_ADVANCED_FCB_HEADER)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSRTL_PER_FILEOBJECT_CONTEXT {
    pub Links: LIST_ENTRY,
    pub OwnerId: PVOID,
    pub InstanceId: PVOID,
}
pub type FSRTL_PER_FILEOBJECT_CONTEXT = _FSRTL_PER_FILEOBJECT_CONTEXT;
pub type PFSRTL_PER_FILEOBJECT_CONTEXT = *mut _FSRTL_PER_FILEOBJECT_CONTEXT;
unsafe extern "C" {
    pub fn FsRtlInsertPerFileObjectContext(
        FileObject: PFILE_OBJECT,
        Ptr: PFSRTL_PER_FILEOBJECT_CONTEXT,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlLookupPerFileObjectContext(
        FileObject: PFILE_OBJECT,
        OwnerId: PVOID,
        InstanceId: PVOID,
    ) -> PFSRTL_PER_FILEOBJECT_CONTEXT;
}
unsafe extern "C" {
    pub fn FsRtlRemovePerFileObjectContext(
        FileObject: PFILE_OBJECT,
        OwnerId: PVOID,
        InstanceId: PVOID,
    ) -> PFSRTL_PER_FILEOBJECT_CONTEXT;
}
unsafe extern "C" {
    pub fn FsRtlIncrementCcFastReadNotPossible();
}
unsafe extern "C" {
    pub fn FsRtlIncrementCcFastReadWait();
}
unsafe extern "C" {
    pub fn FsRtlIncrementCcFastReadNoWait();
}
unsafe extern "C" {
    pub fn FsRtlIncrementCcFastReadResourceMiss();
}
unsafe extern "C" {
    pub fn FsRtlIncrementCcFastMdlReadWait();
}
unsafe extern "C" {
    pub fn FsRtlIsPagingFile(FileObject: PFILE_OBJECT) -> LOGICAL;
}
unsafe extern "C" {
    pub fn FsRtlIsSystemPagingFile(FileObject: PFILE_OBJECT) -> LOGICAL;
}
unsafe extern "C" {
    pub fn FsRtlCreateSectionForDataScan(
        SectionHandle: PHANDLE,
        SectionObject: *mut PVOID,
        SectionFileSize: PLARGE_INTEGER,
        FileObject: PFILE_OBJECT,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        MaximumSize: PLARGE_INTEGER,
        SectionPageProtection: ULONG,
        AllocationAttributes: ULONG,
        Flags: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlValidateReparsePointBuffer(
        BufferLength: ULONG,
        ReparseBuffer: PREPARSE_DATA_BUFFER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlRemoveDotsFromPath(
        OriginalString: PWSTR,
        PathLength: USHORT,
        NewLength: *mut USHORT,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlIsNonEmptyDirectoryReparsePointAllowed(ReparseTag: ULONG) -> BOOLEAN;
}
pub type ECP_LIST = _ECP_LIST;
pub type PECP_LIST = *mut _ECP_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ECP_HEADER {
    _unused: [u8; 0],
}
pub type ECP_HEADER = _ECP_HEADER;
pub type PECP_HEADER = *mut _ECP_HEADER;
pub type PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK =
::core::option::Option<unsafe extern "C" fn(EcpContext: PVOID, EcpType: LPCGUID)>;
pub type FSRTL_ALLOCATE_ECPLIST_FLAGS = ULONG;
unsafe extern "C" {
    pub fn FsRtlAllocateExtraCreateParameterList(
        Flags: FSRTL_ALLOCATE_ECPLIST_FLAGS,
        EcpList: *mut PECP_LIST,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlFreeExtraCreateParameterList(EcpList: PECP_LIST);
}
unsafe extern "C" {
    pub fn FsRtlInitializeExtraCreateParameterList(EcpList: PECP_LIST) -> NTSTATUS;
}
pub type FSRTL_ALLOCATE_ECP_FLAGS = ULONG;
unsafe extern "C" {
    pub fn FsRtlAllocateExtraCreateParameter(
        EcpType: LPCGUID,
        SizeOfContext: ULONG,
        Flags: FSRTL_ALLOCATE_ECP_FLAGS,
        CleanupCallback: PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK,
        PoolTag: ULONG,
        EcpContext: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlFreeExtraCreateParameter(EcpContext: PVOID);
}
unsafe extern "C" {
    pub fn FsRtlInitializeExtraCreateParameter(
        Ecp: PECP_HEADER,
        EcpFlags: ULONG,
        CleanupCallback: PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK,
        TotalSize: ULONG,
        EcpType: LPCGUID,
        ListAllocatedFrom: PVOID,
    );
}
pub type FSRTL_ECP_LOOKASIDE_FLAGS = ULONG;
unsafe extern "C" {
    pub fn FsRtlInitExtraCreateParameterLookasideList(
        Lookaside: PVOID,
        Flags: FSRTL_ECP_LOOKASIDE_FLAGS,
        Size: SIZE_T,
        Tag: ULONG,
    );
}
unsafe extern "C" {
    pub fn FsRtlDeleteExtraCreateParameterLookasideList(
        Lookaside: PVOID,
        Flags: FSRTL_ECP_LOOKASIDE_FLAGS,
    );
}
unsafe extern "C" {
    pub fn FsRtlAllocateExtraCreateParameterFromLookasideList(
        EcpType: LPCGUID,
        SizeOfContext: ULONG,
        Flags: FSRTL_ALLOCATE_ECP_FLAGS,
        CleanupCallback: PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK,
        LookasideList: PVOID,
        EcpContext: *mut PVOID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlInsertExtraCreateParameter(EcpList: PECP_LIST, EcpContext: PVOID) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlFindExtraCreateParameter(
        EcpList: PECP_LIST,
        EcpType: LPCGUID,
        EcpContext: *mut PVOID,
        EcpContextSize: *mut ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlRemoveExtraCreateParameter(
        EcpList: PECP_LIST,
        EcpType: LPCGUID,
        EcpContext: *mut PVOID,
        EcpContextSize: *mut ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlGetEcpListFromIrp(Irp: PIRP, EcpList: *mut PECP_LIST) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlSetEcpListIntoIrp(Irp: PIRP, EcpList: PECP_LIST) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlGetNextExtraCreateParameter(
        EcpList: PECP_LIST,
        CurrentEcpContext: PVOID,
        NextEcpType: LPGUID,
        NextEcpContext: *mut PVOID,
        NextEcpContextSize: *mut ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlAcknowledgeEcp(EcpContext: PVOID);
}
unsafe extern "C" {
    pub fn FsRtlPrepareToReuseEcp(EcpContext: PVOID);
}
unsafe extern "C" {
    pub fn FsRtlIsEcpAcknowledged(EcpContext: PVOID) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlIsEcpFromUserMode(EcpContext: PVOID) -> BOOLEAN;
}
pub const NETWORK_OPEN_LOCATION_QUALIFIER_NetworkOpenLocationAny: NETWORK_OPEN_LOCATION_QUALIFIER =
    0;
pub const NETWORK_OPEN_LOCATION_QUALIFIER_NetworkOpenLocationRemote:
NETWORK_OPEN_LOCATION_QUALIFIER = 1;
pub const NETWORK_OPEN_LOCATION_QUALIFIER_NetworkOpenLocationLoopback:
NETWORK_OPEN_LOCATION_QUALIFIER = 2;
pub type NETWORK_OPEN_LOCATION_QUALIFIER = core::ffi::c_int;
pub const NETWORK_OPEN_INTEGRITY_QUALIFIER_NetworkOpenIntegrityAny:
NETWORK_OPEN_INTEGRITY_QUALIFIER = 0;
pub const NETWORK_OPEN_INTEGRITY_QUALIFIER_NetworkOpenIntegrityNone:
NETWORK_OPEN_INTEGRITY_QUALIFIER = 1;
pub const NETWORK_OPEN_INTEGRITY_QUALIFIER_NetworkOpenIntegritySigned:
NETWORK_OPEN_INTEGRITY_QUALIFIER = 2;
pub const NETWORK_OPEN_INTEGRITY_QUALIFIER_NetworkOpenIntegrityEncrypted:
NETWORK_OPEN_INTEGRITY_QUALIFIER = 3;
pub const NETWORK_OPEN_INTEGRITY_QUALIFIER_NetworkOpenIntegrityMaximum:
NETWORK_OPEN_INTEGRITY_QUALIFIER = 4;
pub type NETWORK_OPEN_INTEGRITY_QUALIFIER = core::ffi::c_int;
pub type NETWORK_OPEN_IN_FLAGS = ULONG;
pub type NETWORK_OPEN_OUT_FLAGS = ULONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NETWORK_OPEN_ECP_CONTEXT {
    pub Size: USHORT,
    pub Reserved: USHORT,
    pub __bindgen_anon_1: _NETWORK_OPEN_ECP_CONTEXT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NETWORK_OPEN_ECP_CONTEXT__bindgen_ty_1 {
    pub in_: _NETWORK_OPEN_ECP_CONTEXT__bindgen_ty_1__bindgen_ty_1,
    pub out: _NETWORK_OPEN_ECP_CONTEXT__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NETWORK_OPEN_ECP_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    pub Location: NETWORK_OPEN_LOCATION_QUALIFIER,
    pub Integrity: NETWORK_OPEN_INTEGRITY_QUALIFIER,
    pub Flags: NETWORK_OPEN_IN_FLAGS,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NETWORK_OPEN_ECP_CONTEXT__bindgen_ty_1__bindgen_ty_2 {
    pub Location: NETWORK_OPEN_LOCATION_QUALIFIER,
    pub Integrity: NETWORK_OPEN_INTEGRITY_QUALIFIER,
    pub Flags: NETWORK_OPEN_OUT_FLAGS,
}
pub type NETWORK_OPEN_ECP_CONTEXT = _NETWORK_OPEN_ECP_CONTEXT;
pub type PNETWORK_OPEN_ECP_CONTEXT = *mut _NETWORK_OPEN_ECP_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NETWORK_OPEN_ECP_CONTEXT_V0 {
    pub Size: USHORT,
    pub Reserved: USHORT,
    pub __bindgen_anon_1: _NETWORK_OPEN_ECP_CONTEXT_V0__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NETWORK_OPEN_ECP_CONTEXT_V0__bindgen_ty_1 {
    pub in_: _NETWORK_OPEN_ECP_CONTEXT_V0__bindgen_ty_1__bindgen_ty_1,
    pub out: _NETWORK_OPEN_ECP_CONTEXT_V0__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NETWORK_OPEN_ECP_CONTEXT_V0__bindgen_ty_1__bindgen_ty_1 {
    pub Location: NETWORK_OPEN_LOCATION_QUALIFIER,
    pub Integrity: NETWORK_OPEN_INTEGRITY_QUALIFIER,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NETWORK_OPEN_ECP_CONTEXT_V0__bindgen_ty_1__bindgen_ty_2 {
    pub Location: NETWORK_OPEN_LOCATION_QUALIFIER,
    pub Integrity: NETWORK_OPEN_INTEGRITY_QUALIFIER,
}
pub type NETWORK_OPEN_ECP_CONTEXT_V0 = _NETWORK_OPEN_ECP_CONTEXT_V0;
pub type PNETWORK_OPEN_ECP_CONTEXT_V0 = *mut _NETWORK_OPEN_ECP_CONTEXT_V0;
unsafe extern "C" {
    pub static GUID_ECP_NETWORK_OPEN_CONTEXT: GUID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NETWORK_APP_INSTANCE_ECP_CONTEXT {
    pub Size: USHORT,
    pub Reserved: USHORT,
    pub AppInstanceID: GUID,
}
pub type NETWORK_APP_INSTANCE_ECP_CONTEXT = _NETWORK_APP_INSTANCE_ECP_CONTEXT;
pub type PNETWORK_APP_INSTANCE_ECP_CONTEXT = *mut _NETWORK_APP_INSTANCE_ECP_CONTEXT;
unsafe extern "C" {
    pub static GUID_ECP_NETWORK_APP_INSTANCE: GUID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NETWORK_APP_INSTANCE_VERSION_ECP_CONTEXT {
    pub Size: USHORT,
    pub Reserved: USHORT,
    pub VersionHigh: UINT64,
    pub VersionLow: UINT64,
}
pub type NETWORK_APP_INSTANCE_VERSION_ECP_CONTEXT = _NETWORK_APP_INSTANCE_VERSION_ECP_CONTEXT;
pub type PNETWORK_APP_INSTANCE_VERSION_ECP_CONTEXT = *mut _NETWORK_APP_INSTANCE_VERSION_ECP_CONTEXT;
unsafe extern "C" {
    pub static GUID_ECP_NETWORK_APP_INSTANCE_VERSION: GUID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PREFETCH_OPEN_ECP_CONTEXT {
    pub Context: PVOID,
}
pub type PREFETCH_OPEN_ECP_CONTEXT = _PREFETCH_OPEN_ECP_CONTEXT;
pub type PPREFETCH_OPEN_ECP_CONTEXT = *mut _PREFETCH_OPEN_ECP_CONTEXT;
unsafe extern "C" {
    pub static GUID_ECP_PREFETCH_OPEN: GUID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    _unused: [u8; 0],
}
pub type PSOCKADDR_STORAGE_NFS = *mut sockaddr_storage;
unsafe extern "C" {
    pub static GUID_ECP_NFS_OPEN: GUID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NFS_OPEN_ECP_CONTEXT {
    pub ExportAlias: PUNICODE_STRING,
    pub ClientSocketAddress: PSOCKADDR_STORAGE_NFS,
}
pub type NFS_OPEN_ECP_CONTEXT = _NFS_OPEN_ECP_CONTEXT;
pub type PNFS_OPEN_ECP_CONTEXT = *mut _NFS_OPEN_ECP_CONTEXT;
pub type PPNFS_OPEN_ECP_CONTEXT = *mut *mut _NFS_OPEN_ECP_CONTEXT;
unsafe extern "C" {
    pub static GUID_ECP_SRV_OPEN: GUID;
}
pub const _SRV_INSTANCE_TYPE_SrvInstanceTypeUndefined: _SRV_INSTANCE_TYPE = 0;
pub const _SRV_INSTANCE_TYPE_SrvInstanceTypePrimary: _SRV_INSTANCE_TYPE = 1;
pub const _SRV_INSTANCE_TYPE_SrvInstanceTypeCsv: _SRV_INSTANCE_TYPE = 2;
pub const _SRV_INSTANCE_TYPE_SrvInstanceTypeSBL: _SRV_INSTANCE_TYPE = 3;
pub const _SRV_INSTANCE_TYPE_SrvInstanceTypeSR: _SRV_INSTANCE_TYPE = 4;
pub const _SRV_INSTANCE_TYPE_SrvInstanceTypeVSMB: _SRV_INSTANCE_TYPE = 5;
pub type _SRV_INSTANCE_TYPE = core::ffi::c_int;
pub use self::_SRV_INSTANCE_TYPE as SRV_INSTANCE_TYPE;
pub type PSRV_INSTANCE_TYPE = *mut _SRV_INSTANCE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SRV_OPEN_ECP_CONTEXT {
    pub ShareName: PUNICODE_STRING,
    pub SocketAddress: PSOCKADDR_STORAGE_NFS,
    pub OplockBlockState: BOOLEAN,
    pub OplockAppState: BOOLEAN,
    pub OplockFinalState: BOOLEAN,
    pub Version: USHORT,
    pub InstanceType: SRV_INSTANCE_TYPE,
}
pub type SRV_OPEN_ECP_CONTEXT = _SRV_OPEN_ECP_CONTEXT;
pub type PSRV_OPEN_ECP_CONTEXT = *mut _SRV_OPEN_ECP_CONTEXT;
unsafe extern "C" {
    pub static GUID_ECP_RKF_BYPASS: GUID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RKF_BYPASS_ECP_CONTEXT {
    pub Reserved: INT,
    pub Version: INT,
}
pub type RKF_BYPASS_ECP_CONTEXT = _RKF_BYPASS_ECP_CONTEXT;
pub type PRKF_BYPASS_ECP_CONTEXT = *mut _RKF_BYPASS_ECP_CONTEXT;
unsafe extern "C" {
    pub static GUID_ECP_IO_DEVICE_HINT: GUID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_DEVICE_HINT_ECP_CONTEXT {
    pub TargetDevice: PDEVICE_OBJECT,
    pub RemainingName: UNICODE_STRING,
}
pub type IO_DEVICE_HINT_ECP_CONTEXT = _IO_DEVICE_HINT_ECP_CONTEXT;
pub type PIO_DEVICE_HINT_ECP_CONTEXT = *mut _IO_DEVICE_HINT_ECP_CONTEXT;
unsafe extern "C" {
    pub static GUID_ECP_CSV_DOWN_LEVEL_OPEN: GUID;
}
pub const _CSV_DOWN_LEVEL_FILE_TYPE_CsvDownLevelFileObject: _CSV_DOWN_LEVEL_FILE_TYPE = 0;
pub const _CSV_DOWN_LEVEL_FILE_TYPE_CsvCsvFsInternalFileObject: _CSV_DOWN_LEVEL_FILE_TYPE = 1;
pub type _CSV_DOWN_LEVEL_FILE_TYPE = core::ffi::c_int;
pub use self::_CSV_DOWN_LEVEL_FILE_TYPE as CSV_DOWN_LEVEL_FILE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CSV_DOWN_LEVEL_OPEN_ECP_CONTEXT {
    pub Version: ULONG,
    pub IsResume: BOOLEAN,
    pub FileType: CSV_DOWN_LEVEL_FILE_TYPE,
    pub SourceNodeId: ULONG,
    pub DestinationNodeId: ULONG,
}
pub type CSV_DOWN_LEVEL_OPEN_ECP_CONTEXT = _CSV_DOWN_LEVEL_OPEN_ECP_CONTEXT;
pub type PCSV_DOWN_LEVEL_OPEN_ECP_CONTEXT = *mut _CSV_DOWN_LEVEL_OPEN_ECP_CONTEXT;
unsafe extern "C" {
    pub static GUID_ECP_CSV_QUERY_FILE_REVISION: GUID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CSV_QUERY_FILE_REVISION_ECP_CONTEXT {
    pub FileId: LONGLONG,
    pub FileRevision: [LONGLONG; 3usize],
}
pub type CSV_QUERY_FILE_REVISION_ECP_CONTEXT = _CSV_QUERY_FILE_REVISION_ECP_CONTEXT;
pub type PCSV_QUERY_FILE_REVISION_ECP_CONTEXT = *mut _CSV_QUERY_FILE_REVISION_ECP_CONTEXT;
unsafe extern "C" {
    pub static GUID_ECP_CSV_QUERY_FILE_REVISION_FILE_ID_128: GUID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CSV_QUERY_FILE_REVISION_ECP_CONTEXT_FILE_ID_128 {
    pub FileId: FILE_ID_128,
    pub FileRevision: [LONGLONG; 3usize],
}
pub type CSV_QUERY_FILE_REVISION_ECP_CONTEXT_FILE_ID_128 =
_CSV_QUERY_FILE_REVISION_ECP_CONTEXT_FILE_ID_128;
pub type PCSV_QUERY_FILE_REVISION_ECP_CONTEXT_FILE_ID_128 =
*mut _CSV_QUERY_FILE_REVISION_ECP_CONTEXT_FILE_ID_128;
unsafe extern "C" {
    pub static GUID_ECP_CSV_SET_HANDLE_PROPERTIES: GUID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CSV_SET_HANDLE_PROPERTIES_ECP_CONTEXT {
    pub Size: SIZE_T,
    pub PauseTimeoutInSeconds: ULONG,
    pub Flags: ULONG,
}
pub type CSV_SET_HANDLE_PROPERTIES_ECP_CONTEXT = _CSV_SET_HANDLE_PROPERTIES_ECP_CONTEXT;
pub type PCSV_SET_HANDLE_PROPERTIES_ECP_CONTEXT = *mut _CSV_SET_HANDLE_PROPERTIES_ECP_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OPEN_REPARSE_LIST_ENTRY {
    pub OpenReparseListEntry: LIST_ENTRY,
    pub ReparseTag: ULONG,
    pub Flags: ULONG,
    pub ReparseGuid: GUID,
    pub Size: USHORT,
    pub RemainingLength: USHORT,
}
pub type OPEN_REPARSE_LIST_ENTRY = _OPEN_REPARSE_LIST_ENTRY;
pub type POPEN_REPARSE_LIST_ENTRY = *mut _OPEN_REPARSE_LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OPEN_REPARSE_LIST {
    pub OpenReparseList: LIST_ENTRY,
}
pub type OPEN_REPARSE_LIST = _OPEN_REPARSE_LIST;
pub type POPEN_REPARSE_LIST = *mut _OPEN_REPARSE_LIST;
unsafe extern "C" {
    pub static ECP_TYPE_OPEN_REPARSE_GUID: GUID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STOP_ON_SYMLINK_FILTER_ECP_v0 {
    pub Out: _IO_STOP_ON_SYMLINK_FILTER_ECP_v0__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STOP_ON_SYMLINK_FILTER_ECP_v0__bindgen_ty_1 {
    pub ReparseCount: ULONG,
    pub RemainingPathLength: ULONG,
}
pub type IO_STOP_ON_SYMLINK_FILTER_ECP_v0 = _IO_STOP_ON_SYMLINK_FILTER_ECP_v0;
pub type PIO_STOP_ON_SYMLINK_FILTER_ECP_v0 = *mut _IO_STOP_ON_SYMLINK_FILTER_ECP_v0;
unsafe extern "C" {
    pub static ECP_TYPE_IO_STOP_ON_SYMLINK_FILTER_GUID: GUID;
}
unsafe extern "C" {
    pub static ECP_TYPE_CLFS_CREATE_CONTAINER: GUID;
}
unsafe extern "C" {
    pub static GUID_ECP_CREATE_REDIRECTION: GUID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CREATE_REDIRECTION_ECP_CONTEXT {
    pub Size: USHORT,
    pub Flags: USHORT,
    pub FileId: FILE_ID_128,
    pub VolumeGuid: GUID,
}
pub type CREATE_REDIRECTION_ECP_CONTEXT = _CREATE_REDIRECTION_ECP_CONTEXT;
pub type PCREATE_REDIRECTION_ECP_CONTEXT = *mut _CREATE_REDIRECTION_ECP_CONTEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_TIMESTAMPS {
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
}
pub type FILE_TIMESTAMPS = _FILE_TIMESTAMPS;
pub type PFILE_TIMESTAMPS = *mut _FILE_TIMESTAMPS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ATOMIC_CREATE_ECP_CONTEXT {
    pub Size: USHORT,
    pub InFlags: USHORT,
    pub OutFlags: USHORT,
    pub ReparseBufferLength: USHORT,
    pub ReparseBuffer: PREPARSE_DATA_BUFFER,
    pub FileSize: LONGLONG,
    pub ValidDataLength: LONGLONG,
    pub FileTimestamps: PFILE_TIMESTAMPS,
    pub FileAttributes: ULONG,
    pub UsnSourceInfo: ULONG,
    pub Usn: USN,
    pub SuppressFileAttributeInheritanceMask: ULONG,
    pub InOpFlags: ULONG,
    pub OutOpFlags: ULONG,
    pub InGenFlags: ULONG,
    pub OutGenFlags: ULONG,
    pub CaseSensitiveFlagsMask: ULONG,
    pub InCaseSensitiveFlags: ULONG,
    pub OutCaseSensitiveFlags: ULONG,
}
pub type ATOMIC_CREATE_ECP_CONTEXT = _ATOMIC_CREATE_ECP_CONTEXT;
pub type PATOMIC_CREATE_ECP_CONTEXT = *mut _ATOMIC_CREATE_ECP_CONTEXT;
unsafe extern "C" {
    pub static GUID_ECP_ATOMIC_CREATE: GUID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ECP_OPEN_PARAMETERS {
    pub Size: USHORT,
    pub Reserved: USHORT,
    pub Flags: ULONG,
}
pub type ECP_OPEN_PARAMETERS = _ECP_OPEN_PARAMETERS;
pub type PECP_OPEN_PARAMETERS = *mut _ECP_OPEN_PARAMETERS;
unsafe extern "C" {
    pub static GUID_ECP_OPEN_PARAMETERS: GUID;
}
unsafe extern "C" {
    pub fn FsRtlOplockGetAnyBreakOwnerProcess(Oplock: POPLOCK) -> PEPROCESS;
}
pub const OPLOCK_NOTIFY_REASON_OPLOCK_NOTIFY_BREAK_WAIT_INTERIM_TIMEOUT: OPLOCK_NOTIFY_REASON = 0;
pub const OPLOCK_NOTIFY_REASON_OPLOCK_NOTIFY_BREAK_WAIT_TERMINATED: OPLOCK_NOTIFY_REASON = 1;
pub type OPLOCK_NOTIFY_REASON = core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OPLOCK_NOTIFY_PARAMS {
    pub NotifyReason: OPLOCK_NOTIFY_REASON,
    pub NotifyContext: PVOID,
    pub Irp: PIRP,
    pub Status: NTSTATUS,
}
pub type OPLOCK_NOTIFY_PARAMS = _OPLOCK_NOTIFY_PARAMS;
pub type POPLOCK_NOTIFY_PARAMS = *mut _OPLOCK_NOTIFY_PARAMS;
pub type POPLOCK_NOTIFY_ROUTINE =
::core::option::Option<unsafe extern "C" fn(NotifyParams: POPLOCK_NOTIFY_PARAMS) -> NTSTATUS>;
unsafe extern "C" {
    pub fn FsRtlCheckOplockEx2(
        Oplock: POPLOCK,
        Irp: PIRP,
        Flags: ULONG,
        FlagsEx2: ULONG,
        CompletionRoutineContext: PVOID,
        CompletionRoutine: POPLOCK_WAIT_COMPLETE_ROUTINE,
        PostIrpRoutine: POPLOCK_FS_PREPOST_IRP,
        Timeout: ULONGLONG,
        NotifyContext: PVOID,
        NotifyRoutine: POPLOCK_NOTIFY_ROUTINE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlCheckOplockForFsFilterCallback(
        Oplock: POPLOCK,
        CallbackData: PVOID,
        Flags: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlGetCurrentProcessLoaderList() -> PLIST_ENTRY;
}
unsafe extern "C" {
    pub fn FsRtlIs32BitProcess(Process: PEPROCESS) -> BOOLEAN;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _QUERY_ON_CREATE_FILE_STAT_INFORMATION {
    pub FileId: LARGE_INTEGER,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub ReparseTag: ULONG,
    pub NumberOfLinks: ULONG,
}
pub type QUERY_ON_CREATE_FILE_STAT_INFORMATION = _QUERY_ON_CREATE_FILE_STAT_INFORMATION;
pub type PQUERY_ON_CREATE_FILE_STAT_INFORMATION = *mut _QUERY_ON_CREATE_FILE_STAT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _QUERY_ON_CREATE_FILE_LX_INFORMATION {
    pub EffectiveAccess: ACCESS_MASK,
    pub LxFlags: ULONG,
    pub LxUid: ULONG,
    pub LxGid: ULONG,
    pub LxMode: ULONG,
    pub LxDeviceIdMajor: ULONG,
    pub LxDeviceIdMinor: ULONG,
}
pub type QUERY_ON_CREATE_FILE_LX_INFORMATION = _QUERY_ON_CREATE_FILE_LX_INFORMATION;
pub type PQUERY_ON_CREATE_FILE_LX_INFORMATION = *mut _QUERY_ON_CREATE_FILE_LX_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _QUERY_ON_CREATE_EA_INFORMATION {
    pub EaBufferSize: ULONG,
    pub EaBuffer: PFILE_FULL_EA_INFORMATION,
}
pub type QUERY_ON_CREATE_EA_INFORMATION = _QUERY_ON_CREATE_EA_INFORMATION;
pub type PQUERY_ON_CREATE_EA_INFORMATION = *mut _QUERY_ON_CREATE_EA_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _QUERY_ON_CREATE_ECP_CONTEXT {
    pub RequestedClasses: ULONG,
    pub ClassesProcessed: ULONG,
    pub ClassesWithErrors: ULONG,
    pub ClassesWithNoData: ULONG,
    pub StatInformation: QUERY_ON_CREATE_FILE_STAT_INFORMATION,
    pub LxInformation: QUERY_ON_CREATE_FILE_LX_INFORMATION,
    pub EaInformation: QUERY_ON_CREATE_EA_INFORMATION,
}
pub type QUERY_ON_CREATE_ECP_CONTEXT = _QUERY_ON_CREATE_ECP_CONTEXT;
pub type PQUERY_ON_CREATE_ECP_CONTEXT = *mut _QUERY_ON_CREATE_ECP_CONTEXT;
unsafe extern "C" {
    pub static GUID_ECP_QUERY_ON_CREATE: GUID;
}
unsafe extern "C" {
    pub static GUID_ECP_CLOUDFILES_ATTRIBUTION: GUID;
}
pub const _FSRTL_CHANGE_BACKING_TYPE_ChangeDataControlArea: _FSRTL_CHANGE_BACKING_TYPE = 0;
pub const _FSRTL_CHANGE_BACKING_TYPE_ChangeImageControlArea: _FSRTL_CHANGE_BACKING_TYPE = 1;
pub const _FSRTL_CHANGE_BACKING_TYPE_ChangeSharedCacheMap: _FSRTL_CHANGE_BACKING_TYPE = 2;
pub type _FSRTL_CHANGE_BACKING_TYPE = core::ffi::c_int;
pub use self::_FSRTL_CHANGE_BACKING_TYPE as FSRTL_CHANGE_BACKING_TYPE;
pub type PFSRTL_CHANGE_BACKING_TYPE = *mut _FSRTL_CHANGE_BACKING_TYPE;
unsafe extern "C" {
    pub fn FsRtlChangeBackingFileObject(
        CurrentFileObject: PFILE_OBJECT,
        NewFileObject: PFILE_OBJECT,
        ChangeBackingType: FSRTL_CHANGE_BACKING_TYPE,
        Flags: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlLogCcFlushError(
        FileName: PUNICODE_STRING,
        DeviceObject: PDEVICE_OBJECT,
        SectionObjectPointer: PSECTION_OBJECT_POINTERS,
        FlushError: NTSTATUS,
        Flags: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlAreVolumeStartupApplicationsComplete() -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlQueryMaximumVirtualDiskNestingLevel() -> ULONG;
}
unsafe extern "C" {
    pub fn FsRtlGetVirtualDiskNestingLevel(
        DeviceObject: PDEVICE_OBJECT,
        NestingLevel: PULONG,
        NestingFlags: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlVolumeDeviceToCorrelationId(
        VolumeDeviceObject: PDEVICE_OBJECT,
        Guid: *mut GUID,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlIssueDeviceIoControl(
        DeviceObject: PDEVICE_OBJECT,
        IoCtl: ULONG,
        Flags: UCHAR,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
        IosbInformation: PULONG_PTR,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlGetSectorSizeInformation(
        DeviceObject: PDEVICE_OBJECT,
        SectorSizeInfo: PFILE_FS_SECTOR_SIZE_INFORMATION,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlGetSupportedFeatures(
        DeviceObject: PDEVICE_OBJECT,
        SupportedFeatures: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlKernelFsControlFile(
        FileObject: PFILE_OBJECT,
        FsControlCode: ULONG,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
        RetOutputBufferSize: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlQueryKernelEaFile(
        FileObject: PFILE_OBJECT,
        ReturnedEaData: PVOID,
        Length: ULONG,
        ReturnSingleEntry: BOOLEAN,
        EaList: PVOID,
        EaListLength: ULONG,
        EaIndex: PULONG,
        RestartScan: BOOLEAN,
        LengthReturned: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlSetKernelEaFile(
        FileObject: PFILE_OBJECT,
        EaBuffer: PVOID,
        Length: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlQueryInformationFile(
        FileObject: PFILE_OBJECT,
        FileInformation: PVOID,
        Length: ULONG,
        FileInformationClass: FILE_INFORMATION_CLASS,
        RetFileInformationSize: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlQueryCachedVdl(FileObject: PFILE_OBJECT, Vdl: PLONGLONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlUpdateDiskCounters(BytesRead: ULONG64, BytesWritten: ULONG64);
}
unsafe extern "C" {
    pub fn FsRtlDismountComplete(DeviceObject: PDEVICE_OBJECT, DismountStatus: NTSTATUS);
}
unsafe extern "C" {
    pub fn FsRtlSetDriverBacking(DriverObj: PDRIVER_OBJECT, Flags: ULONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn FsRtlIsMobileOS() -> BOOLEAN;
}
unsafe extern "C" {
    pub fn FsRtlIsExtentDangling(
        StartPage: PFN_NUMBER,
        NumberOfPages: PFN_NUMBER,
        Flags: ULONG,
    ) -> PFN_NUMBER;
}
unsafe extern "C" {
    pub fn FsRtlIsDaxVolume(FileObject: PFILE_OBJECT) -> BOOLEAN;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PUBLIC_BCB {
    pub NodeTypeCode: CSHORT,
    pub NodeByteSize: CSHORT,
    pub MappedLength: ULONG,
    pub MappedFileOffset: LARGE_INTEGER,
}
pub type PUBLIC_BCB = _PUBLIC_BCB;
pub type PPUBLIC_BCB = *mut _PUBLIC_BCB;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CC_FILE_SIZES {
    pub AllocationSize: LARGE_INTEGER,
    pub FileSize: LARGE_INTEGER,
    pub ValidDataLength: LARGE_INTEGER,
}
pub type CC_FILE_SIZES = _CC_FILE_SIZES;
pub type PCC_FILE_SIZES = *mut _CC_FILE_SIZES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _READ_AHEAD_PARAMETERS {
    pub NodeByteSize: CSHORT,
    pub Granularity: ULONG,
    pub PipelinedRequestSize: ULONG,
    pub ReadAheadGrowthPercentage: ULONG,
}
pub type READ_AHEAD_PARAMETERS = _READ_AHEAD_PARAMETERS;
pub type PREAD_AHEAD_PARAMETERS = *mut _READ_AHEAD_PARAMETERS;
pub type PACQUIRE_FOR_LAZY_WRITE =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, Wait: BOOLEAN) -> BOOLEAN>;
pub type PRELEASE_FROM_LAZY_WRITE = ::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
pub type PACQUIRE_FOR_READ_AHEAD =
::core::option::Option<unsafe extern "C" fn(Context: PVOID, Wait: BOOLEAN) -> BOOLEAN>;
pub type PRELEASE_FROM_READ_AHEAD = ::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CACHE_MANAGER_CALLBACKS {
    pub AcquireForLazyWrite: PACQUIRE_FOR_LAZY_WRITE,
    pub ReleaseFromLazyWrite: PRELEASE_FROM_LAZY_WRITE,
    pub AcquireForReadAhead: PACQUIRE_FOR_READ_AHEAD,
    pub ReleaseFromReadAhead: PRELEASE_FROM_READ_AHEAD,
}
pub type CACHE_MANAGER_CALLBACKS = _CACHE_MANAGER_CALLBACKS;
pub type PCACHE_MANAGER_CALLBACKS = *mut _CACHE_MANAGER_CALLBACKS;
pub type PACQUIRE_FOR_LAZY_WRITE_EX = ::core::option::Option<
    unsafe extern "C" fn(Context: PVOID, InFlags: ULONG, OutFlags: PULONG) -> BOOLEAN,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CACHE_MANAGER_CALLBACK_FUNCTIONS {
    pub AcquireForLazyWriteEx: PACQUIRE_FOR_LAZY_WRITE_EX,
    pub ReleaseFromLazyWrite: PRELEASE_FROM_LAZY_WRITE,
    pub AcquireForReadAhead: PACQUIRE_FOR_READ_AHEAD,
    pub ReleaseFromReadAhead: PRELEASE_FROM_READ_AHEAD,
}
pub type CACHE_MANAGER_CALLBACK_FUNCTIONS = _CACHE_MANAGER_CALLBACK_FUNCTIONS;
pub type PCACHE_MANAGER_CALLBACK_FUNCTIONS = *mut _CACHE_MANAGER_CALLBACK_FUNCTIONS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CACHE_MANAGER_CALLBACKS_EX {
    pub Version: USHORT,
    pub Size: USHORT,
    pub Functions: CACHE_MANAGER_CALLBACK_FUNCTIONS,
}
pub type CACHE_MANAGER_CALLBACKS_EX = _CACHE_MANAGER_CALLBACKS_EX;
pub type PCACHE_MANAGER_CALLBACKS_EX = *mut _CACHE_MANAGER_CALLBACKS_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CACHE_UNINITIALIZE_EVENT {
    pub Next: *mut _CACHE_UNINITIALIZE_EVENT,
    pub Event: KEVENT,
}
pub type CACHE_UNINITIALIZE_EVENT = _CACHE_UNINITIALIZE_EVENT;
pub type PCACHE_UNINITIALIZE_EVENT = *mut _CACHE_UNINITIALIZE_EVENT;
pub type PDIRTY_PAGE_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: PFILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        OldestLsn: PLARGE_INTEGER,
        NewestLsn: PLARGE_INTEGER,
        Context1: PVOID,
        Context2: PVOID,
    ),
>;
pub type PFLUSH_TO_LSN =
::core::option::Option<unsafe extern "C" fn(LogHandle: PVOID, Lsn: LARGE_INTEGER)>;
pub type PQUERY_LOG_USAGE =
::core::option::Option<unsafe extern "C" fn(LogHandle: PVOID, PercentageFull: PUSHORT)>;
pub type PASYNC_READ_COMPLETION_CALLBACK =
::core::option::Option<unsafe extern "C" fn(Context: PVOID) -> BOOLEAN>;
unsafe extern "C" {
    pub static mut CcFastMdlReadWait: ULONG;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CC_ASYNC_READ_CONTEXT {
    pub CompletionRoutine: PASYNC_READ_COMPLETION_CALLBACK,
    pub Context: PVOID,
    pub Mdl: PMDL,
    pub RequestorMode: KPROCESSOR_MODE,
    pub NestingLevel: ULONG,
}
pub type CC_ASYNC_READ_CONTEXT = _CC_ASYNC_READ_CONTEXT;
pub type PCC_ASYNC_READ_CONTEXT = *mut _CC_ASYNC_READ_CONTEXT;
unsafe extern "C" {
    pub fn CcInitializeCacheMap(
        FileObject: PFILE_OBJECT,
        FileSizes: PCC_FILE_SIZES,
        PinAccess: BOOLEAN,
        Callbacks: PCACHE_MANAGER_CALLBACKS,
        LazyWriteContext: PVOID,
    );
}
unsafe extern "C" {
    pub fn CcUninitializeCacheMap(
        FileObject: PFILE_OBJECT,
        TruncateSize: PLARGE_INTEGER,
        UninitializeEvent: PCACHE_UNINITIALIZE_EVENT,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn CcSetFileSizes(FileObject: PFILE_OBJECT, FileSizes: PCC_FILE_SIZES);
}
unsafe extern "C" {
    pub fn CcSetFileSizesEx(FileObject: PFILE_OBJECT, FileSizes: PCC_FILE_SIZES) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn CcPurgeCacheSection(
        SectionObjectPointer: PSECTION_OBJECT_POINTERS,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        Flags: ULONG,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn CcCoherencyFlushAndPurgeCache(
        SectionObjectPointer: PSECTION_OBJECT_POINTERS,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        IoStatus: PIO_STATUS_BLOCK,
        Flags: ULONG,
    );
}
unsafe extern "C" {
    pub fn CcSetDirtyPageThreshold(FileObject: PFILE_OBJECT, DirtyPageThreshold: ULONG);
}
unsafe extern "C" {
    pub fn CcFlushCache(
        SectionObjectPointer: PSECTION_OBJECT_POINTERS,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        IoStatus: PIO_STATUS_BLOCK,
    );
}
unsafe extern "C" {
    pub fn CcGetFlushedValidData(
        SectionObjectPointer: PSECTION_OBJECT_POINTERS,
        BcbListHeld: BOOLEAN,
    ) -> LARGE_INTEGER;
}
unsafe extern "C" {
    pub fn CcZeroData(
        FileObject: PFILE_OBJECT,
        StartOffset: PLARGE_INTEGER,
        EndOffset: PLARGE_INTEGER,
        Wait: BOOLEAN,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn CcRemapBcb(Bcb: PVOID) -> PVOID;
}
unsafe extern "C" {
    pub fn CcRepinBcb(Bcb: PVOID);
}
unsafe extern "C" {
    pub fn CcUnpinRepinnedBcb(Bcb: PVOID, WriteThrough: BOOLEAN, IoStatus: PIO_STATUS_BLOCK);
}
unsafe extern "C" {
    pub fn CcGetFileObjectFromSectionPtrs(
        SectionObjectPointer: PSECTION_OBJECT_POINTERS,
    ) -> PFILE_OBJECT;
}
unsafe extern "C" {
    pub fn CcGetFileObjectFromSectionPtrsRef(
        SectionObjectPointer: PSECTION_OBJECT_POINTERS,
    ) -> PFILE_OBJECT;
}
unsafe extern "C" {
    pub fn CcGetFileObjectFromBcb(Bcb: PVOID) -> PFILE_OBJECT;
}
unsafe extern "C" {
    pub fn CcCopyWriteWontFlush(
        FileObject: PFILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn CcCanIWrite(
        FileObject: PFILE_OBJECT,
        BytesToWrite: ULONG,
        Wait: BOOLEAN,
        Retrying: UCHAR,
    ) -> BOOLEAN;
}
pub type PCC_POST_DEFERRED_WRITE =
::core::option::Option<unsafe extern "C" fn(Context1: PVOID, Context2: PVOID)>;
unsafe extern "C" {
    pub fn CcDeferWrite(
        FileObject: PFILE_OBJECT,
        PostRoutine: PCC_POST_DEFERRED_WRITE,
        Context1: PVOID,
        Context2: PVOID,
        BytesToWrite: ULONG,
        Retrying: BOOLEAN,
    );
}
unsafe extern "C" {
    pub fn CcCopyRead(
        FileObject: PFILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        Wait: BOOLEAN,
        Buffer: PVOID,
        IoStatus: PIO_STATUS_BLOCK,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn CcFastCopyRead(
        FileObject: PFILE_OBJECT,
        FileOffset: ULONG,
        Length: ULONG,
        PageCount: ULONG,
        Buffer: PVOID,
        IoStatus: PIO_STATUS_BLOCK,
    );
}
unsafe extern "C" {
    pub fn CcCopyWrite(
        FileObject: PFILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        Wait: BOOLEAN,
        Buffer: PVOID,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn CcFastCopyWrite(
        FileObject: PFILE_OBJECT,
        FileOffset: ULONG,
        Length: ULONG,
        Buffer: PVOID,
    );
}
unsafe extern "C" {
    pub fn CcMdlRead(
        FileObject: PFILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        MdlChain: *mut PMDL,
        IoStatus: PIO_STATUS_BLOCK,
    );
}
unsafe extern "C" {
    pub fn CcMdlReadComplete(FileObject: PFILE_OBJECT, MdlChain: PMDL);
}
unsafe extern "C" {
    pub fn CcPrepareMdlWrite(
        FileObject: PFILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        MdlChain: *mut PMDL,
        IoStatus: PIO_STATUS_BLOCK,
    );
}
unsafe extern "C" {
    pub fn CcMdlWriteComplete(FileObject: PFILE_OBJECT, FileOffset: PLARGE_INTEGER, MdlChain: PMDL);
}
unsafe extern "C" {
    pub fn CcMdlWriteAbort(FileObject: PFILE_OBJECT, MdlChain: PMDL);
}
unsafe extern "C" {
    pub fn CcScheduleReadAhead(FileObject: PFILE_OBJECT, FileOffset: PLARGE_INTEGER, Length: ULONG);
}
unsafe extern "C" {
    pub fn CcWaitForCurrentLazyWriterActivity() -> NTSTATUS;
}
unsafe extern "C" {
    pub fn CcSetReadAheadGranularity(FileObject: PFILE_OBJECT, Granularity: ULONG);
}
unsafe extern "C" {
    pub fn CcCopyWriteEx(
        FileObject: PFILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        Wait: BOOLEAN,
        Buffer: PVOID,
        IoIssuerThread: PETHREAD,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn CcCopyReadEx(
        FileObject: PFILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        Wait: BOOLEAN,
        Buffer: PVOID,
        IoStatus: PIO_STATUS_BLOCK,
        IoIssuerThread: PETHREAD,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn CcAsyncCopyRead(
        FileObject: PFILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        Wait: BOOLEAN,
        Buffer: PVOID,
        IoStatus: PIO_STATUS_BLOCK,
        IoIssuerThread: PETHREAD,
        AsyncReadContext: PCC_ASYNC_READ_CONTEXT,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn CcScheduleReadAheadEx(
        FileObject: PFILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        IoIssuerThread: PETHREAD,
    );
}
unsafe extern "C" {
    pub fn CcInitializeCacheMapEx(
        FileObject: PFILE_OBJECT,
        FileSizes: PCC_FILE_SIZES,
        PinAccess: BOOLEAN,
        Callbacks: PCACHE_MANAGER_CALLBACKS,
        LazyWriteContext: PVOID,
        Flags: ULONG,
    );
}
unsafe extern "C" {
    pub fn CcPinRead(
        FileObject: PFILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        Flags: ULONG,
        Bcb: *mut PVOID,
        Buffer: *mut PVOID,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn CcMapData(
        FileObject: PFILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        Flags: ULONG,
        Bcb: *mut PVOID,
        Buffer: *mut PVOID,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn CcPinMappedData(
        FileObject: PFILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        Flags: ULONG,
        Bcb: *mut PVOID,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn CcPreparePinWrite(
        FileObject: PFILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        Zero: BOOLEAN,
        Flags: ULONG,
        Bcb: *mut PVOID,
        Buffer: *mut PVOID,
    ) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn CcSetDirtyPinnedData(BcbVoid: PVOID, Lsn: PLARGE_INTEGER);
}
unsafe extern "C" {
    pub fn CcUnpinData(Bcb: PVOID);
}
unsafe extern "C" {
    pub fn CcSetBcbOwnerPointer(Bcb: PVOID, OwnerPointer: PVOID);
}
unsafe extern "C" {
    pub fn CcUnpinDataForThread(Bcb: PVOID, ResourceThreadId: ERESOURCE_THREAD);
}
unsafe extern "C" {
    pub fn CcSetAdditionalCacheAttributes(
        FileObject: PFILE_OBJECT,
        DisableReadAhead: BOOLEAN,
        DisableWriteBehind: BOOLEAN,
    );
}
unsafe extern "C" {
    pub fn CcSetAdditionalCacheAttributesEx(FileObject: PFILE_OBJECT, Flags: ULONG);
}
unsafe extern "C" {
    pub fn CcSetParallelFlushFile(FileObject: PFILE_OBJECT, EnableParallelFlush: BOOLEAN);
}
unsafe extern "C" {
    pub fn CcSetLogHandleForFile(
        FileObject: PFILE_OBJECT,
        LogHandle: PVOID,
        FlushToLsnRoutine: PFLUSH_TO_LSN,
    );
}
unsafe extern "C" {
    pub fn CcGetDirtyPages(
        LogHandle: PVOID,
        DirtyPageRoutine: PDIRTY_PAGE_ROUTINE,
        Context1: PVOID,
        Context2: PVOID,
    ) -> LARGE_INTEGER;
}
unsafe extern "C" {
    pub fn CcIsThereDirtyData(Vpb: PVPB) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn CcIsThereDirtyDataEx(Vpb: PVPB, NumberOfDirtyPages: PULONG) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn CcIsCacheManagerCallbackNeeded(Status: NTSTATUS) -> BOOLEAN;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CC_ERROR_CALLBACK_CONTEXT {
    pub NodeByteSize: CSHORT,
    pub ErrorCode: NTSTATUS,
}
pub type CC_ERROR_CALLBACK_CONTEXT = _CC_ERROR_CALLBACK_CONTEXT;
pub type PCC_ERROR_CALLBACK_CONTEXT = *mut _CC_ERROR_CALLBACK_CONTEXT;
unsafe extern "C" {
    pub fn CcErrorCallbackRoutine(Context: PCC_ERROR_CALLBACK_CONTEXT) -> NTSTATUS;
}
pub type SEC_WCHAR = WCHAR;
pub type SEC_CHAR = CHAR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SecHandle {
    pub dwLower: ULONG_PTR,
    pub dwUpper: ULONG_PTR,
}
pub type SecHandle = _SecHandle;
pub type PSecHandle = *mut _SecHandle;
pub type CredHandle = SecHandle;
pub type PCredHandle = PSecHandle;
pub type CtxtHandle = SecHandle;
pub type PCtxtHandle = PSecHandle;
pub type _SECURITY_INTEGER = LARGE_INTEGER;
pub type SECURITY_INTEGER = LARGE_INTEGER;
pub type PSECURITY_INTEGER = *mut LARGE_INTEGER;
pub type TimeStamp = SECURITY_INTEGER;
pub type PTimeStamp = *mut SECURITY_INTEGER;
pub type SECURITY_STRING = UNICODE_STRING;
pub type PSECURITY_STRING = *mut UNICODE_STRING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SecPkgInfoW {
    pub fCapabilities: core::ffi::c_ulong,
    pub wVersion: core::ffi::c_ushort,
    pub wRPCID: core::ffi::c_ushort,
    pub cbMaxToken: core::ffi::c_ulong,
    pub Name: *mut SEC_WCHAR,
    pub Comment: *mut SEC_WCHAR,
}
pub type SecPkgInfoW = _SecPkgInfoW;
pub type PSecPkgInfoW = *mut _SecPkgInfoW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SecBuffer {
    pub cbBuffer: core::ffi::c_ulong,
    pub BufferType: core::ffi::c_ulong,
    pub pvBuffer: *mut core::ffi::c_void,
}
pub type SecBuffer = _SecBuffer;
pub type PSecBuffer = *mut _SecBuffer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SecBufferDesc {
    pub ulVersion: core::ffi::c_ulong,
    pub cBuffers: core::ffi::c_ulong,
    pub pBuffers: PSecBuffer,
}
pub type SecBufferDesc = _SecBufferDesc;
pub type PSecBufferDesc = *mut _SecBufferDesc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SEC_NEGOTIATION_INFO {
    pub Size: core::ffi::c_ulong,
    pub NameLength: core::ffi::c_ulong,
    pub Name: *mut SEC_WCHAR,
    pub Reserved: *mut core::ffi::c_void,
}
pub type SEC_NEGOTIATION_INFO = _SEC_NEGOTIATION_INFO;
pub type PSEC_NEGOTIATION_INFO = *mut _SEC_NEGOTIATION_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SEC_CHANNEL_BINDINGS {
    pub dwInitiatorAddrType: core::ffi::c_ulong,
    pub cbInitiatorLength: core::ffi::c_ulong,
    pub dwInitiatorOffset: core::ffi::c_ulong,
    pub dwAcceptorAddrType: core::ffi::c_ulong,
    pub cbAcceptorLength: core::ffi::c_ulong,
    pub dwAcceptorOffset: core::ffi::c_ulong,
    pub cbApplicationDataLength: core::ffi::c_ulong,
    pub dwApplicationDataOffset: core::ffi::c_ulong,
}
pub type SEC_CHANNEL_BINDINGS = _SEC_CHANNEL_BINDINGS;
pub type PSEC_CHANNEL_BINDINGS = *mut _SEC_CHANNEL_BINDINGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SEC_CHANNEL_BINDINGS_EX {
    pub magicNumber: core::ffi::c_ulong,
    pub flags: core::ffi::c_ulong,
    pub cbHeaderLength: core::ffi::c_ulong,
    pub cbStructureLength: core::ffi::c_ulong,
    pub dwInitiatorAddrType: core::ffi::c_ulong,
    pub cbInitiatorLength: core::ffi::c_ulong,
    pub dwInitiatorOffset: core::ffi::c_ulong,
    pub dwAcceptorAddrType: core::ffi::c_ulong,
    pub cbAcceptorLength: core::ffi::c_ulong,
    pub dwAcceptorOffset: core::ffi::c_ulong,
    pub cbApplicationDataLength: core::ffi::c_ulong,
    pub dwApplicationDataOffset: core::ffi::c_ulong,
}
pub type SEC_CHANNEL_BINDINGS_EX = _SEC_CHANNEL_BINDINGS_EX;
pub type PSEC_CHANNEL_BINDINGS_EX = *mut _SEC_CHANNEL_BINDINGS_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SEC_CHANNEL_BINDINGS_RESULT {
    pub flags: core::ffi::c_ulong,
}
pub type SEC_CHANNEL_BINDINGS_RESULT = _SEC_CHANNEL_BINDINGS_RESULT;
pub type PSEC_CHANNEL_BINDINGS_RESULT = *mut _SEC_CHANNEL_BINDINGS_RESULT;
pub const _SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT_SecApplicationProtocolNegotiationExt_None:
_SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT = 0;
pub const _SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT_SecApplicationProtocolNegotiationExt_NPN:
_SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT = 1;
pub const _SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT_SecApplicationProtocolNegotiationExt_ALPN:
_SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT = 2;
pub type _SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT = core::ffi::c_int;
pub use self::_SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT as SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT;
pub type PSEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT = *mut _SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SEC_APPLICATION_PROTOCOL_LIST {
    pub ProtoNegoExt: SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT,
    pub ProtocolListSize: core::ffi::c_ushort,
    pub ProtocolList: [core::ffi::c_uchar; 1usize],
}
pub type SEC_APPLICATION_PROTOCOL_LIST = _SEC_APPLICATION_PROTOCOL_LIST;
pub type PSEC_APPLICATION_PROTOCOL_LIST = *mut _SEC_APPLICATION_PROTOCOL_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SEC_APPLICATION_PROTOCOLS {
    pub ProtocolListsSize: core::ffi::c_ulong,
    pub ProtocolLists: [SEC_APPLICATION_PROTOCOL_LIST; 1usize],
}
pub type SEC_APPLICATION_PROTOCOLS = _SEC_APPLICATION_PROTOCOLS;
pub type PSEC_APPLICATION_PROTOCOLS = *mut _SEC_APPLICATION_PROTOCOLS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SEC_SRTP_PROTECTION_PROFILES {
    pub ProfilesSize: core::ffi::c_ushort,
    pub ProfilesList: [core::ffi::c_ushort; 1usize],
}
pub type SEC_SRTP_PROTECTION_PROFILES = _SEC_SRTP_PROTECTION_PROFILES;
pub type PSEC_SRTP_PROTECTION_PROFILES = *mut _SEC_SRTP_PROTECTION_PROFILES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SEC_SRTP_MASTER_KEY_IDENTIFIER {
    pub MasterKeyIdentifierSize: core::ffi::c_uchar,
    pub MasterKeyIdentifier: [core::ffi::c_uchar; 1usize],
}
pub type SEC_SRTP_MASTER_KEY_IDENTIFIER = _SEC_SRTP_MASTER_KEY_IDENTIFIER;
pub type PSEC_SRTP_MASTER_KEY_IDENTIFIER = *mut _SEC_SRTP_MASTER_KEY_IDENTIFIER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SEC_TOKEN_BINDING {
    pub MajorVersion: core::ffi::c_uchar,
    pub MinorVersion: core::ffi::c_uchar,
    pub KeyParametersSize: core::ffi::c_ushort,
    pub KeyParameters: [core::ffi::c_uchar; 1usize],
}
pub type SEC_TOKEN_BINDING = _SEC_TOKEN_BINDING;
pub type PSEC_TOKEN_BINDING = *mut _SEC_TOKEN_BINDING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SEC_PRESHAREDKEY {
    pub KeySize: core::ffi::c_ushort,
    pub Key: [core::ffi::c_uchar; 1usize],
}
pub type SEC_PRESHAREDKEY = _SEC_PRESHAREDKEY;
pub type PSEC_PRESHAREDKEY = *mut _SEC_PRESHAREDKEY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SEC_PRESHAREDKEY_IDENTITY {
    pub KeyIdentitySize: core::ffi::c_ushort,
    pub KeyIdentity: [core::ffi::c_uchar; 1usize],
}
pub type SEC_PRESHAREDKEY_IDENTITY = _SEC_PRESHAREDKEY_IDENTITY;
pub type PSEC_PRESHAREDKEY_IDENTITY = *mut _SEC_PRESHAREDKEY_IDENTITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SEC_DTLS_MTU {
    pub PathMTU: core::ffi::c_ushort,
}
pub type SEC_DTLS_MTU = _SEC_DTLS_MTU;
pub type PSEC_DTLS_MTU = *mut _SEC_DTLS_MTU;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SEC_FLAGS {
    pub Flags: core::ffi::c_ulonglong,
}
pub type SEC_FLAGS = _SEC_FLAGS;
pub type PSEC_FLAGS = *mut _SEC_FLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SEC_CERTIFICATE_REQUEST_CONTEXT {
    pub cbCertificateRequestContext: core::ffi::c_uchar,
    pub rgCertificateRequestContext: [core::ffi::c_uchar; 1usize],
}
pub type SEC_CERTIFICATE_REQUEST_CONTEXT = _SEC_CERTIFICATE_REQUEST_CONTEXT;
pub type PSEC_CERTIFICATE_REQUEST_CONTEXT = *mut _SEC_CERTIFICATE_REQUEST_CONTEXT;
pub const _SEC_TRAFFIC_SECRET_TYPE_SecTrafficSecret_None: _SEC_TRAFFIC_SECRET_TYPE = 0;
pub const _SEC_TRAFFIC_SECRET_TYPE_SecTrafficSecret_Client: _SEC_TRAFFIC_SECRET_TYPE = 1;
pub const _SEC_TRAFFIC_SECRET_TYPE_SecTrafficSecret_Server: _SEC_TRAFFIC_SECRET_TYPE = 2;
pub type _SEC_TRAFFIC_SECRET_TYPE = core::ffi::c_int;
pub use self::_SEC_TRAFFIC_SECRET_TYPE as SEC_TRAFFIC_SECRET_TYPE;
pub type PSEC_TRAFFIC_SECRET_TYPE = *mut _SEC_TRAFFIC_SECRET_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SEC_TRAFFIC_SECRETS {
    pub SymmetricAlgId: [wchar_t; 64usize],
    pub ChainingMode: [wchar_t; 64usize],
    pub HashAlgId: [wchar_t; 64usize],
    pub KeySize: core::ffi::c_ushort,
    pub IvSize: core::ffi::c_ushort,
    pub MsgSequenceStart: core::ffi::c_ushort,
    pub MsgSequenceEnd: core::ffi::c_ushort,
    pub TrafficSecretType: SEC_TRAFFIC_SECRET_TYPE,
    pub TrafficSecretSize: core::ffi::c_ushort,
    pub TrafficSecret: [core::ffi::c_uchar; 1usize],
}
pub type SEC_TRAFFIC_SECRETS = _SEC_TRAFFIC_SECRETS;
pub type PSEC_TRAFFIC_SECRETS = *mut _SEC_TRAFFIC_SECRETS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SecPkgCredentials_NamesW {
    pub sUserName: *mut SEC_WCHAR,
}
pub type SecPkgCredentials_NamesW = _SecPkgCredentials_NamesW;
pub type PSecPkgCredentials_NamesW = *mut _SecPkgCredentials_NamesW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SecPkgCredentials_SSIProviderW {
    pub sProviderName: *mut SEC_WCHAR,
    pub ProviderInfoLength: core::ffi::c_ulong,
    pub ProviderInfo: *mut core::ffi::c_char,
}
pub type SecPkgCredentials_SSIProviderW = _SecPkgCredentials_SSIProviderW;
pub type PSecPkgCredentials_SSIProviderW = *mut _SecPkgCredentials_SSIProviderW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SecPkgCredentials_KdcProxySettingsW {
    pub Version: ULONG,
    pub Flags: ULONG,
    pub ProxyServerOffset: USHORT,
    pub ProxyServerLength: USHORT,
    pub ClientTlsCredOffset: USHORT,
    pub ClientTlsCredLength: USHORT,
}
pub type SecPkgCredentials_KdcProxySettingsW = _SecPkgCredentials_KdcProxySettingsW;
pub type PSecPkgCredentials_KdcProxySettingsW = *mut _SecPkgCredentials_KdcProxySettingsW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SecPkgCredentials_Cert {
    pub EncodedCertSize: core::ffi::c_ulong,
    pub EncodedCert: *mut core::ffi::c_uchar,
}
pub type SecPkgCredentials_Cert = _SecPkgCredentials_Cert;
pub type PSecPkgCredentials_Cert = *mut _SecPkgCredentials_Cert;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SecPkgContext_SubjectAttributes {
    pub AttributeInfo: *mut core::ffi::c_void,
}
pub type SecPkgContext_SubjectAttributes = _SecPkgContext_SubjectAttributes;
pub type PSecPkgContext_SubjectAttributes = *mut _SecPkgContext_SubjectAttributes;
pub const _SECPKG_CRED_CLASS_SecPkgCredClass_None: _SECPKG_CRED_CLASS = 0;
pub const _SECPKG_CRED_CLASS_SecPkgCredClass_Ephemeral: _SECPKG_CRED_CLASS = 10;
pub const _SECPKG_CRED_CLASS_SecPkgCredClass_PersistedGeneric: _SECPKG_CRED_CLASS = 20;
pub const _SECPKG_CRED_CLASS_SecPkgCredClass_PersistedSpecific: _SECPKG_CRED_CLASS = 30;
pub const _SECPKG_CRED_CLASS_SecPkgCredClass_Explicit: _SECPKG_CRED_CLASS = 40;
pub type _SECPKG_CRED_CLASS = core::ffi::c_int;
pub use self::_SECPKG_CRED_CLASS as SECPKG_CRED_CLASS;
pub type PSECPKG_CRED_CLASS = *mut _SECPKG_CRED_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SecPkgContext_CredInfo {
    pub CredClass: SECPKG_CRED_CLASS,
    pub IsPromptingNeeded: core::ffi::c_ulong,
}
pub type SecPkgContext_CredInfo = _SecPkgContext_CredInfo;
pub type PSecPkgContext_CredInfo = *mut _SecPkgContext_CredInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SecPkgContext_NegoPackageInfo {
    pub PackageMask: core::ffi::c_ulong,
}
pub type SecPkgContext_NegoPackageInfo = _SecPkgContext_NegoPackageInfo;
pub type PSecPkgContext_NegoPackageInfo = *mut _SecPkgContext_NegoPackageInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SecPkgContext_NegoStatus {
    pub LastStatus: core::ffi::c_ulong,
}
pub type SecPkgContext_NegoStatus = _SecPkgContext_NegoStatus;
pub type PSecPkgContext_NegoStatus = *mut _SecPkgContext_NegoStatus;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SecPkgContext_Sizes {
    pub cbMaxToken: core::ffi::c_ulong,
    pub cbMaxSignature: core::ffi::c_ulong,
    pub cbBlockSize: core::ffi::c_ulong,
    pub cbSecurityTrailer: core::ffi::c_ulong,
}
pub type SecPkgContext_Sizes = _SecPkgContext_Sizes;
pub type PSecPkgContext_Sizes = *mut _SecPkgContext_Sizes;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SecPkgContext_StreamSizes {
    pub cbHeader: core::ffi::c_ulong,
    pub cbTrailer: core::ffi::c_ulong,
    pub cbMaximumMessage: core::ffi::c_ulong,
    pub cBuffers: core::ffi::c_ulong,
    pub cbBlockSize: core::ffi::c_ulong,
}
pub type SecPkgContext_StreamSizes = _SecPkgContext_StreamSizes;
pub type PSecPkgContext_StreamSizes = *mut _SecPkgContext_StreamSizes;
pub type SecPkgContext_DatagramSizes = SecPkgContext_StreamSizes;
pub type PSecPkgContext_DatagramSizes = PSecPkgContext_StreamSizes;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SecPkgContext_NamesW {
    pub sUserName: *mut SEC_WCHAR,
}
pub type SecPkgContext_NamesW = _SecPkgContext_NamesW;
pub type PSecPkgContext_NamesW = *mut _SecPkgContext_NamesW;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SecPkgContext_Lifespan {
    pub tsStart: TimeStamp,
    pub tsExpiry: TimeStamp,
}
pub type SecPkgContext_Lifespan = _SecPkgContext_Lifespan;
pub type PSecPkgContext_Lifespan = *mut _SecPkgContext_Lifespan;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SecPkgContext_DceInfo {
    pub AuthzSvc: core::ffi::c_ulong,
    pub pPac: *mut core::ffi::c_void,
}
pub type SecPkgContext_DceInfo = _SecPkgContext_DceInfo;
pub type PSecPkgContext_DceInfo = *mut _SecPkgContext_DceInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SecPkgContext_KeyInfoW {
    pub sSignatureAlgorithmName: *mut SEC_WCHAR,
    pub sEncryptAlgorithmName: *mut SEC_WCHAR,
    pub KeySize: core::ffi::c_ulong,
    pub SignatureAlgorithm: core::ffi::c_ulong,
    pub EncryptAlgorithm: core::ffi::c_ulong,
}
pub type SecPkgContext_KeyInfoW = _SecPkgContext_KeyInfoW;
pub type PSecPkgContext_KeyInfoW = *mut _SecPkgContext_KeyInfoW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SecPkgContext_AuthorityW {
    pub sAuthorityName: *mut SEC_WCHAR,
}
pub type SecPkgContext_AuthorityW = _SecPkgContext_AuthorityW;
pub type PSecPkgContext_AuthorityW = *mut _SecPkgContext_AuthorityW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SecPkgContext_ProtoInfoW {
    pub sProtocolName: *mut SEC_WCHAR,
    pub majorVersion: core::ffi::c_ulong,
    pub minorVersion: core::ffi::c_ulong,
}
pub type SecPkgContext_ProtoInfoW = _SecPkgContext_ProtoInfoW;
pub type PSecPkgContext_ProtoInfoW = *mut _SecPkgContext_ProtoInfoW;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SecPkgContext_PasswordExpiry {
    pub tsPasswordExpires: TimeStamp,
}
pub type SecPkgContext_PasswordExpiry = _SecPkgContext_PasswordExpiry;
pub type PSecPkgContext_PasswordExpiry = *mut _SecPkgContext_PasswordExpiry;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SecPkgContext_LogoffTime {
    pub tsLogoffTime: TimeStamp,
}
pub type SecPkgContext_LogoffTime = _SecPkgContext_LogoffTime;
pub type PSecPkgContext_LogoffTime = *mut _SecPkgContext_LogoffTime;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SecPkgContext_SessionKey {
    pub SessionKeyLength: core::ffi::c_ulong,
    pub SessionKey: *mut core::ffi::c_uchar,
}
pub type SecPkgContext_SessionKey = _SecPkgContext_SessionKey;
pub type PSecPkgContext_SessionKey = *mut _SecPkgContext_SessionKey;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SecPkgContext_NegoKeys {
    pub KeyType: core::ffi::c_ulong,
    pub KeyLength: core::ffi::c_ushort,
    pub KeyValue: *mut core::ffi::c_uchar,
    pub VerifyKeyType: core::ffi::c_ulong,
    pub VerifyKeyLength: core::ffi::c_ushort,
    pub VerifyKeyValue: *mut core::ffi::c_uchar,
}
pub type SecPkgContext_NegoKeys = _SecPkgContext_NegoKeys;
pub type PSecPkgContext_NegoKeys = *mut _SecPkgContext_NegoKeys;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SecPkgContext_PackageInfoW {
    pub PackageInfo: PSecPkgInfoW,
}
pub type SecPkgContext_PackageInfoW = _SecPkgContext_PackageInfoW;
pub type PSecPkgContext_PackageInfoW = *mut _SecPkgContext_PackageInfoW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SecPkgContext_UserFlags {
    pub UserFlags: core::ffi::c_ulong,
}
pub type SecPkgContext_UserFlags = _SecPkgContext_UserFlags;
pub type PSecPkgContext_UserFlags = *mut _SecPkgContext_UserFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SecPkgContext_Flags {
    pub Flags: core::ffi::c_ulong,
}
pub type SecPkgContext_Flags = _SecPkgContext_Flags;
pub type PSecPkgContext_Flags = *mut _SecPkgContext_Flags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SecPkgContext_NegotiationInfoW {
    pub PackageInfo: PSecPkgInfoW,
    pub NegotiationState: core::ffi::c_ulong,
}
pub type SecPkgContext_NegotiationInfoW = _SecPkgContext_NegotiationInfoW;
pub type PSecPkgContext_NegotiationInfoW = *mut _SecPkgContext_NegotiationInfoW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SecPkgContext_CredentialNameW {
    pub CredentialType: core::ffi::c_ulong,
    pub sCredentialName: *mut SEC_WCHAR,
}
pub type SecPkgContext_CredentialNameW = _SecPkgContext_CredentialNameW;
pub type PSecPkgContext_CredentialNameW = *mut _SecPkgContext_CredentialNameW;
pub type SEC_GET_KEY_FN = ::core::option::Option<
    unsafe extern "C" fn(
        Arg: *mut core::ffi::c_void,
        Principal: *mut core::ffi::c_void,
        KeyVer: core::ffi::c_ulong,
        Key: *mut *mut core::ffi::c_void,
        Status: *mut SECURITY_STATUS,
    ),
>;
unsafe extern "C" {
    pub fn AcquireCredentialsHandleW(
        pPrincipal: PSECURITY_STRING,
        pPackage: PSECURITY_STRING,
        fCredentialUse: core::ffi::c_ulong,
        pvLogonId: *mut core::ffi::c_void,
        pAuthData: *mut core::ffi::c_void,
        pGetKeyFn: SEC_GET_KEY_FN,
        pvGetKeyArgument: *mut core::ffi::c_void,
        phCredential: PCredHandle,
        ptsExpiry: PTimeStamp,
    ) -> SECURITY_STATUS;
}
pub type ACQUIRE_CREDENTIALS_HANDLE_FN_W = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: PSECURITY_STRING,
        arg2: PSECURITY_STRING,
        arg3: core::ffi::c_ulong,
        arg4: *mut core::ffi::c_void,
        arg5: *mut core::ffi::c_void,
        arg6: SEC_GET_KEY_FN,
        arg7: *mut core::ffi::c_void,
        arg8: PCredHandle,
        arg9: PTimeStamp,
    ) -> SECURITY_STATUS,
>;
unsafe extern "C" {
    pub fn FreeCredentialsHandle(phCredential: PCredHandle) -> SECURITY_STATUS;
}
pub type FREE_CREDENTIALS_HANDLE_FN =
::core::option::Option<unsafe extern "C" fn(arg1: PCredHandle) -> SECURITY_STATUS>;
unsafe extern "C" {
    pub fn AddCredentialsW(
        hCredentials: PCredHandle,
        pPrincipal: PSECURITY_STRING,
        pPackage: PSECURITY_STRING,
        fCredentialUse: core::ffi::c_ulong,
        pAuthData: *mut core::ffi::c_void,
        pGetKeyFn: SEC_GET_KEY_FN,
        pvGetKeyArgument: *mut core::ffi::c_void,
        ptsExpiry: PTimeStamp,
    ) -> SECURITY_STATUS;
}
pub type ADD_CREDENTIALS_FN_W = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: PCredHandle,
        arg2: PSECURITY_STRING,
        arg3: PSECURITY_STRING,
        arg4: core::ffi::c_ulong,
        arg5: *mut core::ffi::c_void,
        arg6: SEC_GET_KEY_FN,
        arg7: *mut core::ffi::c_void,
        arg8: PTimeStamp,
    ) -> SECURITY_STATUS,
>;
unsafe extern "C" {
    pub fn AddCredentialsA(
        hCredentials: PCredHandle,
        pszPrincipal: LPSTR,
        pszPackage: LPSTR,
        fCredentialUse: core::ffi::c_ulong,
        pAuthData: *mut core::ffi::c_void,
        pGetKeyFn: SEC_GET_KEY_FN,
        pvGetKeyArgument: *mut core::ffi::c_void,
        ptsExpiry: PTimeStamp,
    ) -> SECURITY_STATUS;
}
pub type ADD_CREDENTIALS_FN_A = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: PCredHandle,
        arg2: *mut SEC_CHAR,
        arg3: *mut SEC_CHAR,
        arg4: core::ffi::c_ulong,
        arg5: *mut core::ffi::c_void,
        arg6: SEC_GET_KEY_FN,
        arg7: *mut core::ffi::c_void,
        arg8: PTimeStamp,
    ) -> SECURITY_STATUS,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SspiAsyncContext {
    _unused: [u8; 0],
}
pub type SspiAsyncContext = _SspiAsyncContext;
pub type SspiAsyncNotifyCallback = ::core::option::Option<
    unsafe extern "C" fn(Handle: *mut SspiAsyncContext, CallbackData: PVOID),
>;
unsafe extern "C" {
    pub fn SspiCreateAsyncContext() -> *mut SspiAsyncContext;
}
unsafe extern "C" {
    pub fn SspiFreeAsyncContext(Handle: *mut SspiAsyncContext);
}
unsafe extern "C" {
    pub fn SspiReinitAsyncContext(Handle: *mut SspiAsyncContext) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SspiSetAsyncNotifyCallback(
        Context: *mut SspiAsyncContext,
        Callback: SspiAsyncNotifyCallback,
        CallbackData: *mut core::ffi::c_void,
    ) -> SECURITY_STATUS;
}
unsafe extern "C" {
    pub fn SspiAsyncContextRequiresNotify(AsyncContext: *mut SspiAsyncContext) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn SspiGetAsyncCallStatus(Handle: *mut SspiAsyncContext) -> SECURITY_STATUS;
}
unsafe extern "C" {
    pub fn SspiAcquireCredentialsHandleAsyncW(
        AsyncContext: *mut SspiAsyncContext,
        pszPrincipal: PSECURITY_STRING,
        pszPackage: PSECURITY_STRING,
        fCredentialUse: core::ffi::c_ulong,
        pvLogonId: *mut core::ffi::c_void,
        pAuthData: *mut core::ffi::c_void,
        pGetKeyFn: SEC_GET_KEY_FN,
        pvGetKeyArgument: *mut core::ffi::c_void,
        phCredential: PCredHandle,
        ptsExpiry: PTimeStamp,
    ) -> SECURITY_STATUS;
}
unsafe extern "C" {
    pub fn SspiAcquireCredentialsHandleAsyncA(
        AsyncContext: *mut SspiAsyncContext,
        pszPrincipal: LPSTR,
        pszPackage: LPSTR,
        fCredentialUse: core::ffi::c_ulong,
        pvLogonId: *mut core::ffi::c_void,
        pAuthData: *mut core::ffi::c_void,
        pGetKeyFn: SEC_GET_KEY_FN,
        pvGetKeyArgument: *mut core::ffi::c_void,
        phCredential: PCredHandle,
        ptsExpiry: PTimeStamp,
    ) -> SECURITY_STATUS;
}
unsafe extern "C" {
    pub fn SspiInitializeSecurityContextAsyncW(
        AsyncContext: *mut SspiAsyncContext,
        phCredential: PCredHandle,
        phContext: PCtxtHandle,
        pszTargetName: PSECURITY_STRING,
        fContextReq: core::ffi::c_ulong,
        Reserved1: core::ffi::c_ulong,
        TargetDataRep: core::ffi::c_ulong,
        pInput: PSecBufferDesc,
        Reserved2: core::ffi::c_ulong,
        phNewContext: PCtxtHandle,
        pOutput: PSecBufferDesc,
        pfContextAttr: *mut core::ffi::c_ulong,
        ptsExpiry: PTimeStamp,
    ) -> SECURITY_STATUS;
}
unsafe extern "C" {
    pub fn SspiInitializeSecurityContextAsyncA(
        AsyncContext: *mut SspiAsyncContext,
        phCredential: PCredHandle,
        phContext: PCtxtHandle,
        pszTargetName: LPSTR,
        fContextReq: core::ffi::c_ulong,
        Reserved1: core::ffi::c_ulong,
        TargetDataRep: core::ffi::c_ulong,
        pInput: PSecBufferDesc,
        Reserved2: core::ffi::c_ulong,
        phNewContext: PCtxtHandle,
        pOutput: PSecBufferDesc,
        pfContextAttr: *mut core::ffi::c_ulong,
        ptsExpiry: PTimeStamp,
    ) -> SECURITY_STATUS;
}
unsafe extern "C" {
    pub fn SspiAcceptSecurityContextAsync(
        AsyncContext: *mut SspiAsyncContext,
        phCredential: PCredHandle,
        phContext: PCtxtHandle,
        pInput: PSecBufferDesc,
        fContextReq: core::ffi::c_ulong,
        TargetDataRep: core::ffi::c_ulong,
        phNewContext: PCtxtHandle,
        pOutput: PSecBufferDesc,
        pfContextAttr: *mut core::ffi::c_ulong,
        ptsExpiry: PTimeStamp,
    ) -> SECURITY_STATUS;
}
unsafe extern "C" {
    pub fn SspiFreeCredentialsHandleAsync(
        AsyncContext: *mut SspiAsyncContext,
        phCredential: PCredHandle,
    ) -> SECURITY_STATUS;
}
unsafe extern "C" {
    pub fn SspiDeleteSecurityContextAsync(
        AsyncContext: *mut SspiAsyncContext,
        phContext: PCtxtHandle,
    ) -> SECURITY_STATUS;
}
unsafe extern "C" {
    pub fn InitializeSecurityContextW(
        phCredential: PCredHandle,
        phContext: PCtxtHandle,
        pTargetName: PSECURITY_STRING,
        fContextReq: core::ffi::c_ulong,
        Reserved1: core::ffi::c_ulong,
        TargetDataRep: core::ffi::c_ulong,
        pInput: PSecBufferDesc,
        Reserved2: core::ffi::c_ulong,
        phNewContext: PCtxtHandle,
        pOutput: PSecBufferDesc,
        pfContextAttr: *mut core::ffi::c_ulong,
        ptsExpiry: PTimeStamp,
    ) -> SECURITY_STATUS;
}
pub type INITIALIZE_SECURITY_CONTEXT_FN_W = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: PCredHandle,
        arg2: PCtxtHandle,
        arg3: PSECURITY_STRING,
        arg4: core::ffi::c_ulong,
        arg5: core::ffi::c_ulong,
        arg6: core::ffi::c_ulong,
        arg7: PSecBufferDesc,
        arg8: core::ffi::c_ulong,
        arg9: PCtxtHandle,
        arg10: PSecBufferDesc,
        arg11: *mut core::ffi::c_ulong,
        arg12: PTimeStamp,
    ) -> SECURITY_STATUS,
>;
unsafe extern "C" {
    pub fn AcceptSecurityContext(
        phCredential: PCredHandle,
        phContext: PCtxtHandle,
        pInput: PSecBufferDesc,
        fContextReq: core::ffi::c_ulong,
        TargetDataRep: core::ffi::c_ulong,
        phNewContext: PCtxtHandle,
        pOutput: PSecBufferDesc,
        pfContextAttr: *mut core::ffi::c_ulong,
        ptsExpiry: PTimeStamp,
    ) -> SECURITY_STATUS;
}
pub type ACCEPT_SECURITY_CONTEXT_FN = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: PCredHandle,
        arg2: PCtxtHandle,
        arg3: PSecBufferDesc,
        arg4: core::ffi::c_ulong,
        arg5: core::ffi::c_ulong,
        arg6: PCtxtHandle,
        arg7: PSecBufferDesc,
        arg8: *mut core::ffi::c_ulong,
        arg9: PTimeStamp,
    ) -> SECURITY_STATUS,
>;
unsafe extern "C" {
    pub fn CompleteAuthToken(phContext: PCtxtHandle, pToken: PSecBufferDesc) -> SECURITY_STATUS;
}
pub type COMPLETE_AUTH_TOKEN_FN = ::core::option::Option<
    unsafe extern "C" fn(arg1: PCtxtHandle, arg2: PSecBufferDesc) -> SECURITY_STATUS,
>;
unsafe extern "C" {
    pub fn ImpersonateSecurityContext(phContext: PCtxtHandle) -> SECURITY_STATUS;
}
pub type IMPERSONATE_SECURITY_CONTEXT_FN =
::core::option::Option<unsafe extern "C" fn(arg1: PCtxtHandle) -> SECURITY_STATUS>;
unsafe extern "C" {
    pub fn RevertSecurityContext(phContext: PCtxtHandle) -> SECURITY_STATUS;
}
pub type REVERT_SECURITY_CONTEXT_FN =
::core::option::Option<unsafe extern "C" fn(arg1: PCtxtHandle) -> SECURITY_STATUS>;
unsafe extern "C" {
    pub fn QuerySecurityContextToken(
        phContext: PCtxtHandle,
        Token: *mut *mut core::ffi::c_void,
    ) -> SECURITY_STATUS;
}
pub type QUERY_SECURITY_CONTEXT_TOKEN_FN = ::core::option::Option<
    unsafe extern "C" fn(arg1: PCtxtHandle, arg2: *mut *mut core::ffi::c_void) -> SECURITY_STATUS,
>;
unsafe extern "C" {
    pub fn DeleteSecurityContext(phContext: PCtxtHandle) -> SECURITY_STATUS;
}
pub type DELETE_SECURITY_CONTEXT_FN =
::core::option::Option<unsafe extern "C" fn(arg1: PCtxtHandle) -> SECURITY_STATUS>;
unsafe extern "C" {
    pub fn ApplyControlToken(phContext: PCtxtHandle, pInput: PSecBufferDesc) -> SECURITY_STATUS;
}
pub type APPLY_CONTROL_TOKEN_FN = ::core::option::Option<
    unsafe extern "C" fn(arg1: PCtxtHandle, arg2: PSecBufferDesc) -> SECURITY_STATUS,
>;
unsafe extern "C" {
    pub fn QueryContextAttributesW(
        phContext: PCtxtHandle,
        ulAttribute: core::ffi::c_ulong,
        pBuffer: *mut core::ffi::c_void,
    ) -> SECURITY_STATUS;
}
pub type QUERY_CONTEXT_ATTRIBUTES_FN_W = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: PCtxtHandle,
        arg2: core::ffi::c_ulong,
        arg3: *mut core::ffi::c_void,
    ) -> SECURITY_STATUS,
>;
unsafe extern "C" {
    pub fn QueryContextAttributesExW(
        phContext: PCtxtHandle,
        ulAttribute: core::ffi::c_ulong,
        pBuffer: *mut core::ffi::c_void,
        cbBuffer: core::ffi::c_ulong,
    ) -> SECURITY_STATUS;
}
pub type QUERY_CONTEXT_ATTRIBUTES_EX_FN_W = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: PCtxtHandle,
        arg2: core::ffi::c_ulong,
        arg3: *mut core::ffi::c_void,
        arg4: core::ffi::c_ulong,
    ) -> SECURITY_STATUS,
>;
unsafe extern "C" {
    pub fn SetContextAttributesW(
        phContext: PCtxtHandle,
        ulAttribute: core::ffi::c_ulong,
        pBuffer: *mut core::ffi::c_void,
        cbBuffer: core::ffi::c_ulong,
    ) -> SECURITY_STATUS;
}
pub type SET_CONTEXT_ATTRIBUTES_FN_W = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: PCtxtHandle,
        arg2: core::ffi::c_ulong,
        arg3: *mut core::ffi::c_void,
        arg4: core::ffi::c_ulong,
    ) -> SECURITY_STATUS,
>;
unsafe extern "C" {
    pub fn QueryCredentialsAttributesW(
        phCredential: PCredHandle,
        ulAttribute: core::ffi::c_ulong,
        pBuffer: *mut core::ffi::c_void,
    ) -> SECURITY_STATUS;
}
pub type QUERY_CREDENTIALS_ATTRIBUTES_FN_W = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: PCredHandle,
        arg2: core::ffi::c_ulong,
        arg3: *mut core::ffi::c_void,
    ) -> SECURITY_STATUS,
>;
unsafe extern "C" {
    pub fn QueryCredentialsAttributesExW(
        phCredential: PCredHandle,
        ulAttribute: core::ffi::c_ulong,
        pBuffer: *mut core::ffi::c_void,
        cbBuffer: core::ffi::c_ulong,
    ) -> SECURITY_STATUS;
}
pub type QUERY_CREDENTIALS_ATTRIBUTES_EX_FN_W = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: PCredHandle,
        arg2: core::ffi::c_ulong,
        arg3: *mut core::ffi::c_void,
        arg4: core::ffi::c_ulong,
    ) -> SECURITY_STATUS,
>;
unsafe extern "C" {
    pub fn SetCredentialsAttributesW(
        phCredential: PCredHandle,
        ulAttribute: core::ffi::c_ulong,
        pBuffer: *mut core::ffi::c_void,
        cbBuffer: core::ffi::c_ulong,
    ) -> SECURITY_STATUS;
}
pub type SET_CREDENTIALS_ATTRIBUTES_FN_W = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: PCredHandle,
        arg2: core::ffi::c_ulong,
        arg3: *mut core::ffi::c_void,
        arg4: core::ffi::c_ulong,
    ) -> SECURITY_STATUS,
>;
unsafe extern "C" {
    pub fn FreeContextBuffer(pvContextBuffer: PVOID) -> SECURITY_STATUS;
}
pub type FREE_CONTEXT_BUFFER_FN =
::core::option::Option<unsafe extern "C" fn(arg1: PVOID) -> SECURITY_STATUS>;
unsafe extern "C" {
    pub fn MakeSignature(
        phContext: PCtxtHandle,
        fQOP: core::ffi::c_ulong,
        pMessage: PSecBufferDesc,
        MessageSeqNo: core::ffi::c_ulong,
    ) -> SECURITY_STATUS;
}
pub type MAKE_SIGNATURE_FN = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: PCtxtHandle,
        arg2: core::ffi::c_ulong,
        arg3: PSecBufferDesc,
        arg4: core::ffi::c_ulong,
    ) -> SECURITY_STATUS,
>;
unsafe extern "C" {
    pub fn VerifySignature(
        phContext: PCtxtHandle,
        pMessage: PSecBufferDesc,
        MessageSeqNo: core::ffi::c_ulong,
        pfQOP: *mut core::ffi::c_ulong,
    ) -> SECURITY_STATUS;
}
pub type VERIFY_SIGNATURE_FN = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: PCtxtHandle,
        arg2: PSecBufferDesc,
        arg3: core::ffi::c_ulong,
        arg4: *mut core::ffi::c_ulong,
    ) -> SECURITY_STATUS,
>;
unsafe extern "C" {
    pub fn EncryptMessage(
        phContext: PCtxtHandle,
        fQOP: core::ffi::c_ulong,
        pMessage: PSecBufferDesc,
        MessageSeqNo: core::ffi::c_ulong,
    ) -> SECURITY_STATUS;
}
pub type ENCRYPT_MESSAGE_FN = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: PCtxtHandle,
        arg2: core::ffi::c_ulong,
        arg3: PSecBufferDesc,
        arg4: core::ffi::c_ulong,
    ) -> SECURITY_STATUS,
>;
unsafe extern "C" {
    pub fn DecryptMessage(
        phContext: PCtxtHandle,
        pMessage: PSecBufferDesc,
        MessageSeqNo: core::ffi::c_ulong,
        pfQOP: *mut core::ffi::c_ulong,
    ) -> SECURITY_STATUS;
}
pub type DECRYPT_MESSAGE_FN = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: PCtxtHandle,
        arg2: PSecBufferDesc,
        arg3: core::ffi::c_ulong,
        arg4: *mut core::ffi::c_ulong,
    ) -> SECURITY_STATUS,
>;
unsafe extern "C" {
    pub fn EnumerateSecurityPackagesW(
        pcPackages: *mut core::ffi::c_ulong,
        ppPackageInfo: *mut PSecPkgInfoW,
    ) -> SECURITY_STATUS;
}
pub type ENUMERATE_SECURITY_PACKAGES_FN_W = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut core::ffi::c_ulong, arg2: *mut PSecPkgInfoW) -> SECURITY_STATUS,
>;
unsafe extern "C" {
    pub fn QuerySecurityPackageInfoW(
        pPackageName: PSECURITY_STRING,
        ppPackageInfo: *mut PSecPkgInfoW,
    ) -> SECURITY_STATUS;
}
pub type QUERY_SECURITY_PACKAGE_INFO_FN_W = ::core::option::Option<
    unsafe extern "C" fn(arg1: PSECURITY_STRING, arg2: *mut PSecPkgInfoW) -> SECURITY_STATUS,
>;
unsafe extern "C" {
    pub fn ExportSecurityContext(
        phContext: PCtxtHandle,
        fFlags: ULONG,
        pPackedContext: PSecBuffer,
        pToken: *mut *mut core::ffi::c_void,
    ) -> SECURITY_STATUS;
}
pub type EXPORT_SECURITY_CONTEXT_FN = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: PCtxtHandle,
        arg2: ULONG,
        arg3: PSecBuffer,
        arg4: *mut *mut core::ffi::c_void,
    ) -> SECURITY_STATUS,
>;
unsafe extern "C" {
    pub fn ImportSecurityContextW(
        pszPackage: PSECURITY_STRING,
        pPackedContext: PSecBuffer,
        Token: *mut core::ffi::c_void,
        phContext: PCtxtHandle,
    ) -> SECURITY_STATUS;
}
pub type IMPORT_SECURITY_CONTEXT_FN_W = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: PSECURITY_STRING,
        arg2: PSecBuffer,
        arg3: *mut core::ffi::c_void,
        arg4: PCtxtHandle,
    ) -> SECURITY_STATUS,
>;
unsafe extern "C" {
    pub fn SecMakeSPN(
        ServiceClass: PUNICODE_STRING,
        ServiceName: PUNICODE_STRING,
        InstanceName: PUNICODE_STRING,
        InstancePort: USHORT,
        Referrer: PUNICODE_STRING,
        Spn: PUNICODE_STRING,
        Length: PULONG,
        Allocate: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SecMakeSPNEx(
        ServiceClass: PUNICODE_STRING,
        ServiceName: PUNICODE_STRING,
        InstanceName: PUNICODE_STRING,
        InstancePort: USHORT,
        Referrer: PUNICODE_STRING,
        TargetInfo: PUNICODE_STRING,
        Spn: PUNICODE_STRING,
        Length: PULONG,
        Allocate: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SecMakeSPNEx2(
        ServiceClass: PUNICODE_STRING,
        ServiceName: PUNICODE_STRING,
        InstanceName: PUNICODE_STRING,
        InstancePort: USHORT,
        Referrer: PUNICODE_STRING,
        InTargetInfo: PUNICODE_STRING,
        Spn: PUNICODE_STRING,
        TotalSize: PULONG,
        Allocate: BOOLEAN,
        IsTargetInfoMarshaled: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SecLookupAccountSid(
        Sid: PSID,
        NameSize: PULONG,
        NameBuffer: PUNICODE_STRING,
        DomainSize: PULONG,
        DomainBuffer: PUNICODE_STRING,
        NameUse: PSID_NAME_USE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SecLookupAccountName(
        Name: PUNICODE_STRING,
        SidSize: PULONG,
        Sid: PSID,
        NameUse: PSID_NAME_USE,
        DomainSize: PULONG,
        ReferencedDomain: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn SecLookupWellKnownSid(
        SidType: WELL_KNOWN_SID_TYPE,
        Sid: PSID,
        SidBufferSize: ULONG,
        SidSize: PULONG,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_FUNCTION_TABLE_W {
    pub dwVersion: core::ffi::c_ulong,
    pub EnumerateSecurityPackagesW: ENUMERATE_SECURITY_PACKAGES_FN_W,
    pub QueryCredentialsAttributesW: QUERY_CREDENTIALS_ATTRIBUTES_FN_W,
    pub AcquireCredentialsHandleW: ACQUIRE_CREDENTIALS_HANDLE_FN_W,
    pub FreeCredentialsHandle: FREE_CREDENTIALS_HANDLE_FN,
    pub Reserved2: *mut core::ffi::c_void,
    pub InitializeSecurityContextW: INITIALIZE_SECURITY_CONTEXT_FN_W,
    pub AcceptSecurityContext: ACCEPT_SECURITY_CONTEXT_FN,
    pub CompleteAuthToken: COMPLETE_AUTH_TOKEN_FN,
    pub DeleteSecurityContext: DELETE_SECURITY_CONTEXT_FN,
    pub ApplyControlToken: APPLY_CONTROL_TOKEN_FN,
    pub QueryContextAttributesW: QUERY_CONTEXT_ATTRIBUTES_FN_W,
    pub ImpersonateSecurityContext: IMPERSONATE_SECURITY_CONTEXT_FN,
    pub RevertSecurityContext: REVERT_SECURITY_CONTEXT_FN,
    pub MakeSignature: MAKE_SIGNATURE_FN,
    pub VerifySignature: VERIFY_SIGNATURE_FN,
    pub FreeContextBuffer: FREE_CONTEXT_BUFFER_FN,
    pub QuerySecurityPackageInfoW: QUERY_SECURITY_PACKAGE_INFO_FN_W,
    pub Reserved3: *mut core::ffi::c_void,
    pub Reserved4: *mut core::ffi::c_void,
    pub ExportSecurityContext: EXPORT_SECURITY_CONTEXT_FN,
    pub ImportSecurityContextW: IMPORT_SECURITY_CONTEXT_FN_W,
    pub AddCredentialsW: ADD_CREDENTIALS_FN_W,
    pub Reserved8: *mut core::ffi::c_void,
    pub QuerySecurityContextToken: QUERY_SECURITY_CONTEXT_TOKEN_FN,
    pub EncryptMessage: ENCRYPT_MESSAGE_FN,
    pub DecryptMessage: DECRYPT_MESSAGE_FN,
    pub SetContextAttributesW: SET_CONTEXT_ATTRIBUTES_FN_W,
    pub SetCredentialsAttributesW: SET_CREDENTIALS_ATTRIBUTES_FN_W,
    pub Reserved9: *mut core::ffi::c_void,
    pub QueryContextAttributesExW: QUERY_CONTEXT_ATTRIBUTES_EX_FN_W,
    pub QueryCredentialsAttributesExW: QUERY_CREDENTIALS_ATTRIBUTES_EX_FN_W,
}
pub type SecurityFunctionTableW = _SECURITY_FUNCTION_TABLE_W;
pub type PSecurityFunctionTableW = *mut _SECURITY_FUNCTION_TABLE_W;
unsafe extern "C" {
    pub fn InitSecurityInterfaceW() -> PSecurityFunctionTableW;
}
pub type INIT_SECURITY_INTERFACE_W =
::core::option::Option<unsafe extern "C" fn() -> PSecurityFunctionTableW>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SEC_WINNT_AUTH_IDENTITY_EX2 {
    pub Version: core::ffi::c_ulong,
    pub cbHeaderLength: core::ffi::c_ushort,
    pub cbStructureLength: core::ffi::c_ulong,
    pub UserOffset: core::ffi::c_ulong,
    pub UserLength: core::ffi::c_ushort,
    pub DomainOffset: core::ffi::c_ulong,
    pub DomainLength: core::ffi::c_ushort,
    pub PackedCredentialsOffset: core::ffi::c_ulong,
    pub PackedCredentialsLength: core::ffi::c_ushort,
    pub Flags: core::ffi::c_ulong,
    pub PackageListOffset: core::ffi::c_ulong,
    pub PackageListLength: core::ffi::c_ushort,
}
pub type SEC_WINNT_AUTH_IDENTITY_EX2 = _SEC_WINNT_AUTH_IDENTITY_EX2;
pub type PSEC_WINNT_AUTH_IDENTITY_EX2 = *mut _SEC_WINNT_AUTH_IDENTITY_EX2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SEC_WINNT_AUTH_IDENTITY_W {
    pub User: *mut core::ffi::c_ushort,
    pub UserLength: core::ffi::c_ulong,
    pub Domain: *mut core::ffi::c_ushort,
    pub DomainLength: core::ffi::c_ulong,
    pub Password: *mut core::ffi::c_ushort,
    pub PasswordLength: core::ffi::c_ulong,
    pub Flags: core::ffi::c_ulong,
}
pub type SEC_WINNT_AUTH_IDENTITY_W = _SEC_WINNT_AUTH_IDENTITY_W;
pub type PSEC_WINNT_AUTH_IDENTITY_W = *mut _SEC_WINNT_AUTH_IDENTITY_W;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SEC_WINNT_AUTH_IDENTITY_EXW {
    pub Version: core::ffi::c_ulong,
    pub Length: core::ffi::c_ulong,
    pub User: *mut core::ffi::c_ushort,
    pub UserLength: core::ffi::c_ulong,
    pub Domain: *mut core::ffi::c_ushort,
    pub DomainLength: core::ffi::c_ulong,
    pub Password: *mut core::ffi::c_ushort,
    pub PasswordLength: core::ffi::c_ulong,
    pub Flags: core::ffi::c_ulong,
    pub PackageList: *mut core::ffi::c_ushort,
    pub PackageListLength: core::ffi::c_ulong,
}
pub type SEC_WINNT_AUTH_IDENTITY_EXW = _SEC_WINNT_AUTH_IDENTITY_EXW;
pub type PSEC_WINNT_AUTH_IDENTITY_EXW = *mut _SEC_WINNT_AUTH_IDENTITY_EXW;
pub type PSEC_WINNT_AUTH_IDENTITY_OPAQUE = PVOID;
unsafe extern "C" {
    pub fn SspiEncodeAuthIdentityAsStrings(
        pAuthIdentity: PSEC_WINNT_AUTH_IDENTITY_OPAQUE,
        ppszUserName: *mut PCWSTR,
        ppszDomainName: *mut PCWSTR,
        ppszPackedCredentialsString: *mut PCWSTR,
    ) -> SECURITY_STATUS;
}
unsafe extern "C" {
    pub fn SspiValidateAuthIdentity(AuthData: PSEC_WINNT_AUTH_IDENTITY_OPAQUE) -> SECURITY_STATUS;
}
unsafe extern "C" {
    pub fn SspiCopyAuthIdentity(
        AuthData: PSEC_WINNT_AUTH_IDENTITY_OPAQUE,
        AuthDataCopy: *mut PSEC_WINNT_AUTH_IDENTITY_OPAQUE,
    ) -> SECURITY_STATUS;
}
unsafe extern "C" {
    pub fn SspiFreeAuthIdentity(AuthData: PSEC_WINNT_AUTH_IDENTITY_OPAQUE);
}
unsafe extern "C" {
    pub fn SspiZeroAuthIdentity(AuthData: PSEC_WINNT_AUTH_IDENTITY_OPAQUE);
}
unsafe extern "C" {
    pub fn SspiLocalFree(DataBuffer: PVOID);
}
unsafe extern "C" {
    pub fn SspiEncodeStringsAsAuthIdentity(
        pszUserName: PCWSTR,
        pszDomainName: PCWSTR,
        pszPackedCredentialsString: PCWSTR,
        ppAuthIdentity: *mut PSEC_WINNT_AUTH_IDENTITY_OPAQUE,
    ) -> SECURITY_STATUS;
}
unsafe extern "C" {
    pub fn SspiCompareAuthIdentities(
        AuthIdentity1: PSEC_WINNT_AUTH_IDENTITY_OPAQUE,
        AuthIdentity2: PSEC_WINNT_AUTH_IDENTITY_OPAQUE,
        SameSuppliedUser: PBOOLEAN,
        SameSuppliedIdentity: PBOOLEAN,
    ) -> SECURITY_STATUS;
}
unsafe extern "C" {
    pub fn SspiMarshalAuthIdentity(
        AuthIdentity: PSEC_WINNT_AUTH_IDENTITY_OPAQUE,
        AuthIdentityLength: *mut core::ffi::c_ulong,
        AuthIdentityByteArray: *mut *mut core::ffi::c_char,
    ) -> SECURITY_STATUS;
}
unsafe extern "C" {
    pub fn SspiUnmarshalAuthIdentity(
        AuthIdentityLength: core::ffi::c_ulong,
        AuthIdentityByteArray: *mut core::ffi::c_char,
        ppAuthIdentity: *mut PSEC_WINNT_AUTH_IDENTITY_OPAQUE,
    ) -> SECURITY_STATUS;
}
unsafe extern "C" {
    pub fn SspiIsPromptingNeeded(ErrorOrNtStatus: core::ffi::c_ulong) -> BOOLEAN;
}
unsafe extern "C" {
    pub fn SspiGetTargetHostName(pszTargetName: PCWSTR, pszHostName: *mut PWSTR)
                                 -> SECURITY_STATUS;
}
unsafe extern "C" {
    pub fn SspiExcludePackage(
        AuthIdentity: PSEC_WINNT_AUTH_IDENTITY_OPAQUE,
        pszPackageName: PCWSTR,
        ppNewAuthIdentity: *mut PSEC_WINNT_AUTH_IDENTITY_OPAQUE,
    ) -> SECURITY_STATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_USER_DATA {
    pub UserName: SECURITY_STRING,
    pub LogonDomainName: SECURITY_STRING,
    pub LogonServer: SECURITY_STRING,
    pub pSid: PSID,
}
pub type SECURITY_USER_DATA = _SECURITY_USER_DATA;
pub type PSECURITY_USER_DATA = *mut _SECURITY_USER_DATA;
pub type SecurityUserData = SECURITY_USER_DATA;
pub type PSecurityUserData = *mut SECURITY_USER_DATA;
unsafe extern "C" {
    pub fn GetSecurityUserInfo(
        LogonId: PLUID,
        Flags: ULONG,
        UserInformation: *mut PSecurityUserData,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn MapSecurityError(SecStatus: SECURITY_STATUS) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _QUERY_PATH_REQUEST {
    pub PathNameLength: ULONG,
    pub SecurityContext: PIO_SECURITY_CONTEXT,
    pub FilePathName: [WCHAR; 1usize],
}
pub type QUERY_PATH_REQUEST = _QUERY_PATH_REQUEST;
pub type PQUERY_PATH_REQUEST = *mut _QUERY_PATH_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _QUERY_PATH_REQUEST_EX {
    pub pSecurityContext: PIO_SECURITY_CONTEXT,
    pub EaLength: ULONG,
    pub pEaBuffer: PVOID,
    pub PathName: UNICODE_STRING,
    pub DomainServiceName: UNICODE_STRING,
    pub EcpList: PECP_LIST,
    pub Silo: PESILO,
    pub Reserved: ULONG_PTR,
}
pub type QUERY_PATH_REQUEST_EX = _QUERY_PATH_REQUEST_EX;
pub type PQUERY_PATH_REQUEST_EX = *mut _QUERY_PATH_REQUEST_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _QUERY_PATH_RESPONSE {
    pub LengthAccepted: ULONG,
}
pub type QUERY_PATH_RESPONSE = _QUERY_PATH_RESPONSE;
pub type PQUERY_PATH_RESPONSE = *mut _QUERY_PATH_RESPONSE;
unsafe extern "C" {
    pub fn ZwQueryObject(
        Handle: HANDLE,
        ObjectInformationClass: OBJECT_INFORMATION_CLASS,
        ObjectInformation: PVOID,
        ObjectInformationLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwNotifyChangeKey(
        KeyHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        CompletionFilter: ULONG,
        WatchTree: BOOLEAN,
        Buffer: PVOID,
        BufferSize: ULONG,
        Asynchronous: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwCreateEvent(
        EventHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        EventType: EVENT_TYPE,
        InitialState: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwDeleteFile(ObjectAttributes: POBJECT_ATTRIBUTES) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwQueryDirectoryFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FileInformation: PVOID,
        Length: ULONG,
        FileInformationClass: FILE_INFORMATION_CLASS,
        ReturnSingleEntry: BOOLEAN,
        FileName: PUNICODE_STRING,
        RestartScan: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwQueryDirectoryFileEx(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FileInformation: PVOID,
        Length: ULONG,
        FileInformationClass: FILE_INFORMATION_CLASS,
        QueryFlags: ULONG,
        FileName: PUNICODE_STRING,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwSetVolumeInformationFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FsInformation: PVOID,
        Length: ULONG,
        FsInformationClass: FS_INFORMATION_CLASS,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwFsControlFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FsControlCode: ULONG,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwDuplicateObject(
        SourceProcessHandle: HANDLE,
        SourceHandle: HANDLE,
        TargetProcessHandle: HANDLE,
        TargetHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        HandleAttributes: ULONG,
        Options: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwOpenDirectoryObject(
        DirectoryHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwAllocateVirtualMemory(
        ProcessHandle: HANDLE,
        BaseAddress: *mut PVOID,
        ZeroBits: ULONG_PTR,
        RegionSize: PSIZE_T,
        AllocationType: ULONG,
        Protect: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwAllocateVirtualMemoryEx(
        ProcessHandle: HANDLE,
        BaseAddress: *mut PVOID,
        RegionSize: PSIZE_T,
        AllocationType: ULONG,
        PageProtection: ULONG,
        ExtendedParameters: PMEM_EXTENDED_PARAMETER,
        ExtendedParameterCount: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwFreeVirtualMemory(
        ProcessHandle: HANDLE,
        BaseAddress: *mut PVOID,
        RegionSize: PSIZE_T,
        FreeType: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwQueryVirtualMemory(
        ProcessHandle: HANDLE,
        BaseAddress: PVOID,
        MemoryInformationClass: MEMORY_INFORMATION_CLASS,
        MemoryInformation: PVOID,
        MemoryInformationLength: SIZE_T,
        ReturnLength: PSIZE_T,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwSetInformationVirtualMemory(
        ProcessHandle: HANDLE,
        VmInformationClass: VIRTUAL_MEMORY_INFORMATION_CLASS,
        NumberOfEntries: ULONG_PTR,
        VirtualAddresses: PMEMORY_RANGE_ENTRY,
        VmInformation: PVOID,
        VmInformationLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwWaitForSingleObject(
        Handle: HANDLE,
        Alertable: BOOLEAN,
        Timeout: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwSetEvent(EventHandle: HANDLE, PreviousState: PLONG) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwFlushVirtualMemory(
        ProcessHandle: HANDLE,
        BaseAddress: *mut PVOID,
        RegionSize: PSIZE_T,
        IoStatus: PIO_STATUS_BLOCK,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwOpenProcessTokenEx(
        ProcessHandle: HANDLE,
        DesiredAccess: ACCESS_MASK,
        HandleAttributes: ULONG,
        TokenHandle: PHANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwOpenThreadTokenEx(
        ThreadHandle: HANDLE,
        DesiredAccess: ACCESS_MASK,
        OpenAsSelf: BOOLEAN,
        HandleAttributes: ULONG,
        TokenHandle: PHANDLE,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwQueryInformationToken(
        TokenHandle: HANDLE,
        TokenInformationClass: TOKEN_INFORMATION_CLASS,
        TokenInformation: PVOID,
        TokenInformationLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwSetInformationToken(
        TokenHandle: HANDLE,
        TokenInformationClass: TOKEN_INFORMATION_CLASS,
        TokenInformation: PVOID,
        TokenInformationLength: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwSetSecurityObject(
        Handle: HANDLE,
        SecurityInformation: SECURITY_INFORMATION,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwQuerySecurityObject(
        Handle: HANDLE,
        SecurityInformation: SECURITY_INFORMATION,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        Length: ULONG,
        LengthNeeded: PULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwLockFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        ByteOffset: PLARGE_INTEGER,
        Length: PLARGE_INTEGER,
        Key: ULONG,
        FailImmediately: BOOLEAN,
        ExclusiveLock: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwUnlockFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        ByteOffset: PLARGE_INTEGER,
        Length: PLARGE_INTEGER,
        Key: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwQueryQuotaInformationFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Buffer: PVOID,
        Length: ULONG,
        ReturnSingleEntry: BOOLEAN,
        SidList: PVOID,
        SidListLength: ULONG,
        StartSid: PSID,
        RestartScan: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwSetQuotaInformationFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Buffer: PVOID,
        Length: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwFlushBuffersFile(FileHandle: HANDLE, IoStatusBlock: PIO_STATUS_BLOCK) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwFlushBuffersFileEx(
        FileHandle: HANDLE,
        FLags: ULONG,
        Parameters: PVOID,
        ParametersSize: ULONG,
        IoStatusBlock: PIO_STATUS_BLOCK,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwQueryEaFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Buffer: PVOID,
        Length: ULONG,
        ReturnSingleEntry: BOOLEAN,
        EaList: PVOID,
        EaListLength: ULONG,
        EaIndex: PULONG,
        RestartScan: BOOLEAN,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwSetEaFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Buffer: PVOID,
        Length: ULONG,
    ) -> NTSTATUS;
}
unsafe extern "C" {
    pub fn ZwDuplicateToken(
        ExistingTokenHandle: HANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        EffectiveOnly: BOOLEAN,
        TokenType: TOKEN_TYPE,
        NewTokenHandle: PHANDLE,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EPROCESS {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IORING_OBJECT {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KGDTENTRY64 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTSS64 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KPRCB {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KIDTENTRY64 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ECP_LIST {
    pub _address: u8,
}
